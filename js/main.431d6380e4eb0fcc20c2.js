(self.webpackChunkvox_client = self.webpackChunkvox_client || []).push([[179], { 8255: t => { function e(t) { return Promise.resolve().then(() => { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e }) } e.keys = () => [], e.resolve = e, e.id = 8255, t.exports = e }, 1362: (t, e, n) => { "use strict"; n.d(e, { i: () => r }); const r = "abi/5.1.1" }, 3941: (t, e, n) => { "use strict"; n.d(e, { R: () => R, $: () => L }); var r = n(1488), i = n(2275), s = n(3898), o = n(1362), a = n(1125), l = n(2885); class c extends a.XI { constructor(t) { super("address", "address", t, !1) } defaultValue() { return "0x0000000000000000000000000000000000000000" } encode(t, e) { try { (0, l.getAddress)(e) } catch (n) { this._throwError(n.message, e) } return t.writeValue(e) } decode(t) { return (0, l.getAddress)((0, r.hexZeroPad)(t.readValue().toHexString(), 20)) } } class u extends a.XI { constructor(t) { super(t.name, t.type, void 0, t.dynamic), this.coder = t } defaultValue() { return this.coder.defaultValue() } encode(t, e) { return this.coder.encode(t, e) } decode(t) { return this.coder.decode(t) } } const h = new s.Logger(o.i); function d(t, e, n) { let r = null; if (Array.isArray(n)) r = n; else if (n && "object" == typeof n) { let t = {}; r = e.map(e => { const r = e.localName; return r || h.throwError("cannot encode object for signature with missing names", s.Logger.errors.INVALID_ARGUMENT, { argument: "values", coder: e, value: n }), t[r] && h.throwError("cannot encode object for signature with duplicate names", s.Logger.errors.INVALID_ARGUMENT, { argument: "values", coder: e, value: n }), t[r] = !0, n[r] }) } else h.throwArgumentError("invalid tuple value", "tuple", n); e.length !== r.length && h.throwArgumentError("types/value length mismatch", "tuple", n); let i = new a.QV(t.wordSize), o = new a.QV(t.wordSize), l = []; e.forEach((t, e) => { let n = r[e]; if (t.dynamic) { let e = o.length; t.encode(o, n); let r = i.writeUpdatableValue(); l.push(t => { r(t + e) }) } else t.encode(i, n) }), l.forEach(t => { t(i.length) }); let c = t.appendWriter(i); return c += t.appendWriter(o), c } function p(t, e) { let n = [], r = t.subReader(0); e.forEach(e => { let i = null; if (e.dynamic) { let n = t.readValue(), a = r.subReader(n.toNumber()); try { i = e.decode(a) } catch (o) { if (o.code === s.Logger.errors.BUFFER_OVERRUN) throw o; i = o, i.baseType = e.name, i.name = e.localName, i.type = e.type } } else try { i = e.decode(t) } catch (o) { if (o.code === s.Logger.errors.BUFFER_OVERRUN) throw o; i = o, i.baseType = e.name, i.name = e.localName, i.type = e.type } null != i && n.push(i) }); const i = e.reduce((t, e) => { const n = e.localName; return n && (t[n] || (t[n] = 0), t[n]++), t }, {}); e.forEach((t, e) => { let r = t.localName; if (!r || 1 !== i[r]) return; if ("length" === r && (r = "_length"), null != n[r]) return; const s = n[e]; s instanceof Error ? Object.defineProperty(n, r, { get: () => { throw s } }) : n[r] = s }); for (let s = 0; s < n.length; s++) { const t = n[s]; t instanceof Error && Object.defineProperty(n, s, { get: () => { throw t } }) } return Object.freeze(n) } class f extends a.XI { constructor(t, e, n) { super("array", t.type + "[" + (e >= 0 ? e : "") + "]", n, -1 === e || t.dynamic), this.coder = t, this.length = e } defaultValue() { const t = this.coder.defaultValue(), e = []; for (let n = 0; n < this.length; n++)e.push(t); return e } encode(t, e) { Array.isArray(e) || this._throwError("expected array value", e); let n = this.length; -1 === n && (n = e.length, t.writeValue(e.length)), h.checkArgumentCount(e.length, n, "coder array" + (this.localName ? " " + this.localName : "")); let r = []; for (let i = 0; i < e.length; i++)r.push(this.coder); return d(t, r, e) } decode(t) { let e = this.length; -1 === e && (e = t.readValue().toNumber(), 32 * e > t._data.length && h.throwError("insufficient data length", s.Logger.errors.BUFFER_OVERRUN, { length: t._data.length, count: e })); let n = []; for (let r = 0; r < e; r++)n.push(new u(this.coder)); return t.coerce(this.name, p(t, n)) } } class m extends a.XI { constructor(t) { super("bool", "bool", t, !1) } defaultValue() { return !1 } encode(t, e) { return t.writeValue(e ? 1 : 0) } decode(t) { return t.coerce(this.type, !t.readValue().isZero()) } } class g extends a.XI { constructor(t, e) { super(t, t, e, !0) } defaultValue() { return "0x" } encode(t, e) { e = (0, r.arrayify)(e); let n = t.writeValue(e.length); return n += t.writeBytes(e), n } decode(t) { return t.readBytes(t.readValue().toNumber(), !0) } } class v extends g { constructor(t) { super("bytes", t) } decode(t) { return t.coerce(this.name, (0, r.hexlify)(super.decode(t))) } } class y extends a.XI { constructor(t, e) { let n = "bytes" + String(t); super(n, n, e, !1), this.size = t } defaultValue() { return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + 2 * this.size) } encode(t, e) { let n = (0, r.arrayify)(e); return n.length !== this.size && this._throwError("incorrect data length", e), t.writeBytes(n) } decode(t) { return t.coerce(this.name, (0, r.hexlify)(t.readBytes(this.size))) } } class b extends a.XI { constructor(t) { super("null", "", t, !1) } defaultValue() { return null } encode(t, e) { return null != e && this._throwError("not null", e), t.writeBytes([]) } decode(t) { return t.readBytes(0), t.coerce(this.name, null) } } var _ = n(2024), w = n(6659); class S extends a.XI { constructor(t, e, n) { const r = (e ? "int" : "uint") + 8 * t; super(r, r, n, !1), this.size = t, this.signed = e } defaultValue() { return 0 } encode(t, e) { let n = _.O$.from(e), r = w.Bz.mask(8 * t.wordSize); if (this.signed) { let t = r.mask(8 * this.size - 1); (n.gt(t) || n.lt(t.add(w.fh).mul(w.tL))) && this._throwError("value out-of-bounds", e) } else (n.lt(w._Y) || n.gt(r.mask(8 * this.size))) && this._throwError("value out-of-bounds", e); return n = n.toTwos(8 * this.size).mask(8 * this.size), this.signed && (n = n.fromTwos(8 * this.size).toTwos(8 * t.wordSize)), t.writeValue(n) } decode(t) { let e = t.readValue().mask(8 * this.size); return this.signed && (e = e.fromTwos(8 * this.size)), t.coerce(this.name, e) } } var x = n(8822); class T extends g { constructor(t) { super("string", t) } defaultValue() { return "" } encode(t, e) { return super.encode(t, (0, x.Y0)(e)) } decode(t) { return (0, x.ZN)(super.decode(t)) } } class E extends a.XI { constructor(t, e) { let n = !1; const r = []; t.forEach(t => { t.dynamic && (n = !0), r.push(t.type) }), super("tuple", "tuple(" + r.join(",") + ")", e, n), this.coders = t } defaultValue() { const t = []; this.coders.forEach(e => { t.push(e.defaultValue()) }); const e = this.coders.reduce((t, e) => { const n = e.localName; return n && (t[n] || (t[n] = 0), t[n]++), t }, {}); return this.coders.forEach((n, r) => { let i = n.localName; i && 1 === e[i] && ("length" === i && (i = "_length"), null == t[i] && (t[i] = t[r])) }), Object.freeze(t) } encode(t, e) { return d(t, this.coders, e) } decode(t) { return t.coerce(this.name, p(t, this.coders)) } } var M = n(5586); const A = new s.Logger(o.i), C = new RegExp(/^bytes([0-9]*)$/), P = new RegExp(/^(u?int)([0-9]*)$/); class R { constructor(t) { A.checkNew(new.target, R), (0, i.defineReadOnly)(this, "coerceFunc", t || null) } _getCoder(t) { switch (t.baseType) { case "address": return new c(t.name); case "bool": return new m(t.name); case "string": return new T(t.name); case "bytes": return new v(t.name); case "array": return new f(this._getCoder(t.arrayChildren), t.arrayLength, t.name); case "tuple": return new E((t.components || []).map(t => this._getCoder(t)), t.name); case "": return new b(t.name) }let e = t.type.match(P); if (e) { let n = parseInt(e[2] || "256"); return (0 === n || n > 256 || n % 8 != 0) && A.throwArgumentError("invalid " + e[1] + " bit length", "param", t), new S(n / 8, "int" === e[1], t.name) } if (e = t.type.match(C), e) { let n = parseInt(e[1]); return (0 === n || n > 32) && A.throwArgumentError("invalid bytes length", "param", t), new y(n, t.name) } return A.throwArgumentError("invalid type", "type", t.type) } _getWordSize() { return 32 } _getReader(t, e) { return new a.Ej(t, this._getWordSize(), this.coerceFunc, e) } _getWriter() { return new a.QV(this._getWordSize()) } getDefaultValue(t) { const e = t.map(t => this._getCoder(M._R.from(t))); return new E(e, "_").defaultValue() } encode(t, e) { t.length !== e.length && A.throwError("types/values length mismatch", s.Logger.errors.INVALID_ARGUMENT, { count: { types: t.length, values: e.length }, value: { types: t, values: e } }); const n = t.map(t => this._getCoder(M._R.from(t))), r = new E(n, "_"), i = this._getWriter(); return r.encode(i, e), i.data } decode(t, e, n) { const i = t.map(t => this._getCoder(M._R.from(t))); return new E(i, "_").decode(this._getReader((0, r.arrayify)(e), n)) } } const L = new R }, 1125: (t, e, n) => { "use strict"; n.d(e, { BR: () => c, XI: () => u, QV: () => h, Ej: () => d }); var r = n(1488), i = n(2024), s = n(2275), o = n(3898), a = n(1362); const l = new o.Logger(a.i); function c(t) { const e = [], n = function (t, r) { if (Array.isArray(r)) for (let s in r) { const o = t.slice(); o.push(s); try { n(o, r[s]) } catch (i) { e.push({ path: o, error: i }) } } }; return n([], t), e } class u { constructor(t, e, n, r) { this.name = t, this.type = e, this.localName = n, this.dynamic = r } _throwError(t, e) { l.throwArgumentError(t, this.localName, e) } } class h { constructor(t) { (0, s.defineReadOnly)(this, "wordSize", t || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(t) } get data() { return (0, r.hexConcat)(this._data) } get length() { return this._dataLength } _writeData(t) { return this._data.push(t), this._dataLength += t.length, t.length } appendWriter(t) { return this._writeData((0, r.concat)(t._data)) } writeBytes(t) { let e = (0, r.arrayify)(t); const n = e.length % this.wordSize; return n && (e = (0, r.concat)([e, this._padding.slice(n)])), this._writeData(e) } _getValue(t) { let e = (0, r.arrayify)(i.O$.from(t)); return e.length > this.wordSize && l.throwError("value out-of-bounds", o.Logger.errors.BUFFER_OVERRUN, { length: this.wordSize, offset: e.length }), e.length % this.wordSize && (e = (0, r.concat)([this._padding.slice(e.length % this.wordSize), e])), e } writeValue(t) { return this._writeData(this._getValue(t)) } writeUpdatableValue() { const t = this._data.length; return this._data.push(this._padding), this._dataLength += this.wordSize, e => { this._data[t] = this._getValue(e) } } } class d { constructor(t, e, n, i) { (0, s.defineReadOnly)(this, "_data", (0, r.arrayify)(t)), (0, s.defineReadOnly)(this, "wordSize", e || 32), (0, s.defineReadOnly)(this, "_coerceFunc", n), (0, s.defineReadOnly)(this, "allowLoose", i), this._offset = 0 } get data() { return (0, r.hexlify)(this._data) } get consumed() { return this._offset } static coerce(t, e) { let n = t.match("^u?int([0-9]+)$"); return n && parseInt(n[1]) <= 48 && (e = e.toNumber()), e } coerce(t, e) { return this._coerceFunc ? this._coerceFunc(t, e) : d.coerce(t, e) } _peekBytes(t, e, n) { let r = Math.ceil(e / this.wordSize) * this.wordSize; return this._offset + r > this._data.length && (this.allowLoose && n && this._offset + e <= this._data.length ? r = e : l.throwError("data out-of-bounds", o.Logger.errors.BUFFER_OVERRUN, { length: this._data.length, offset: this._offset + r })), this._data.slice(this._offset, this._offset + r) } subReader(t) { return new d(this._data.slice(this._offset + t), this.wordSize, this._coerceFunc, this.allowLoose) } readBytes(t, e) { let n = this._peekBytes(0, t, !!e); return this._offset += n.length, n.slice(0, t) } readValue() { return i.O$.from(this.readBytes(this.wordSize)) } } }, 5586: (t, e, n) => { "use strict"; n.d(e, { pc: () => p, _R: () => m, HY: () => v, QV: () => y, Xg: () => S, YW: () => x }); var r = n(2024), i = n(2275), s = n(3898), o = n(1362); const a = new s.Logger(o.i), l = {}; let c = { calldata: !0, memory: !0, storage: !0 }, u = { calldata: !0, memory: !0 }; function h(t, e) { if ("bytes" === t || "string" === t) { if (c[e]) return !0 } else if ("address" === t) { if ("payable" === e) return !0 } else if ((t.indexOf("[") >= 0 || "tuple" === t) && u[e]) return !0; return (c[e] || "payable" === e) && a.throwArgumentError("invalid modifier", "name", e), !1 } function d(t, e) { for (let n in e) (0, i.defineReadOnly)(t, n, e[n]) } const p = Object.freeze({ sighash: "sighash", minimal: "minimal", full: "full", json: "json" }), f = new RegExp(/^(.*)\[([0-9]*)\]$/); class m { constructor(t, e) { t !== l && a.throwError("use fromString", s.Logger.errors.UNSUPPORTED_OPERATION, { operation: "new ParamType()" }), d(this, e); let n = this.type.match(f); d(this, n ? { arrayLength: parseInt(n[2] || "-1"), arrayChildren: m.fromObject({ type: n[1], components: this.components }), baseType: "array" } : { arrayLength: null, arrayChildren: null, baseType: null != this.components ? "tuple" : this.type }), this._isParamType = !0, Object.freeze(this) } format(t) { if (t || (t = p.sighash), p[t] || a.throwArgumentError("invalid format type", "format", t), t === p.json) { let e = { type: "tuple" === this.baseType ? "tuple" : this.type, name: this.name || void 0 }; return "boolean" == typeof this.indexed && (e.indexed = this.indexed), this.components && (e.components = this.components.map(e => JSON.parse(e.format(t)))), JSON.stringify(e) } let e = ""; return "array" === this.baseType ? (e += this.arrayChildren.format(t), e += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : "tuple" === this.baseType ? (t !== p.sighash && (e += this.type), e += "(" + this.components.map(e => e.format(t)).join(t === p.full ? ", " : ",") + ")") : e += this.type, t !== p.sighash && (!0 === this.indexed && (e += " indexed"), t === p.full && this.name && (e += " " + this.name)), e } static from(t, e) { return "string" == typeof t ? m.fromString(t, e) : m.fromObject(t) } static fromObject(t) { return m.isParamType(t) ? t : new m(l, { name: t.name || null, type: T(t.type), indexed: null == t.indexed ? null : !!t.indexed, components: t.components ? t.components.map(m.fromObject) : null }) } static fromString(t, e) { return n = function (t, e) { let n = t; function r(e) { a.throwArgumentError(`unexpected character at position ${e}`, "param", t) } function i(t) { let n = { type: "", name: "", parent: t, state: { allowType: !0 } }; return e && (n.indexed = !1), n } t = t.replace(/\s/g, " "); let s = { type: "", name: "", state: { allowType: !0 } }, o = s; for (let a = 0; a < t.length; a++) { let n = t[a]; switch (n) { case "(": o.state.allowType && "" === o.type ? o.type = "tuple" : o.state.allowParams || r(a), o.state.allowType = !1, o.type = T(o.type), o.components = [i(o)], o = o.components[0]; break; case ")": delete o.state, "indexed" === o.name && (e || r(a), o.indexed = !0, o.name = ""), h(o.type, o.name) && (o.name = ""), o.type = T(o.type); let t = o; o = o.parent, o || r(a), delete t.parent, o.state.allowParams = !1, o.state.allowName = !0, o.state.allowArray = !0; break; case ",": delete o.state, "indexed" === o.name && (e || r(a), o.indexed = !0, o.name = ""), h(o.type, o.name) && (o.name = ""), o.type = T(o.type); let s = i(o.parent); o.parent.components.push(s), delete o.parent, o = s; break; case " ": o.state.allowType && "" !== o.type && (o.type = T(o.type), delete o.state.allowType, o.state.allowName = !0, o.state.allowParams = !0), o.state.allowName && "" !== o.name && ("indexed" === o.name ? (e || r(a), o.indexed && r(a), o.indexed = !0, o.name = "") : h(o.type, o.name) ? o.name = "" : o.state.allowName = !1); break; case "[": o.state.allowArray || r(a), o.type += n, o.state.allowArray = !1, o.state.allowName = !1, o.state.readArray = !0; break; case "]": o.state.readArray || r(a), o.type += n, o.state.readArray = !1, o.state.allowArray = !0, o.state.allowName = !0; break; default: o.state.allowType ? (o.type += n, o.state.allowParams = !0, o.state.allowArray = !0) : o.state.allowName ? (o.name += n, delete o.state.allowArray) : o.state.readArray ? o.type += n : r(a) } } return o.parent && a.throwArgumentError("unexpected eof", "param", t), delete s.state, "indexed" === o.name ? (e || r(n.length - 7), o.indexed && r(n.length - 7), o.indexed = !0, o.name = "") : h(o.type, o.name) && (o.name = ""), s.type = T(s.type), s }(t, !!e), m.fromObject({ name: n.name, type: n.type, indexed: n.indexed, components: n.components }); var n } static isParamType(t) { return !(null == t || !t._isParamType) } } function g(t, e) { return function (t) { t = t.trim(); let e = [], n = "", r = 0; for (let i = 0; i < t.length; i++) { let s = t[i]; "," === s && 0 === r ? (e.push(n), n = "") : (n += s, "(" === s ? r++ : ")" === s && (r--, -1 === r && a.throwArgumentError("unbalanced parenthesis", "value", t))) } return n && e.push(n), e }(t).map(t => m.fromString(t, e)) } class v { constructor(t, e) { t !== l && a.throwError("use a static from method", s.Logger.errors.UNSUPPORTED_OPERATION, { operation: "new Fragment()" }), d(this, e), this._isFragment = !0, Object.freeze(this) } static from(t) { return v.isFragment(t) ? t : "string" == typeof t ? v.fromString(t) : v.fromObject(t) } static fromObject(t) { if (v.isFragment(t)) return t; switch (t.type) { case "function": return x.fromObject(t); case "event": return y.fromObject(t); case "constructor": return S.fromObject(t); case "fallback": case "receive": return null }return a.throwArgumentError("invalid fragment object", "value", t) } static fromString(t) { return "event" === (t = (t = (t = t.replace(/\s/g, " ")).replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")).trim()).split(" ")[0] ? y.fromString(t.substring(5).trim()) : "function" === t.split(" ")[0] ? x.fromString(t.substring(8).trim()) : "constructor" === t.split("(")[0].trim() ? S.fromString(t.trim()) : a.throwArgumentError("unsupported fragment", "value", t) } static isFragment(t) { return !(!t || !t._isFragment) } } class y extends v { format(t) { if (t || (t = p.sighash), p[t] || a.throwArgumentError("invalid format type", "format", t), t === p.json) return JSON.stringify({ type: "event", anonymous: this.anonymous, name: this.name, inputs: this.inputs.map(e => JSON.parse(e.format(t))) }); let e = ""; return t !== p.sighash && (e += "event "), e += this.name + "(" + this.inputs.map(e => e.format(t)).join(t === p.full ? ", " : ",") + ") ", t !== p.sighash && this.anonymous && (e += "anonymous "), e.trim() } static from(t) { return "string" == typeof t ? y.fromString(t) : y.fromObject(t) } static fromObject(t) { if (y.isEventFragment(t)) return t; "event" !== t.type && a.throwArgumentError("invalid event object", "value", t); const e = { name: M(t.name), anonymous: t.anonymous, inputs: t.inputs ? t.inputs.map(m.fromObject) : [], type: "event" }; return new y(l, e) } static fromString(t) { let e = t.match(A); e || a.throwArgumentError("invalid event string", "value", t); let n = !1; return e[3].split(" ").forEach(t => { switch (t.trim()) { case "anonymous": n = !0; break; case "": break; default: a.warn("unknown modifier: " + t) } }), y.fromObject({ name: e[1].trim(), anonymous: n, inputs: g(e[2], !0), type: "event" }) } static isEventFragment(t) { return t && t._isFragment && "event" === t.type } } function b(t, e) { e.gas = null; let n = t.split("@"); return 1 !== n.length ? (n.length > 2 && a.throwArgumentError("invalid human-readable ABI signature", "value", t), n[1].match(/^[0-9]+$/) || a.throwArgumentError("invalid human-readable ABI signature gas", "value", t), e.gas = r.O$.from(n[1]), n[0]) : t } function _(t, e) { e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", t.split(" ").forEach(t => { switch (t.trim()) { case "constant": e.constant = !0; break; case "payable": e.payable = !0, e.stateMutability = "payable"; break; case "nonpayable": e.payable = !1, e.stateMutability = "nonpayable"; break; case "pure": e.constant = !0, e.stateMutability = "pure"; break; case "view": e.constant = !0, e.stateMutability = "view"; break; case "external": case "public": case "": break; default: console.log("unknown modifier: " + t) } }) } function w(t) { let e = { constant: !1, payable: !0, stateMutability: "payable" }; return null != t.stateMutability ? (e.stateMutability = t.stateMutability, e.constant = "view" === e.stateMutability || "pure" === e.stateMutability, null != t.constant && !!t.constant !== e.constant && a.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", t), e.payable = "payable" === e.stateMutability, null != t.payable && !!t.payable !== e.payable && a.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", t)) : null != t.payable ? (e.payable = !!t.payable, null != t.constant || e.payable || "constructor" === t.type || a.throwArgumentError("unable to determine stateMutability", "value", t), e.constant = !!t.constant, e.stateMutability = e.constant ? "view" : e.payable ? "payable" : "nonpayable", e.payable && e.constant && a.throwArgumentError("cannot have constant payable function", "value", t)) : null != t.constant ? (e.constant = !!t.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : "constructor" !== t.type && a.throwArgumentError("unable to determine stateMutability", "value", t), e } class S extends v { format(t) { if (t || (t = p.sighash), p[t] || a.throwArgumentError("invalid format type", "format", t), t === p.json) return JSON.stringify({ type: "constructor", stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0, payable: this.payable, gas: this.gas ? this.gas.toNumber() : void 0, inputs: this.inputs.map(e => JSON.parse(e.format(t))) }); t === p.sighash && a.throwError("cannot format a constructor for sighash", s.Logger.errors.UNSUPPORTED_OPERATION, { operation: "format(sighash)" }); let e = "constructor(" + this.inputs.map(e => e.format(t)).join(t === p.full ? ", " : ",") + ") "; return this.stateMutability && "nonpayable" !== this.stateMutability && (e += this.stateMutability + " "), e.trim() } static from(t) { return "string" == typeof t ? S.fromString(t) : S.fromObject(t) } static fromObject(t) { if (S.isConstructorFragment(t)) return t; "constructor" !== t.type && a.throwArgumentError("invalid constructor object", "value", t); let e = w(t); e.constant && a.throwArgumentError("constructor cannot be constant", "value", t); const n = { name: null, type: t.type, inputs: t.inputs ? t.inputs.map(m.fromObject) : [], payable: e.payable, stateMutability: e.stateMutability, gas: t.gas ? r.O$.from(t.gas) : null }; return new S(l, n) } static fromString(t) { let e = { type: "constructor" }, n = (t = b(t, e)).match(A); return n && "constructor" === n[1].trim() || a.throwArgumentError("invalid constructor string", "value", t), e.inputs = g(n[2].trim(), !1), _(n[3].trim(), e), S.fromObject(e) } static isConstructorFragment(t) { return t && t._isFragment && "constructor" === t.type } } class x extends S { format(t) { if (t || (t = p.sighash), p[t] || a.throwArgumentError("invalid format type", "format", t), t === p.json) return JSON.stringify({ type: "function", name: this.name, constant: this.constant, stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0, payable: this.payable, gas: this.gas ? this.gas.toNumber() : void 0, inputs: this.inputs.map(e => JSON.parse(e.format(t))), outputs: this.outputs.map(e => JSON.parse(e.format(t))) }); let e = ""; return t !== p.sighash && (e += "function "), e += this.name + "(" + this.inputs.map(e => e.format(t)).join(t === p.full ? ", " : ",") + ") ", t !== p.sighash && (this.stateMutability ? "nonpayable" !== this.stateMutability && (e += this.stateMutability + " ") : this.constant && (e += "view "), this.outputs && this.outputs.length && (e += "returns (" + this.outputs.map(e => e.format(t)).join(", ") + ") "), null != this.gas && (e += "@" + this.gas.toString() + " ")), e.trim() } static from(t) { return "string" == typeof t ? x.fromString(t) : x.fromObject(t) } static fromObject(t) { if (x.isFunctionFragment(t)) return t; "function" !== t.type && a.throwArgumentError("invalid function object", "value", t); let e = w(t); const n = { type: t.type, name: M(t.name), constant: e.constant, inputs: t.inputs ? t.inputs.map(m.fromObject) : [], outputs: t.outputs ? t.outputs.map(m.fromObject) : [], payable: e.payable, stateMutability: e.stateMutability, gas: t.gas ? r.O$.from(t.gas) : null }; return new x(l, n) } static fromString(t) { let e = { type: "function" }, n = (t = b(t, e)).split(" returns "); n.length > 2 && a.throwArgumentError("invalid function string", "value", t); let r = n[0].match(A); if (r || a.throwArgumentError("invalid function signature", "value", t), e.name = r[1].trim(), e.name && M(e.name), e.inputs = g(r[2], !1), _(r[3].trim(), e), n.length > 1) { let r = n[1].match(A); "" == r[1].trim() && "" == r[3].trim() || a.throwArgumentError("unexpected tokens", "value", t), e.outputs = g(r[2], !1) } else e.outputs = []; return x.fromObject(e) } static isFunctionFragment(t) { return t && t._isFragment && "function" === t.type } } function T(t) { return t.match(/^uint($|[^1-9])/) ? t = "uint256" + t.substring(4) : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)), t } const E = new RegExp("^[A-Za-z_][A-Za-z0-9_]*$"); function M(t) { return t && t.match(E) || a.throwArgumentError(`invalid identifier "${t}"`, "value", t), t } const A = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$") }, 7910: (t, e, n) => { "use strict"; n.r(e), n.d(e, { ConstructorFragment: () => r.Xg, EventFragment: () => r.QV, Fragment: () => r.HY, FunctionFragment: () => r.YW, ParamType: () => r._R, FormatTypes: () => r.pc, AbiCoder: () => i.R, defaultAbiCoder: () => i.$, Interface: () => s.vU, Indexed: () => s.Hk, checkResultErrors: () => o.BR, LogDescription: () => s.CC, TransactionDescription: () => s.vk }); var r = n(5586), i = n(3941), s = n(886), o = n(1125) }, 886: (t, e, n) => { "use strict"; n.d(e, { CC: () => f, vk: () => m, Hk: () => g, vU: () => y }); var r = n(2885), i = n(2024), s = n(1488), o = n(7475), a = n(8518), l = n(2275), c = n(3941), u = n(5586), h = n(3898), d = n(1362); const p = new h.Logger(d.i); class f extends l.Description { } class m extends l.Description { } class g extends l.Description { static isIndexed(t) { return !(!t || !t._isIndexed) } } function v(t, e) { const n = new Error(`deferred error during ABI decoding triggered accessing ${t}`); return n.error = e, n } class y { constructor(t) { p.checkNew(new.target, y); let e = []; e = "string" == typeof t ? JSON.parse(t) : t, (0, l.defineReadOnly)(this, "fragments", e.map(t => u.HY.from(t)).filter(t => null != t)), (0, l.defineReadOnly)(this, "_abiCoder", (0, l.getStatic)(new.target, "getAbiCoder")()), (0, l.defineReadOnly)(this, "functions", {}), (0, l.defineReadOnly)(this, "errors", {}), (0, l.defineReadOnly)(this, "events", {}), (0, l.defineReadOnly)(this, "structs", {}), this.fragments.forEach(t => { let e = null; switch (t.type) { case "constructor": return this.deploy ? void p.warn("duplicate definition - constructor") : void (0, l.defineReadOnly)(this, "deploy", t); case "function": e = this.functions; break; case "event": e = this.events; break; default: return }let n = t.format(); e[n] ? p.warn("duplicate definition - " + n) : e[n] = t }), this.deploy || (0, l.defineReadOnly)(this, "deploy", u.Xg.from({ payable: !1, type: "constructor" })), (0, l.defineReadOnly)(this, "_isInterface", !0) } format(t) { t || (t = u.pc.full), t === u.pc.sighash && p.throwArgumentError("interface does not support formatting sighash", "format", t); const e = this.fragments.map(e => e.format(t)); return t === u.pc.json ? JSON.stringify(e.map(t => JSON.parse(t))) : e } static getAbiCoder() { return c.$ } static getAddress(t) { return (0, r.getAddress)(t) } static getSighash(t) { return (0, s.hexDataSlice)((0, o.id)(t.format()), 0, 4) } static getEventTopic(t) { return (0, o.id)(t.format()) } getFunction(t) { if ((0, s.isHexString)(t)) { for (const e in this.functions) if (t === this.getSighash(e)) return this.functions[e]; p.throwArgumentError("no matching function", "sighash", t) } if (-1 === t.indexOf("(")) { const e = t.trim(), n = Object.keys(this.functions).filter(t => t.split("(")[0] === e); return 0 === n.length ? p.throwArgumentError("no matching function", "name", e) : n.length > 1 && p.throwArgumentError("multiple matching functions", "name", e), this.functions[n[0]] } const e = this.functions[u.YW.fromString(t).format()]; return e || p.throwArgumentError("no matching function", "signature", t), e } getEvent(t) { if ((0, s.isHexString)(t)) { const e = t.toLowerCase(); for (const t in this.events) if (e === this.getEventTopic(t)) return this.events[t]; p.throwArgumentError("no matching event", "topichash", e) } if (-1 === t.indexOf("(")) { const e = t.trim(), n = Object.keys(this.events).filter(t => t.split("(")[0] === e); return 0 === n.length ? p.throwArgumentError("no matching event", "name", e) : n.length > 1 && p.throwArgumentError("multiple matching events", "name", e), this.events[n[0]] } const e = this.events[u.QV.fromString(t).format()]; return e || p.throwArgumentError("no matching event", "signature", t), e } getSighash(t) { return "string" == typeof t && (t = this.getFunction(t)), (0, l.getStatic)(this.constructor, "getSighash")(t) } getEventTopic(t) { return "string" == typeof t && (t = this.getEvent(t)), (0, l.getStatic)(this.constructor, "getEventTopic")(t) } _decodeParams(t, e) { return this._abiCoder.decode(t, e) } _encodeParams(t, e) { return this._abiCoder.encode(t, e) } encodeDeploy(t) { return this._encodeParams(this.deploy.inputs, t || []) } decodeFunctionData(t, e) { "string" == typeof t && (t = this.getFunction(t)); const n = (0, s.arrayify)(e); return (0, s.hexlify)(n.slice(0, 4)) !== this.getSighash(t) && p.throwArgumentError(`data signature does not match function ${t.name}.`, "data", (0, s.hexlify)(n)), this._decodeParams(t.inputs, n.slice(4)) } encodeFunctionData(t, e) { return "string" == typeof t && (t = this.getFunction(t)), (0, s.hexlify)((0, s.concat)([this.getSighash(t), this._encodeParams(t.inputs, e || [])])) } decodeFunctionResult(t, e) { "string" == typeof t && (t = this.getFunction(t)); let n = (0, s.arrayify)(e), r = null, i = null; switch (n.length % this._abiCoder._getWordSize()) { case 0: try { return this._abiCoder.decode(t.outputs, n) } catch (o) { } break; case 4: "0x08c379a0" === (0, s.hexlify)(n.slice(0, 4)) && (i = "Error(string)", r = this._abiCoder.decode(["string"], n.slice(4))[0]) }return p.throwError("call revert exception", h.Logger.errors.CALL_EXCEPTION, { method: t.format(), errorSignature: i, errorArgs: [r], reason: r }) } encodeFunctionResult(t, e) { return "string" == typeof t && (t = this.getFunction(t)), (0, s.hexlify)(this._abiCoder.encode(t.outputs, e || [])) } encodeFilterTopics(t, e) { "string" == typeof t && (t = this.getEvent(t)), e.length > t.inputs.length && p.throwError("too many arguments for " + t.format(), h.Logger.errors.UNEXPECTED_ARGUMENT, { argument: "values", value: e }); let n = []; t.anonymous || n.push(this.getEventTopic(t)); const r = (t, e) => "string" === t.type ? (0, o.id)(e) : "bytes" === t.type ? (0, a.keccak256)((0, s.hexlify)(e)) : ("address" === t.type && this._abiCoder.encode(["address"], [e]), (0, s.hexZeroPad)((0, s.hexlify)(e), 32)); for (e.forEach((e, i) => { let s = t.inputs[i]; s.indexed ? null == e ? n.push(null) : "array" === s.baseType || "tuple" === s.baseType ? p.throwArgumentError("filtering with tuples or arrays not supported", "contract." + s.name, e) : Array.isArray(e) ? n.push(e.map(t => r(s, t))) : n.push(r(s, e)) : null != e && p.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + s.name, e) }); n.length && null === n[n.length - 1];)n.pop(); return n } encodeEventLog(t, e) { "string" == typeof t && (t = this.getEvent(t)); const n = [], r = [], i = []; return t.anonymous || n.push(this.getEventTopic(t)), e.length !== t.inputs.length && p.throwArgumentError("event arguments/values mismatch", "values", e), t.inputs.forEach((t, s) => { const l = e[s]; if (t.indexed) if ("string" === t.type) n.push((0, o.id)(l)); else if ("bytes" === t.type) n.push((0, a.keccak256)(l)); else { if ("tuple" === t.baseType || "array" === t.baseType) throw new Error("not implemented"); n.push(this._abiCoder.encode([t.type], [l])) } else r.push(t), i.push(l) }), { data: this._abiCoder.encode(r, i), topics: n } } decodeEventLog(t, e, n) { if ("string" == typeof t && (t = this.getEvent(t)), null != n && !t.anonymous) { let e = this.getEventTopic(t); (0, s.isHexString)(n[0], 32) && n[0].toLowerCase() === e || p.throwError("fragment/topic mismatch", h.Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: e, value: n[0] }), n = n.slice(1) } let r = [], i = [], o = []; t.inputs.forEach((t, e) => { t.indexed ? "string" === t.type || "bytes" === t.type || "tuple" === t.baseType || "array" === t.baseType ? (r.push(u._R.fromObject({ type: "bytes32", name: t.name })), o.push(!0)) : (r.push(t), o.push(!1)) : (i.push(t), o.push(!1)) }); let a = null != n ? this._abiCoder.decode(r, (0, s.concat)(n)) : null, l = this._abiCoder.decode(i, e, !0), c = [], d = 0, f = 0; t.inputs.forEach((t, e) => { if (t.indexed) if (null == a) c[e] = new g({ _isIndexed: !0, hash: null }); else if (o[e]) c[e] = new g({ _isIndexed: !0, hash: a[f++] }); else try { c[e] = a[f++] } catch (n) { c[e] = n } else try { c[e] = l[d++] } catch (n) { c[e] = n } if (t.name && null == c[t.name]) { const n = c[e]; n instanceof Error ? Object.defineProperty(c, t.name, { get: () => { throw v(`property ${JSON.stringify(t.name)}`, n) } }) : c[t.name] = n } }); for (let s = 0; s < c.length; s++) { const t = c[s]; t instanceof Error && Object.defineProperty(c, s, { get: () => { throw v(`index ${s}`, t) } }) } return Object.freeze(c) } parseTransaction(t) { let e = this.getFunction(t.data.substring(0, 10).toLowerCase()); return e ? new m({ args: this._abiCoder.decode(e.inputs, "0x" + t.data.substring(10)), functionFragment: e, name: e.name, signature: e.format(), sighash: this.getSighash(e), value: i.O$.from(t.value || "0") }) : null } parseLog(t) { let e = this.getEvent(t.topics[0]); return !e || e.anonymous ? null : new f({ eventFragment: e, name: e.name, signature: e.format(), topic: this.getEventTopic(e), args: this.decodeEventLog(e, t.data, t.topics) }) } static isInterface(t) { return !(!t || !t._isInterface) } } }, 1527: (t, e, n) => { "use strict"; n.d(e, { Sg: () => s, zt: () => o }); var r = n(2275); const i = new (n(3898).Logger)("abstract-provider/5.1.0"); class s extends r.Description { static isForkEvent(t) { return !(!t || !t._isForkEvent) } } class o { constructor() { i.checkAbstract(new.target, o), (0, r.defineReadOnly)(this, "_isProvider", !0) } addListener(t, e) { return this.on(t, e) } removeListener(t, e) { return this.off(t, e) } static isProvider(t) { return !(!t || !t._isProvider) } } }, 1221: (t, e, n) => { "use strict"; n.r(e), n.d(e, { Signer: () => c, VoidSigner: () => u }); var r = n(2275), i = n(3898), s = function (t, e, n, r) { return new (n || (n = Promise))(function (i, s) { function o(t) { try { l(r.next(t)) } catch (e) { s(e) } } function a(t) { try { l(r.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } l((r = r.apply(t, e || [])).next()) }) }; const o = new i.Logger("abstract-signer/5.1.0"), a = ["accessList", "chainId", "data", "from", "gasLimit", "gasPrice", "nonce", "to", "type", "value"], l = [i.Logger.errors.INSUFFICIENT_FUNDS, i.Logger.errors.NONCE_EXPIRED, i.Logger.errors.REPLACEMENT_UNDERPRICED]; class c { constructor() { o.checkAbstract(new.target, c), (0, r.defineReadOnly)(this, "_isSigner", !0) } getBalance(t) { return s(this, void 0, void 0, function* () { return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), t) }) } getTransactionCount(t) { return s(this, void 0, void 0, function* () { return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), t) }) } estimateGas(t) { return s(this, void 0, void 0, function* () { this._checkProvider("estimateGas"); const e = yield (0, r.resolveProperties)(this.checkTransaction(t)); return yield this.provider.estimateGas(e) }) } call(t, e) { return s(this, void 0, void 0, function* () { this._checkProvider("call"); const n = yield (0, r.resolveProperties)(this.checkTransaction(t)); return yield this.provider.call(n, e) }) } sendTransaction(t) { return this._checkProvider("sendTransaction"), this.populateTransaction(t).then(t => this.signTransaction(t).then(t => this.provider.sendTransaction(t))) } getChainId() { return s(this, void 0, void 0, function* () { return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId }) } getGasPrice() { return s(this, void 0, void 0, function* () { return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice() }) } resolveName(t) { return s(this, void 0, void 0, function* () { return this._checkProvider("resolveName"), yield this.provider.resolveName(t) }) } checkTransaction(t) { for (const n in t) -1 === a.indexOf(n) && o.throwArgumentError("invalid transaction key: " + n, "transaction", t); const e = (0, r.shallowCopy)(t); return e.from = null == e.from ? this.getAddress() : Promise.all([Promise.resolve(e.from), this.getAddress()]).then(e => (e[0].toLowerCase() !== e[1].toLowerCase() && o.throwArgumentError("from address mismatch", "transaction", t), e[0])), e } populateTransaction(t) { return s(this, void 0, void 0, function* () { const e = yield (0, r.resolveProperties)(this.checkTransaction(t)); return null != e.to && (e.to = Promise.resolve(e.to).then(t => s(this, void 0, void 0, function* () { if (null == t) return null; const e = yield this.resolveName(t); return null == e && o.throwArgumentError("provided ENS name resolves to null", "tx.to", t), e }))), null == e.gasPrice && (e.gasPrice = this.getGasPrice()), null == e.nonce && (e.nonce = this.getTransactionCount("pending")), null == e.gasLimit && (e.gasLimit = this.estimateGas(e).catch(t => { if (l.indexOf(t.code) >= 0) throw t; return o.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", i.Logger.errors.UNPREDICTABLE_GAS_LIMIT, { error: t, tx: e }) })), e.chainId = null == e.chainId ? this.getChainId() : Promise.all([Promise.resolve(e.chainId), this.getChainId()]).then(e => (0 !== e[1] && e[0] !== e[1] && o.throwArgumentError("chainId address mismatch", "transaction", t), e[0])), yield (0, r.resolveProperties)(e) }) } _checkProvider(t) { this.provider || o.throwError("missing provider", i.Logger.errors.UNSUPPORTED_OPERATION, { operation: t || "_checkProvider" }) } static isSigner(t) { return !(!t || !t._isSigner) } } class u extends c { constructor(t, e) { o.checkNew(new.target, u), super(), (0, r.defineReadOnly)(this, "address", t), (0, r.defineReadOnly)(this, "provider", e || null) } getAddress() { return Promise.resolve(this.address) } _fail(t, e) { return Promise.resolve().then(() => { o.throwError(t, i.Logger.errors.UNSUPPORTED_OPERATION, { operation: e }) }) } signMessage(t) { return this._fail("VoidSigner cannot sign messages", "signMessage") } signTransaction(t) { return this._fail("VoidSigner cannot sign transactions", "signTransaction") } _signTypedData(t, e, n) { return this._fail("VoidSigner cannot sign typed data", "signTypedData") } connect(t) { return new u(this.address, t) } } }, 2885: (t, e, n) => { "use strict"; n.r(e), n.d(e, { getAddress: () => p, getContractAddress: () => g, getCreate2Address: () => v, getIcapAddress: () => m, isAddress: () => f }); var r = n(1488), i = n(2024), s = n(8518), o = n(9276); const a = new (n(3898).Logger)("address/5.1.0"); function l(t) { (0, r.isHexString)(t, 20) || a.throwArgumentError("invalid address", "address", t); const e = (t = t.toLowerCase()).substring(2).split(""), n = new Uint8Array(40); for (let r = 0; r < 40; r++)n[r] = e[r].charCodeAt(0); const i = (0, r.arrayify)((0, s.keccak256)(n)); for (let r = 0; r < 40; r += 2)i[r >> 1] >> 4 >= 8 && (e[r] = e[r].toUpperCase()), (15 & i[r >> 1]) >= 8 && (e[r + 1] = e[r + 1].toUpperCase()); return "0x" + e.join("") } const c = {}; for (let y = 0; y < 10; y++)c[String(y)] = String(y); for (let y = 0; y < 26; y++)c[String.fromCharCode(65 + y)] = String(10 + y); const u = Math.floor((h = 9007199254740991, Math.log10 ? Math.log10(h) : Math.log(h) / Math.LN10)); var h; function d(t) { let e = (t = (t = t.toUpperCase()).substring(4) + t.substring(0, 2) + "00").split("").map(t => c[t]).join(""); for (; e.length >= u;) { let t = e.substring(0, u); e = parseInt(t, 10) % 97 + e.substring(t.length) } let n = String(98 - parseInt(e, 10) % 97); for (; n.length < 2;)n = "0" + n; return n } function p(t) { let e = null; if ("string" != typeof t && a.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) "0x" !== t.substring(0, 2) && (t = "0x" + t), e = l(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && a.throwArgumentError("bad address checksum", "address", t); else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) { for (t.substring(2, 4) !== d(t) && a.throwArgumentError("bad icap checksum", "address", t), e = (0, i.g$)(t.substring(4)); e.length < 40;)e = "0" + e; e = l("0x" + e) } else a.throwArgumentError("invalid address", "address", t); return e } function f(t) { try { return p(t), !0 } catch (e) { } return !1 } function m(t) { let e = (0, i.t2)(p(t).substring(2)).toUpperCase(); for (; e.length < 30;)e = "0" + e; return "XE" + d("XE00" + e) + e } function g(t) { let e = null; try { e = p(t.from) } catch (l) { a.throwArgumentError("missing from address", "transaction", t) } const n = (0, r.stripZeros)((0, r.arrayify)(i.O$.from(t.nonce).toHexString())); return p((0, r.hexDataSlice)((0, s.keccak256)((0, o.encode)([e, n])), 12)) } function v(t, e, n) { return 32 !== (0, r.hexDataLength)(e) && a.throwArgumentError("salt must be 32 bytes", "salt", e), 32 !== (0, r.hexDataLength)(n) && a.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", n), p((0, r.hexDataSlice)((0, s.keccak256)((0, r.concat)(["0xff", p(t), e, n])), 12)) } }, 7530: (t, e, n) => { "use strict"; n.d(e, { J: () => i, c: () => s }); var r = n(1488); function i(t) { t = atob(t); const e = []; for (let n = 0; n < t.length; n++)e.push(t.charCodeAt(n)); return (0, r.arrayify)(e) } function s(t) { t = (0, r.arrayify)(t); let e = ""; for (let n = 0; n < t.length; n++)e += String.fromCharCode(t[n]); return btoa(e) } }, 2220: (t, e, n) => { "use strict"; n.r(e), n.d(e, { decode: () => r.J, encode: () => r.c }); var r = n(7530) }, 3744: (t, e, n) => { "use strict"; n.r(e), n.d(e, { BaseX: () => s, Base32: () => o, Base58: () => a }); var r = n(1488), i = n(2275); class s { constructor(t) { (0, i.defineReadOnly)(this, "alphabet", t), (0, i.defineReadOnly)(this, "base", t.length), (0, i.defineReadOnly)(this, "_alphabetMap", {}), (0, i.defineReadOnly)(this, "_leader", t.charAt(0)); for (let e = 0; e < t.length; e++)this._alphabetMap[t.charAt(e)] = e } encode(t) { let e = (0, r.arrayify)(t); if (0 === e.length) return ""; let n = [0]; for (let r = 0; r < e.length; ++r) { let t = e[r]; for (let e = 0; e < n.length; ++e)t += n[e] << 8, n[e] = t % this.base, t = t / this.base | 0; for (; t > 0;)n.push(t % this.base), t = t / this.base | 0 } let i = ""; for (let r = 0; 0 === e[r] && r < e.length - 1; ++r)i += this._leader; for (let r = n.length - 1; r >= 0; --r)i += this.alphabet[n[r]]; return i } decode(t) { if ("string" != typeof t) throw new TypeError("Expected String"); let e = []; if (0 === t.length) return new Uint8Array(e); e.push(0); for (let n = 0; n < t.length; n++) { let r = this._alphabetMap[t[n]]; if (void 0 === r) throw new Error("Non-base" + this.base + " character"); let i = r; for (let t = 0; t < e.length; ++t)i += e[t] * this.base, e[t] = 255 & i, i >>= 8; for (; i > 0;)e.push(255 & i), i >>= 8 } for (let n = 0; t[n] === this._leader && n < t.length - 1; ++n)e.push(0); return (0, r.arrayify)(new Uint8Array(e.reverse())) } } const o = new s("abcdefghijklmnopqrstuvwxyz234567"), a = new s("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz") }, 4325: (t, e, n) => { "use strict"; n.d(e, { i: () => r }); const r = "bignumber/5.1.1" }, 2024: (t, e, n) => { "use strict"; n.d(e, { Zm: () => d, O$: () => f, g$: () => b, t2: () => _ }); var r = n(3191), i = n.n(r), s = n(1488), o = n(3898), a = n(4325), l = i().BN; const c = new o.Logger(a.i), u = {}, h = 9007199254740991; function d(t) { return null != t && (f.isBigNumber(t) || "number" == typeof t && t % 1 == 0 || "string" == typeof t && !!t.match(/^-?[0-9]+$/) || (0, s.isHexString)(t) || "bigint" == typeof t || (0, s.isBytes)(t)) } let p = !1; class f { constructor(t, e) { c.checkNew(new.target, f), t !== u && c.throwError("cannot call constructor directly; use BigNumber.from", o.Logger.errors.UNSUPPORTED_OPERATION, { operation: "new (BigNumber)" }), this._hex = e, this._isBigNumber = !0, Object.freeze(this) } fromTwos(t) { return g(v(this).fromTwos(t)) } toTwos(t) { return g(v(this).toTwos(t)) } abs() { return "-" === this._hex[0] ? f.from(this._hex.substring(1)) : this } add(t) { return g(v(this).add(v(t))) } sub(t) { return g(v(this).sub(v(t))) } div(t) { return f.from(t).isZero() && y("division by zero", "div"), g(v(this).div(v(t))) } mul(t) { return g(v(this).mul(v(t))) } mod(t) { const e = v(t); return e.isNeg() && y("cannot modulo negative values", "mod"), g(v(this).umod(e)) } pow(t) { const e = v(t); return e.isNeg() && y("cannot raise to negative values", "pow"), g(v(this).pow(e)) } and(t) { const e = v(t); return (this.isNegative() || e.isNeg()) && y("cannot 'and' negative values", "and"), g(v(this).and(e)) } or(t) { const e = v(t); return (this.isNegative() || e.isNeg()) && y("cannot 'or' negative values", "or"), g(v(this).or(e)) } xor(t) { const e = v(t); return (this.isNegative() || e.isNeg()) && y("cannot 'xor' negative values", "xor"), g(v(this).xor(e)) } mask(t) { return (this.isNegative() || t < 0) && y("cannot mask negative values", "mask"), g(v(this).maskn(t)) } shl(t) { return (this.isNegative() || t < 0) && y("cannot shift negative values", "shl"), g(v(this).shln(t)) } shr(t) { return (this.isNegative() || t < 0) && y("cannot shift negative values", "shr"), g(v(this).shrn(t)) } eq(t) { return v(this).eq(v(t)) } lt(t) { return v(this).lt(v(t)) } lte(t) { return v(this).lte(v(t)) } gt(t) { return v(this).gt(v(t)) } gte(t) { return v(this).gte(v(t)) } isNegative() { return "-" === this._hex[0] } isZero() { return v(this).isZero() } toNumber() { try { return v(this).toNumber() } catch (t) { y("overflow", "toNumber", this.toString()) } return null } toBigInt() { try { return BigInt(this.toString()) } catch (t) { } return c.throwError("this platform does not support BigInt", o.Logger.errors.UNSUPPORTED_OPERATION, { value: this.toString() }) } toString() { return arguments.length > 0 && (10 === arguments[0] ? p || (p = !0, c.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : c.throwError(16 === arguments[0] ? "BigNumber.toString does not accept any parameters; use bigNumber.toHexString()" : "BigNumber.toString does not accept parameters", o.Logger.errors.UNEXPECTED_ARGUMENT, {})), v(this).toString(10) } toHexString() { return this._hex } toJSON(t) { return { type: "BigNumber", hex: this.toHexString() } } static from(t) { if (t instanceof f) return t; if ("string" == typeof t) return t.match(/^-?0x[0-9a-f]+$/i) ? new f(u, m(t)) : t.match(/^-?[0-9]+$/) ? new f(u, m(new l(t))) : c.throwArgumentError("invalid BigNumber string", "value", t); if ("number" == typeof t) return t % 1 && y("underflow", "BigNumber.from", t), (t >= h || t <= -h) && y("overflow", "BigNumber.from", t), f.from(String(t)); const e = t; if ("bigint" == typeof e) return f.from(e.toString()); if ((0, s.isBytes)(e)) return f.from((0, s.hexlify)(e)); if (e) if (e.toHexString) { const t = e.toHexString(); if ("string" == typeof t) return f.from(t) } else { let t = e._hex; if (null == t && "BigNumber" === e.type && (t = e.hex), "string" == typeof t && ((0, s.isHexString)(t) || "-" === t[0] && (0, s.isHexString)(t.substring(1)))) return f.from(t) } return c.throwArgumentError("invalid BigNumber value", "value", t) } static isBigNumber(t) { return !(!t || !t._isBigNumber) } } function m(t) { if ("string" != typeof t) return m(t.toString(16)); if ("-" === t[0]) return "-" === (t = t.substring(1))[0] && c.throwArgumentError("invalid hex", "value", t), "0x00" === (t = m(t)) ? t : "-" + t; if ("0x" !== t.substring(0, 2) && (t = "0x" + t), "0x" === t) return "0x00"; for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && "0x00" === t.substring(0, 4);)t = "0x" + t.substring(4); return t } function g(t) { return f.from(m(t)) } function v(t) { const e = f.from(t).toHexString(); return new l("-" === e[0] ? "-" + e.substring(3) : e.substring(2), 16) } function y(t, e, n) { const r = { fault: t, operation: e }; return null != n && (r.value = n), c.throwError(t, o.Logger.errors.NUMERIC_FAULT, r) } function b(t) { return new l(t, 36).toString(16) } function _(t) { return new l(t, 16).toString(36) } }, 1677: (t, e, n) => { "use strict"; n.d(e, { S5: () => f, Ox: () => m, xO: () => g, xs: () => v }); var r = n(1488), i = n(3898), s = n(4325), o = n(2024); const a = new i.Logger(s.i), l = {}, c = o.O$.from(0), u = o.O$.from(-1); function h(t, e, n, r) { const s = { fault: e, operation: n }; return void 0 !== r && (s.value = r), a.throwError(t, i.Logger.errors.NUMERIC_FAULT, s) } let d = "0"; for (; d.length < 256;)d += d; function p(t) { if ("number" != typeof t) try { t = o.O$.from(t).toNumber() } catch (e) { } return "number" == typeof t && t >= 0 && t <= 256 && !(t % 1) ? "1" + d.substring(0, t) : a.throwArgumentError("invalid decimal size", "decimals", t) } function f(t, e) { null == e && (e = 0); const n = p(e), r = (t = o.O$.from(t)).lt(c); r && (t = t.mul(u)); let i = t.mod(n).toString(); for (; i.length < n.length - 1;)i = "0" + i; i = i.match(/^([0-9]*[1-9]|0)(0*)/)[1]; const s = t.div(n).toString(); return t = s + "." + i, r && (t = "-" + t), t } function m(t, e) { null == e && (e = 0); const n = p(e); if ("string" == typeof t && t.match(/^-?[0-9.,]+$/) || a.throwArgumentError("invalid decimal value", "value", t), n.length - 1 == 0) return o.O$.from(t); const r = "-" === t.substring(0, 1); r && (t = t.substring(1)), "." === t && a.throwArgumentError("missing value", "value", t); const i = t.split("."); i.length > 2 && a.throwArgumentError("too many decimal points", "value", t); let s = i[0], l = i[1]; for (s || (s = "0"), l || (l = "0"), l.length > n.length - 1 && h("fractional component exceeds decimals", "underflow", "parseFixed"); l.length < n.length - 1;)l += "0"; const c = o.O$.from(s), d = o.O$.from(l); let f = c.mul(n).add(d); return r && (f = f.mul(u)), f } class g { constructor(t, e, n, r) { t !== l && a.throwError("cannot use FixedFormat constructor; use FixedFormat.from", i.Logger.errors.UNSUPPORTED_OPERATION, { operation: "new FixedFormat" }), this.signed = e, this.width = n, this.decimals = r, this.name = (e ? "" : "u") + "fixed" + String(n) + "x" + String(r), this._multiplier = p(r), Object.freeze(this) } static from(t) { if (t instanceof g) return t; let e = !0, n = 128, r = 18; if ("string" == typeof t) { if ("fixed" === t); else if ("ufixed" === t) e = !1; else if (null != t) { const i = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/); i || a.throwArgumentError("invalid fixed format", "format", t), e = "u" !== i[1], n = parseInt(i[2]), r = parseInt(i[3]) } } else if (t) { const i = (e, n, r) => null == t[e] ? r : (typeof t[e] !== n && a.throwArgumentError("invalid fixed format (" + e + " not " + n + ")", "format." + e, t[e]), t[e]); e = i("signed", "boolean", e), n = i("width", "number", n), r = i("decimals", "number", r) } return n % 8 && a.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", n), r > 80 && a.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", r), new g(l, e, n, r) } } class v { constructor(t, e, n, r) { a.checkNew(new.target, v), t !== l && a.throwError("cannot use FixedNumber constructor; use FixedNumber.from", i.Logger.errors.UNSUPPORTED_OPERATION, { operation: "new FixedFormat" }), this.format = r, this._hex = e, this._value = n, this._isFixedNumber = !0, Object.freeze(this) } _checkFormat(t) { this.format.name !== t.format.name && a.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", t) } addUnsafe(t) { this._checkFormat(t); const e = m(this._value, this.format.decimals), n = m(t._value, t.format.decimals); return v.fromValue(e.add(n), this.format.decimals, this.format) } subUnsafe(t) { this._checkFormat(t); const e = m(this._value, this.format.decimals), n = m(t._value, t.format.decimals); return v.fromValue(e.sub(n), this.format.decimals, this.format) } mulUnsafe(t) { this._checkFormat(t); const e = m(this._value, this.format.decimals), n = m(t._value, t.format.decimals); return v.fromValue(e.mul(n).div(this.format._multiplier), this.format.decimals, this.format) } divUnsafe(t) { this._checkFormat(t); const e = m(this._value, this.format.decimals), n = m(t._value, t.format.decimals); return v.fromValue(e.mul(this.format._multiplier).div(n), this.format.decimals, this.format) } floor() { let t = this.toString().split("."), e = v.from(t[0], this.format); const n = !t[1].match(/^(0*)$/); return this.isNegative() && n && (e = e.subUnsafe(y)), e } ceiling() { let t = this.toString().split("."), e = v.from(t[0], this.format); const n = !t[1].match(/^(0*)$/); return !this.isNegative() && n && (e = e.addUnsafe(y)), e } round(t) { null == t && (t = 0); let e = this.toString().split("."); if ((t < 0 || t > 80 || t % 1) && a.throwArgumentError("invalid decimal count", "decimals", t), e[1].length <= t) return this; const n = v.from("1" + d.substring(0, t)); return this.mulUnsafe(n).addUnsafe(b).floor().divUnsafe(n) } isZero() { return "0.0" === this._value } isNegative() { return "-" === this._value[0] } toString() { return this._value } toHexString(t) { if (null == t) return this._hex; t % 8 && a.throwArgumentError("invalid byte width", "width", t); const e = o.O$.from(this._hex).fromTwos(this.format.width).toTwos(t).toHexString(); return (0, r.hexZeroPad)(e, t / 8) } toUnsafeFloat() { return parseFloat(this.toString()) } toFormat(t) { return v.fromString(this._value, t) } static fromValue(t, e, n) { return null != n || null == e || (0, o.Zm)(e) || (n = e, e = null), null == e && (e = 0), null == n && (n = "fixed"), v.fromString(f(t, e), g.from(n)) } static fromString(t, e) { null == e && (e = "fixed"); const n = g.from(e), i = m(t, n.decimals); !n.signed && i.lt(c) && h("unsigned value cannot be negative", "overflow", "value", t); let s = null; n.signed ? s = i.toTwos(n.width).toHexString() : (s = i.toHexString(), s = (0, r.hexZeroPad)(s, n.width / 8)); const o = f(i, n.decimals); return new v(l, s, o, n) } static fromBytes(t, e) { null == e && (e = "fixed"); const n = g.from(e); if ((0, r.arrayify)(t).length > n.width / 8) throw new Error("overflow"); let i = o.O$.from(t); n.signed && (i = i.fromTwos(n.width)); const s = i.toTwos((n.signed ? 0 : 1) + n.width).toHexString(), a = f(i, n.decimals); return new v(l, s, a, n) } static from(t, e) { if ("string" == typeof t) return v.fromString(t, e); if ((0, r.isBytes)(t)) return v.fromBytes(t, e); try { return v.fromValue(t, 0, e) } catch (n) { if (n.code !== i.Logger.errors.INVALID_ARGUMENT) throw n } return a.throwArgumentError("invalid FixedNumber value", "value", t) } static isFixedNumber(t) { return !(!t || !t._isFixedNumber) } } const y = v.from(1), b = v.from("0.5") }, 4078: (t, e, n) => { "use strict"; n.r(e), n.d(e, { BigNumber: () => r.O$, formatFixed: () => i.S5, FixedFormat: () => i.xO, FixedNumber: () => i.xs, parseFixed: () => i.Ox, _base16To36: () => r.t2, _base36To16: () => r.g$ }); var r = n(2024), i = n(1677) }, 3191: function (t, e, n) { !function (t, e) { "use strict"; function r(t, e) { if (!t) throw new Error(e || "Assertion failed") } function i(t, e) { t.super_ = e; var n = function () { }; n.prototype = e.prototype, t.prototype = new n, t.prototype.constructor = t } function s(t, e, n) { if (s.isBN(t)) return t; this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== e && "be" !== e || (n = e, e = 10), this._init(t || 0, e || 10, n || "be")) } var o; "object" == typeof t ? t.exports = s : e.BN = s, s.BN = s, s.wordSize = 26; try { o = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : n(8677).Buffer } catch (E) { } function a(t, e) { var n = t.charCodeAt(e); return n >= 65 && n <= 70 ? n - 55 : n >= 97 && n <= 102 ? n - 87 : n - 48 & 15 } function l(t, e, n) { var r = a(t, n); return n - 1 >= e && (r |= a(t, n - 1) << 4), r } function c(t, e, n, r) { for (var i = 0, s = Math.min(t.length, n), o = e; o < s; o++) { var a = t.charCodeAt(o) - 48; i *= r, i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a } return i } s.isBN = function (t) { return t instanceof s || null !== t && "object" == typeof t && t.constructor.wordSize === s.wordSize && Array.isArray(t.words) }, s.max = function (t, e) { return t.cmp(e) > 0 ? t : e }, s.min = function (t, e) { return t.cmp(e) < 0 ? t : e }, s.prototype._init = function (t, e, n) { if ("number" == typeof t) return this._initNumber(t, e, n); if ("object" == typeof t) return this._initArray(t, e, n); "hex" === e && (e = 16), r(e === (0 | e) && e >= 2 && e <= 36); var i = 0; "-" === (t = t.toString().replace(/\s+/g, ""))[0] && (i++, this.negative = 1), i < t.length && (16 === e ? this._parseHex(t, i, n) : (this._parseBase(t, e, i), "le" === n && this._initArray(this.toArray(), e, n))) }, s.prototype._initNumber = function (t, e, n) { t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [67108863 & t], this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (r(t < 9007199254740992), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === n && this._initArray(this.toArray(), e, n) }, s.prototype._initArray = function (t, e, n) { if (r("number" == typeof t.length), t.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(t.length / 3), this.words = new Array(this.length); for (var i = 0; i < this.length; i++)this.words[i] = 0; var s, o, a = 0; if ("be" === n) for (i = t.length - 1, s = 0; i >= 0; i -= 3)this.words[s] |= (o = t[i] | t[i - 1] << 8 | t[i - 2] << 16) << a & 67108863, this.words[s + 1] = o >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, s++); else if ("le" === n) for (i = 0, s = 0; i < t.length; i += 3)this.words[s] |= (o = t[i] | t[i + 1] << 8 | t[i + 2] << 16) << a & 67108863, this.words[s + 1] = o >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, s++); return this.strip() }, s.prototype._parseHex = function (t, e, n) { this.length = Math.ceil((t.length - e) / 6), this.words = new Array(this.length); for (var r = 0; r < this.length; r++)this.words[r] = 0; var i, s = 0, o = 0; if ("be" === n) for (r = t.length - 1; r >= e; r -= 2)i = l(t, e, r) << s, this.words[o] |= 67108863 & i, s >= 18 ? (s -= 18, this.words[o += 1] |= i >>> 26) : s += 8; else for (r = (t.length - e) % 2 == 0 ? e + 1 : e; r < t.length; r += 2)i = l(t, e, r) << s, this.words[o] |= 67108863 & i, s >= 18 ? (s -= 18, this.words[o += 1] |= i >>> 26) : s += 8; this.strip() }, s.prototype._parseBase = function (t, e, n) { this.words = [0], this.length = 1; for (var r = 0, i = 1; i <= 67108863; i *= e)r++; r--, i = i / e | 0; for (var s = t.length - n, o = s % r, a = Math.min(s, s - o) + n, l = 0, u = n; u < a; u += r)l = c(t, u, u + r, e), this.imuln(i), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l); if (0 !== o) { var h = 1; for (l = c(t, u, t.length, e), u = 0; u < o; u++)h *= e; this.imuln(h), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l) } this.strip() }, s.prototype.copy = function (t) { t.words = new Array(this.length); for (var e = 0; e < this.length; e++)t.words[e] = this.words[e]; t.length = this.length, t.negative = this.negative, t.red = this.red }, s.prototype.clone = function () { var t = new s(null); return this.copy(t), t }, s.prototype._expand = function (t) { for (; this.length < t;)this.words[this.length++] = 0; return this }, s.prototype.strip = function () { for (; this.length > 1 && 0 === this.words[this.length - 1];)this.length--; return this._normSign() }, s.prototype._normSign = function () { return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this }, s.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" }; var u = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], d = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; function p(t, e, n) { n.negative = e.negative ^ t.negative; var r = t.length + e.length | 0; n.length = r, r = r - 1 | 0; var i = 0 | t.words[0], s = 0 | e.words[0], o = i * s, a = o / 67108864 | 0; n.words[0] = 67108863 & o; for (var l = 1; l < r; l++) { for (var c = a >>> 26, u = 67108863 & a, h = Math.min(l, e.length - 1), d = Math.max(0, l - t.length + 1); d <= h; d++)c += (o = (i = 0 | t.words[l - d | 0]) * (s = 0 | e.words[d]) + u) / 67108864 | 0, u = 67108863 & o; n.words[l] = 0 | u, a = 0 | c } return 0 !== a ? n.words[l] = 0 | a : n.length--, n.strip() } s.prototype.toString = function (t, e) { var n; if (e = 0 | e || 1, 16 === (t = t || 10) || "hex" === t) { n = ""; for (var i = 0, s = 0, o = 0; o < this.length; o++) { var a = this.words[o], l = (16777215 & (a << i | s)).toString(16); n = 0 != (s = a >>> 24 - i & 16777215) || o !== this.length - 1 ? u[6 - l.length] + l + n : l + n, (i += 2) >= 26 && (i -= 26, o--) } for (0 !== s && (n = s.toString(16) + n); n.length % e != 0;)n = "0" + n; return 0 !== this.negative && (n = "-" + n), n } if (t === (0 | t) && t >= 2 && t <= 36) { var c = h[t], p = d[t]; n = ""; var f = this.clone(); for (f.negative = 0; !f.isZero();) { var m = f.modn(p).toString(t); n = (f = f.idivn(p)).isZero() ? m + n : u[c - m.length] + m + n } for (this.isZero() && (n = "0" + n); n.length % e != 0;)n = "0" + n; return 0 !== this.negative && (n = "-" + n), n } r(!1, "Base should be between 2 and 36") }, s.prototype.toNumber = function () { var t = this.words[0]; return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t }, s.prototype.toJSON = function () { return this.toString(16) }, s.prototype.toBuffer = function (t, e) { return r(void 0 !== o), this.toArrayLike(o, t, e) }, s.prototype.toArray = function (t, e) { return this.toArrayLike(Array, t, e) }, s.prototype.toArrayLike = function (t, e, n) { var i = this.byteLength(), s = n || Math.max(1, i); r(i <= s, "byte array longer than desired length"), r(s > 0, "Requested array length <= 0"), this.strip(); var o, a, l = "le" === e, c = new t(s), u = this.clone(); if (l) { for (a = 0; !u.isZero(); a++)o = u.andln(255), u.iushrn(8), c[a] = o; for (; a < s; a++)c[a] = 0 } else { for (a = 0; a < s - i; a++)c[a] = 0; for (a = 0; !u.isZero(); a++)o = u.andln(255), u.iushrn(8), c[s - a - 1] = o } return c }, s.prototype._countBits = Math.clz32 ? function (t) { return 32 - Math.clz32(t) } : function (t) { var e = t, n = 0; return e >= 4096 && (n += 13, e >>>= 13), e >= 64 && (n += 7, e >>>= 7), e >= 8 && (n += 4, e >>>= 4), e >= 2 && (n += 2, e >>>= 2), n + e }, s.prototype._zeroBits = function (t) { if (0 === t) return 26; var e = t, n = 0; return 0 == (8191 & e) && (n += 13, e >>>= 13), 0 == (127 & e) && (n += 7, e >>>= 7), 0 == (15 & e) && (n += 4, e >>>= 4), 0 == (3 & e) && (n += 2, e >>>= 2), 0 == (1 & e) && n++, n }, s.prototype.bitLength = function () { var t = this._countBits(this.words[this.length - 1]); return 26 * (this.length - 1) + t }, s.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var t = 0, e = 0; e < this.length; e++) { var n = this._zeroBits(this.words[e]); if (t += n, 26 !== n) break } return t }, s.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, s.prototype.toTwos = function (t) { return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone() }, s.prototype.fromTwos = function (t) { return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone() }, s.prototype.isNeg = function () { return 0 !== this.negative }, s.prototype.neg = function () { return this.clone().ineg() }, s.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, s.prototype.iuor = function (t) { for (; this.length < t.length;)this.words[this.length++] = 0; for (var e = 0; e < t.length; e++)this.words[e] = this.words[e] | t.words[e]; return this.strip() }, s.prototype.ior = function (t) { return r(0 == (this.negative | t.negative)), this.iuor(t) }, s.prototype.or = function (t) { return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this) }, s.prototype.uor = function (t) { return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this) }, s.prototype.iuand = function (t) { var e; e = this.length > t.length ? t : this; for (var n = 0; n < e.length; n++)this.words[n] = this.words[n] & t.words[n]; return this.length = e.length, this.strip() }, s.prototype.iand = function (t) { return r(0 == (this.negative | t.negative)), this.iuand(t) }, s.prototype.and = function (t) { return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this) }, s.prototype.uand = function (t) { return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this) }, s.prototype.iuxor = function (t) { var e, n; this.length > t.length ? (e = this, n = t) : (e = t, n = this); for (var r = 0; r < n.length; r++)this.words[r] = e.words[r] ^ n.words[r]; if (this !== e) for (; r < e.length; r++)this.words[r] = e.words[r]; return this.length = e.length, this.strip() }, s.prototype.ixor = function (t) { return r(0 == (this.negative | t.negative)), this.iuxor(t) }, s.prototype.xor = function (t) { return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this) }, s.prototype.uxor = function (t) { return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this) }, s.prototype.inotn = function (t) { r("number" == typeof t && t >= 0); var e = 0 | Math.ceil(t / 26), n = t % 26; this._expand(e), n > 0 && e--; for (var i = 0; i < e; i++)this.words[i] = 67108863 & ~this.words[i]; return n > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - n), this.strip() }, s.prototype.notn = function (t) { return this.clone().inotn(t) }, s.prototype.setn = function (t, e) { r("number" == typeof t && t >= 0); var n = t / 26 | 0, i = t % 26; return this._expand(n + 1), this.words[n] = e ? this.words[n] | 1 << i : this.words[n] & ~(1 << i), this.strip() }, s.prototype.iadd = function (t) { var e, n, r; if (0 !== this.negative && 0 === t.negative) return this.negative = 0, e = this.isub(t), this.negative ^= 1, this._normSign(); if (0 === this.negative && 0 !== t.negative) return t.negative = 0, e = this.isub(t), t.negative = 1, e._normSign(); this.length > t.length ? (n = this, r = t) : (n = t, r = this); for (var i = 0, s = 0; s < r.length; s++)this.words[s] = 67108863 & (e = (0 | n.words[s]) + (0 | r.words[s]) + i), i = e >>> 26; for (; 0 !== i && s < n.length; s++)this.words[s] = 67108863 & (e = (0 | n.words[s]) + i), i = e >>> 26; if (this.length = n.length, 0 !== i) this.words[this.length] = i, this.length++; else if (n !== this) for (; s < n.length; s++)this.words[s] = n.words[s]; return this }, s.prototype.add = function (t) { var e; return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, e = this.sub(t), t.negative ^= 1, e) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, e = t.sub(this), this.negative = 1, e) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this) }, s.prototype.isub = function (t) { if (0 !== t.negative) { t.negative = 0; var e = this.iadd(t); return t.negative = 1, e._normSign() } if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign(); var n, r, i = this.cmp(t); if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this; i > 0 ? (n = this, r = t) : (n = t, r = this); for (var s = 0, o = 0; o < r.length; o++)s = (e = (0 | n.words[o]) - (0 | r.words[o]) + s) >> 26, this.words[o] = 67108863 & e; for (; 0 !== s && o < n.length; o++)s = (e = (0 | n.words[o]) + s) >> 26, this.words[o] = 67108863 & e; if (0 === s && o < n.length && n !== this) for (; o < n.length; o++)this.words[o] = n.words[o]; return this.length = Math.max(this.length, o), n !== this && (this.negative = 1), this.strip() }, s.prototype.sub = function (t) { return this.clone().isub(t) }; var f = function (t, e, n) { var r, i, s, o = t.words, a = e.words, l = n.words, c = 0, u = 0 | o[0], h = 8191 & u, d = u >>> 13, p = 0 | o[1], f = 8191 & p, m = p >>> 13, g = 0 | o[2], v = 8191 & g, y = g >>> 13, b = 0 | o[3], _ = 8191 & b, w = b >>> 13, S = 0 | o[4], x = 8191 & S, T = S >>> 13, E = 0 | o[5], M = 8191 & E, A = E >>> 13, C = 0 | o[6], P = 8191 & C, R = C >>> 13, L = 0 | o[7], k = 8191 & L, D = L >>> 13, I = 0 | o[8], O = 8191 & I, F = I >>> 13, N = 0 | o[9], B = 8191 & N, H = N >>> 13, U = 0 | a[0], G = 8191 & U, V = U >>> 13, z = 0 | a[1], j = 8191 & z, J = z >>> 13, X = 0 | a[2], W = 8191 & X, q = X >>> 13, Z = 0 | a[3], K = 8191 & Z, Y = Z >>> 13, Q = 0 | a[4], $ = 8191 & Q, tt = Q >>> 13, et = 0 | a[5], nt = 8191 & et, rt = et >>> 13, it = 0 | a[6], st = 8191 & it, ot = it >>> 13, at = 0 | a[7], lt = 8191 & at, ct = at >>> 13, ut = 0 | a[8], ht = 8191 & ut, dt = ut >>> 13, pt = 0 | a[9], ft = 8191 & pt, mt = pt >>> 13; n.negative = t.negative ^ e.negative, n.length = 19; var gt = (c + (r = Math.imul(h, G)) | 0) + ((8191 & (i = (i = Math.imul(h, V)) + Math.imul(d, G) | 0)) << 13) | 0; c = ((s = Math.imul(d, V)) + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, r = Math.imul(f, G), i = (i = Math.imul(f, V)) + Math.imul(m, G) | 0, s = Math.imul(m, V); var vt = (c + (r = r + Math.imul(h, j) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, J) | 0) + Math.imul(d, j) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, J) | 0) + (i >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, r = Math.imul(v, G), i = (i = Math.imul(v, V)) + Math.imul(y, G) | 0, s = Math.imul(y, V), r = r + Math.imul(f, j) | 0, i = (i = i + Math.imul(f, J) | 0) + Math.imul(m, j) | 0, s = s + Math.imul(m, J) | 0; var yt = (c + (r = r + Math.imul(h, W) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, q) | 0) + Math.imul(d, W) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, q) | 0) + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, r = Math.imul(_, G), i = (i = Math.imul(_, V)) + Math.imul(w, G) | 0, s = Math.imul(w, V), r = r + Math.imul(v, j) | 0, i = (i = i + Math.imul(v, J) | 0) + Math.imul(y, j) | 0, s = s + Math.imul(y, J) | 0, r = r + Math.imul(f, W) | 0, i = (i = i + Math.imul(f, q) | 0) + Math.imul(m, W) | 0, s = s + Math.imul(m, q) | 0; var bt = (c + (r = r + Math.imul(h, K) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, Y) | 0) + Math.imul(d, K) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, Y) | 0) + (i >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, r = Math.imul(x, G), i = (i = Math.imul(x, V)) + Math.imul(T, G) | 0, s = Math.imul(T, V), r = r + Math.imul(_, j) | 0, i = (i = i + Math.imul(_, J) | 0) + Math.imul(w, j) | 0, s = s + Math.imul(w, J) | 0, r = r + Math.imul(v, W) | 0, i = (i = i + Math.imul(v, q) | 0) + Math.imul(y, W) | 0, s = s + Math.imul(y, q) | 0, r = r + Math.imul(f, K) | 0, i = (i = i + Math.imul(f, Y) | 0) + Math.imul(m, K) | 0, s = s + Math.imul(m, Y) | 0; var _t = (c + (r = r + Math.imul(h, $) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, tt) | 0) + Math.imul(d, $) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, tt) | 0) + (i >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, r = Math.imul(M, G), i = (i = Math.imul(M, V)) + Math.imul(A, G) | 0, s = Math.imul(A, V), r = r + Math.imul(x, j) | 0, i = (i = i + Math.imul(x, J) | 0) + Math.imul(T, j) | 0, s = s + Math.imul(T, J) | 0, r = r + Math.imul(_, W) | 0, i = (i = i + Math.imul(_, q) | 0) + Math.imul(w, W) | 0, s = s + Math.imul(w, q) | 0, r = r + Math.imul(v, K) | 0, i = (i = i + Math.imul(v, Y) | 0) + Math.imul(y, K) | 0, s = s + Math.imul(y, Y) | 0, r = r + Math.imul(f, $) | 0, i = (i = i + Math.imul(f, tt) | 0) + Math.imul(m, $) | 0, s = s + Math.imul(m, tt) | 0; var wt = (c + (r = r + Math.imul(h, nt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, rt) | 0) + Math.imul(d, nt) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, rt) | 0) + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, r = Math.imul(P, G), i = (i = Math.imul(P, V)) + Math.imul(R, G) | 0, s = Math.imul(R, V), r = r + Math.imul(M, j) | 0, i = (i = i + Math.imul(M, J) | 0) + Math.imul(A, j) | 0, s = s + Math.imul(A, J) | 0, r = r + Math.imul(x, W) | 0, i = (i = i + Math.imul(x, q) | 0) + Math.imul(T, W) | 0, s = s + Math.imul(T, q) | 0, r = r + Math.imul(_, K) | 0, i = (i = i + Math.imul(_, Y) | 0) + Math.imul(w, K) | 0, s = s + Math.imul(w, Y) | 0, r = r + Math.imul(v, $) | 0, i = (i = i + Math.imul(v, tt) | 0) + Math.imul(y, $) | 0, s = s + Math.imul(y, tt) | 0, r = r + Math.imul(f, nt) | 0, i = (i = i + Math.imul(f, rt) | 0) + Math.imul(m, nt) | 0, s = s + Math.imul(m, rt) | 0; var St = (c + (r = r + Math.imul(h, st) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, ot) | 0) + Math.imul(d, st) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, ot) | 0) + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, r = Math.imul(k, G), i = (i = Math.imul(k, V)) + Math.imul(D, G) | 0, s = Math.imul(D, V), r = r + Math.imul(P, j) | 0, i = (i = i + Math.imul(P, J) | 0) + Math.imul(R, j) | 0, s = s + Math.imul(R, J) | 0, r = r + Math.imul(M, W) | 0, i = (i = i + Math.imul(M, q) | 0) + Math.imul(A, W) | 0, s = s + Math.imul(A, q) | 0, r = r + Math.imul(x, K) | 0, i = (i = i + Math.imul(x, Y) | 0) + Math.imul(T, K) | 0, s = s + Math.imul(T, Y) | 0, r = r + Math.imul(_, $) | 0, i = (i = i + Math.imul(_, tt) | 0) + Math.imul(w, $) | 0, s = s + Math.imul(w, tt) | 0, r = r + Math.imul(v, nt) | 0, i = (i = i + Math.imul(v, rt) | 0) + Math.imul(y, nt) | 0, s = s + Math.imul(y, rt) | 0, r = r + Math.imul(f, st) | 0, i = (i = i + Math.imul(f, ot) | 0) + Math.imul(m, st) | 0, s = s + Math.imul(m, ot) | 0; var xt = (c + (r = r + Math.imul(h, lt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, ct) | 0) + Math.imul(d, lt) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, ct) | 0) + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, r = Math.imul(O, G), i = (i = Math.imul(O, V)) + Math.imul(F, G) | 0, s = Math.imul(F, V), r = r + Math.imul(k, j) | 0, i = (i = i + Math.imul(k, J) | 0) + Math.imul(D, j) | 0, s = s + Math.imul(D, J) | 0, r = r + Math.imul(P, W) | 0, i = (i = i + Math.imul(P, q) | 0) + Math.imul(R, W) | 0, s = s + Math.imul(R, q) | 0, r = r + Math.imul(M, K) | 0, i = (i = i + Math.imul(M, Y) | 0) + Math.imul(A, K) | 0, s = s + Math.imul(A, Y) | 0, r = r + Math.imul(x, $) | 0, i = (i = i + Math.imul(x, tt) | 0) + Math.imul(T, $) | 0, s = s + Math.imul(T, tt) | 0, r = r + Math.imul(_, nt) | 0, i = (i = i + Math.imul(_, rt) | 0) + Math.imul(w, nt) | 0, s = s + Math.imul(w, rt) | 0, r = r + Math.imul(v, st) | 0, i = (i = i + Math.imul(v, ot) | 0) + Math.imul(y, st) | 0, s = s + Math.imul(y, ot) | 0, r = r + Math.imul(f, lt) | 0, i = (i = i + Math.imul(f, ct) | 0) + Math.imul(m, lt) | 0, s = s + Math.imul(m, ct) | 0; var Tt = (c + (r = r + Math.imul(h, ht) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, dt) | 0) + Math.imul(d, ht) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, dt) | 0) + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, r = Math.imul(B, G), i = (i = Math.imul(B, V)) + Math.imul(H, G) | 0, s = Math.imul(H, V), r = r + Math.imul(O, j) | 0, i = (i = i + Math.imul(O, J) | 0) + Math.imul(F, j) | 0, s = s + Math.imul(F, J) | 0, r = r + Math.imul(k, W) | 0, i = (i = i + Math.imul(k, q) | 0) + Math.imul(D, W) | 0, s = s + Math.imul(D, q) | 0, r = r + Math.imul(P, K) | 0, i = (i = i + Math.imul(P, Y) | 0) + Math.imul(R, K) | 0, s = s + Math.imul(R, Y) | 0, r = r + Math.imul(M, $) | 0, i = (i = i + Math.imul(M, tt) | 0) + Math.imul(A, $) | 0, s = s + Math.imul(A, tt) | 0, r = r + Math.imul(x, nt) | 0, i = (i = i + Math.imul(x, rt) | 0) + Math.imul(T, nt) | 0, s = s + Math.imul(T, rt) | 0, r = r + Math.imul(_, st) | 0, i = (i = i + Math.imul(_, ot) | 0) + Math.imul(w, st) | 0, s = s + Math.imul(w, ot) | 0, r = r + Math.imul(v, lt) | 0, i = (i = i + Math.imul(v, ct) | 0) + Math.imul(y, lt) | 0, s = s + Math.imul(y, ct) | 0, r = r + Math.imul(f, ht) | 0, i = (i = i + Math.imul(f, dt) | 0) + Math.imul(m, ht) | 0, s = s + Math.imul(m, dt) | 0; var Et = (c + (r = r + Math.imul(h, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, mt) | 0) + Math.imul(d, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, mt) | 0) + (i >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, r = Math.imul(B, j), i = (i = Math.imul(B, J)) + Math.imul(H, j) | 0, s = Math.imul(H, J), r = r + Math.imul(O, W) | 0, i = (i = i + Math.imul(O, q) | 0) + Math.imul(F, W) | 0, s = s + Math.imul(F, q) | 0, r = r + Math.imul(k, K) | 0, i = (i = i + Math.imul(k, Y) | 0) + Math.imul(D, K) | 0, s = s + Math.imul(D, Y) | 0, r = r + Math.imul(P, $) | 0, i = (i = i + Math.imul(P, tt) | 0) + Math.imul(R, $) | 0, s = s + Math.imul(R, tt) | 0, r = r + Math.imul(M, nt) | 0, i = (i = i + Math.imul(M, rt) | 0) + Math.imul(A, nt) | 0, s = s + Math.imul(A, rt) | 0, r = r + Math.imul(x, st) | 0, i = (i = i + Math.imul(x, ot) | 0) + Math.imul(T, st) | 0, s = s + Math.imul(T, ot) | 0, r = r + Math.imul(_, lt) | 0, i = (i = i + Math.imul(_, ct) | 0) + Math.imul(w, lt) | 0, s = s + Math.imul(w, ct) | 0, r = r + Math.imul(v, ht) | 0, i = (i = i + Math.imul(v, dt) | 0) + Math.imul(y, ht) | 0, s = s + Math.imul(y, dt) | 0; var Mt = (c + (r = r + Math.imul(f, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, mt) | 0) + Math.imul(m, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(m, mt) | 0) + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, r = Math.imul(B, W), i = (i = Math.imul(B, q)) + Math.imul(H, W) | 0, s = Math.imul(H, q), r = r + Math.imul(O, K) | 0, i = (i = i + Math.imul(O, Y) | 0) + Math.imul(F, K) | 0, s = s + Math.imul(F, Y) | 0, r = r + Math.imul(k, $) | 0, i = (i = i + Math.imul(k, tt) | 0) + Math.imul(D, $) | 0, s = s + Math.imul(D, tt) | 0, r = r + Math.imul(P, nt) | 0, i = (i = i + Math.imul(P, rt) | 0) + Math.imul(R, nt) | 0, s = s + Math.imul(R, rt) | 0, r = r + Math.imul(M, st) | 0, i = (i = i + Math.imul(M, ot) | 0) + Math.imul(A, st) | 0, s = s + Math.imul(A, ot) | 0, r = r + Math.imul(x, lt) | 0, i = (i = i + Math.imul(x, ct) | 0) + Math.imul(T, lt) | 0, s = s + Math.imul(T, ct) | 0, r = r + Math.imul(_, ht) | 0, i = (i = i + Math.imul(_, dt) | 0) + Math.imul(w, ht) | 0, s = s + Math.imul(w, dt) | 0; var At = (c + (r = r + Math.imul(v, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(v, mt) | 0) + Math.imul(y, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(y, mt) | 0) + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, r = Math.imul(B, K), i = (i = Math.imul(B, Y)) + Math.imul(H, K) | 0, s = Math.imul(H, Y), r = r + Math.imul(O, $) | 0, i = (i = i + Math.imul(O, tt) | 0) + Math.imul(F, $) | 0, s = s + Math.imul(F, tt) | 0, r = r + Math.imul(k, nt) | 0, i = (i = i + Math.imul(k, rt) | 0) + Math.imul(D, nt) | 0, s = s + Math.imul(D, rt) | 0, r = r + Math.imul(P, st) | 0, i = (i = i + Math.imul(P, ot) | 0) + Math.imul(R, st) | 0, s = s + Math.imul(R, ot) | 0, r = r + Math.imul(M, lt) | 0, i = (i = i + Math.imul(M, ct) | 0) + Math.imul(A, lt) | 0, s = s + Math.imul(A, ct) | 0, r = r + Math.imul(x, ht) | 0, i = (i = i + Math.imul(x, dt) | 0) + Math.imul(T, ht) | 0, s = s + Math.imul(T, dt) | 0; var Ct = (c + (r = r + Math.imul(_, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(_, mt) | 0) + Math.imul(w, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(w, mt) | 0) + (i >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, r = Math.imul(B, $), i = (i = Math.imul(B, tt)) + Math.imul(H, $) | 0, s = Math.imul(H, tt), r = r + Math.imul(O, nt) | 0, i = (i = i + Math.imul(O, rt) | 0) + Math.imul(F, nt) | 0, s = s + Math.imul(F, rt) | 0, r = r + Math.imul(k, st) | 0, i = (i = i + Math.imul(k, ot) | 0) + Math.imul(D, st) | 0, s = s + Math.imul(D, ot) | 0, r = r + Math.imul(P, lt) | 0, i = (i = i + Math.imul(P, ct) | 0) + Math.imul(R, lt) | 0, s = s + Math.imul(R, ct) | 0, r = r + Math.imul(M, ht) | 0, i = (i = i + Math.imul(M, dt) | 0) + Math.imul(A, ht) | 0, s = s + Math.imul(A, dt) | 0; var Pt = (c + (r = r + Math.imul(x, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(x, mt) | 0) + Math.imul(T, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(T, mt) | 0) + (i >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, r = Math.imul(B, nt), i = (i = Math.imul(B, rt)) + Math.imul(H, nt) | 0, s = Math.imul(H, rt), r = r + Math.imul(O, st) | 0, i = (i = i + Math.imul(O, ot) | 0) + Math.imul(F, st) | 0, s = s + Math.imul(F, ot) | 0, r = r + Math.imul(k, lt) | 0, i = (i = i + Math.imul(k, ct) | 0) + Math.imul(D, lt) | 0, s = s + Math.imul(D, ct) | 0, r = r + Math.imul(P, ht) | 0, i = (i = i + Math.imul(P, dt) | 0) + Math.imul(R, ht) | 0, s = s + Math.imul(R, dt) | 0; var Rt = (c + (r = r + Math.imul(M, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(M, mt) | 0) + Math.imul(A, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(A, mt) | 0) + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, r = Math.imul(B, st), i = (i = Math.imul(B, ot)) + Math.imul(H, st) | 0, s = Math.imul(H, ot), r = r + Math.imul(O, lt) | 0, i = (i = i + Math.imul(O, ct) | 0) + Math.imul(F, lt) | 0, s = s + Math.imul(F, ct) | 0, r = r + Math.imul(k, ht) | 0, i = (i = i + Math.imul(k, dt) | 0) + Math.imul(D, ht) | 0, s = s + Math.imul(D, dt) | 0; var Lt = (c + (r = r + Math.imul(P, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(P, mt) | 0) + Math.imul(R, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(R, mt) | 0) + (i >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, r = Math.imul(B, lt), i = (i = Math.imul(B, ct)) + Math.imul(H, lt) | 0, s = Math.imul(H, ct), r = r + Math.imul(O, ht) | 0, i = (i = i + Math.imul(O, dt) | 0) + Math.imul(F, ht) | 0, s = s + Math.imul(F, dt) | 0; var kt = (c + (r = r + Math.imul(k, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(k, mt) | 0) + Math.imul(D, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(D, mt) | 0) + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, r = Math.imul(B, ht), i = (i = Math.imul(B, dt)) + Math.imul(H, ht) | 0, s = Math.imul(H, dt); var Dt = (c + (r = r + Math.imul(O, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(O, mt) | 0) + Math.imul(F, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(F, mt) | 0) + (i >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863; var It = (c + (r = Math.imul(B, ft)) | 0) + ((8191 & (i = (i = Math.imul(B, mt)) + Math.imul(H, ft) | 0)) << 13) | 0; return c = ((s = Math.imul(H, mt)) + (i >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, l[0] = gt, l[1] = vt, l[2] = yt, l[3] = bt, l[4] = _t, l[5] = wt, l[6] = St, l[7] = xt, l[8] = Tt, l[9] = Et, l[10] = Mt, l[11] = At, l[12] = Ct, l[13] = Pt, l[14] = Rt, l[15] = Lt, l[16] = kt, l[17] = Dt, l[18] = It, 0 !== c && (l[19] = c, n.length++), n }; function m(t, e, n) { return (new g).mulp(t, e, n) } function g(t, e) { this.x = t, this.y = e } Math.imul || (f = p), s.prototype.mulTo = function (t, e) { var n = this.length + t.length; return 10 === this.length && 10 === t.length ? f(this, t, e) : n < 63 ? p(this, t, e) : n < 1024 ? function (t, e, n) { n.negative = e.negative ^ t.negative, n.length = t.length + e.length; for (var r = 0, i = 0, s = 0; s < n.length - 1; s++) { var o = i; i = 0; for (var a = 67108863 & r, l = Math.min(s, e.length - 1), c = Math.max(0, s - t.length + 1); c <= l; c++) { var u = (0 | t.words[s - c]) * (0 | e.words[c]), h = 67108863 & u; a = 67108863 & (h = h + a | 0), i += (o = (o = o + (u / 67108864 | 0) | 0) + (h >>> 26) | 0) >>> 26, o &= 67108863 } n.words[s] = a, r = o, o = i } return 0 !== r ? n.words[s] = r : n.length--, n.strip() }(this, t, e) : m(this, t, e) }, g.prototype.makeRBT = function (t) { for (var e = new Array(t), n = s.prototype._countBits(t) - 1, r = 0; r < t; r++)e[r] = this.revBin(r, n, t); return e }, g.prototype.revBin = function (t, e, n) { if (0 === t || t === n - 1) return t; for (var r = 0, i = 0; i < e; i++)r |= (1 & t) << e - i - 1, t >>= 1; return r }, g.prototype.permute = function (t, e, n, r, i, s) { for (var o = 0; o < s; o++)r[o] = e[t[o]], i[o] = n[t[o]] }, g.prototype.transform = function (t, e, n, r, i, s) { this.permute(s, t, e, n, r, i); for (var o = 1; o < i; o <<= 1)for (var a = o << 1, l = Math.cos(2 * Math.PI / a), c = Math.sin(2 * Math.PI / a), u = 0; u < i; u += a)for (var h = l, d = c, p = 0; p < o; p++) { var f = n[u + p], m = r[u + p], g = n[u + p + o], v = r[u + p + o], y = h * g - d * v; v = h * v + d * g, n[u + p] = f + (g = y), r[u + p] = m + v, n[u + p + o] = f - g, r[u + p + o] = m - v, p !== a && (y = l * h - c * d, d = l * d + c * h, h = y) } }, g.prototype.guessLen13b = function (t, e) { var n = 1 | Math.max(e, t), r = 1 & n, i = 0; for (n = n / 2 | 0; n; n >>>= 1)i++; return 1 << i + 1 + r }, g.prototype.conjugate = function (t, e, n) { if (!(n <= 1)) for (var r = 0; r < n / 2; r++) { var i = t[r]; t[r] = t[n - r - 1], t[n - r - 1] = i, i = e[r], e[r] = -e[n - r - 1], e[n - r - 1] = -i } }, g.prototype.normalize13b = function (t, e) { for (var n = 0, r = 0; r < e / 2; r++) { var i = 8192 * Math.round(t[2 * r + 1] / e) + Math.round(t[2 * r] / e) + n; t[r] = 67108863 & i, n = i < 67108864 ? 0 : i / 67108864 | 0 } return t }, g.prototype.convert13b = function (t, e, n, i) { for (var s = 0, o = 0; o < e; o++)n[2 * o] = 8191 & (s += 0 | t[o]), n[2 * o + 1] = 8191 & (s >>>= 13), s >>>= 13; for (o = 2 * e; o < i; ++o)n[o] = 0; r(0 === s), r(0 == (-8192 & s)) }, g.prototype.stub = function (t) { for (var e = new Array(t), n = 0; n < t; n++)e[n] = 0; return e }, g.prototype.mulp = function (t, e, n) { var r = 2 * this.guessLen13b(t.length, e.length), i = this.makeRBT(r), s = this.stub(r), o = new Array(r), a = new Array(r), l = new Array(r), c = new Array(r), u = new Array(r), h = new Array(r), d = n.words; d.length = r, this.convert13b(t.words, t.length, o, r), this.convert13b(e.words, e.length, c, r), this.transform(o, s, a, l, r, i), this.transform(c, s, u, h, r, i); for (var p = 0; p < r; p++) { var f = a[p] * u[p] - l[p] * h[p]; l[p] = a[p] * h[p] + l[p] * u[p], a[p] = f } return this.conjugate(a, l, r), this.transform(a, l, d, s, r, i), this.conjugate(d, s, r), this.normalize13b(d, r), n.negative = t.negative ^ e.negative, n.length = t.length + e.length, n.strip() }, s.prototype.mul = function (t) { var e = new s(null); return e.words = new Array(this.length + t.length), this.mulTo(t, e) }, s.prototype.mulf = function (t) { var e = new s(null); return e.words = new Array(this.length + t.length), m(this, t, e) }, s.prototype.imul = function (t) { return this.clone().mulTo(t, this) }, s.prototype.imuln = function (t) { r("number" == typeof t), r(t < 67108864); for (var e = 0, n = 0; n < this.length; n++) { var i = (0 | this.words[n]) * t, s = (67108863 & i) + (67108863 & e); e >>= 26, e += i / 67108864 | 0, e += s >>> 26, this.words[n] = 67108863 & s } return 0 !== e && (this.words[n] = e, this.length++), this }, s.prototype.muln = function (t) { return this.clone().imuln(t) }, s.prototype.sqr = function () { return this.mul(this) }, s.prototype.isqr = function () { return this.imul(this.clone()) }, s.prototype.pow = function (t) { var e = function (t) { for (var e = new Array(t.bitLength()), n = 0; n < e.length; n++) { var r = n % 26; e[n] = (t.words[n / 26 | 0] & 1 << r) >>> r } return e }(t); if (0 === e.length) return new s(1); for (var n = this, r = 0; r < e.length && 0 === e[r]; r++, n = n.sqr()); if (++r < e.length) for (var i = n.sqr(); r < e.length; r++, i = i.sqr())0 !== e[r] && (n = n.mul(i)); return n }, s.prototype.iushln = function (t) { r("number" == typeof t && t >= 0); var e, n = t % 26, i = (t - n) / 26, s = 67108863 >>> 26 - n << 26 - n; if (0 !== n) { var o = 0; for (e = 0; e < this.length; e++) { var a = this.words[e] & s; this.words[e] = (0 | this.words[e]) - a << n | o, o = a >>> 26 - n } o && (this.words[e] = o, this.length++) } if (0 !== i) { for (e = this.length - 1; e >= 0; e--)this.words[e + i] = this.words[e]; for (e = 0; e < i; e++)this.words[e] = 0; this.length += i } return this.strip() }, s.prototype.ishln = function (t) { return r(0 === this.negative), this.iushln(t) }, s.prototype.iushrn = function (t, e, n) { var i; r("number" == typeof t && t >= 0), i = e ? (e - e % 26) / 26 : 0; var s = t % 26, o = Math.min((t - s) / 26, this.length), a = 67108863 ^ 67108863 >>> s << s, l = n; if (i -= o, i = Math.max(0, i), l) { for (var c = 0; c < o; c++)l.words[c] = this.words[c]; l.length = o } if (0 === o); else if (this.length > o) for (this.length -= o, c = 0; c < this.length; c++)this.words[c] = this.words[c + o]; else this.words[0] = 0, this.length = 1; var u = 0; for (c = this.length - 1; c >= 0 && (0 !== u || c >= i); c--) { var h = 0 | this.words[c]; this.words[c] = u << 26 - s | h >>> s, u = h & a } return l && 0 !== u && (l.words[l.length++] = u), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip() }, s.prototype.ishrn = function (t, e, n) { return r(0 === this.negative), this.iushrn(t, e, n) }, s.prototype.shln = function (t) { return this.clone().ishln(t) }, s.prototype.ushln = function (t) { return this.clone().iushln(t) }, s.prototype.shrn = function (t) { return this.clone().ishrn(t) }, s.prototype.ushrn = function (t) { return this.clone().iushrn(t) }, s.prototype.testn = function (t) { r("number" == typeof t && t >= 0); var e = t % 26, n = (t - e) / 26; return !(this.length <= n || !(this.words[n] & 1 << e)) }, s.prototype.imaskn = function (t) { r("number" == typeof t && t >= 0); var e = t % 26, n = (t - e) / 26; return r(0 === this.negative, "imaskn works only with positive numbers"), this.length <= n ? this : (0 !== e && n++, this.length = Math.min(n, this.length), 0 !== e && (this.words[this.length - 1] &= 67108863 ^ 67108863 >>> e << e), this.strip()) }, s.prototype.maskn = function (t) { return this.clone().imaskn(t) }, s.prototype.iaddn = function (t) { return r("number" == typeof t), r(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t) }, s.prototype._iaddn = function (t) { this.words[0] += t; for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)this.words[e] -= 67108864, e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++; return this.length = Math.max(this.length, e + 1), this }, s.prototype.isubn = function (t) { if (r("number" == typeof t), r(t < 67108864), t < 0) return this.iaddn(-t); if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this; if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var e = 0; e < this.length && this.words[e] < 0; e++)this.words[e] += 67108864, this.words[e + 1] -= 1; return this.strip() }, s.prototype.addn = function (t) { return this.clone().iaddn(t) }, s.prototype.subn = function (t) { return this.clone().isubn(t) }, s.prototype.iabs = function () { return this.negative = 0, this }, s.prototype.abs = function () { return this.clone().iabs() }, s.prototype._ishlnsubmul = function (t, e, n) { var i, s; this._expand(t.length + n); var o = 0; for (i = 0; i < t.length; i++) { s = (0 | this.words[i + n]) + o; var a = (0 | t.words[i]) * e; o = ((s -= 67108863 & a) >> 26) - (a / 67108864 | 0), this.words[i + n] = 67108863 & s } for (; i < this.length - n; i++)o = (s = (0 | this.words[i + n]) + o) >> 26, this.words[i + n] = 67108863 & s; if (0 === o) return this.strip(); for (r(-1 === o), o = 0, i = 0; i < this.length; i++)o = (s = -(0 | this.words[i]) + o) >> 26, this.words[i] = 67108863 & s; return this.negative = 1, this.strip() }, s.prototype._wordDiv = function (t, e) { var n, r = this.clone(), i = t, o = 0 | i.words[i.length - 1]; 0 != (n = 26 - this._countBits(o)) && (i = i.ushln(n), r.iushln(n), o = 0 | i.words[i.length - 1]); var a, l = r.length - i.length; if ("mod" !== e) { (a = new s(null)).length = l + 1, a.words = new Array(a.length); for (var c = 0; c < a.length; c++)a.words[c] = 0 } var u = r.clone()._ishlnsubmul(i, 1, l); 0 === u.negative && (r = u, a && (a.words[l] = 1)); for (var h = l - 1; h >= 0; h--) { var d = 67108864 * (0 | r.words[i.length + h]) + (0 | r.words[i.length + h - 1]); for (d = Math.min(d / o | 0, 67108863), r._ishlnsubmul(i, d, h); 0 !== r.negative;)d--, r.negative = 0, r._ishlnsubmul(i, 1, h), r.isZero() || (r.negative ^= 1); a && (a.words[h] = d) } return a && a.strip(), r.strip(), "div" !== e && 0 !== n && r.iushrn(n), { div: a || null, mod: r } }, s.prototype.divmod = function (t, e, n) { return r(!t.isZero()), this.isZero() ? { div: new s(0), mod: new s(0) } : 0 !== this.negative && 0 === t.negative ? (a = this.neg().divmod(t, e), "mod" !== e && (i = a.div.neg()), "div" !== e && (o = a.mod.neg(), n && 0 !== o.negative && o.iadd(t)), { div: i, mod: o }) : 0 === this.negative && 0 !== t.negative ? (a = this.divmod(t.neg(), e), "mod" !== e && (i = a.div.neg()), { div: i, mod: a.mod }) : 0 != (this.negative & t.negative) ? (a = this.neg().divmod(t.neg(), e), "div" !== e && (o = a.mod.neg(), n && 0 !== o.negative && o.isub(t)), { div: a.div, mod: o }) : t.length > this.length || this.cmp(t) < 0 ? { div: new s(0), mod: this } : 1 === t.length ? "div" === e ? { div: this.divn(t.words[0]), mod: null } : "mod" === e ? { div: null, mod: new s(this.modn(t.words[0])) } : { div: this.divn(t.words[0]), mod: new s(this.modn(t.words[0])) } : this._wordDiv(t, e); var i, o, a }, s.prototype.div = function (t) { return this.divmod(t, "div", !1).div }, s.prototype.mod = function (t) { return this.divmod(t, "mod", !1).mod }, s.prototype.umod = function (t) { return this.divmod(t, "mod", !0).mod }, s.prototype.divRound = function (t) { var e = this.divmod(t); if (e.mod.isZero()) return e.div; var n = 0 !== e.div.negative ? e.mod.isub(t) : e.mod, r = t.ushrn(1), i = t.andln(1), s = n.cmp(r); return s < 0 || 1 === i && 0 === s ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1) }, s.prototype.modn = function (t) { r(t <= 67108863); for (var e = (1 << 26) % t, n = 0, i = this.length - 1; i >= 0; i--)n = (e * n + (0 | this.words[i])) % t; return n }, s.prototype.idivn = function (t) { r(t <= 67108863); for (var e = 0, n = this.length - 1; n >= 0; n--) { var i = (0 | this.words[n]) + 67108864 * e; this.words[n] = i / t | 0, e = i % t } return this.strip() }, s.prototype.divn = function (t) { return this.clone().idivn(t) }, s.prototype.egcd = function (t) { r(0 === t.negative), r(!t.isZero()); var e = this, n = t.clone(); e = 0 !== e.negative ? e.umod(t) : e.clone(); for (var i = new s(1), o = new s(0), a = new s(0), l = new s(1), c = 0; e.isEven() && n.isEven();)e.iushrn(1), n.iushrn(1), ++c; for (var u = n.clone(), h = e.clone(); !e.isZero();) { for (var d = 0, p = 1; 0 == (e.words[0] & p) && d < 26; ++d, p <<= 1); if (d > 0) for (e.iushrn(d); d-- > 0;)(i.isOdd() || o.isOdd()) && (i.iadd(u), o.isub(h)), i.iushrn(1), o.iushrn(1); for (var f = 0, m = 1; 0 == (n.words[0] & m) && f < 26; ++f, m <<= 1); if (f > 0) for (n.iushrn(f); f-- > 0;)(a.isOdd() || l.isOdd()) && (a.iadd(u), l.isub(h)), a.iushrn(1), l.iushrn(1); e.cmp(n) >= 0 ? (e.isub(n), i.isub(a), o.isub(l)) : (n.isub(e), a.isub(i), l.isub(o)) } return { a: a, b: l, gcd: n.iushln(c) } }, s.prototype._invmp = function (t) { r(0 === t.negative), r(!t.isZero()); var e = this, n = t.clone(); e = 0 !== e.negative ? e.umod(t) : e.clone(); for (var i, o = new s(1), a = new s(0), l = n.clone(); e.cmpn(1) > 0 && n.cmpn(1) > 0;) { for (var c = 0, u = 1; 0 == (e.words[0] & u) && c < 26; ++c, u <<= 1); if (c > 0) for (e.iushrn(c); c-- > 0;)o.isOdd() && o.iadd(l), o.iushrn(1); for (var h = 0, d = 1; 0 == (n.words[0] & d) && h < 26; ++h, d <<= 1); if (h > 0) for (n.iushrn(h); h-- > 0;)a.isOdd() && a.iadd(l), a.iushrn(1); e.cmp(n) >= 0 ? (e.isub(n), o.isub(a)) : (n.isub(e), a.isub(o)) } return (i = 0 === e.cmpn(1) ? o : a).cmpn(0) < 0 && i.iadd(t), i }, s.prototype.gcd = function (t) { if (this.isZero()) return t.abs(); if (t.isZero()) return this.abs(); var e = this.clone(), n = t.clone(); e.negative = 0, n.negative = 0; for (var r = 0; e.isEven() && n.isEven(); r++)e.iushrn(1), n.iushrn(1); for (; ;) { for (; e.isEven();)e.iushrn(1); for (; n.isEven();)n.iushrn(1); var i = e.cmp(n); if (i < 0) { var s = e; e = n, n = s } else if (0 === i || 0 === n.cmpn(1)) break; e.isub(n) } return n.iushln(r) }, s.prototype.invm = function (t) { return this.egcd(t).a.umod(t) }, s.prototype.isEven = function () { return 0 == (1 & this.words[0]) }, s.prototype.isOdd = function () { return 1 == (1 & this.words[0]) }, s.prototype.andln = function (t) { return this.words[0] & t }, s.prototype.bincn = function (t) { r("number" == typeof t); var e = t % 26, n = (t - e) / 26, i = 1 << e; if (this.length <= n) return this._expand(n + 1), this.words[n] |= i, this; for (var s = i, o = n; 0 !== s && o < this.length; o++) { var a = 0 | this.words[o]; s = (a += s) >>> 26, this.words[o] = a &= 67108863 } return 0 !== s && (this.words[o] = s, this.length++), this }, s.prototype.isZero = function () { return 1 === this.length && 0 === this.words[0] }, s.prototype.cmpn = function (t) { var e, n = t < 0; if (0 !== this.negative && !n) return -1; if (0 === this.negative && n) return 1; if (this.strip(), this.length > 1) e = 1; else { n && (t = -t), r(t <= 67108863, "Number is too big"); var i = 0 | this.words[0]; e = i === t ? 0 : i < t ? -1 : 1 } return 0 !== this.negative ? 0 | -e : e }, s.prototype.cmp = function (t) { if (0 !== this.negative && 0 === t.negative) return -1; if (0 === this.negative && 0 !== t.negative) return 1; var e = this.ucmp(t); return 0 !== this.negative ? 0 | -e : e }, s.prototype.ucmp = function (t) { if (this.length > t.length) return 1; if (this.length < t.length) return -1; for (var e = 0, n = this.length - 1; n >= 0; n--) { var r = 0 | this.words[n], i = 0 | t.words[n]; if (r !== i) { r < i ? e = -1 : r > i && (e = 1); break } } return e }, s.prototype.gtn = function (t) { return 1 === this.cmpn(t) }, s.prototype.gt = function (t) { return 1 === this.cmp(t) }, s.prototype.gten = function (t) { return this.cmpn(t) >= 0 }, s.prototype.gte = function (t) { return this.cmp(t) >= 0 }, s.prototype.ltn = function (t) { return -1 === this.cmpn(t) }, s.prototype.lt = function (t) { return -1 === this.cmp(t) }, s.prototype.lten = function (t) { return this.cmpn(t) <= 0 }, s.prototype.lte = function (t) { return this.cmp(t) <= 0 }, s.prototype.eqn = function (t) { return 0 === this.cmpn(t) }, s.prototype.eq = function (t) { return 0 === this.cmp(t) }, s.red = function (t) { return new x(t) }, s.prototype.toRed = function (t) { return r(!this.red, "Already a number in reduction context"), r(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t) }, s.prototype.fromRed = function () { return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, s.prototype._forceRed = function (t) { return this.red = t, this }, s.prototype.forceRed = function (t) { return r(!this.red, "Already a number in reduction context"), this._forceRed(t) }, s.prototype.redAdd = function (t) { return r(this.red, "redAdd works only with red numbers"), this.red.add(this, t) }, s.prototype.redIAdd = function (t) { return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t) }, s.prototype.redSub = function (t) { return r(this.red, "redSub works only with red numbers"), this.red.sub(this, t) }, s.prototype.redISub = function (t) { return r(this.red, "redISub works only with red numbers"), this.red.isub(this, t) }, s.prototype.redShl = function (t) { return r(this.red, "redShl works only with red numbers"), this.red.shl(this, t) }, s.prototype.redMul = function (t) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t) }, s.prototype.redIMul = function (t) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t) }, s.prototype.redSqr = function () { return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, s.prototype.redISqr = function () { return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, s.prototype.redSqrt = function () { return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, s.prototype.redInvm = function () { return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, s.prototype.redNeg = function () { return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, s.prototype.redPow = function (t) { return r(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t) }; var v = { k256: null, p224: null, p192: null, p25519: null }; function y(t, e) { this.name = t, this.p = new s(e, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } function b() { y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } function _() { y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } function w() { y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } function S() { y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } function x(t) { if ("string" == typeof t) { var e = s._prime(t); this.m = e.p, this.prime = e } else r(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null } function T(t) { x.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } y.prototype._tmp = function () { var t = new s(null); return t.words = new Array(Math.ceil(this.n / 13)), t }, y.prototype.ireduce = function (t) { var e, n = t; do { this.split(n, this.tmp), e = (n = (n = this.imulK(n)).iadd(this.tmp)).bitLength() } while (e > this.n); var r = e < this.n ? -1 : n.ucmp(this.p); return 0 === r ? (n.words[0] = 0, n.length = 1) : r > 0 ? n.isub(this.p) : void 0 !== n.strip ? n.strip() : n._strip(), n }, y.prototype.split = function (t, e) { t.iushrn(this.n, 0, e) }, y.prototype.imulK = function (t) { return t.imul(this.k) }, i(b, y), b.prototype.split = function (t, e) { for (var n = 4194303, r = Math.min(t.length, 9), i = 0; i < r; i++)e.words[i] = t.words[i]; if (e.length = r, t.length <= 9) return t.words[0] = 0, void (t.length = 1); var s = t.words[9]; for (e.words[e.length++] = s & n, i = 10; i < t.length; i++) { var o = 0 | t.words[i]; t.words[i - 10] = (o & n) << 4 | s >>> 22, s = o } t.words[i - 10] = s >>>= 22, t.length -= 0 === s && t.length > 10 ? 10 : 9 }, b.prototype.imulK = function (t) { t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2; for (var e = 0, n = 0; n < t.length; n++) { var r = 0 | t.words[n]; t.words[n] = 67108863 & (e += 977 * r), e = 64 * r + (e / 67108864 | 0) } return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t }, i(_, y), i(w, y), i(S, y), S.prototype.imulK = function (t) { for (var e = 0, n = 0; n < t.length; n++) { var r = 19 * (0 | t.words[n]) + e, i = 67108863 & r; r >>>= 26, t.words[n] = i, e = r } return 0 !== e && (t.words[t.length++] = e), t }, s._prime = function (t) { if (v[t]) return v[t]; var e; if ("k256" === t) e = new b; else if ("p224" === t) e = new _; else if ("p192" === t) e = new w; else { if ("p25519" !== t) throw new Error("Unknown prime " + t); e = new S } return v[t] = e, e }, x.prototype._verify1 = function (t) { r(0 === t.negative, "red works only with positives"), r(t.red, "red works only with red numbers") }, x.prototype._verify2 = function (t, e) { r(0 == (t.negative | e.negative), "red works only with positives"), r(t.red && t.red === e.red, "red works only with red numbers") }, x.prototype.imod = function (t) { return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this) }, x.prototype.neg = function (t) { return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this) }, x.prototype.add = function (t, e) { this._verify2(t, e); var n = t.add(e); return n.cmp(this.m) >= 0 && n.isub(this.m), n._forceRed(this) }, x.prototype.iadd = function (t, e) { this._verify2(t, e); var n = t.iadd(e); return n.cmp(this.m) >= 0 && n.isub(this.m), n }, x.prototype.sub = function (t, e) { this._verify2(t, e); var n = t.sub(e); return n.cmpn(0) < 0 && n.iadd(this.m), n._forceRed(this) }, x.prototype.isub = function (t, e) { this._verify2(t, e); var n = t.isub(e); return n.cmpn(0) < 0 && n.iadd(this.m), n }, x.prototype.shl = function (t, e) { return this._verify1(t), this.imod(t.ushln(e)) }, x.prototype.imul = function (t, e) { return this._verify2(t, e), this.imod(t.imul(e)) }, x.prototype.mul = function (t, e) { return this._verify2(t, e), this.imod(t.mul(e)) }, x.prototype.isqr = function (t) { return this.imul(t, t.clone()) }, x.prototype.sqr = function (t) { return this.mul(t, t) }, x.prototype.sqrt = function (t) { if (t.isZero()) return t.clone(); var e = this.m.andln(3); if (r(e % 2 == 1), 3 === e) { var n = this.m.add(new s(1)).iushrn(2); return this.pow(t, n) } for (var i = this.m.subn(1), o = 0; !i.isZero() && 0 === i.andln(1);)o++, i.iushrn(1); r(!i.isZero()); var a = new s(1).toRed(this), l = a.redNeg(), c = this.m.subn(1).iushrn(1), u = this.m.bitLength(); for (u = new s(2 * u * u).toRed(this); 0 !== this.pow(u, c).cmp(l);)u.redIAdd(l); for (var h = this.pow(u, i), d = this.pow(t, i.addn(1).iushrn(1)), p = this.pow(t, i), f = o; 0 !== p.cmp(a);) { for (var m = p, g = 0; 0 !== m.cmp(a); g++)m = m.redSqr(); r(g < f); var v = this.pow(h, new s(1).iushln(f - g - 1)); d = d.redMul(v), h = v.redSqr(), p = p.redMul(h), f = g } return d }, x.prototype.invm = function (t) { var e = t._invmp(this.m); return 0 !== e.negative ? (e.negative = 0, this.imod(e).redNeg()) : this.imod(e) }, x.prototype.pow = function (t, e) { if (e.isZero()) return new s(1).toRed(this); if (0 === e.cmpn(1)) return t.clone(); var n = new Array(16); n[0] = new s(1).toRed(this), n[1] = t; for (var r = 2; r < n.length; r++)n[r] = this.mul(n[r - 1], t); var i = n[0], o = 0, a = 0, l = e.bitLength() % 26; for (0 === l && (l = 26), r = e.length - 1; r >= 0; r--) { for (var c = e.words[r], u = l - 1; u >= 0; u--) { var h = c >> u & 1; i !== n[0] && (i = this.sqr(i)), 0 !== h || 0 !== o ? (o <<= 1, o |= h, (4 == ++a || 0 === r && 0 === u) && (i = this.mul(i, n[o]), a = 0, o = 0)) : a = 0 } l = 26 } return i }, x.prototype.convertTo = function (t) { var e = t.umod(this.m); return e === t ? e.clone() : e }, x.prototype.convertFrom = function (t) { var e = t.clone(); return e.red = null, e }, s.mont = function (t) { return new T(t) }, i(T, x), T.prototype.convertTo = function (t) { return this.imod(t.ushln(this.shift)) }, T.prototype.convertFrom = function (t) { var e = this.imod(t.mul(this.rinv)); return e.red = null, e }, T.prototype.imul = function (t, e) { if (t.isZero() || e.isZero()) return t.words[0] = 0, t.length = 1, t; var n = t.imul(e), r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i = n.isub(r).iushrn(this.shift), s = i; return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this) }, T.prototype.mul = function (t, e) { if (t.isZero() || e.isZero()) return new s(0)._forceRed(this); var n = t.mul(e), r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i = n.isub(r).iushrn(this.shift), o = i; return i.cmp(this.m) >= 0 ? o = i.isub(this.m) : i.cmpn(0) < 0 && (o = i.iadd(this.m)), o._forceRed(this) }, T.prototype.invm = function (t) { return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this) } }(t = n.nmd(t), this) }, 1488: (t, e, n) => { "use strict"; n.r(e), n.d(e, { arrayify: () => l, concat: () => c, hexConcat: () => v, hexDataLength: () => m, hexDataSlice: () => g, hexStripZeros: () => b, hexValue: () => y, hexZeroPad: () => _, hexlify: () => f, isBytes: () => a, isBytesLike: () => o, isHexString: () => d, joinSignature: () => S, splitSignature: () => w, stripZeros: () => u, zeroPad: () => h }); const r = new (n(3898).Logger)("bytes/5.1.0"); function i(t) { return !!t.toHexString } function s(t) { return t.slice || (t.slice = function () { const e = Array.prototype.slice.call(arguments); return s(new Uint8Array(Array.prototype.slice.apply(t, e))) }), t } function o(t) { return d(t) && !(t.length % 2) || a(t) } function a(t) { if (null == t) return !1; if (t.constructor === Uint8Array) return !0; if ("string" == typeof t) return !1; if (null == t.length) return !1; for (let e = 0; e < t.length; e++) { const n = t[e]; if ("number" != typeof n || n < 0 || n >= 256 || n % 1) return !1 } return !0 } function l(t, e) { if (e || (e = {}), "number" == typeof t) { r.checkSafeUint53(t, "invalid arrayify value"); const e = []; for (; t;)e.unshift(255 & t), t = parseInt(String(t / 256)); return 0 === e.length && e.push(0), s(new Uint8Array(e)) } if (e.allowMissingPrefix && "string" == typeof t && "0x" !== t.substring(0, 2) && (t = "0x" + t), i(t) && (t = t.toHexString()), d(t)) { let n = t.substring(2); n.length % 2 && ("left" === e.hexPad ? n = "0x0" + n.substring(2) : "right" === e.hexPad ? n += "0" : r.throwArgumentError("hex data is odd-length", "value", t)); const i = []; for (let t = 0; t < n.length; t += 2)i.push(parseInt(n.substring(t, t + 2), 16)); return s(new Uint8Array(i)) } return a(t) ? s(new Uint8Array(t)) : r.throwArgumentError("invalid arrayify value", "value", t) } function c(t) { const e = t.map(t => l(t)), n = e.reduce((t, e) => t + e.length, 0), r = new Uint8Array(n); return e.reduce((t, e) => (r.set(e, t), t + e.length), 0), s(r) } function u(t) { let e = l(t); if (0 === e.length) return e; let n = 0; for (; n < e.length && 0 === e[n];)n++; return n && (e = e.slice(n)), e } function h(t, e) { (t = l(t)).length > e && r.throwArgumentError("value out of range", "value", arguments[0]); const n = new Uint8Array(e); return n.set(t, e - t.length), s(n) } function d(t, e) { return !("string" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e) } const p = "0123456789abcdef"; function f(t, e) { if (e || (e = {}), "number" == typeof t) { r.checkSafeUint53(t, "invalid hexlify value"); let e = ""; for (; t;)e = p[15 & t] + e, t = Math.floor(t / 16); return e.length ? (e.length % 2 && (e = "0" + e), "0x" + e) : "0x00" } if (e.allowMissingPrefix && "string" == typeof t && "0x" !== t.substring(0, 2) && (t = "0x" + t), i(t)) return t.toHexString(); if (d(t)) return t.length % 2 && ("left" === e.hexPad ? t = "0x0" + t.substring(2) : "right" === e.hexPad ? t += "0" : r.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase(); if (a(t)) { let e = "0x"; for (let n = 0; n < t.length; n++) { let r = t[n]; e += p[(240 & r) >> 4] + p[15 & r] } return e } return r.throwArgumentError("invalid hexlify value", "value", t) } function m(t) { if ("string" != typeof t) t = f(t); else if (!d(t) || t.length % 2) return null; return (t.length - 2) / 2 } function g(t, e, n) { return "string" != typeof t ? t = f(t) : (!d(t) || t.length % 2) && r.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, null != n ? "0x" + t.substring(e, 2 + 2 * n) : "0x" + t.substring(e) } function v(t) { let e = "0x"; return t.forEach(t => { e += f(t).substring(2) }), e } function y(t) { const e = b(f(t, { hexPad: "left" })); return "0x" === e ? "0x0" : e } function b(t) { "string" != typeof t && (t = f(t)), d(t) || r.throwArgumentError("invalid hex string", "value", t), t = t.substring(2); let e = 0; for (; e < t.length && "0" === t[e];)e++; return "0x" + t.substring(e) } function _(t, e) { for ("string" != typeof t ? t = f(t) : d(t) || r.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && r.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2;)t = "0x0" + t.substring(2); return t } function w(t) { const e = { r: "0x", s: "0x", _vs: "0x", recoveryParam: 0, v: 0 }; if (o(t)) { const n = l(t); 65 !== n.length && r.throwArgumentError("invalid signature string; must be 65 bytes", "signature", t), e.r = f(n.slice(0, 32)), e.s = f(n.slice(32, 64)), e.v = n[64], e.v < 27 && (0 === e.v || 1 === e.v ? e.v += 27 : r.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (n[32] |= 128), e._vs = f(n.slice(32, 64)) } else { if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, null != e._vs) { const n = h(l(e._vs), 32); e._vs = f(n); const i = n[0] >= 128 ? 1 : 0; null == e.recoveryParam ? e.recoveryParam = i : e.recoveryParam !== i && r.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), n[0] &= 127; const s = f(n); null == e.s ? e.s = s : e.s !== s && r.throwArgumentError("signature v mismatch _vs", "signature", t) } null == e.recoveryParam ? null == e.v ? r.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.recoveryParam = 0 === e.v || 1 === e.v ? e.v : 1 - e.v % 2 : null == e.v ? e.v = 27 + e.recoveryParam : e.recoveryParam !== 1 - e.v % 2 && r.throwArgumentError("signature recoveryParam mismatch v", "signature", t), null != e.r && d(e.r) ? e.r = _(e.r, 32) : r.throwArgumentError("signature missing or invalid r", "signature", t), null != e.s && d(e.s) ? e.s = _(e.s, 32) : r.throwArgumentError("signature missing or invalid s", "signature", t); const n = l(e.s); n[0] >= 128 && r.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (n[0] |= 128); const i = f(n); e._vs && (d(e._vs) || r.throwArgumentError("signature invalid _vs", "signature", t), e._vs = _(e._vs, 32)), null == e._vs ? e._vs = i : e._vs !== i && r.throwArgumentError("signature _vs mismatch v and s", "signature", t) } return e } function S(t) { return f(c([(t = w(t)).r, t.s, t.recoveryParam ? "0x1c" : "0x1b"])) } }, 1528: (t, e, n) => { "use strict"; n.d(e, { d: () => r }); const r = "0x0000000000000000000000000000000000000000" }, 6659: (t, e, n) => { "use strict"; n.d(e, { tL: () => i, _Y: () => s, fh: () => o, Py: () => a, Ce: () => l, Bz: () => c }); var r = n(2024); const i = r.O$.from(-1), s = r.O$.from(0), o = r.O$.from(1), a = r.O$.from(2), l = r.O$.from("1000000000000000000"), c = r.O$.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff") }, 5052: (t, e, n) => { "use strict"; n.d(e, { R: () => r }); const r = "0x0000000000000000000000000000000000000000000000000000000000000000" }, 1843: (t, e, n) => { "use strict"; n.r(e), n.d(e, { AddressZero: () => r.d, EtherSymbol: () => o, HashZero: () => s.R, MaxUint256: () => i.Bz, NegativeOne: () => i.tL, One: () => i.fh, Two: () => i.Py, WeiPerEther: () => i.Ce, Zero: () => i._Y }); var r = n(1528), i = n(6659), s = n(5052); const o = "\u039e" }, 6776: (t, e, n) => { "use strict"; n.r(e), n.d(e, { BaseContract: () => M, Contract: () => A, ContractFactory: () => C }); var r = n(1125), i = n(886), s = n(1527), o = n(1221), a = n(2885), l = n(2024), c = n(1488), u = n(2275), h = n(2701), d = n(3898), p = function (t, e, n, r) { return new (n || (n = Promise))(function (i, s) { function o(t) { try { l(r.next(t)) } catch (e) { s(e) } } function a(t) { try { l(r.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } l((r = r.apply(t, e || [])).next()) }) }; const f = new d.Logger("contracts/5.1.1"), m = { chainId: !0, data: !0, from: !0, gasLimit: !0, gasPrice: !0, nonce: !0, to: !0, value: !0, type: !0, accessList: !0 }; function g(t, e) { return p(this, void 0, void 0, function* () { const n = yield e; try { return (0, a.getAddress)(n) } catch (i) { } t || f.throwError("a provider or signer is needed to resolve ENS names", d.Logger.errors.UNSUPPORTED_OPERATION, { operation: "resolveName" }); const r = yield t.resolveName(n); return null == r && f.throwArgumentError("resolver or addr is not configured for ENS name", "name", n), r }) } function v(t, e, n) { return p(this, void 0, void 0, function* () { return Array.isArray(n) ? yield Promise.all(n.map((n, r) => v(t, Array.isArray(e) ? e[r] : e[n.name], n))) : "address" === n.type ? yield g(t, e) : "tuple" === n.type ? yield v(t, e, n.components) : "array" === n.baseType ? Array.isArray(e) ? yield Promise.all(e.map(e => v(t, e, n.arrayChildren))) : Promise.reject(new Error("invalid value for array")) : e }) } function y(t, e, n) { return p(this, void 0, void 0, function* () { let r = {}; n.length === e.inputs.length + 1 && "object" == typeof n[n.length - 1] && (r = (0, u.shallowCopy)(n.pop())), f.checkArgumentCount(n.length, e.inputs.length, "passed to contract"), t.signer ? r.from = r.from ? (0, u.resolveProperties)({ override: g(t.signer, r.from), signer: t.signer.getAddress() }).then(t => p(this, void 0, void 0, function* () { return (0, a.getAddress)(t.signer) !== t.override && f.throwError("Contract with a Signer cannot override from", d.Logger.errors.UNSUPPORTED_OPERATION, { operation: "overrides.from" }), t.override })) : t.signer.getAddress() : r.from && (r.from = g(t.provider, r.from)); const i = yield (0, u.resolveProperties)({ args: v(t.signer || t.provider, n, e.inputs), address: t.resolvedAddress, overrides: (0, u.resolveProperties)(r) || {} }), s = t.interface.encodeFunctionData(e, i.args), o = { data: s, to: i.address }, m = i.overrides; if (null != m.nonce && (o.nonce = l.O$.from(m.nonce).toNumber()), null != m.gasLimit && (o.gasLimit = l.O$.from(m.gasLimit)), null != m.gasPrice && (o.gasPrice = l.O$.from(m.gasPrice)), null != m.from && (o.from = m.from), null != m.type && (o.type = m.type), null != m.accessList && (o.accessList = (0, h.accessListify)(m.accessList)), null == o.gasLimit && null != e.gas) { let t = 21e3; const n = (0, c.arrayify)(s); for (let e = 0; e < n.length; e++)t += 4, n[e] && (t += 64); o.gasLimit = l.O$.from(e.gas).add(t) } if (m.value) { const t = l.O$.from(m.value); t.isZero() || e.payable || f.throwError("non-payable method cannot override value", d.Logger.errors.UNSUPPORTED_OPERATION, { operation: "overrides.value", value: r.value }), o.value = t } delete r.nonce, delete r.gasLimit, delete r.gasPrice, delete r.from, delete r.value, delete r.type, delete r.accessList; const y = Object.keys(r).filter(t => null != r[t]); return y.length && f.throwError(`cannot override ${y.map(t => JSON.stringify(t)).join(",")}`, d.Logger.errors.UNSUPPORTED_OPERATION, { operation: "overrides", overrides: y }), o }) } function b(t, e, n) { const r = t.signer || t.provider; return function (...i) { return p(this, void 0, void 0, function* () { let s; if (i.length === e.inputs.length + 1 && "object" == typeof i[i.length - 1]) { const t = (0, u.shallowCopy)(i.pop()); null != t.blockTag && (s = yield t.blockTag), delete t.blockTag, i.push(t) } null != t.deployTransaction && (yield t._deployed(s)); const o = yield y(t, e, i), a = yield r.call(o, s); try { let r = t.interface.decodeFunctionResult(e, a); return n && 1 === e.outputs.length && (r = r[0]), r } catch (l) { throw l.code === d.Logger.errors.CALL_EXCEPTION && (l.address = t.address, l.args = i, l.transaction = o), l } }) } } function _(t, e, n) { return e.constant ? b(t, e, n) : function (t, e) { return function (...n) { return p(this, void 0, void 0, function* () { t.signer || f.throwError("sending a transaction requires a signer", d.Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction" }), null != t.deployTransaction && (yield t._deployed()); const r = yield y(t, e, n), i = yield t.signer.sendTransaction(r), s = i.wait.bind(i); return i.wait = e => s(e).then(e => (e.events = e.logs.map(n => { let r = (0, u.deepCopy)(n), i = null; try { i = t.interface.parseLog(n) } catch (s) { } return i && (r.args = i.args, r.decode = (e, n) => t.interface.decodeEventLog(i.eventFragment, e, n), r.event = i.name, r.eventSignature = i.signature), r.removeListener = () => t.provider, r.getBlock = () => t.provider.getBlock(e.blockHash), r.getTransaction = () => t.provider.getTransaction(e.transactionHash), r.getTransactionReceipt = () => Promise.resolve(e), r }), e)), i }) } }(t, e) } function w(t) { return !t.address || null != t.topics && 0 !== t.topics.length ? (t.address || "*") + "@" + (t.topics ? t.topics.map(t => Array.isArray(t) ? t.join("|") : t).join(":") : "") : "*" } class S { constructor(t, e) { (0, u.defineReadOnly)(this, "tag", t), (0, u.defineReadOnly)(this, "filter", e), this._listeners = [] } addListener(t, e) { this._listeners.push({ listener: t, once: e }) } removeListener(t) { let e = !1; this._listeners = this._listeners.filter(n => !(!e && n.listener === t && (e = !0, 1))) } removeAllListeners() { this._listeners = [] } listeners() { return this._listeners.map(t => t.listener) } listenerCount() { return this._listeners.length } run(t) { const e = this.listenerCount(); return this._listeners = this._listeners.filter(e => { const n = t.slice(); return setTimeout(() => { e.listener.apply(this, n) }, 0), !e.once }), e } prepareEvent(t) { } getEmit(t) { return [t] } } class x extends S { constructor() { super("error", null) } } class T extends S { constructor(t, e, n, r) { const i = { address: t }; let s = e.getEventTopic(n); r ? (s !== r[0] && f.throwArgumentError("topic mismatch", "topics", r), i.topics = r.slice()) : i.topics = [s], super(w(i), i), (0, u.defineReadOnly)(this, "address", t), (0, u.defineReadOnly)(this, "interface", e), (0, u.defineReadOnly)(this, "fragment", n) } prepareEvent(t) { super.prepareEvent(t), t.event = this.fragment.name, t.eventSignature = this.fragment.format(), t.decode = (t, e) => this.interface.decodeEventLog(this.fragment, t, e); try { t.args = this.interface.decodeEventLog(this.fragment, t.data, t.topics) } catch (e) { t.args = null, t.decodeError = e } } getEmit(t) { const e = (0, r.BR)(t.args); if (e.length) throw e[0].error; const n = (t.args || []).slice(); return n.push(t), n } } class E extends S { constructor(t, e) { super("*", { address: t }), (0, u.defineReadOnly)(this, "address", t), (0, u.defineReadOnly)(this, "interface", e) } prepareEvent(t) { super.prepareEvent(t); try { const e = this.interface.parseLog(t); t.event = e.name, t.eventSignature = e.signature, t.decode = (t, n) => this.interface.decodeEventLog(e.eventFragment, t, n), t.args = e.args } catch (e) { } } } class M { constructor(t, e, n) { f.checkNew(new.target, A), (0, u.defineReadOnly)(this, "interface", (0, u.getStatic)(new.target, "getInterface")(e)), null == n ? ((0, u.defineReadOnly)(this, "provider", null), (0, u.defineReadOnly)(this, "signer", null)) : o.Signer.isSigner(n) ? ((0, u.defineReadOnly)(this, "provider", n.provider || null), (0, u.defineReadOnly)(this, "signer", n)) : s.zt.isProvider(n) ? ((0, u.defineReadOnly)(this, "provider", n), (0, u.defineReadOnly)(this, "signer", null)) : f.throwArgumentError("invalid signer or provider", "signerOrProvider", n), (0, u.defineReadOnly)(this, "callStatic", {}), (0, u.defineReadOnly)(this, "estimateGas", {}), (0, u.defineReadOnly)(this, "functions", {}), (0, u.defineReadOnly)(this, "populateTransaction", {}), (0, u.defineReadOnly)(this, "filters", {}); { const t = {}; Object.keys(this.interface.events).forEach(e => { const n = this.interface.events[e]; (0, u.defineReadOnly)(this.filters, e, (...t) => ({ address: this.address, topics: this.interface.encodeFilterTopics(n, t) })), t[n.name] || (t[n.name] = []), t[n.name].push(e) }), Object.keys(t).forEach(e => { const n = t[e]; 1 === n.length ? (0, u.defineReadOnly)(this.filters, e, this.filters[n[0]]) : f.warn(`Duplicate definition of ${e} (${n.join(", ")})`) }) } if ((0, u.defineReadOnly)(this, "_runningEvents", {}), (0, u.defineReadOnly)(this, "_wrappedEmits", {}), null == t && f.throwArgumentError("invalid contract address or ENS name", "addressOrName", t), (0, u.defineReadOnly)(this, "address", t), this.provider) (0, u.defineReadOnly)(this, "resolvedAddress", g(this.provider, t)); else try { (0, u.defineReadOnly)(this, "resolvedAddress", Promise.resolve((0, a.getAddress)(t))) } catch (l) { f.throwError("provider is required to use ENS name as contract address", d.Logger.errors.UNSUPPORTED_OPERATION, { operation: "new Contract" }) } const r = {}, i = {}; Object.keys(this.interface.functions).forEach(t => { const e = this.interface.functions[t]; if (i[t]) f.warn(`Duplicate ABI entry for ${JSON.stringify(name)}`); else { i[t] = !0; { const n = e.name; r[n] || (r[n] = []), r[n].push(t) } null == this[t] && (0, u.defineReadOnly)(this, t, _(this, e, !0)), null == this.functions[t] && (0, u.defineReadOnly)(this.functions, t, _(this, e, !1)), null == this.callStatic[t] && (0, u.defineReadOnly)(this.callStatic, t, b(this, e, !0)), null == this.populateTransaction[t] && (0, u.defineReadOnly)(this.populateTransaction, t, function (t, e) { return function (...n) { return y(t, e, n) } }(this, e)), null == this.estimateGas[t] && (0, u.defineReadOnly)(this.estimateGas, t, function (t, e) { const n = t.signer || t.provider; return function (...r) { return p(this, void 0, void 0, function* () { n || f.throwError("estimate require a provider or signer", d.Logger.errors.UNSUPPORTED_OPERATION, { operation: "estimateGas" }); const i = yield y(t, e, r); return yield n.estimateGas(i) }) } }(this, e)) } }), Object.keys(r).forEach(t => { const e = r[t]; if (e.length > 1) return; const n = e[0]; try { null == this[t] && (0, u.defineReadOnly)(this, t, this[n]) } catch (i) { } null == this.functions[t] && (0, u.defineReadOnly)(this.functions, t, this.functions[n]), null == this.callStatic[t] && (0, u.defineReadOnly)(this.callStatic, t, this.callStatic[n]), null == this.populateTransaction[t] && (0, u.defineReadOnly)(this.populateTransaction, t, this.populateTransaction[n]), null == this.estimateGas[t] && (0, u.defineReadOnly)(this.estimateGas, t, this.estimateGas[n]) }) } static getContractAddress(t) { return (0, a.getContractAddress)(t) } static getInterface(t) { return i.vU.isInterface(t) ? t : new i.vU(t) } deployed() { return this._deployed() } _deployed(t) { return this._deployedPromise || (this._deployedPromise = this.deployTransaction ? this.deployTransaction.wait().then(() => this) : this.provider.getCode(this.address, t).then(t => ("0x" === t && f.throwError("contract not deployed", d.Logger.errors.UNSUPPORTED_OPERATION, { contractAddress: this.address, operation: "getDeployed" }), this))), this._deployedPromise } fallback(t) { this.signer || f.throwError("sending a transactions require a signer", d.Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" }); const e = (0, u.shallowCopy)(t || {}); return ["from", "to"].forEach(function (t) { null != e[t] && f.throwError("cannot override " + t, d.Logger.errors.UNSUPPORTED_OPERATION, { operation: t }) }), e.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(e)) } connect(t) { "string" == typeof t && (t = new o.VoidSigner(t, this.provider)); const e = new this.constructor(this.address, this.interface, t); return this.deployTransaction && (0, u.defineReadOnly)(e, "deployTransaction", this.deployTransaction), e } attach(t) { return new this.constructor(t, this.interface, this.signer || this.provider) } static isIndexed(t) { return i.Hk.isIndexed(t) } _normalizeRunningEvent(t) { return this._runningEvents[t.tag] ? this._runningEvents[t.tag] : t } _getRunningEvent(t) { if ("string" == typeof t) { if ("error" === t) return this._normalizeRunningEvent(new x); if ("event" === t) return this._normalizeRunningEvent(new S("event", null)); if ("*" === t) return this._normalizeRunningEvent(new E(this.address, this.interface)); const e = this.interface.getEvent(t); return this._normalizeRunningEvent(new T(this.address, this.interface, e)) } if (t.topics && t.topics.length > 0) { try { const e = t.topics[0]; if ("string" != typeof e) throw new Error("invalid topic"); const n = this.interface.getEvent(e); return this._normalizeRunningEvent(new T(this.address, this.interface, n, t.topics)) } catch (e) { } const n = { address: this.address, topics: t.topics }; return this._normalizeRunningEvent(new S(w(n), n)) } return this._normalizeRunningEvent(new E(this.address, this.interface)) } _checkRunningEvents(t) { if (0 === t.listenerCount()) { delete this._runningEvents[t.tag]; const e = this._wrappedEmits[t.tag]; e && t.filter && (this.provider.off(t.filter, e), delete this._wrappedEmits[t.tag]) } } _wrapEvent(t, e, n) { const r = (0, u.deepCopy)(e); return r.removeListener = () => { n && (t.removeListener(n), this._checkRunningEvents(t)) }, r.getBlock = () => this.provider.getBlock(e.blockHash), r.getTransaction = () => this.provider.getTransaction(e.transactionHash), r.getTransactionReceipt = () => this.provider.getTransactionReceipt(e.transactionHash), t.prepareEvent(r), r } _addEventListener(t, e, n) { if (this.provider || f.throwError("events require a provider or a signer with a provider", d.Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" }), t.addListener(e, n), this._runningEvents[t.tag] = t, !this._wrappedEmits[t.tag]) { const n = n => { let r = this._wrapEvent(t, n, e); if (null == r.decodeError) try { const e = t.getEmit(r); this.emit(t.filter, ...e) } catch (i) { r.decodeError = i.error } null != t.filter && this.emit("event", r), null != r.decodeError && this.emit("error", r.decodeError, r) }; this._wrappedEmits[t.tag] = n, null != t.filter && this.provider.on(t.filter, n) } } queryFilter(t, e, n) { const r = this._getRunningEvent(t), i = (0, u.shallowCopy)(r.filter); return "string" == typeof e && (0, c.isHexString)(e, 32) ? (null != n && f.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", n), i.blockHash = e) : (i.fromBlock = null != e ? e : 0, i.toBlock = null != n ? n : "latest"), this.provider.getLogs(i).then(t => t.map(t => this._wrapEvent(r, t, null))) } on(t, e) { return this._addEventListener(this._getRunningEvent(t), e, !1), this } once(t, e) { return this._addEventListener(this._getRunningEvent(t), e, !0), this } emit(t, ...e) { if (!this.provider) return !1; const n = this._getRunningEvent(t), r = n.run(e) > 0; return this._checkRunningEvents(n), r } listenerCount(t) { return this.provider ? null == t ? Object.keys(this._runningEvents).reduce((t, e) => t + this._runningEvents[e].listenerCount(), 0) : this._getRunningEvent(t).listenerCount() : 0 } listeners(t) { if (!this.provider) return []; if (null == t) { const t = []; for (let e in this._runningEvents) this._runningEvents[e].listeners().forEach(e => { t.push(e) }); return t } return this._getRunningEvent(t).listeners() } removeAllListeners(t) { if (!this.provider) return this; if (null == t) { for (const t in this._runningEvents) { const e = this._runningEvents[t]; e.removeAllListeners(), this._checkRunningEvents(e) } return this } const e = this._getRunningEvent(t); return e.removeAllListeners(), this._checkRunningEvents(e), this } off(t, e) { if (!this.provider) return this; const n = this._getRunningEvent(t); return n.removeListener(e), this._checkRunningEvents(n), this } removeListener(t, e) { return this.off(t, e) } } class A extends M { } class C { constructor(t, e, n) { let r = null; r = "string" == typeof e ? e : (0, c.isBytes)(e) ? (0, c.hexlify)(e) : e && "string" == typeof e.object ? e.object : "!", "0x" !== r.substring(0, 2) && (r = "0x" + r), (!(0, c.isHexString)(r) || r.length % 2) && f.throwArgumentError("invalid bytecode", "bytecode", e), n && !o.Signer.isSigner(n) && f.throwArgumentError("invalid signer", "signer", n), (0, u.defineReadOnly)(this, "bytecode", r), (0, u.defineReadOnly)(this, "interface", (0, u.getStatic)(new.target, "getInterface")(t)), (0, u.defineReadOnly)(this, "signer", n || null) } getDeployTransaction(...t) { let e = {}; if (t.length === this.interface.deploy.inputs.length + 1 && "object" == typeof t[t.length - 1]) { e = (0, u.shallowCopy)(t.pop()); for (const t in e) if (!m[t]) throw new Error("unknown transaction override " + t) } return ["data", "from", "to"].forEach(t => { null != e[t] && f.throwError("cannot override " + t, d.Logger.errors.UNSUPPORTED_OPERATION, { operation: t }) }), f.checkArgumentCount(t.length, this.interface.deploy.inputs.length, " in Contract constructor"), e.data = (0, c.hexlify)((0, c.concat)([this.bytecode, this.interface.encodeDeploy(t)])), e } deploy(...t) { return p(this, void 0, void 0, function* () { let e = {}; t.length === this.interface.deploy.inputs.length + 1 && (e = t.pop()), f.checkArgumentCount(t.length, this.interface.deploy.inputs.length, " in Contract constructor"); const n = yield v(this.signer, t, this.interface.deploy.inputs); n.push(e); const r = this.getDeployTransaction(...n), i = yield this.signer.sendTransaction(r), s = (0, u.getStatic)(this.constructor, "getContractAddress")(i), o = (0, u.getStatic)(this.constructor, "getContract")(s, this.interface, this.signer); return (0, u.defineReadOnly)(o, "deployTransaction", i), o }) } attach(t) { return this.constructor.getContract(t, this.interface, this.signer) } connect(t) { return new this.constructor(this.interface, this.bytecode, t) } static fromSolidity(t, e) { null == t && f.throwError("missing compiler output", d.Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" }), "string" == typeof t && (t = JSON.parse(t)); let n = null; return t.bytecode ? n = t.bytecode : t.evm && t.evm.bytecode && (n = t.evm.bytecode), new this(t.abi, n, e) } static getInterface(t) { return A.getInterface(t) } static getContractAddress(t) { return (0, a.getContractAddress)(t) } static getContract(t, e, n) { return new A(t, e, n) } } }, 8022: (t, e, n) => { "use strict"; n.d(e, { i: () => r }); const r = "hash/5.1.0" }, 7475: (t, e, n) => { "use strict"; n.d(e, { id: () => s }); var r = n(8518), i = n(8822); function s(t) { return (0, r.keccak256)((0, i.Y0)(t)) } }, 778: (t, e, n) => { "use strict"; n.r(e), n.d(e, { id: () => r.id, namehash: () => i.V, isValidName: () => i.r, messagePrefix: () => s.B, hashMessage: () => s.r, _TypedDataEncoder: () => o.E }); var r = n(7475), i = n(7975), s = n(8429), o = n(2072) }, 8429: (t, e, n) => { "use strict"; n.d(e, { B: () => o, r: () => a }); var r = n(1488), i = n(8518), s = n(8822); const o = "\x19Ethereum Signed Message:\n"; function a(t) { return "string" == typeof t && (t = (0, s.Y0)(t)), (0, i.keccak256)((0, r.concat)([(0, s.Y0)(o), (0, s.Y0)(String(t.length)), t])) } }, 7975: (t, e, n) => { "use strict"; n.d(e, { r: () => d, V: () => p }); var r = n(1488), i = n(7188), s = n(8822), o = n(8518), a = n(3898), l = n(8022); const c = new a.Logger(l.i), u = new Uint8Array(32); u.fill(0); const h = new RegExp("^((.*)\\.)?([^.]+)$"); function d(t) { try { const e = t.split("."); for (let t = 0; t < e.length; t++)if (0 === (0, i.Ll)(e[t]).length) throw new Error("empty"); return !0 } catch (e) { } return !1 } function p(t) { "string" != typeof t && c.throwArgumentError("invalid address - " + String(t), "name", t); let e = u; for (; t.length;) { const n = t.match(h), a = (0, s.Y0)((0, i.Ll)(n[3])); e = (0, o.keccak256)((0, r.concat)([e, (0, o.keccak256)(a)])), t = n[2] || "" } return (0, r.hexlify)(e) } }, 2072: (t, e, n) => { "use strict"; n.d(e, { E: () => E }); var r = n(2885), i = n(2024), s = n(1488), o = n(8518), a = n(2275), l = n(3898), c = n(8022), u = n(7475); const h = new l.Logger(c.i), d = new Uint8Array(32); d.fill(0); const p = i.O$.from(-1), f = i.O$.from(0), m = i.O$.from(1), g = i.O$.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), v = (0, s.hexZeroPad)(m.toHexString(), 32), y = (0, s.hexZeroPad)(f.toHexString(), 32), b = { name: "string", version: "string", chainId: "uint256", verifyingContract: "address", salt: "bytes32" }, _ = ["name", "version", "chainId", "verifyingContract", "salt"]; function w(t) { return function (e) { return "string" != typeof e && h.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e } } const S = { name: w("name"), version: w("version"), chainId: function (t) { try { return i.O$.from(t).toString() } catch (e) { } return h.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", t) }, verifyingContract: function (t) { try { return (0, r.getAddress)(t).toLowerCase() } catch (e) { } return h.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", t) }, salt: function (t) { try { const e = (0, s.arrayify)(t); if (32 !== e.length) throw new Error("bad length"); return (0, s.hexlify)(e) } catch (e) { } return h.throwArgumentError('invalid domain value "salt"', "domain.salt", t) } }; function x(t) { { const e = t.match(/^(u?)int(\d*)$/); if (e) { const n = "" === e[1], r = parseInt(e[2] || "256"); (r % 8 != 0 || r > 256 || e[2] && e[2] !== String(r)) && h.throwArgumentError("invalid numeric width", "type", t); const o = g.mask(n ? r - 1 : r), a = n ? o.add(m).mul(p) : f; return function (e) { const n = i.O$.from(e); return (n.lt(a) || n.gt(o)) && h.throwArgumentError(`value out-of-bounds for ${t}`, "value", e), (0, s.hexZeroPad)(n.toTwos(256).toHexString(), 32) } } } { const e = t.match(/^bytes(\d+)$/); if (e) { const n = parseInt(e[1]); return (0 === n || n > 32 || e[1] !== String(n)) && h.throwArgumentError("invalid bytes width", "type", t), function (e) { return (0, s.arrayify)(e).length !== n && h.throwArgumentError(`invalid length for ${t}`, "value", e), function (t) { const e = (0, s.arrayify)(t), n = e.length % 32; return n ? (0, s.hexConcat)([e, d.slice(n)]) : (0, s.hexlify)(e) }(e) } } } switch (t) { case "address": return function (t) { return (0, s.hexZeroPad)((0, r.getAddress)(t), 32) }; case "bool": return function (t) { return t ? v : y }; case "bytes": return function (t) { return (0, o.keccak256)(t) }; case "string": return function (t) { return (0, u.id)(t) } }return null } function T(t, e) { return `${t}(${e.map(({ name: t, type: e }) => e + " " + t).join(",")})` } class E { constructor(t) { (0, a.defineReadOnly)(this, "types", Object.freeze((0, a.deepCopy)(t))), (0, a.defineReadOnly)(this, "_encoderCache", {}), (0, a.defineReadOnly)(this, "_types", {}); const e = {}, n = {}, r = {}; Object.keys(t).forEach(t => { e[t] = {}, n[t] = [], r[t] = {} }); for (const s in t) { const r = {}; t[s].forEach(i => { r[i.name] && h.throwArgumentError(`duplicate variable name ${JSON.stringify(i.name)} in ${JSON.stringify(s)}`, "types", t), r[i.name] = !0; const o = i.type.match(/^([^\x5b]*)(\x5b|$)/)[1]; o === s && h.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`, "types", t), x(o) || (n[o] || h.throwArgumentError(`unknown type ${JSON.stringify(o)}`, "types", t), n[o].push(s), e[s][o] = !0) }) } const i = Object.keys(n).filter(t => 0 === n[t].length); 0 === i.length ? h.throwArgumentError("missing primary type", "types", t) : i.length > 1 && h.throwArgumentError(`ambiguous primary types or unused types: ${i.map(t => JSON.stringify(t)).join(", ")}`, "types", t), (0, a.defineReadOnly)(this, "primaryType", i[0]), function i(s, o) { o[s] && h.throwArgumentError(`circular type reference to ${JSON.stringify(s)}`, "types", t), o[s] = !0, Object.keys(e[s]).forEach(t => { n[t] && (i(t, o), Object.keys(o).forEach(e => { r[e][t] = !0 })) }), delete o[s] }(this.primaryType, {}); for (const s in r) { const e = Object.keys(r[s]); e.sort(), this._types[s] = T(s, t[s]) + e.map(e => T(e, t[e])).join("") } } getEncoder(t) { let e = this._encoderCache[t]; return e || (e = this._encoderCache[t] = this._getEncoder(t)), e } _getEncoder(t) { { const e = x(t); if (e) return e } const e = t.match(/^(.*)(\x5b(\d*)\x5d)$/); if (e) { const t = e[1], n = this.getEncoder(t), r = parseInt(e[3]); return e => { r >= 0 && e.length !== r && h.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", e); let i = e.map(n); return this._types[t] && (i = i.map(o.keccak256)), (0, o.keccak256)((0, s.hexConcat)(i)) } } const n = this.types[t]; if (n) { const e = (0, u.id)(this._types[t]); return t => { const r = n.map(({ name: e, type: n }) => { const r = this.getEncoder(n)(t[e]); return this._types[n] ? (0, o.keccak256)(r) : r }); return r.unshift(e), (0, s.hexConcat)(r) } } return h.throwArgumentError(`unknown type: ${t}`, "type", t) } encodeType(t) { const e = this._types[t]; return e || h.throwArgumentError(`unknown type: ${JSON.stringify(t)}`, "name", t), e } encodeData(t, e) { return this.getEncoder(t)(e) } hashStruct(t, e) { return (0, o.keccak256)(this.encodeData(t, e)) } encode(t) { return this.encodeData(this.primaryType, t) } hash(t) { return this.hashStruct(this.primaryType, t) } _visit(t, e, n) { if (x(t)) return n(t, e); const r = t.match(/^(.*)(\x5b(\d*)\x5d)$/); if (r) { const t = r[1], i = parseInt(r[3]); return i >= 0 && e.length !== i && h.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", e), e.map(e => this._visit(t, e, n)) } const i = this.types[t]; return i ? i.reduce((t, { name: r, type: i }) => (t[r] = this._visit(i, e[r], n), t), {}) : h.throwArgumentError(`unknown type: ${t}`, "type", t) } visit(t, e) { return this._visit(this.primaryType, t, e) } static from(t) { return new E(t) } static getPrimaryType(t) { return E.from(t).primaryType } static hashStruct(t, e, n) { return E.from(e).hashStruct(t, n) } static hashDomain(t) { const e = []; for (const n in t) { const r = b[n]; r || h.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", t), e.push({ name: n, type: r }) } return e.sort((t, e) => _.indexOf(t.name) - _.indexOf(e.name)), E.hashStruct("EIP712Domain", { EIP712Domain: e }, t) } static encode(t, e, n) { return (0, s.hexConcat)(["0x1901", E.hashDomain(t), E.from(e).hash(n)]) } static hash(t, e, n) { return (0, o.keccak256)(E.encode(t, e, n)) } static resolveNames(t, e, n, r) { return i = this, void 0, l = function* () { t = (0, a.shallowCopy)(t); const i = {}; t.verifyingContract && !(0, s.isHexString)(t.verifyingContract, 20) && (i[t.verifyingContract] = "0x"); const o = E.from(e); o.visit(n, (t, e) => ("address" !== t || (0, s.isHexString)(e, 20) || (i[e] = "0x"), e)); for (const t in i) i[t] = yield r(t); return t.verifyingContract && i[t.verifyingContract] && (t.verifyingContract = i[t.verifyingContract]), n = o.visit(n, (t, e) => "address" === t && i[e] ? i[e] : e), { domain: t, value: n } }, new ((o = void 0) || (o = Promise))(function (t, e) { function n(t) { try { s(l.next(t)) } catch (n) { e(n) } } function r(t) { try { s(l.throw(t)) } catch (n) { e(n) } } function s(e) { var i; e.done ? t(e.value) : (i = e.value, i instanceof o ? i : new o(function (t) { t(i) })).then(n, r) } s((l = l.apply(i, [])).next()) }); var i, o, l } static getPayload(t, e, n) { E.hashDomain(t); const r = {}, o = []; _.forEach(e => { const n = t[e]; null != n && (r[e] = S[e](n), o.push({ name: e, type: b[e] })) }); const l = E.from(e), c = (0, a.shallowCopy)(e); return c.EIP712Domain ? h.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", e) : c.EIP712Domain = o, l.encode(n), { types: c, domain: r, primaryType: l.primaryType, message: l.visit(n, (t, e) => { if (t.match(/^bytes(\d*)/)) return (0, s.hexlify)((0, s.arrayify)(e)); if (t.match(/^u?int/)) return i.O$.from(e).toString(); switch (t) { case "address": return e.toLowerCase(); case "bool": return !!e; case "string": return "string" != typeof e && h.throwArgumentError("invalid string", "value", e), e }return h.throwArgumentError("unsupported type", "type", t) }) } } } }, 9593: (t, e, n) => { "use strict"; n.r(e), n.d(e, { HDNode: () => T, defaultPath: () => x, entropyToMnemonic: () => A, isValidMnemonic: () => C, mnemonicToEntropy: () => M, mnemonicToSeed: () => E }); var r = n(3744), i = n(1488), s = n(2024), o = n(8822), a = n(9938), l = n(2275), c = n(9596), u = n(5614), h = n(3389), d = n(2701), p = n(7887); const f = new (n(3898).Logger)("hdnode/5.1.0"), m = s.O$.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), g = (0, o.Y0)("Bitcoin seed"), v = 2147483648; function y(t) { return (1 << t) - 1 << 8 - t } function b(t) { return (0, i.hexZeroPad)((0, i.hexlify)(t), 32) } function _(t) { return r.Base58.encode((0, i.concat)([t, (0, i.hexDataSlice)((0, u.JQ)((0, u.JQ)(t)), 0, 4)])) } function w(t) { if (null == t) return p.E.en; if ("string" == typeof t) { const e = p.E[t]; return null == e && f.throwArgumentError("unknown locale", "wordlist", t), e } return t } const S = {}, x = "m/44'/60'/0'/0/0"; class T { constructor(t, e, n, r, s, o, a, h) { if (f.checkNew(new.target, T), t !== S) throw new Error("HDNode constructor cannot be called directly"); if (e) { const t = new c.SigningKey(e); (0, l.defineReadOnly)(this, "privateKey", t.privateKey), (0, l.defineReadOnly)(this, "publicKey", t.compressedPublicKey) } else (0, l.defineReadOnly)(this, "privateKey", null), (0, l.defineReadOnly)(this, "publicKey", (0, i.hexlify)(n)); (0, l.defineReadOnly)(this, "parentFingerprint", r), (0, l.defineReadOnly)(this, "fingerprint", (0, i.hexDataSlice)((0, u.bP)((0, u.JQ)(this.publicKey)), 0, 4)), (0, l.defineReadOnly)(this, "address", (0, d.computeAddress)(this.publicKey)), (0, l.defineReadOnly)(this, "chainCode", s), (0, l.defineReadOnly)(this, "index", o), (0, l.defineReadOnly)(this, "depth", a), null == h ? ((0, l.defineReadOnly)(this, "mnemonic", null), (0, l.defineReadOnly)(this, "path", null)) : "string" == typeof h ? ((0, l.defineReadOnly)(this, "mnemonic", null), (0, l.defineReadOnly)(this, "path", h)) : ((0, l.defineReadOnly)(this, "mnemonic", h), (0, l.defineReadOnly)(this, "path", h.path)) } get extendedKey() { if (this.depth >= 256) throw new Error("Depth too large!"); return _((0, i.concat)([null != this.privateKey ? "0x0488ADE4" : "0x0488B21E", (0, i.hexlify)(this.depth), this.parentFingerprint, (0, i.hexZeroPad)((0, i.hexlify)(this.index), 4), this.chainCode, null != this.privateKey ? (0, i.concat)(["0x00", this.privateKey]) : this.publicKey])) } neuter() { return new T(S, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path) } _derive(t) { if (t > 4294967295) throw new Error("invalid index - " + String(t)); let e = this.path; e && (e += "/" + (2147483647 & t)); const n = new Uint8Array(37); if (t & v) { if (!this.privateKey) throw new Error("cannot derive child of neutered node"); n.set((0, i.arrayify)(this.privateKey), 1), e && (e += "'") } else n.set((0, i.arrayify)(this.publicKey)); for (let i = 24; i >= 0; i -= 8)n[33 + (i >> 3)] = t >> 24 - i & 255; const r = (0, i.arrayify)((0, u.Gy)(h.p.sha512, this.chainCode, n)), o = r.slice(0, 32), a = r.slice(32); let l = null, d = null; this.privateKey ? l = b(s.O$.from(o).add(this.privateKey).mod(m)) : d = new c.SigningKey((0, i.hexlify)(o))._addPoint(this.publicKey); let p = e; const f = this.mnemonic; return f && (p = Object.freeze({ phrase: f.phrase, path: e, locale: f.locale || "en" })), new T(S, l, d, this.fingerprint, b(a), t, this.depth + 1, p) } derivePath(t) { const e = t.split("/"); if (0 === e.length || "m" === e[0] && 0 !== this.depth) throw new Error("invalid path - " + t); "m" === e[0] && e.shift(); let n = this; for (let r = 0; r < e.length; r++) { const t = e[r]; if (t.match(/^[0-9]+'$/)) { const e = parseInt(t.substring(0, t.length - 1)); if (e >= v) throw new Error("invalid path index - " + t); n = n._derive(v + e) } else { if (!t.match(/^[0-9]+$/)) throw new Error("invalid path component - " + t); { const e = parseInt(t); if (e >= v) throw new Error("invalid path index - " + t); n = n._derive(e) } } } return n } static _fromSeed(t, e) { const n = (0, i.arrayify)(t); if (n.length < 16 || n.length > 64) throw new Error("invalid seed"); const r = (0, i.arrayify)((0, u.Gy)(h.p.sha512, g, n)); return new T(S, b(r.slice(0, 32)), null, "0x00000000", b(r.slice(32)), 0, 0, e) } static fromMnemonic(t, e, n) { return t = A(M(t, n = w(n)), n), T._fromSeed(E(t, e), { phrase: t, path: "m", locale: n.locale }) } static fromSeed(t) { return T._fromSeed(t, null) } static fromExtendedKey(t) { const e = r.Base58.decode(t); 82 === e.length && _(e.slice(0, 78)) === t || f.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]"); const n = e[4], s = (0, i.hexlify)(e.slice(5, 9)), o = parseInt((0, i.hexlify)(e.slice(9, 13)).substring(2), 16), a = (0, i.hexlify)(e.slice(13, 45)), l = e.slice(45, 78); switch ((0, i.hexlify)(e.slice(0, 4))) { case "0x0488b21e": case "0x043587cf": return new T(S, null, (0, i.hexlify)(l), s, a, o, n, null); case "0x0488ade4": case "0x04358394 ": if (0 !== l[0]) break; return new T(S, (0, i.hexlify)(l.slice(1)), null, s, a, o, n, null) }return f.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]") } } function E(t, e) { e || (e = ""); const n = (0, o.Y0)("mnemonic" + e, o.Uj.NFKD); return (0, a.n)((0, o.Y0)(t, o.Uj.NFKD), n, 2048, 64, "sha512") } function M(t, e) { e = w(e), f.checkNormalize(); const n = e.split(t); if (n.length % 3 != 0) throw new Error("invalid mnemonic"); const r = (0, i.arrayify)(new Uint8Array(Math.ceil(11 * n.length / 8))); let s = 0; for (let i = 0; i < n.length; i++) { let t = e.getWordIndex(n[i].normalize("NFKD")); if (-1 === t) throw new Error("invalid mnemonic"); for (let e = 0; e < 11; e++)t & 1 << 10 - e && (r[s >> 3] |= 1 << 7 - s % 8), s++ } const o = 32 * n.length / 3, a = y(n.length / 3); if (((0, i.arrayify)((0, u.JQ)(r.slice(0, o / 8)))[0] & a) != (r[r.length - 1] & a)) throw new Error("invalid checksum"); return (0, i.hexlify)(r.slice(0, o / 8)) } function A(t, e) { if (e = w(e), (t = (0, i.arrayify)(t)).length % 4 != 0 || t.length < 16 || t.length > 32) throw new Error("invalid entropy"); const n = [0]; let r = 11; for (let i = 0; i < t.length; i++)r > 8 ? (n[n.length - 1] <<= 8, n[n.length - 1] |= t[i], r -= 8) : (n[n.length - 1] <<= r, n[n.length - 1] |= t[i] >> 8 - r, n.push(t[i] & (1 << 8 - r) - 1), r += 3); const s = t.length / 4, o = (0, i.arrayify)((0, u.JQ)(t))[0] & y(s); return n[n.length - 1] <<= s, n[n.length - 1] |= o >> 8 - s, e.join(n.map(t => e.getWord(t))) } function C(t, e) { try { return M(t, e), !0 } catch (n) { } return !1 } }, 8590: (t, e, n) => { "use strict"; n.d(e, { i: () => r }); const r = "json-wallets/5.1.0" }, 9799: (t, e, n) => { "use strict"; n.r(e), n.d(e, { decryptCrowdsale: () => g, decryptJsonWallet: () => w, decryptJsonWalletSync: () => S, decryptKeystore: () => _.pe, decryptKeystoreSync: () => _.hb, encryptKeystore: () => _.HI, getJsonWalletAddress: () => b, isCrowdsaleWallet: () => v, isKeystoreWallet: () => y }); var r = n(2280), i = n.n(r), s = n(2885), o = n(1488), a = n(8518), l = n(9938), c = n(8822), u = n(2275), h = n(3898), d = n(8590), p = n(3137); const f = new h.Logger(d.i); class m extends u.Description { isCrowdsaleAccount(t) { return !(!t || !t._isCrowdsaleAccount) } } function g(t, e) { const n = JSON.parse(t); e = (0, p.Ij)(e); const r = (0, s.getAddress)((0, p.gx)(n, "ethaddr")), u = (0, p.p3)((0, p.gx)(n, "encseed")); u && u.length % 16 == 0 || f.throwArgumentError("invalid encseed", "json", t); const h = (0, o.arrayify)((0, l.n)(e, e, 2e3, 32, "sha256")).slice(0, 16), d = u.slice(0, 16), g = u.slice(16), v = new (i().ModeOfOperation.cbc)(h, d), y = i().padding.pkcs7.strip((0, o.arrayify)(v.decrypt(g))); let b = ""; for (let i = 0; i < y.length; i++)b += String.fromCharCode(y[i]); const _ = (0, c.Y0)(b), w = (0, a.keccak256)(_); return new m({ _isCrowdsaleAccount: !0, address: r, privateKey: w }) } function v(t) { let e = null; try { e = JSON.parse(t) } catch (n) { return !1 } return e.encseed && e.ethaddr } function y(t) { let e = null; try { e = JSON.parse(t) } catch (n) { return !1 } return !(!e.version || parseInt(e.version) !== e.version || 3 !== parseInt(e.version)) } function b(t) { if (v(t)) try { return (0, s.getAddress)(JSON.parse(t).ethaddr) } catch (e) { return null } if (y(t)) try { return (0, s.getAddress)(JSON.parse(t).address) } catch (e) { return null } return null } var _ = n(6484); function w(t, e, n) { if (v(t)) { n && n(0); const r = g(t, e); return n && n(1), Promise.resolve(r) } return y(t) ? (0, _.pe)(t, e, n) : Promise.reject(new Error("invalid JSON wallet")) } function S(t, e) { if (v(t)) return g(t, e); if (y(t)) return (0, _.hb)(t, e); throw new Error("invalid JSON wallet") } }, 6484: (t, e, n) => { "use strict"; n.d(e, { hb: () => E, pe: () => M, HI: () => A }); var r = n(2280), i = n.n(r), s = n(1719), o = n.n(s), a = n(2885), l = n(1488), c = n(9593), u = n(8518), h = n(9938), d = n(2563), p = n(2275), f = n(2701), m = n(3137), g = n(3898), v = n(8590); const y = new g.Logger(v.i); function b(t) { return null != t && t.mnemonic && t.mnemonic.phrase } class _ extends p.Description { isKeystoreAccount(t) { return !(!t || !t._isKeystoreAccount) } } function w(t, e) { const n = (0, m.p3)((0, m.gx)(t, "crypto/ciphertext")); if ((0, l.hexlify)((0, u.keccak256)((0, l.concat)([e.slice(16, 32), n]))).substring(2) !== (0, m.gx)(t, "crypto/mac").toLowerCase()) throw new Error("invalid password"); const r = function (t, e, n) { if ("aes-128-ctr" === (0, m.gx)(t, "crypto/cipher")) { const r = (0, m.p3)((0, m.gx)(t, "crypto/cipherparams/iv")), s = new (i().Counter)(r), o = new (i().ModeOfOperation.ctr)(e, s); return (0, l.arrayify)(o.decrypt(n)) } return null }(t, e.slice(0, 16), n); r || y.throwError("unsupported cipher", g.Logger.errors.UNSUPPORTED_OPERATION, { operation: "decrypt" }); const s = e.slice(32, 64), o = (0, f.computeAddress)(r); if (t.address) { let e = t.address.toLowerCase(); if ("0x" !== e.substring(0, 2) && (e = "0x" + e), (0, a.getAddress)(e) !== o) throw new Error("address mismatch") } const h = { _isKeystoreAccount: !0, address: o, privateKey: (0, l.hexlify)(r) }; if ("0.1" === (0, m.gx)(t, "x-ethers/version")) { const e = (0, m.p3)((0, m.gx)(t, "x-ethers/mnemonicCiphertext")), n = (0, m.p3)((0, m.gx)(t, "x-ethers/mnemonicCounter")), r = new (i().Counter)(n), o = new (i().ModeOfOperation.ctr)(s, r), a = (0, m.gx)(t, "x-ethers/path") || c.defaultPath, u = (0, m.gx)(t, "x-ethers/locale") || "en", p = (0, l.arrayify)(o.decrypt(e)); try { const t = (0, c.entropyToMnemonic)(p, u), e = c.HDNode.fromMnemonic(t, null, u).derivePath(a); if (e.privateKey != h.privateKey) throw new Error("mnemonic mismatch"); h.mnemonic = e.mnemonic } catch (d) { if (d.code !== g.Logger.errors.INVALID_ARGUMENT || "wordlist" !== d.argument) throw d } } return new _(h) } function S(t, e, n, r, i) { return (0, l.arrayify)((0, h.n)(t, e, n, r, i)) } function x(t, e, n, r, i) { return Promise.resolve(S(t, e, n, r, i)) } function T(t, e, n, r, i) { const s = (0, m.Ij)(e), o = (0, m.gx)(t, "crypto/kdf"); if (o && "string" == typeof o) { const e = function (t, e) { return y.throwArgumentError("invalid key-derivation function parameters", t, e) }; if ("scrypt" === o.toLowerCase()) { const n = (0, m.p3)((0, m.gx)(t, "crypto/kdfparams/salt")), a = parseInt((0, m.gx)(t, "crypto/kdfparams/n")), l = parseInt((0, m.gx)(t, "crypto/kdfparams/r")), c = parseInt((0, m.gx)(t, "crypto/kdfparams/p")); a && l && c || e("kdf", o), 0 != (a & a - 1) && e("N", a); const u = parseInt((0, m.gx)(t, "crypto/kdfparams/dklen")); return 32 !== u && e("dklen", u), r(s, n, a, l, c, 64, i) } if ("pbkdf2" === o.toLowerCase()) { const r = (0, m.p3)((0, m.gx)(t, "crypto/kdfparams/salt")); let i = null; const o = (0, m.gx)(t, "crypto/kdfparams/prf"); "hmac-sha256" === o ? i = "sha256" : "hmac-sha512" === o ? i = "sha512" : e("prf", o); const a = parseInt((0, m.gx)(t, "crypto/kdfparams/c")), l = parseInt((0, m.gx)(t, "crypto/kdfparams/dklen")); return 32 !== l && e("dklen", l), n(s, r, a, l, i) } } return y.throwArgumentError("unsupported key-derivation function", "kdf", o) } function E(t, e) { const n = JSON.parse(t); return w(n, T(n, e, S, o().syncScrypt)) } function M(t, e, n) { return r = this, void 0, s = function* () { const r = JSON.parse(t); return w(r, yield T(r, e, x, o().scrypt, n)) }, new ((i = void 0) || (i = Promise))(function (t, e) { function n(t) { try { a(s.next(t)) } catch (n) { e(n) } } function o(t) { try { a(s.throw(t)) } catch (n) { e(n) } } function a(e) { var r; e.done ? t(e.value) : (r = e.value, r instanceof i ? r : new i(function (t) { t(r) })).then(n, o) } a((s = s.apply(r, [])).next()) }); var r, i, s } function A(t, e, n, r) { try { if ((0, a.getAddress)(t.address) !== (0, f.computeAddress)(t.privateKey)) throw new Error("address/privateKey mismatch"); if (b(t)) { const e = t.mnemonic; if (c.HDNode.fromMnemonic(e.phrase, null, e.locale).derivePath(e.path || c.defaultPath).privateKey != t.privateKey) throw new Error("mnemonic mismatch") } } catch (M) { return Promise.reject(M) } "function" != typeof n || r || (r = n, n = {}), n || (n = {}); const s = (0, l.arrayify)(t.privateKey), h = (0, m.Ij)(e); let p = null, g = null, v = null; if (b(t)) { const e = t.mnemonic; p = (0, l.arrayify)((0, c.mnemonicToEntropy)(e.phrase, e.locale || "en")), g = e.path || c.defaultPath, v = e.locale || "en" } let y = n.client; y || (y = "ethers.js"); let _ = null; _ = n.salt ? (0, l.arrayify)(n.salt) : (0, d.O)(32); let w = null; if (n.iv) { if (w = (0, l.arrayify)(n.iv), 16 !== w.length) throw new Error("invalid iv") } else w = (0, d.O)(16); let S = null; if (n.uuid) { if (S = (0, l.arrayify)(n.uuid), 16 !== S.length) throw new Error("invalid uuid") } else S = (0, d.O)(16); let x = 1 << 17, T = 8, E = 1; return n.scrypt && (n.scrypt.N && (x = n.scrypt.N), n.scrypt.r && (T = n.scrypt.r), n.scrypt.p && (E = n.scrypt.p)), o().scrypt(h, _, x, T, E, 64, r).then(e => { const n = (e = (0, l.arrayify)(e)).slice(0, 16), r = e.slice(16, 32), o = e.slice(32, 64), a = new (i().Counter)(w), c = new (i().ModeOfOperation.ctr)(n, a), h = (0, l.arrayify)(c.encrypt(s)), f = (0, u.keccak256)((0, l.concat)([r, h])), b = { address: t.address.substring(2).toLowerCase(), id: (0, m.EH)(S), version: 3, Crypto: { cipher: "aes-128-ctr", cipherparams: { iv: (0, l.hexlify)(w).substring(2) }, ciphertext: (0, l.hexlify)(h).substring(2), kdf: "scrypt", kdfparams: { salt: (0, l.hexlify)(_).substring(2), n: x, dklen: 32, p: E, r: T }, mac: f.substring(2) } }; if (p) { const t = (0, d.O)(16), e = new (i().Counter)(t), n = new (i().ModeOfOperation.ctr)(o, e), r = (0, l.arrayify)(n.encrypt(p)), s = new Date, a = s.getUTCFullYear() + "-" + (0, m.VP)(s.getUTCMonth() + 1, 2) + "-" + (0, m.VP)(s.getUTCDate(), 2) + "T" + (0, m.VP)(s.getUTCHours(), 2) + "-" + (0, m.VP)(s.getUTCMinutes(), 2) + "-" + (0, m.VP)(s.getUTCSeconds(), 2) + ".0Z"; b["x-ethers"] = { client: y, gethFilename: "UTC--" + a + "--" + b.address, mnemonicCounter: (0, l.hexlify)(t).substring(2), mnemonicCiphertext: (0, l.hexlify)(r).substring(2), path: g, locale: v, version: "0.1" } } return JSON.stringify(b) }) } }, 3137: (t, e, n) => { "use strict"; n.d(e, { p3: () => s, VP: () => o, Ij: () => a, gx: () => l, EH: () => c }); var r = n(1488), i = n(8822); function s(t) { return "string" == typeof t && "0x" !== t.substring(0, 2) && (t = "0x" + t), (0, r.arrayify)(t) } function o(t, e) { for (t = String(t); t.length < e;)t = "0" + t; return t } function a(t) { return "string" == typeof t ? (0, i.Y0)(t, i.Uj.NFKC) : (0, r.arrayify)(t) } function l(t, e) { let n = t; const r = e.toLowerCase().split("/"); for (let i = 0; i < r.length; i++) { let t = null; for (const e in n) if (e.toLowerCase() === r[i]) { t = n[e]; break } if (null === t) return null; n = t } return n } function c(t) { const e = (0, r.arrayify)(t); e[6] = 15 & e[6] | 64, e[8] = 63 & e[8] | 128; const n = (0, r.hexlify)(e); return [n.substring(2, 10), n.substring(10, 14), n.substring(14, 18), n.substring(18, 22), n.substring(22, 34)].join("-") } }, 8518: (t, e, n) => { "use strict"; n.r(e), n.d(e, { keccak256: () => o }); var r = n(7109), i = n.n(r), s = n(1488); function o(t) { return "0x" + i().keccak_256((0, s.arrayify)(t)) } }, 3898: (t, e, n) => { "use strict"; n.r(e), n.d(e, { ErrorCode: () => u, LogLevel: () => c, Logger: () => h }); let r = !1, i = !1; const s = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 }; let o = s.default, a = null; const l = function () { try { const t = []; if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => { try { if ("test" !== "test".normalize(e)) throw new Error("bad normalize") } catch (n) { t.push(e) } }), t.length) throw new Error("missing " + t.join(", ")); if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation") } catch (t) { return t.message } return null }(); var c = (() => (function (t) { t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF" }(c || (c = {})), c))(), u = (() => (function (t) { t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT" }(u || (u = {})), u))(); let h = (() => { class t { constructor(t) { Object.defineProperty(this, "version", { enumerable: !0, value: t, writable: !1 }) } _log(t, e) { const n = t.toLowerCase(); null == s[n] && this.throwArgumentError("invalid log level name", "logLevel", t), o > s[n] || console.log.apply(console, e) } debug(...e) { this._log(t.levels.DEBUG, e) } info(...e) { this._log(t.levels.INFO, e) } warn(...e) { this._log(t.levels.WARNING, e) } makeError(e, n, r) { if (i) return this.makeError("censored error", n, {}); n || (n = t.errors.UNKNOWN_ERROR), r || (r = {}); const s = []; Object.keys(r).forEach(t => { try { s.push(t + "=" + JSON.stringify(r[t])) } catch (a) { s.push(t + "=" + JSON.stringify(r[t].toString())) } }), s.push(`code=${n}`), s.push(`version=${this.version}`); const o = e; s.length && (e += " (" + s.join(", ") + ")"); const a = new Error(e); return a.reason = o, a.code = n, Object.keys(r).forEach(function (t) { a[t] = r[t] }), a } throwError(t, e, n) { throw this.makeError(t, e, n) } throwArgumentError(e, n, r) { return this.throwError(e, t.errors.INVALID_ARGUMENT, { argument: n, value: r }) } assert(t, e, n, r) { t || this.throwError(e, n, r) } assertArgument(t, e, n, r) { t || this.throwArgumentError(e, n, r) } checkNormalize(e) { null == e && (e = "platform missing String.prototype.normalize"), l && this.throwError("platform missing String.prototype.normalize", t.errors.UNSUPPORTED_OPERATION, { operation: "String.prototype.normalize", form: l }) } checkSafeUint53(e, n) { "number" == typeof e && (null == n && (n = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(n, t.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "out-of-safe-range", value: e }), e % 1 && this.throwError(n, t.errors.NUMERIC_FAULT, { operation: "checkSafeInteger", fault: "non-integer", value: e })) } checkArgumentCount(e, n, r) { r = r ? ": " + r : "", e < n && this.throwError("missing argument" + r, t.errors.MISSING_ARGUMENT, { count: e, expectedCount: n }), e > n && this.throwError("too many arguments" + r, t.errors.UNEXPECTED_ARGUMENT, { count: e, expectedCount: n }) } checkNew(e, n) { e !== Object && null != e || this.throwError("missing new", t.errors.MISSING_NEW, { name: n.name }) } checkAbstract(e, n) { e === n ? this.throwError("cannot instantiate abstract class " + JSON.stringify(n.name) + " directly; use a sub-class", t.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : e !== Object && null != e || this.throwError("missing new", t.errors.MISSING_NEW, { name: n.name }) } static globalLogger() { return a || (a = new t("logger/5.1.0")), a } static setCensorship(e, n) { if (!e && n && this.globalLogger().throwError("cannot permanently disable censorship", t.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" }), r) { if (!e) return; this.globalLogger().throwError("error censorship permanent", t.errors.UNSUPPORTED_OPERATION, { operation: "setCensorship" }) } i = !!e, r = !!n } static setLogLevel(e) { const n = s[e.toLowerCase()]; null != n ? o = n : t.globalLogger().warn("invalid log level - " + e) } static from(e) { return new t(e) } } return t.errors = u, t.levels = c, t })() }, 5473: (t, e, n) => { "use strict"; n.d(e, { H: () => u }); const r = new (n(3898).Logger)("networks/5.1.0"); function i(t) { const e = function (e, n) { null == n && (n = {}); const r = []; if (e.InfuraProvider) try { r.push(new e.InfuraProvider(t, n.infura)) } catch (i) { } if (e.EtherscanProvider) try { r.push(new e.EtherscanProvider(t, n.etherscan)) } catch (i) { } if (e.AlchemyProvider) { const s = ["goerli", "ropsten", "rinkeby"]; try { const i = new e.AlchemyProvider(t, n.alchemy); i.network && -1 === s.indexOf(i.network.name) && r.push(i) } catch (i) { } } if (e.PocketProvider) { const n = ["goerli", "ropsten", "rinkeby"]; try { const i = new e.PocketProvider(t); i.network && -1 === n.indexOf(i.network.name) && r.push(i) } catch (i) { } } if (e.CloudflareProvider) try { r.push(new e.CloudflareProvider(t)) } catch (i) { } if (0 === r.length) return null; if (e.FallbackProvider) { let i = 1; return null != n.quorum ? i = n.quorum : "homestead" === t && (i = 2), new e.FallbackProvider(r, i) } return r[0] }; return e.renetwork = function (t) { return i(t) }, e } function s(t, e) { const n = function (n, r) { return n.JsonRpcProvider ? new n.JsonRpcProvider(t, e) : null }; return n.renetwork = function (e) { return s(t, e) }, n } const o = { chainId: 1, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "homestead", _defaultProvider: i("homestead") }, a = { chainId: 3, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "ropsten", _defaultProvider: i("ropsten") }, l = { chainId: 63, name: "classicMordor", _defaultProvider: s("https://www.ethercluster.com/mordor", "classicMordor") }, c = { unspecified: { chainId: 0, name: "unspecified" }, homestead: o, mainnet: o, morden: { chainId: 2, name: "morden" }, ropsten: a, testnet: a, rinkeby: { chainId: 4, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "rinkeby", _defaultProvider: i("rinkeby") }, kovan: { chainId: 42, name: "kovan", _defaultProvider: i("kovan") }, goerli: { chainId: 5, ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e", name: "goerli", _defaultProvider: i("goerli") }, classic: { chainId: 61, name: "classic", _defaultProvider: s("https://www.ethercluster.com/etc", "classic") }, classicMorden: { chainId: 62, name: "classicMorden" }, classicMordor: l, classicTestnet: l, classicKotti: { chainId: 6, name: "classicKotti", _defaultProvider: s("https://www.ethercluster.com/kotti", "classicKotti") } }; function u(t) { if (null == t) return null; if ("number" == typeof t) { for (const e in c) { const n = c[e]; if (n.chainId === t) return { name: n.name, chainId: n.chainId, ensAddress: n.ensAddress || null, _defaultProvider: n._defaultProvider || null } } return { chainId: t, name: "unknown" } } if ("string" == typeof t) { const e = c[t]; return null == e ? null : { name: e.name, chainId: e.chainId, ensAddress: e.ensAddress, _defaultProvider: e._defaultProvider || null } } const e = c[t.name]; if (!e) return "number" != typeof t.chainId && r.throwArgumentError("invalid network chainId", "network", t), t; 0 !== t.chainId && t.chainId !== e.chainId && r.throwArgumentError("network chainId mismatch", "network", t); let n = t._defaultProvider || null; var i; return null == n && e._defaultProvider && (n = (i = e._defaultProvider) && "function" == typeof i.renetwork ? e._defaultProvider.renetwork(t) : e._defaultProvider), { name: t.name, chainId: e.chainId, ensAddress: t.ensAddress || e.ensAddress || null, _defaultProvider: n } } }, 9938: (t, e, n) => { "use strict"; n.d(e, { n: () => s }); var r = n(1488), i = n(5614); function s(t, e, n, s, o) { let a; t = (0, r.arrayify)(t), e = (0, r.arrayify)(e); let l = 1; const c = new Uint8Array(s), u = new Uint8Array(e.length + 4); let h, d; u.set(e); for (let p = 1; p <= l; p++) { u[e.length] = p >> 24 & 255, u[e.length + 1] = p >> 16 & 255, u[e.length + 2] = p >> 8 & 255, u[e.length + 3] = 255 & p; let f = (0, r.arrayify)((0, i.Gy)(o, t, u)); a || (a = f.length, d = new Uint8Array(a), l = Math.ceil(s / a), h = s - (l - 1) * a), d.set(f); for (let e = 1; e < n; e++) { f = (0, r.arrayify)((0, i.Gy)(o, t, f)); for (let t = 0; t < a; t++)d[t] ^= f[t] } const m = (p - 1) * a, g = p === l ? h : a; c.set((0, r.arrayify)(d).slice(0, g), m) } return (0, r.hexlify)(c) } }, 2275: (t, e, n) => { "use strict"; n.r(e), n.d(e, { Description: () => p, checkProperties: () => a, deepCopy: () => d, defineReadOnly: () => i, getStatic: () => s, resolveProperties: () => o, shallowCopy: () => l }); const r = new (n(3898).Logger)("properties/5.1.0"); function i(t, e, n) { Object.defineProperty(t, e, { enumerable: !0, value: n, writable: !1 }) } function s(t, e) { for (let n = 0; n < 32; n++) { if (t[e]) return t[e]; if (!t.prototype || "object" != typeof t.prototype) break; t = Object.getPrototypeOf(t.prototype).constructor } return null } function o(t) { return e = this, void 0, r = function* () { const e = Object.keys(t).map(e => Promise.resolve(t[e]).then(t => ({ key: e, value: t }))); return (yield Promise.all(e)).reduce((t, e) => (t[e.key] = e.value, t), {}) }, new ((n = void 0) || (n = Promise))(function (t, i) { function s(t) { try { a(r.next(t)) } catch (e) { i(e) } } function o(t) { try { a(r.throw(t)) } catch (e) { i(e) } } function a(e) { var r; e.done ? t(e.value) : (r = e.value, r instanceof n ? r : new n(function (t) { t(r) })).then(s, o) } a((r = r.apply(e, [])).next()) }); var e, n, r } function a(t, e) { t && "object" == typeof t || r.throwArgumentError("invalid object", "object", t), Object.keys(t).forEach(n => { e[n] || r.throwArgumentError("invalid object key - " + n, "transaction:" + n, t) }) } function l(t) { const e = {}; for (const n in t) e[n] = t[n]; return e } const c = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 }; function u(t) { if (null == t || c[typeof t]) return !0; if (Array.isArray(t) || "object" == typeof t) { if (!Object.isFrozen(t)) return !1; const e = Object.keys(t); for (let n = 0; n < e.length; n++)if (!u(t[e[n]])) return !1; return !0 } return r.throwArgumentError("Cannot deepCopy " + typeof t, "object", t) } function h(t) { if (u(t)) return t; if (Array.isArray(t)) return Object.freeze(t.map(t => d(t))); if ("object" == typeof t) { const e = {}; for (const n in t) { const r = t[n]; void 0 !== r && i(e, n, d(r)) } return e } return r.throwArgumentError("Cannot deepCopy " + typeof t, "object", t) } function d(t) { return h(t) } class p { constructor(t) { for (const e in t) this[e] = d(t[e]) } } }, 5102: (t, e, n) => { "use strict"; n.d(e, { i: () => r }); const r = "providers/5.1.2" }, 2645: (t, e, n) => { "use strict"; n.d(e, { H2: () => R, Zk: () => D }); var r = n(1527), i = n(3744), s = n(2024), o = n(1488), a = n(5052), l = n(7975), c = n(5473), u = n(2275), h = n(5614), d = n(8822), p = n(3511), f = n(9901), m = n.n(f), g = n(3898), v = n(5102), y = n(7949), b = function (t, e, n, r) { return new (n || (n = Promise))(function (i, s) { function o(t) { try { l(r.next(t)) } catch (e) { s(e) } } function a(t) { try { l(r.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } l((r = r.apply(t, e || [])).next()) }) }; const _ = new g.Logger(v.i); function w(t) { return null == t ? "null" : (32 !== (0, o.hexDataLength)(t) && _.throwArgumentError("invalid topic", "topic", t), t.toLowerCase()) } function S(t) { for (t = t.slice(); t.length > 0 && null == t[t.length - 1];)t.pop(); return t.map(t => { if (Array.isArray(t)) { const e = {}; t.forEach(t => { e[w(t)] = !0 }); const n = Object.keys(e); return n.sort(), n.join("|") } return w(t) }).join("&") } function x(t) { if ("string" == typeof t) { if (t = t.toLowerCase(), 32 === (0, o.hexDataLength)(t)) return "tx:" + t; if (-1 === t.indexOf(":")) return t } else { if (Array.isArray(t)) return "filter:*:" + S(t); if (r.Sg.isForkEvent(t)) throw _.warn("not implemented"), new Error("not implemented"); if (t && "object" == typeof t) return "filter:" + (t.address || "*") + ":" + S(t.topics || []) } throw new Error("invalid event - " + t) } function T() { return (new Date).getTime() } const E = ["block", "network", "pending", "poll"]; class M { constructor(t, e, n) { (0, u.defineReadOnly)(this, "tag", t), (0, u.defineReadOnly)(this, "listener", e), (0, u.defineReadOnly)(this, "once", n) } get event() { switch (this.type) { case "tx": return this.hash; case "filter": return this.filter }return this.tag } get type() { return this.tag.split(":")[0] } get hash() { const t = this.tag.split(":"); return "tx" !== t[0] ? null : t[1] } get filter() { const t = this.tag.split(":"); if ("filter" !== t[0]) return null; const e = t[1], n = "" === (r = t[2]) ? [] : r.split(/&/g).map(t => { if ("" === t) return []; const e = t.split("|").map(t => "null" === t ? null : t); return 1 === e.length ? e[0] : e }); var r; const i = {}; return n.length > 0 && (i.topics = n), e && "*" !== e && (i.address = e), i } pollable() { return this.tag.indexOf(":") >= 0 || E.indexOf(this.tag) >= 0 } } const A = { 0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" }, 2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" }, 3: { symbol: "doge", p2pkh: 30, p2sh: 22 }, 60: { symbol: "eth", ilk: "eth" }, 61: { symbol: "etc", ilk: "eth" }, 700: { symbol: "xdai", ilk: "eth" } }; function C(t) { return (0, o.hexZeroPad)(s.O$.from(t).toHexString(), 32) } function P(t) { return i.Base58.encode((0, o.concat)([t, (0, o.hexDataSlice)((0, h.JQ)((0, h.JQ)(t)), 0, 4)])) } class R { constructor(t, e, n) { (0, u.defineReadOnly)(this, "provider", t), (0, u.defineReadOnly)(this, "name", n), (0, u.defineReadOnly)(this, "address", t.formatter.address(e)) } _fetchBytes(t, e) { return b(this, void 0, void 0, function* () { const n = { to: this.address, data: (0, o.hexConcat)([t, (0, l.V)(this.name), e || "0x"]) }, r = yield this.provider.call(n); if ("0x" === r) return null; const i = s.O$.from((0, o.hexDataSlice)(r, 0, 32)).toNumber(), a = s.O$.from((0, o.hexDataSlice)(r, i, i + 32)).toNumber(); return (0, o.hexDataSlice)(r, i + 32, i + 32 + a) }) } _getAddress(t, e) { const n = A[String(t)]; if (null == n && _.throwError(`unsupported coin type: ${t}`, g.Logger.errors.UNSUPPORTED_OPERATION, { operation: `getAddress(${t})` }), "eth" === n.ilk) return this.provider.formatter.address(e); const r = (0, o.arrayify)(e); if (null != n.p2pkh) { const t = e.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/); if (t) { const e = parseInt(t[1], 16); if (t[2].length === 2 * e && e >= 1 && e <= 75) return P((0, o.concat)([[n.p2pkh], "0x" + t[2]])) } } if (null != n.p2sh) { const t = e.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/); if (t) { const e = parseInt(t[1], 16); if (t[2].length === 2 * e && e >= 1 && e <= 75) return P((0, o.concat)([[n.p2sh], "0x" + t[2]])) } } if (null != n.prefix) { const t = r[1]; let e = r[0]; if (0 === e ? 20 !== t && 32 !== t && (e = -1) : e = -1, e >= 0 && r.length === 2 + t && t >= 1 && t <= 75) { const t = m().toWords(r.slice(2)); return t.unshift(e), m().encode(n.prefix, t) } } return null } getAddress(t) { return b(this, void 0, void 0, function* () { if (null == t && (t = 60), 60 === t) { const t = { to: this.address, data: "0x3b3b57de" + (0, l.V)(this.name).substring(2) }, e = yield this.provider.call(t); return "0x" === e || e === a.R ? null : this.provider.formatter.callAddress(e) } const e = yield this._fetchBytes("0xf1cb7e06", C(t)); if (null == e || "0x" === e) return null; const n = this._getAddress(t, e); return null == n && _.throwError("invalid or unsupported coin data", g.Logger.errors.UNSUPPORTED_OPERATION, { operation: `getAddress(${t})`, coinType: t, data: e }), n }) } getContentHash() { return b(this, void 0, void 0, function* () { const t = yield this._fetchBytes("0xbc1c58d1"); if (null == t || "0x" === t) return null; const e = t.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/); if (e) { const t = parseInt(e[3], 16); if (e[4].length === 2 * t) return "ipfs://" + i.Base58.encode("0x" + e[1]) } const n = t.match(/^0xe40101fa011b20([0-9a-f]*)$/); return n && 64 === n[1].length ? "bzz://" + n[1] : _.throwError("invalid or unsupported content hash data", g.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getContentHash()", data: t }) }) } getText(t) { return b(this, void 0, void 0, function* () { let e = (0, d.Y0)(t); e = (0, o.concat)([C(64), C(e.length), e]), e.length % 32 != 0 && (e = (0, o.concat)([e, (0, o.hexZeroPad)("0x", 32 - t.length % 32)])); const n = yield this._fetchBytes("0x59d1d43c", (0, o.hexlify)(e)); return null == n || "0x" === n ? null : (0, d.ZN)(n) }) } } let L = null, k = 1; class D extends r.zt { constructor(t) { if (_.checkNew(new.target, r.zt), super(), this._events = [], this._emitted = { block: -2 }, this.formatter = new.target.getFormatter(), (0, u.defineReadOnly)(this, "anyNetwork", "any" === t), this.anyNetwork && (t = this.detectNetwork()), t instanceof Promise) this._networkPromise = t, t.catch(t => { }), this._ready().catch(t => { }); else { const e = (0, u.getStatic)(new.target, "getNetwork")(t); e ? ((0, u.defineReadOnly)(this, "_network", e), this.emit("network", e, null)) : _.throwArgumentError("invalid network", "network", t) } this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._pollingInterval = 4e3, this._fastQueryDate = 0 } _ready() { return b(this, void 0, void 0, function* () { if (null == this._network) { let e = null; if (this._networkPromise) try { e = yield this._networkPromise } catch (t) { } null == e && (e = yield this.detectNetwork()), e || _.throwError("no network detected", g.Logger.errors.UNKNOWN_ERROR, {}), null == this._network && (this.anyNetwork ? this._network = e : (0, u.defineReadOnly)(this, "_network", e), this.emit("network", e, null)) } return this._network }) } get ready() { return (0, p.poll)(() => this._ready().then(t => t, t => { if (t.code !== g.Logger.errors.NETWORK_ERROR || "noNetwork" !== t.event) throw t })) } static getFormatter() { return null == L && (L = new y.Mb), L } static getNetwork(t) { return (0, c.H)(null == t ? "homestead" : t) } _getInternalBlockNumber(t) { return b(this, void 0, void 0, function* () { if (yield this._ready(), t > 0) for (; this._internalBlockNumber;) { const e = this._internalBlockNumber; try { const n = yield e; if (T() - n.respTime <= t) return n.blockNumber; break } catch (r) { if (this._internalBlockNumber === e) break } } const e = T(), n = (0, u.resolveProperties)({ blockNumber: this.perform("getBlockNumber", {}), networkError: this.getNetwork().then(t => null, t => t) }).then(({ blockNumber: t, networkError: r }) => { if (r) throw this._internalBlockNumber === n && (this._internalBlockNumber = null), r; const i = T(); return (t = s.O$.from(t).toNumber()) < this._maxInternalBlockNumber && (t = this._maxInternalBlockNumber), this._maxInternalBlockNumber = t, this._setFastBlockNumber(t), { blockNumber: t, reqTime: e, respTime: i } }); return this._internalBlockNumber = n, n.catch(t => { this._internalBlockNumber === n && (this._internalBlockNumber = null) }), (yield n).blockNumber }) } poll() { return b(this, void 0, void 0, function* () { const t = k++, e = []; let n = null; try { n = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2) } catch (r) { return void this.emit("error", r) } if (this._setFastBlockNumber(n), this.emit("poll", t, n), n !== this._lastBlockNumber) { if (-2 === this._emitted.block && (this._emitted.block = n - 1), Math.abs(this._emitted.block - n) > 1e3) _.warn("network block skew detected; skipping block events"), this.emit("error", _.makeError("network block skew detected", g.Logger.errors.NETWORK_ERROR, { blockNumber: n, event: "blockSkew", previousBlockNumber: this._emitted.block })), this.emit("block", n); else for (let t = this._emitted.block + 1; t <= n; t++)this.emit("block", t); this._emitted.block !== n && (this._emitted.block = n, Object.keys(this._emitted).forEach(t => { if ("block" === t) return; const e = this._emitted[t]; "pending" !== e && n - e > 12 && delete this._emitted[t] })), -2 === this._lastBlockNumber && (this._lastBlockNumber = n - 1), this._events.forEach(t => { switch (t.type) { case "tx": { const n = t.hash; let r = this.getTransactionReceipt(n).then(t => t && null != t.blockNumber ? (this._emitted["t:" + n] = t.blockNumber, this.emit(n, t), null) : null).catch(t => { this.emit("error", t) }); e.push(r); break } case "filter": { const r = t.filter; r.fromBlock = this._lastBlockNumber + 1, r.toBlock = n; const i = this.getLogs(r).then(t => { 0 !== t.length && t.forEach(t => { this._emitted["b:" + t.blockHash] = t.blockNumber, this._emitted["t:" + t.transactionHash] = t.blockNumber, this.emit(r, t) }) }).catch(t => { this.emit("error", t) }); e.push(i); break } } }), this._lastBlockNumber = n, Promise.all(e).then(() => { this.emit("didPoll", t) }).catch(t => { this.emit("error", t) }) } else this.emit("didPoll", t) }) } resetEventsBlock(t) { this._lastBlockNumber = t - 1, this.polling && this.poll() } get network() { return this._network } detectNetwork() { return b(this, void 0, void 0, function* () { return _.throwError("provider does not support network detection", g.Logger.errors.UNSUPPORTED_OPERATION, { operation: "provider.detectNetwork" }) }) } getNetwork() { return b(this, void 0, void 0, function* () { const t = yield this._ready(), e = yield this.detectNetwork(); if (t.chainId !== e.chainId) { if (this.anyNetwork) return this._network = e, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", e, t), yield new Promise(t => { setTimeout(t, 0) }), this._network; const n = _.makeError("underlying network changed", g.Logger.errors.NETWORK_ERROR, { event: "changed", network: t, detectedNetwork: e }); throw this.emit("error", n), n } return t }) } get blockNumber() { return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(t => { this._setFastBlockNumber(t) }, t => { }), null != this._fastBlockNumber ? this._fastBlockNumber : -1 } get polling() { return null != this._poller } set polling(t) { t && !this._poller ? (this._poller = setInterval(() => { this.poll() }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => { this.poll(), this._bootstrapPoll = setTimeout(() => { this._poller || this.poll(), this._bootstrapPoll = null }, this.pollingInterval) }, 0))) : !t && this._poller && (clearInterval(this._poller), this._poller = null) } get pollingInterval() { return this._pollingInterval } set pollingInterval(t) { if ("number" != typeof t || t <= 0 || parseInt(String(t)) != t) throw new Error("invalid polling interval"); this._pollingInterval = t, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => { this.poll() }, this._pollingInterval)) } _getFastBlockNumber() { const t = T(); return t - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = t, this._fastBlockNumberPromise = this.getBlockNumber().then(t => ((null == this._fastBlockNumber || t > this._fastBlockNumber) && (this._fastBlockNumber = t), this._fastBlockNumber))), this._fastBlockNumberPromise } _setFastBlockNumber(t) { null != this._fastBlockNumber && t < this._fastBlockNumber || (this._fastQueryDate = T(), (null == this._fastBlockNumber || t > this._fastBlockNumber) && (this._fastBlockNumber = t, this._fastBlockNumberPromise = Promise.resolve(t))) } waitForTransaction(t, e, n) { return b(this, void 0, void 0, function* () { null == e && (e = 1); const r = yield this.getTransactionReceipt(t); return (r ? r.confirmations : 0) >= e ? r : new Promise((r, i) => { let s = null, o = !1; const a = n => { n.confirmations < e || (s && clearTimeout(s), o || (o = !0, this.removeListener(t, a), r(n))) }; this.on(t, a), "number" == typeof n && n > 0 && (s = setTimeout(() => { o || (s = null, o = !0, this.removeListener(t, a), i(_.makeError("timeout exceeded", g.Logger.errors.TIMEOUT, { timeout: n }))) }, n), s.unref && s.unref()) }) }) } getBlockNumber() { return b(this, void 0, void 0, function* () { return this._getInternalBlockNumber(0) }) } getGasPrice() { return b(this, void 0, void 0, function* () { yield this.getNetwork(); const t = yield this.perform("getGasPrice", {}); try { return s.O$.from(t) } catch (e) { return _.throwError("bad result from backend", g.Logger.errors.SERVER_ERROR, { method: "getGasPrice", result: t, error: e }) } }) } getBalance(t, e) { return b(this, void 0, void 0, function* () { yield this.getNetwork(); const n = yield (0, u.resolveProperties)({ address: this._getAddress(t), blockTag: this._getBlockTag(e) }), r = yield this.perform("getBalance", n); try { return s.O$.from(r) } catch (i) { return _.throwError("bad result from backend", g.Logger.errors.SERVER_ERROR, { method: "getBalance", params: n, result: r, error: i }) } }) } getTransactionCount(t, e) { return b(this, void 0, void 0, function* () { yield this.getNetwork(); const n = yield (0, u.resolveProperties)({ address: this._getAddress(t), blockTag: this._getBlockTag(e) }), r = yield this.perform("getTransactionCount", n); try { return s.O$.from(r).toNumber() } catch (i) { return _.throwError("bad result from backend", g.Logger.errors.SERVER_ERROR, { method: "getTransactionCount", params: n, result: r, error: i }) } }) } getCode(t, e) { return b(this, void 0, void 0, function* () { yield this.getNetwork(); const n = yield (0, u.resolveProperties)({ address: this._getAddress(t), blockTag: this._getBlockTag(e) }), r = yield this.perform("getCode", n); try { return (0, o.hexlify)(r) } catch (i) { return _.throwError("bad result from backend", g.Logger.errors.SERVER_ERROR, { method: "getCode", params: n, result: r, error: i }) } }) } getStorageAt(t, e, n) { return b(this, void 0, void 0, function* () { yield this.getNetwork(); const r = yield (0, u.resolveProperties)({ address: this._getAddress(t), blockTag: this._getBlockTag(n), position: Promise.resolve(e).then(t => (0, o.hexValue)(t)) }), i = yield this.perform("getStorageAt", r); try { return (0, o.hexlify)(i) } catch (s) { return _.throwError("bad result from backend", g.Logger.errors.SERVER_ERROR, { method: "getStorageAt", params: r, result: i, error: s }) } }) } _wrapTransaction(t, e) { if (null != e && 32 !== (0, o.hexDataLength)(e)) throw new Error("invalid response - sendTransaction"); const n = t; return null != e && t.hash !== e && _.throwError("Transaction hash mismatch from Provider.sendTransaction.", g.Logger.errors.UNKNOWN_ERROR, { expectedHash: t.hash, returnedHash: e }), n.wait = e => b(this, void 0, void 0, function* () { 0 !== e && (this._emitted["t:" + t.hash] = "pending"); const n = yield this.waitForTransaction(t.hash, e); return null == n && 0 === e ? null : (this._emitted["t:" + t.hash] = n.blockNumber, 0 === n.status && _.throwError("transaction failed", g.Logger.errors.CALL_EXCEPTION, { transactionHash: t.hash, transaction: t, receipt: n }), n) }), n } sendTransaction(t) { return b(this, void 0, void 0, function* () { yield this.getNetwork(); const e = yield Promise.resolve(t).then(t => (0, o.hexlify)(t)), n = this.formatter.transaction(t); try { const t = yield this.perform("sendTransaction", { signedTransaction: e }); return this._wrapTransaction(n, t) } catch (r) { throw r.transaction = n, r.transactionHash = n.hash, r } }) } _getTransactionRequest(t) { return b(this, void 0, void 0, function* () { const e = yield t, n = {}; return ["from", "to"].forEach(t => { null != e[t] && (n[t] = Promise.resolve(e[t]).then(t => t ? this._getAddress(t) : null)) }), ["gasLimit", "gasPrice", "value"].forEach(t => { null != e[t] && (n[t] = Promise.resolve(e[t]).then(t => t ? s.O$.from(t) : null)) }), ["type"].forEach(t => { null != e[t] && (n[t] = Promise.resolve(e[t]).then(t => null != t ? t : null)) }), e.accessList && (n.accessList = this.formatter.accessList(e.accessList)), ["data"].forEach(t => { null != e[t] && (n[t] = Promise.resolve(e[t]).then(t => t ? (0, o.hexlify)(t) : null)) }), this.formatter.transactionRequest(yield (0, u.resolveProperties)(n)) }) } _getFilter(t) { return b(this, void 0, void 0, function* () { t = yield t; const e = {}; return null != t.address && (e.address = this._getAddress(t.address)), ["blockHash", "topics"].forEach(n => { null != t[n] && (e[n] = t[n]) }), ["fromBlock", "toBlock"].forEach(n => { null != t[n] && (e[n] = this._getBlockTag(t[n])) }), this.formatter.filter(yield (0, u.resolveProperties)(e)) }) } call(t, e) { return b(this, void 0, void 0, function* () { yield this.getNetwork(); const n = yield (0, u.resolveProperties)({ transaction: this._getTransactionRequest(t), blockTag: this._getBlockTag(e) }), r = yield this.perform("call", n); try { return (0, o.hexlify)(r) } catch (i) { return _.throwError("bad result from backend", g.Logger.errors.SERVER_ERROR, { method: "call", params: n, result: r, error: i }) } }) } estimateGas(t) { return b(this, void 0, void 0, function* () { yield this.getNetwork(); const e = yield (0, u.resolveProperties)({ transaction: this._getTransactionRequest(t) }), n = yield this.perform("estimateGas", e); try { return s.O$.from(n) } catch (r) { return _.throwError("bad result from backend", g.Logger.errors.SERVER_ERROR, { method: "estimateGas", params: e, result: n, error: r }) } }) } _getAddress(t) { return b(this, void 0, void 0, function* () { const e = yield this.resolveName(t); return null == e && _.throwError("ENS name not configured", g.Logger.errors.UNSUPPORTED_OPERATION, { operation: `resolveName(${JSON.stringify(t)})` }), e }) } _getBlock(t, e) { return b(this, void 0, void 0, function* () { yield this.getNetwork(), t = yield t; let n = -128; const r = { includeTransactions: !!e }; if ((0, o.isHexString)(t, 32)) r.blockHash = t; else try { r.blockTag = this.formatter.blockTag(yield this._getBlockTag(t)), (0, o.isHexString)(r.blockTag) && (n = parseInt(r.blockTag.substring(2), 16)) } catch (i) { _.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", t) } return (0, p.poll)(() => b(this, void 0, void 0, function* () { const t = yield this.perform("getBlock", r); if (null == t) return null != r.blockHash && null == this._emitted["b:" + r.blockHash] || null != r.blockTag && n > this._emitted.block ? null : void 0; if (e) { let e = null; for (let n = 0; n < t.transactions.length; n++) { const r = t.transactions[n]; if (null == r.blockNumber) r.confirmations = 0; else if (null == r.confirmations) { null == e && (e = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)); let t = e - r.blockNumber + 1; t <= 0 && (t = 1), r.confirmations = t } } return this.formatter.blockWithTransactions(t) } return this.formatter.block(t) }), { oncePoll: this }) }) } getBlock(t) { return this._getBlock(t, !1) } getBlockWithTransactions(t) { return this._getBlock(t, !0) } getTransaction(t) { return b(this, void 0, void 0, function* () { yield this.getNetwork(), t = yield t; const e = { transactionHash: this.formatter.hash(t, !0) }; return (0, p.poll)(() => b(this, void 0, void 0, function* () { const n = yield this.perform("getTransaction", e); if (null == n) return null == this._emitted["t:" + t] ? null : void 0; const r = this.formatter.transactionResponse(n); if (null == r.blockNumber) r.confirmations = 0; else if (null == r.confirmations) { let t = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - r.blockNumber + 1; t <= 0 && (t = 1), r.confirmations = t } return this._wrapTransaction(r) }), { oncePoll: this }) }) } getTransactionReceipt(t) { return b(this, void 0, void 0, function* () { yield this.getNetwork(), t = yield t; const e = { transactionHash: this.formatter.hash(t, !0) }; return (0, p.poll)(() => b(this, void 0, void 0, function* () { const n = yield this.perform("getTransactionReceipt", e); if (null == n) return null == this._emitted["t:" + t] ? null : void 0; if (null == n.blockHash) return; const r = this.formatter.receipt(n); if (null == r.blockNumber) r.confirmations = 0; else if (null == r.confirmations) { let t = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - r.blockNumber + 1; t <= 0 && (t = 1), r.confirmations = t } return r }), { oncePoll: this }) }) } getLogs(t) { return b(this, void 0, void 0, function* () { yield this.getNetwork(); const e = yield (0, u.resolveProperties)({ filter: this._getFilter(t) }), n = yield this.perform("getLogs", e); return n.forEach(t => { null == t.removed && (t.removed = !1) }), y.Mb.arrayOf(this.formatter.filterLog.bind(this.formatter))(n) }) } getEtherPrice() { return b(this, void 0, void 0, function* () { return yield this.getNetwork(), this.perform("getEtherPrice", {}) }) } _getBlockTag(t) { return b(this, void 0, void 0, function* () { if ("number" == typeof (t = yield t) && t < 0) { t % 1 && _.throwArgumentError("invalid BlockTag", "blockTag", t); let e = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval); return e += t, e < 0 && (e = 0), this.formatter.blockTag(e) } return this.formatter.blockTag(t) }) } getResolver(t) { return b(this, void 0, void 0, function* () { const e = yield this._getResolver(t); return null == e ? null : new R(this, e, t) }) } _getResolver(t) { return b(this, void 0, void 0, function* () { const e = yield this.getNetwork(); e.ensAddress || _.throwError("network does not support ENS", g.Logger.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: e.name }); const n = { to: e.ensAddress, data: "0x0178b8bf" + (0, l.V)(t).substring(2) }; return this.formatter.callAddress(yield this.call(n)) }) } resolveName(t) { return b(this, void 0, void 0, function* () { t = yield t; try { return Promise.resolve(this.formatter.address(t)) } catch (n) { if ((0, o.isHexString)(t)) throw n } "string" != typeof t && _.throwArgumentError("invalid ENS name", "name", t); const e = yield this.getResolver(t); return e ? yield e.getAddress() : null }) } lookupAddress(t) { return b(this, void 0, void 0, function* () { t = yield t; const e = (t = this.formatter.address(t)).substring(2).toLowerCase() + ".addr.reverse", n = yield this._getResolver(e); if (!n) return null; let r = (0, o.arrayify)(yield this.call({ to: n, data: "0x691f3431" + (0, l.V)(e).substring(2) })); if (r.length < 32 || !s.O$.from(r.slice(0, 32)).eq(32)) return null; if (r = r.slice(32), r.length < 32) return null; const i = s.O$.from(r.slice(0, 32)).toNumber(); if (r = r.slice(32), i > r.length) return null; const a = (0, d.ZN)(r.slice(0, i)); return (yield this.resolveName(a)) != t ? null : a }) } perform(t, e) { return _.throwError(t + " not implemented", g.Logger.errors.NOT_IMPLEMENTED, { operation: t }) } _startEvent(t) { this.polling = this._events.filter(t => t.pollable()).length > 0 } _stopEvent(t) { this.polling = this._events.filter(t => t.pollable()).length > 0 } _addEventListener(t, e, n) { const r = new M(x(t), e, n); return this._events.push(r), this._startEvent(r), this } on(t, e) { return this._addEventListener(t, e, !1) } once(t, e) { return this._addEventListener(t, e, !0) } emit(t, ...e) { let n = !1, r = [], i = x(t); return this._events = this._events.filter(t => t.tag !== i || (setTimeout(() => { t.listener.apply(this, e) }, 0), n = !0, !t.once || (r.push(t), !1))), r.forEach(t => { this._stopEvent(t) }), n } listenerCount(t) { if (!t) return this._events.length; let e = x(t); return this._events.filter(t => t.tag === e).length } listeners(t) { if (null == t) return this._events.map(t => t.listener); let e = x(t); return this._events.filter(t => t.tag === e).map(t => t.listener) } off(t, e) { if (null == e) return this.removeAllListeners(t); const n = []; let r = !1, i = x(t); return this._events = this._events.filter(t => t.tag !== i || t.listener != e || !!r || (r = !0, n.push(t), !1)), n.forEach(t => { this._stopEvent(t) }), this } removeAllListeners(t) { let e = []; if (null == t) e = this._events, this._events = []; else { const n = x(t); this._events = this._events.filter(t => t.tag !== n || (e.push(t), !1)) } return e.forEach(t => { this._stopEvent(t) }), this } } }, 7949: (t, e, n) => { "use strict"; n.d(e, { Mb: () => d, Ed: () => p, Gp: () => f, vh: () => g }); var r = n(2885), i = n(2024), s = n(1488), o = n(1528), a = n(2275), l = n(2701), c = n(3898), u = n(5102); const h = new c.Logger(u.i); class d { constructor() { h.checkNew(new.target, d), this.formats = this.getDefaultFormats() } getDefaultFormats() { const t = {}, e = this.address.bind(this), n = this.bigNumber.bind(this), r = this.blockTag.bind(this), i = this.data.bind(this), s = this.hash.bind(this), o = this.hex.bind(this), l = this.number.bind(this); return t.transaction = { hash: s, type: d.allowNull(l, null), accessList: d.allowNull(this.accessList.bind(this), null), blockHash: d.allowNull(s, null), blockNumber: d.allowNull(l, null), transactionIndex: d.allowNull(l, null), confirmations: d.allowNull(l, null), from: e, gasPrice: n, gasLimit: n, to: d.allowNull(e, null), value: n, nonce: l, data: i, r: d.allowNull(this.uint256), s: d.allowNull(this.uint256), v: d.allowNull(l), creates: d.allowNull(e, null), raw: d.allowNull(i) }, t.transactionRequest = { from: d.allowNull(e), nonce: d.allowNull(l), gasLimit: d.allowNull(n), gasPrice: d.allowNull(n), to: d.allowNull(e), value: d.allowNull(n), data: d.allowNull(t => this.data(t, !0)), type: d.allowNull(l), accessList: d.allowNull(this.accessList.bind(this), null) }, t.receiptLog = { transactionIndex: l, blockNumber: l, transactionHash: s, address: e, topics: d.arrayOf(s), data: i, logIndex: l, blockHash: s }, t.receipt = { to: d.allowNull(this.address, null), from: d.allowNull(this.address, null), contractAddress: d.allowNull(e, null), transactionIndex: l, root: d.allowNull(o), gasUsed: n, logsBloom: d.allowNull(i), blockHash: s, transactionHash: s, logs: d.arrayOf(this.receiptLog.bind(this)), blockNumber: l, confirmations: d.allowNull(l, null), cumulativeGasUsed: n, status: d.allowNull(l) }, t.block = { hash: s, parentHash: s, number: l, timestamp: l, nonce: d.allowNull(o), difficulty: this.difficulty.bind(this), gasLimit: n, gasUsed: n, miner: e, extraData: i, transactions: d.allowNull(d.arrayOf(s)) }, t.blockWithTransactions = (0, a.shallowCopy)(t.block), t.blockWithTransactions.transactions = d.allowNull(d.arrayOf(this.transactionResponse.bind(this))), t.filter = { fromBlock: d.allowNull(r, void 0), toBlock: d.allowNull(r, void 0), blockHash: d.allowNull(s, void 0), address: d.allowNull(e, void 0), topics: d.allowNull(this.topics.bind(this), void 0) }, t.filterLog = { blockNumber: d.allowNull(l), blockHash: d.allowNull(s), transactionIndex: l, removed: d.allowNull(this.boolean.bind(this)), address: e, data: d.allowFalsish(i, "0x"), topics: d.arrayOf(s), transactionHash: s, logIndex: l }, t } accessList(t) { return (0, l.accessListify)(t || []) } number(t) { return "0x" === t ? 0 : i.O$.from(t).toNumber() } bigNumber(t) { return i.O$.from(t) } boolean(t) { if ("boolean" == typeof t) return t; if ("string" == typeof t) { if ("true" === (t = t.toLowerCase())) return !0; if ("false" === t) return !1 } throw new Error("invalid boolean - " + t) } hex(t, e) { return "string" == typeof t && (e || "0x" === t.substring(0, 2) || (t = "0x" + t), (0, s.isHexString)(t)) ? t.toLowerCase() : h.throwArgumentError("invalid hash", "value", t) } data(t, e) { const n = this.hex(t, e); if (n.length % 2 != 0) throw new Error("invalid data; odd-length - " + t); return n } address(t) { return (0, r.getAddress)(t) } callAddress(t) { if (!(0, s.isHexString)(t, 32)) return null; const e = (0, r.getAddress)((0, s.hexDataSlice)(t, 12)); return e === o.d ? null : e } contractAddress(t) { return (0, r.getContractAddress)(t) } blockTag(t) { if (null == t) return "latest"; if ("earliest" === t) return "0x0"; if ("latest" === t || "pending" === t) return t; if ("number" == typeof t || (0, s.isHexString)(t)) return (0, s.hexValue)(t); throw new Error("invalid blockTag") } hash(t, e) { const n = this.hex(t, e); return 32 !== (0, s.hexDataLength)(n) ? h.throwArgumentError("invalid hash", "value", t) : n } difficulty(t) { if (null == t) return null; const e = i.O$.from(t); try { return e.toNumber() } catch (n) { } return null } uint256(t) { if (!(0, s.isHexString)(t)) throw new Error("invalid uint256"); return (0, s.hexZeroPad)(t, 32) } _block(t, e) { return null != t.author && null == t.miner && (t.miner = t.author), d.check(e, t) } block(t) { return this._block(t, this.formats.block) } blockWithTransactions(t) { return this._block(t, this.formats.blockWithTransactions) } transactionRequest(t) { return d.check(this.formats.transactionRequest, t) } transactionResponse(t) { null != t.gas && null == t.gasLimit && (t.gasLimit = t.gas), t.to && i.O$.from(t.to).isZero() && (t.to = "0x0000000000000000000000000000000000000000"), null != t.input && null == t.data && (t.data = t.input), null == t.to && null == t.creates && (t.creates = this.contractAddress(t)), 1 === t.type && null == t.accessList && (t.accessList = []); const e = d.check(this.formats.transaction, t); if (null != t.chainId) { let n = t.chainId; (0, s.isHexString)(n) && (n = i.O$.from(n).toNumber()), e.chainId = n } else { let n = t.networkId; null == n && null == e.v && (n = t.chainId), (0, s.isHexString)(n) && (n = i.O$.from(n).toNumber()), "number" != typeof n && null != e.v && (n = (e.v - 35) / 2, n < 0 && (n = 0), n = parseInt(n)), "number" != typeof n && (n = 0), e.chainId = n } return e.blockHash && "x" === e.blockHash.replace(/0/g, "") && (e.blockHash = null), e } transaction(t) { return (0, l.parse)(t) } receiptLog(t) { return d.check(this.formats.receiptLog, t) } receipt(t) { const e = d.check(this.formats.receipt, t); if (null != e.root) if (e.root.length <= 4) { const t = i.O$.from(e.root).toNumber(); 0 === t || 1 === t ? (null != e.status && e.status !== t && h.throwArgumentError("alt-root-status/status mismatch", "value", { root: e.root, status: e.status }), e.status = t, delete e.root) : h.throwArgumentError("invalid alt-root-status", "value.root", e.root) } else 66 !== e.root.length && h.throwArgumentError("invalid root hash", "value.root", e.root); return null != e.status && (e.byzantium = !0), e } topics(t) { return Array.isArray(t) ? t.map(t => this.topics(t)) : null != t ? this.hash(t, !0) : null } filter(t) { return d.check(this.formats.filter, t) } filterLog(t) { return d.check(this.formats.filterLog, t) } static check(t, e) { const n = {}; for (const i in t) try { const r = t[i](e[i]); void 0 !== r && (n[i] = r) } catch (r) { throw r.checkKey = i, r.checkValue = e[i], r } return n } static allowNull(t, e) { return function (n) { return null == n ? e : t(n) } } static allowFalsish(t, e) { return function (n) { return n ? t(n) : e } } static arrayOf(t) { return function (e) { if (!Array.isArray(e)) throw new Error("not an array"); const n = []; return e.forEach(function (e) { n.push(t(e)) }), n } } } function p(t) { return t && "function" == typeof t.isCommunityResource } function f(t) { return p(t) && t.isCommunityResource() } let m = !1; function g() { m || (m = !0, console.log("========= NOTICE ========="), console.log("Request-Rate Exceeded  (this message will not be repeated)"), console.log(""), console.log("The default API keys for each service are provided as a highly-throttled,"), console.log("community resource for low-traffic projects and early prototyping."), console.log(""), console.log("While your application will continue to function, we highly recommended"), console.log("signing up for your own API keys to improve performance, increase your"), console.log("request rate/limit and enable other perks, such as metrics and advanced APIs."), console.log(""), console.log("For more details: https://docs.ethers.io/api-keys/"), console.log("==========================")) } }, 3456: (t, e, n) => { "use strict"; n.r(e), n.d(e, { AlchemyProvider: () => x, AlchemyWebSocketProvider: () => S, BaseProvider: () => s.Zk, CloudflareProvider: () => E, EtherscanProvider: () => N, FallbackProvider: () => Q, Formatter: () => a.Mb, InfuraProvider: () => rt, InfuraWebSocketProvider: () => nt, IpcProvider: () => $, JsonRpcBatchProvider: () => it, JsonRpcProvider: () => c.r, JsonRpcSigner: () => c.C, NodesmithProvider: () => ot, PocketProvider: () => ct, Provider: () => r.zt, Resolver: () => s.H2, StaticJsonRpcProvider: () => y, UrlJsonRpcProvider: () => b, Web3Provider: () => ut.Q, WebSocketProvider: () => g, getDefaultProvider: () => dt, getNetwork: () => i.H, isCommunityResourcable: () => a.Ed, isCommunityResource: () => a.Gp, showThrottleMessage: () => a.vh }); var r = n(1527), i = n(5473), s = n(2645), o = n(2275), a = n(7949), l = n(2024), c = n(1522), u = n(3898), h = n(5102); let d = null; try { if (d = WebSocket, null == d) throw new Error("inject please") } catch (pt) { const t = new u.Logger(h.i); d = function () { t.throwError("WebSockets not supported in this environment", u.Logger.errors.UNSUPPORTED_OPERATION, { operation: "new WebSocket()" }) } } var p = function (t, e, n, r) { return new (n || (n = Promise))(function (i, s) { function o(t) { try { l(r.next(t)) } catch (e) { s(e) } } function a(t) { try { l(r.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } l((r = r.apply(t, e || [])).next()) }) }; const f = new u.Logger(h.i); let m = 1; class g extends c.r { constructor(t, e) { "any" === e && f.throwError("WebSocketProvider does not support 'any' network yet", u.Logger.errors.UNSUPPORTED_OPERATION, { operation: "network:any" }), super(t, e), this._pollingInterval = -1, this._wsReady = !1, (0, o.defineReadOnly)(this, "_websocket", new d(this.connection.url)), (0, o.defineReadOnly)(this, "_requests", {}), (0, o.defineReadOnly)(this, "_subs", {}), (0, o.defineReadOnly)(this, "_subIds", {}), (0, o.defineReadOnly)(this, "_detectNetwork", super.detectNetwork()), this._websocket.onopen = () => { this._wsReady = !0, Object.keys(this._requests).forEach(t => { this._websocket.send(this._requests[t].payload) }) }, this._websocket.onmessage = t => { const e = t.data, n = JSON.parse(e); if (null != n.id) { const t = String(n.id), r = this._requests[t]; if (delete this._requests[t], void 0 !== n.result) r.callback(null, n.result), this.emit("debug", { action: "response", request: JSON.parse(r.payload), response: n.result, provider: this }); else { let t = null; n.error ? (t = new Error(n.error.message || "unknown error"), (0, o.defineReadOnly)(t, "code", n.error.code || null), (0, o.defineReadOnly)(t, "response", e)) : t = new Error("unknown error"), r.callback(t, void 0), this.emit("debug", { action: "response", error: t, request: JSON.parse(r.payload), provider: this }) } } else if ("eth_subscription" === n.method) { const t = this._subs[n.params.subscription]; t && t.processFunc(n.params.result) } else console.warn("this should not happen") }; const n = setInterval(() => { this.emit("poll") }, 1e3); n.unref && n.unref() } detectNetwork() { return this._detectNetwork } get pollingInterval() { return 0 } resetEventsBlock(t) { f.throwError("cannot reset events block on WebSocketProvider", u.Logger.errors.UNSUPPORTED_OPERATION, { operation: "resetEventBlock" }) } set pollingInterval(t) { f.throwError("cannot set polling interval on WebSocketProvider", u.Logger.errors.UNSUPPORTED_OPERATION, { operation: "setPollingInterval" }) } poll() { return p(this, void 0, void 0, function* () { return null }) } set polling(t) { t && f.throwError("cannot set polling on WebSocketProvider", u.Logger.errors.UNSUPPORTED_OPERATION, { operation: "setPolling" }) } send(t, e) { const n = m++; return new Promise((r, i) => { const s = JSON.stringify({ method: t, params: e, id: n, jsonrpc: "2.0" }); this.emit("debug", { action: "request", request: JSON.parse(s), provider: this }), this._requests[String(n)] = { callback: function (t, e) { return t ? i(t) : r(e) }, payload: s }, this._wsReady && this._websocket.send(s) }) } static defaultUrl() { return "ws://localhost:8546" } _subscribe(t, e, n) { return p(this, void 0, void 0, function* () { let r = this._subIds[t]; null == r && (r = Promise.all(e).then(t => this.send("eth_subscribe", t)), this._subIds[t] = r); const i = yield r; this._subs[i] = { tag: t, processFunc: n } }) } _startEvent(t) { switch (t.type) { case "block": this._subscribe("block", ["newHeads"], t => { const e = l.O$.from(t.number).toNumber(); this._emitted.block = e, this.emit("block", e) }); break; case "pending": this._subscribe("pending", ["newPendingTransactions"], t => { this.emit("pending", t) }); break; case "filter": this._subscribe(t.tag, ["logs", this._getFilter(t.filter)], e => { null == e.removed && (e.removed = !1), this.emit(t.filter, this.formatter.filterLog(e)) }); break; case "tx": { const e = t => { const e = t.hash; this.getTransactionReceipt(e).then(t => { t && this.emit(e, t) }) }; e(t), this._subscribe("tx", ["newHeads"], t => { this._events.filter(t => "tx" === t.type).forEach(e) }); break } case "debug": case "poll": case "willPoll": case "didPoll": case "error": break; default: console.log("unhandled:", t) } } _stopEvent(t) { let e = t.tag; if ("tx" === t.type) { if (this._events.filter(t => "tx" === t.type).length) return; e = "tx" } else if (this.listenerCount(t.event)) return; const n = this._subIds[e]; n && (delete this._subIds[e], n.then(t => { this._subs[t] && (delete this._subs[t], this.send("eth_unsubscribe", [t])) })) } destroy() { return p(this, void 0, void 0, function* () { this._websocket.readyState === d.CONNECTING && (yield new Promise(t => { this._websocket.onopen = function () { t(!0) }, this._websocket.onerror = function () { t(!1) } })), this._websocket.close(1e3) }) } } const v = new u.Logger(h.i); class y extends c.r { detectNetwork() { const t = Object.create(null, { detectNetwork: { get: () => super.detectNetwork } }); return e = this, void 0, r = function* () { let e = this.network; return null == e && (e = yield t.detectNetwork.call(this), e || v.throwError("no network detected", u.Logger.errors.UNKNOWN_ERROR, {}), null == this._network && ((0, o.defineReadOnly)(this, "_network", e), this.emit("network", e, null))), e }, new ((n = void 0) || (n = Promise))(function (t, i) { function s(t) { try { a(r.next(t)) } catch (e) { i(e) } } function o(t) { try { a(r.throw(t)) } catch (e) { i(e) } } function a(e) { var r; e.done ? t(e.value) : (r = e.value, r instanceof n ? r : new n(function (t) { t(r) })).then(s, o) } a((r = r.apply(e, [])).next()) }); var e, n, r } } class b extends y { constructor(t, e) { v.checkAbstract(new.target, b), t = (0, o.getStatic)(new.target, "getNetwork")(t), e = (0, o.getStatic)(new.target, "getApiKey")(e), super((0, o.getStatic)(new.target, "getUrl")(t, e), t), "string" == typeof e ? (0, o.defineReadOnly)(this, "apiKey", e) : null != e && Object.keys(e).forEach(t => { (0, o.defineReadOnly)(this, t, e[t]) }) } _startPending() { v.warn("WARNING: API provider does not support pending filters") } isCommunityResource() { return !1 } getSigner(t) { return v.throwError("API provider does not support signing", u.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" }) } listAccounts() { return Promise.resolve([]) } static getApiKey(t) { return t } static getUrl(t, e) { return v.throwError("not implemented; sub-classes must override getUrl", u.Logger.errors.NOT_IMPLEMENTED, { operation: "getUrl" }) } } const _ = new u.Logger(h.i), w = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC"; class S extends g { constructor(t, e) { const n = new x(t, e); super(n.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi."), n.network), (0, o.defineReadOnly)(this, "apiKey", n.apiKey) } isCommunityResource() { return this.apiKey === w } } class x extends b { static getWebSocketProvider(t, e) { return new S(t, e) } static getApiKey(t) { return null == t ? w : (t && "string" != typeof t && _.throwArgumentError("invalid apiKey", "apiKey", t), t) } static getUrl(t, e) { let n = null; switch (t.name) { case "homestead": n = "eth-mainnet.alchemyapi.io/v2/"; break; case "ropsten": n = "eth-ropsten.alchemyapi.io/v2/"; break; case "rinkeby": n = "eth-rinkeby.alchemyapi.io/v2/"; break; case "goerli": n = "eth-goerli.alchemyapi.io/v2/"; break; case "kovan": n = "eth-kovan.alchemyapi.io/v2/"; break; default: _.throwArgumentError("unsupported network", "network", arguments[0]) }return { allowGzip: !0, url: "https://" + n + e, throttleCallback: (t, n) => (e === w && (0, a.vh)(), Promise.resolve(!0)) } } isCommunityResource() { return this.apiKey === w } } const T = new u.Logger(h.i); class E extends b { static getApiKey(t) { return null != t && T.throwArgumentError("apiKey not supported for cloudflare", "apiKey", t), null } static getUrl(t, e) { let n = null; switch (t.name) { case "homestead": n = "https://cloudflare-eth.com/"; break; default: T.throwArgumentError("unsupported network", "network", arguments[0]) }return n } perform(t, e) { const n = Object.create(null, { perform: { get: () => super.perform } }); return r = this, void 0, s = function* () { return "getBlockNumber" === t ? (yield n.perform.call(this, "getBlock", { blockTag: "latest" })).number : n.perform.call(this, t, e) }, new ((i = void 0) || (i = Promise))(function (t, e) { function n(t) { try { a(s.next(t)) } catch (n) { e(n) } } function o(t) { try { a(s.throw(t)) } catch (n) { e(n) } } function a(e) { var r; e.done ? t(e.value) : (r = e.value, r instanceof i ? r : new i(function (t) { t(r) })).then(n, o) } a((s = s.apply(r, [])).next()) }); var r, i, s } } var M = n(1488), A = n(2701), C = n(3511), P = function (t, e, n, r) { return new (n || (n = Promise))(function (i, s) { function o(t) { try { l(r.next(t)) } catch (e) { s(e) } } function a(t) { try { l(r.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } l((r = r.apply(t, e || [])).next()) }) }; const R = new u.Logger(h.i); function L(t) { const e = {}; for (let n in t) { if (null == t[n]) continue; let r = t[n]; r = { type: !0, gasLimit: !0, gasPrice: !0, nonce: !0, value: !0 }[n] ? (0, M.hexValue)((0, M.hexlify)(r)) : "accessList" === n ? "[" + (0, A.accessListify)(r).map(t => `{address:"${t.address}",storageKeys:["${t.storageKeys.join('","')}"]}`).join(",") + "]" : (0, M.hexlify)(r), e[n] = r } return e } function k(t) { if (0 == t.status && ("No records found" === t.message || "No transactions found" === t.message)) return t.result; if (1 != t.status || "OK" != t.message) { const e = new Error("invalid response"); throw e.result = JSON.stringify(t), (t.result || "").toLowerCase().indexOf("rate limit") >= 0 && (e.throttleRetry = !0), e } return t.result } function D(t) { if (t && 0 == t.status && "NOTOK" == t.message && (t.result || "").toLowerCase().indexOf("rate limit") >= 0) { const e = new Error("throttled response"); throw e.result = JSON.stringify(t), e.throttleRetry = !0, e } if ("2.0" != t.jsonrpc) { const e = new Error("invalid response"); throw e.result = JSON.stringify(t), e } if (t.error) { const e = new Error(t.error.message || "unknown error"); throw t.error.code && (e.code = t.error.code), t.error.data && (e.data = t.error.data), e } return t.result } function I(t) { if ("pending" === t) throw new Error("pending not supported"); return "latest" === t ? t : parseInt(t.substring(2), 16) } const O = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB"; function F(t, e, n) { if ("call" === t && e.code === u.Logger.errors.SERVER_ERROR) { const t = e.error; if (t && t.message.match("reverted") && (0, M.isHexString)(t.data)) return t.data } let r = e.message; throw e.code === u.Logger.errors.SERVER_ERROR && (e.error && "string" == typeof e.error.message ? r = e.error.message : "string" == typeof e.body ? r = e.body : "string" == typeof e.responseText && (r = e.responseText)), r = (r || "").toLowerCase(), r.match(/insufficient funds/) && R.throwError("insufficient funds for intrinsic transaction cost", u.Logger.errors.INSUFFICIENT_FUNDS, { error: e, method: t, transaction: n }), r.match(/same hash was already imported|transaction nonce is too low/) && R.throwError("nonce has already been used", u.Logger.errors.NONCE_EXPIRED, { error: e, method: t, transaction: n }), r.match(/another transaction with same nonce/) && R.throwError("replacement fee too low", u.Logger.errors.REPLACEMENT_UNDERPRICED, { error: e, method: t, transaction: n }), r.match(/execution failed due to an exception/) && R.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", u.Logger.errors.UNPREDICTABLE_GAS_LIMIT, { error: e, method: t, transaction: n }), e } class N extends s.Zk { constructor(t, e) { R.checkNew(new.target, N), super(t); let n = "invalid"; this.network && (n = this.network.name); let r = null; switch (n) { case "homestead": r = "https://api.etherscan.io"; break; case "ropsten": r = "https://api-ropsten.etherscan.io"; break; case "rinkeby": r = "https://api-rinkeby.etherscan.io"; break; case "kovan": r = "https://api-kovan.etherscan.io"; break; case "goerli": r = "https://api-goerli.etherscan.io"; break; default: throw new Error("unsupported network") }(0, o.defineReadOnly)(this, "baseUrl", r), (0, o.defineReadOnly)(this, "apiKey", e || O) } detectNetwork() { return P(this, void 0, void 0, function* () { return this.network }) } perform(t, e) { const n = Object.create(null, { perform: { get: () => super.perform } }); return P(this, void 0, void 0, function* () { let r = this.baseUrl + "/api", i = ""; this.apiKey && (i += "&apikey=" + this.apiKey); const s = (t, e, n) => P(this, void 0, void 0, function* () { this.emit("debug", { action: "request", request: t, provider: this }); const r = { url: t, throttleSlotInterval: 1e3, throttleCallback: (t, e) => (this.isCommunityResource() && (0, a.vh)(), Promise.resolve(!0)) }; let i = null; e && (r.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" }, i = Object.keys(e).map(t => `${t}=${e[t]}`).join("&")); const s = yield (0, C.fetchJson)(r, i, n || D); return this.emit("debug", { action: "response", request: t, response: (0, o.deepCopy)(s), provider: this }), s }); switch (t) { case "getBlockNumber": return r += "?module=proxy&action=eth_blockNumber" + i, s(r, null); case "getGasPrice": return r += "?module=proxy&action=eth_gasPrice" + i, s(r, null); case "getBalance": return r += "?module=account&action=balance&address=" + e.address, r += "&tag=" + e.blockTag + i, s(r, null, k); case "getTransactionCount": return r += "?module=proxy&action=eth_getTransactionCount&address=" + e.address, r += "&tag=" + e.blockTag + i, s(r, null); case "getCode": return r += "?module=proxy&action=eth_getCode&address=" + e.address, r += "&tag=" + e.blockTag + i, s(r, null); case "getStorageAt": return r += "?module=proxy&action=eth_getStorageAt&address=" + e.address, r += "&position=" + e.position, r += "&tag=" + e.blockTag + i, s(r, null); case "sendTransaction": return s(r, { module: "proxy", action: "eth_sendRawTransaction", hex: e.signedTransaction, apikey: this.apiKey }).catch(t => F("sendTransaction", t, e.signedTransaction)); case "getBlock": if (e.blockTag) return r += "?module=proxy&action=eth_getBlockByNumber&tag=" + e.blockTag, r += e.includeTransactions ? "&boolean=true" : "&boolean=false", r += i, s(r, null); throw new Error("getBlock by blockHash not implemented"); case "getTransaction": return r += "?module=proxy&action=eth_getTransactionByHash&txhash=" + e.transactionHash, r += i, s(r, null); case "getTransactionReceipt": return r += "?module=proxy&action=eth_getTransactionReceipt&txhash=" + e.transactionHash, r += i, s(r, null); case "call": { if ("latest" !== e.blockTag) throw new Error("EtherscanProvider does not support blockTag for call"); const t = L(e.transaction); t.module = "proxy", t.action = "eth_call", t.apikey = this.apiKey; try { return yield s(r, t) } catch (pt) { return F("call", pt, e.transaction) } } case "estimateGas": { const t = L(e.transaction); t.module = "proxy", t.action = "eth_estimateGas", t.apikey = this.apiKey; try { return yield s(r, t) } catch (pt) { return F("estimateGas", pt, e.transaction) } } case "getLogs": { if (r += "?module=logs&action=getLogs", e.filter.fromBlock && (r += "&fromBlock=" + I(e.filter.fromBlock)), e.filter.toBlock && (r += "&toBlock=" + I(e.filter.toBlock)), e.filter.address && (r += "&address=" + e.filter.address), e.filter.topics && e.filter.topics.length > 0 && (e.filter.topics.length > 1 && R.throwError("unsupported topic count", u.Logger.errors.UNSUPPORTED_OPERATION, { topics: e.filter.topics }), 1 === e.filter.topics.length)) { const t = e.filter.topics[0]; "string" == typeof t && 66 === t.length || R.throwError("unsupported topic format", u.Logger.errors.UNSUPPORTED_OPERATION, { topic0: t }), r += "&topic0=" + t } r += i; const t = yield s(r, null, k); let n = {}; for (let e = 0; e < t.length; e++) { const r = t[e]; if (null == r.blockHash) { if (null == n[r.blockNumber]) { const t = yield this.getBlock(r.blockNumber); t && (n[r.blockNumber] = t.hash) } r.blockHash = n[r.blockNumber] } } return t } case "getEtherPrice": return "homestead" !== this.network.name ? 0 : (r += "?module=stats&action=ethprice", r += i, parseFloat((yield s(r, null, k)).ethusd)) }return n.perform.call(this, t, e) }) } getHistory(t, e, n) { let r = this.baseUrl, i = ""; return this.apiKey && (i += "&apikey=" + this.apiKey), null == e && (e = 0), null == n && (n = 99999999), this.resolveName(t).then(t => (r += "/api?module=account&action=txlist&address=" + t, r += "&startblock=" + e, r += "&endblock=" + n, r += "&sort=asc" + i, this.emit("debug", { action: "request", request: r, provider: this }), (0, C.fetchJson)({ url: r, throttleSlotInterval: 1e3, throttleCallback: (t, e) => (this.apiKey === O && (0, a.vh)(), Promise.resolve(!0)) }, null, k).then(t => { this.emit("debug", { action: "response", request: r, response: (0, o.deepCopy)(t), provider: this }); let e = []; return t.forEach(t => { ["contractAddress", "to"].forEach(function (e) { "" == t[e] && delete t[e] }), null == t.creates && null != t.contractAddress && (t.creates = t.contractAddress); let n = this.formatter.transactionResponse(t); t.timeStamp && (n.timestamp = parseInt(t.timeStamp)), e.push(n) }), e }))) } isCommunityResource() { return this.apiKey === O } } var B = n(4820), H = function (t, e, n, r) { return new (n || (n = Promise))(function (i, s) { function o(t) { try { l(r.next(t)) } catch (e) { s(e) } } function a(t) { try { l(r.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } l((r = r.apply(t, e || [])).next()) }) }; const U = new u.Logger(h.i); function G() { return (new Date).getTime() } function V(t) { let e = null; for (let n = 0; n < t.length; n++) { const r = t[n]; if (null == r) return null; e ? e.name === r.name && e.chainId === r.chainId && (e.ensAddress === r.ensAddress || null == e.ensAddress && null == r.ensAddress) || U.throwArgumentError("provider mismatch", "networks", t) : e = r } return e } function z(t, e) { t = t.slice().sort(); const n = Math.floor(t.length / 2); if (t.length % 2) return t[n]; const r = t[n - 1], i = t[n]; return null != e && Math.abs(r - i) > e ? null : (r + i) / 2 } function j(t) { if (null === t) return "null"; if ("number" == typeof t || "boolean" == typeof t) return JSON.stringify(t); if ("string" == typeof t) return t; if (l.O$.isBigNumber(t)) return t.toString(); if (Array.isArray(t)) return JSON.stringify(t.map(t => j(t))); if ("object" == typeof t) { const e = Object.keys(t); return e.sort(), "{" + e.map(e => { let n = t[e]; return n = "function" == typeof n ? "[function]" : j(n), JSON.stringify(e) + ":" + n }).join(",") + "}" } throw new Error("unknown value type: " + typeof t) } let J = 1; function X(t) { let e = null, n = null, r = new Promise(r => { e = function () { n && (clearTimeout(n), n = null), r() }, n = setTimeout(e, t) }); return { cancel: e, getPromise: function () { return r }, wait: t => (r = r.then(t), r) } } const W = [u.Logger.errors.CALL_EXCEPTION, u.Logger.errors.INSUFFICIENT_FUNDS, u.Logger.errors.NONCE_EXPIRED, u.Logger.errors.REPLACEMENT_UNDERPRICED, u.Logger.errors.UNPREDICTABLE_GAS_LIMIT], q = ["address", "args", "errorArgs", "errorSignature", "method", "transaction"]; function Z(t, e) { const n = { weight: t.weight }; return Object.defineProperty(n, "provider", { get: () => t.provider }), t.start && (n.start = t.start), e && (n.duration = e - t.start), t.done && (t.error ? n.error = t.error : n.result = t.result || null), n } function K(t, e) { return H(this, void 0, void 0, function* () { const n = t.provider; return null != n.blockNumber && n.blockNumber >= e || -1 === e ? n : (0, C.poll)(() => new Promise((r, i) => { setTimeout(function () { return r(n.blockNumber >= e ? n : t.cancelled ? null : void 0) }, 0) }), { oncePoll: n }) }) } function Y(t, e, n, r) { return H(this, void 0, void 0, function* () { let i = t.provider; switch (n) { case "getBlockNumber": case "getGasPrice": return i[n](); case "getEtherPrice": if (i.getEtherPrice) return i.getEtherPrice(); break; case "getBalance": case "getTransactionCount": case "getCode": return r.blockTag && (0, M.isHexString)(r.blockTag) && (i = yield K(t, e)), i[n](r.address, r.blockTag || "latest"); case "getStorageAt": return r.blockTag && (0, M.isHexString)(r.blockTag) && (i = yield K(t, e)), i.getStorageAt(r.address, r.position, r.blockTag || "latest"); case "getBlock": return r.blockTag && (0, M.isHexString)(r.blockTag) && (i = yield K(t, e)), i[r.includeTransactions ? "getBlockWithTransactions" : "getBlock"](r.blockTag || r.blockHash); case "call": case "estimateGas": return r.blockTag && (0, M.isHexString)(r.blockTag) && (i = yield K(t, e)), i[n](r.transaction); case "getTransaction": case "getTransactionReceipt": return i[n](r.transactionHash); case "getLogs": { let n = r.filter; return (n.fromBlock && (0, M.isHexString)(n.fromBlock) || n.toBlock && (0, M.isHexString)(n.toBlock)) && (i = yield K(t, e)), i.getLogs(n) } }return U.throwError("unknown method error", u.Logger.errors.UNKNOWN_ERROR, { method: n, params: r }) }) } class Q extends s.Zk { constructor(t, e) { U.checkNew(new.target, Q), 0 === t.length && U.throwArgumentError("missing providers", "providers", t); const n = t.map((t, e) => { if (r.zt.isProvider(t)) { const e = (0, a.Gp)(t) ? 2e3 : 750; return Object.freeze({ provider: t, weight: 1, stallTimeout: e, priority: 1 }) } const n = (0, o.shallowCopy)(t); null == n.priority && (n.priority = 1), null == n.stallTimeout && (n.stallTimeout = (0, a.Gp)(t) ? 2e3 : 750), null == n.weight && (n.weight = 1); const i = n.weight; return (i % 1 || i > 512 || i < 1) && U.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${e}].weight`, i), Object.freeze(n) }), i = n.reduce((t, e) => t + e.weight, 0); null == e ? e = i / 2 : e > i && U.throwArgumentError("quorum will always fail; larger than total weight", "quorum", e); let s = V(n.map(t => t.provider.network)); null == s && (s = new Promise((t, e) => { setTimeout(() => { this.detectNetwork().then(t, e) }, 0) })), super(s), (0, o.defineReadOnly)(this, "providerConfigs", Object.freeze(n)), (0, o.defineReadOnly)(this, "quorum", e), this._highestBlockNumber = -1 } detectNetwork() { return H(this, void 0, void 0, function* () { return V(yield Promise.all(this.providerConfigs.map(t => t.provider.getNetwork()))) }) } perform(t, e) { return H(this, void 0, void 0, function* () { if ("sendTransaction" === t) { const t = yield Promise.all(this.providerConfigs.map(t => t.provider.sendTransaction(e.signedTransaction).then(t => t.hash, t => t))); for (let e = 0; e < t.length; e++) { const n = t[e]; if ("string" == typeof n) return n } throw t[0] } -1 === this._highestBlockNumber && "getBlockNumber" !== t && (yield this.getBlockNumber()); const n = function (t, e, n) { let r = j; switch (e) { case "getBlockNumber": return function (e) { const n = e.map(t => t.result); let r = z(e.map(t => t.result), 2); if (null != r) return r = Math.ceil(r), n.indexOf(r + 1) >= 0 && r++, r >= t._highestBlockNumber && (t._highestBlockNumber = r), t._highestBlockNumber }; case "getGasPrice": return function (t) { const e = t.map(t => t.result); return e.sort(), e[Math.floor(e.length / 2)] }; case "getEtherPrice": return function (t) { return z(t.map(t => t.result)) }; case "getBalance": case "getTransactionCount": case "getCode": case "getStorageAt": case "call": case "estimateGas": case "getLogs": break; case "getTransaction": case "getTransactionReceipt": r = function (t) { return null == t ? null : ((t = (0, o.shallowCopy)(t)).confirmations = -1, j(t)) }; break; case "getBlock": r = n.includeTransactions ? function (t) { return null == t ? null : ((t = (0, o.shallowCopy)(t)).transactions = t.transactions.map(t => ((t = (0, o.shallowCopy)(t)).confirmations = -1, t)), j(t)) } : function (t) { return null == t ? null : j(t) }; break; default: throw new Error("unknown method: " + e) }return function (t, e) { return function (n) { const r = {}; n.forEach(e => { const n = t(e.result); r[n] || (r[n] = { count: 0, result: e.result }), r[n].count++ }); const i = Object.keys(r); for (let t = 0; t < i.length; t++) { const n = r[i[t]]; if (n.count >= e) return n.result } } }(r, t.quorum) }(this, t, e), r = (0, B.y)(this.providerConfigs.map(o.shallowCopy)); r.sort((t, e) => t.priority - e.priority); const i = this._highestBlockNumber; let s = 0, a = !0; for (; ;) { const l = G(); let c = r.filter(t => t.runner && l - t.start < t.stallTimeout).reduce((t, e) => t + e.weight, 0); for (; c < this.quorum && s < r.length;) { const n = r[s++], a = J++; n.start = G(), n.staller = X(n.stallTimeout), n.staller.wait(() => { n.staller = null }), n.runner = Y(n, i, t, e).then(r => { n.done = !0, n.result = r, this.listenerCount("debug") && this.emit("debug", { action: "request", rid: a, backend: Z(n, G()), request: { method: t, params: (0, o.deepCopy)(e) }, provider: this }) }, r => { n.done = !0, n.error = r, this.listenerCount("debug") && this.emit("debug", { action: "request", rid: a, backend: Z(n, G()), request: { method: t, params: (0, o.deepCopy)(e) }, provider: this }) }), this.listenerCount("debug") && this.emit("debug", { action: "request", rid: a, backend: Z(n, null), request: { method: t, params: (0, o.deepCopy)(e) }, provider: this }), c += n.weight } const u = []; r.forEach(t => { !t.done && t.runner && (u.push(t.runner), t.staller && u.push(t.staller.getPromise())) }), u.length && (yield Promise.race(u)); const h = r.filter(t => t.done && null == t.error); if (h.length >= this.quorum) { const t = n(h); if (void 0 !== t) return r.forEach(t => { t.staller && t.staller.cancel(), t.cancelled = !0 }), t; a || (yield X(100).getPromise()), a = !1 } const d = r.reduce((t, e) => { if (!e.done || null == e.error) return t; const n = e.error.code; return W.indexOf(n) >= 0 && (t[n] || (t[n] = { error: e.error, weight: 0 }), t[n].weight += e.weight), t }, {}); if (Object.keys(d).forEach(t => { const e = d[t]; if (e.weight < this.quorum) return; r.forEach(t => { t.staller && t.staller.cancel(), t.cancelled = !0 }); const n = e.error, i = {}; q.forEach(t => { null != n[t] && (i[t] = n[t]) }), U.throwError(n.reason || n.message, t, i) }), 0 === r.filter(t => !t.done).length) break } return r.forEach(t => { t.staller && t.staller.cancel(), t.cancelled = !0 }), U.throwError("failed to meet quorum", u.Logger.errors.SERVER_ERROR, { method: t, params: e, results: r.map(t => Z(t)), provider: this }) }) } } const $ = null, tt = new u.Logger(h.i), et = "84842078b09946638c03157f83405213"; class nt extends g { constructor(t, e) { const n = new rt(t, e), r = n.connection; r.password && tt.throwError("INFURA WebSocket project secrets unsupported", u.Logger.errors.UNSUPPORTED_OPERATION, { operation: "InfuraProvider.getWebSocketProvider()" }), super(r.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/"), t), (0, o.defineReadOnly)(this, "apiKey", n.projectId), (0, o.defineReadOnly)(this, "projectId", n.projectId), (0, o.defineReadOnly)(this, "projectSecret", n.projectSecret) } isCommunityResource() { return this.projectId === et } } class rt extends b { static getWebSocketProvider(t, e) { return new nt(t, e) } static getApiKey(t) { const e = { apiKey: et, projectId: et, projectSecret: null }; return null == t || ("string" == typeof t ? e.projectId = t : null != t.projectSecret ? (tt.assertArgument("string" == typeof t.projectId, "projectSecret requires a projectId", "projectId", t.projectId), tt.assertArgument("string" == typeof t.projectSecret, "invalid projectSecret", "projectSecret", "[REDACTED]"), e.projectId = t.projectId, e.projectSecret = t.projectSecret) : t.projectId && (e.projectId = t.projectId), e.apiKey = e.projectId), e } static getUrl(t, e) { let n = null; switch (t ? t.name : "unknown") { case "homestead": n = "mainnet.infura.io"; break; case "ropsten": n = "ropsten.infura.io"; break; case "rinkeby": n = "rinkeby.infura.io"; break; case "kovan": n = "kovan.infura.io"; break; case "goerli": n = "goerli.infura.io"; break; default: tt.throwError("unsupported network", u.Logger.errors.INVALID_ARGUMENT, { argument: "network", value: t }) }const r = { allowGzip: !0, url: "https://" + n + "/v3/" + e.projectId, throttleCallback: (t, n) => (e.projectId === et && (0, a.vh)(), Promise.resolve(!0)) }; return null != e.projectSecret && (r.user = "", r.password = e.projectSecret), r } isCommunityResource() { return this.projectId === et } } class it extends c.r { send(t, e) { const n = { method: t, params: e, id: this._nextId++, jsonrpc: "2.0" }; null == this._pendingBatch && (this._pendingBatch = []); const r = { request: n, resolve: null, reject: null }, i = new Promise((t, e) => { r.resolve = t, r.reject = e }); return this._pendingBatch.push(r), this._pendingBatchAggregator || (this._pendingBatchAggregator = setTimeout(() => { const t = this._pendingBatch; this._pendingBatch = null, this._pendingBatchAggregator = null; const e = t.map(t => t.request); return this.emit("debug", { action: "requestBatch", request: (0, o.deepCopy)(e), provider: this }), (0, C.fetchJson)(this.connection, JSON.stringify(e)).then(n => { this.emit("debug", { action: "response", request: e, response: n, provider: this }), t.forEach((t, e) => { const r = n[e]; if (r.error) { const e = new Error(r.error.message); e.code = r.error.code, e.data = r.error.data, t.reject(e) } else t.resolve(r.result) }) }, n => { this.emit("debug", { action: "response", error: n, request: e, provider: this }), t.forEach(t => { t.reject(n) }) }) }, 10)), i } } const st = new u.Logger(h.i); class ot extends b { static getApiKey(t) { return t && "string" != typeof t && st.throwArgumentError("invalid apiKey", "apiKey", t), t || "ETHERS_JS_SHARED" } static getUrl(t, e) { st.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform."); let n = null; switch (t.name) { case "homestead": n = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc"; break; case "ropsten": n = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc"; break; case "rinkeby": n = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc"; break; case "goerli": n = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc"; break; case "kovan": n = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc"; break; default: st.throwArgumentError("unsupported network", "network", arguments[0]) }return n + "?apiKey=" + e } } const at = new u.Logger(h.i), lt = { homestead: "6004bcd10040261633ade990", ropsten: "6004bd4d0040261633ade991", rinkeby: "6004bda20040261633ade994", goerli: "6004bd860040261633ade992" }; class ct extends b { constructor(t, e) { if (null == e) { const n = (0, o.getStatic)(new.target, "getNetwork")(t); if (n) { const t = lt[n.name]; t && (e = { applicationId: t, loadBalancer: !0 }) } null == e && at.throwError("unsupported network", u.Logger.errors.INVALID_ARGUMENT, { argument: "network", value: t }) } super(t, e) } static getApiKey(t) { null == t && at.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", t); const e = { applicationId: null, loadBalancer: !1, applicationSecretKey: null }; return "string" == typeof t ? e.applicationId = t : null != t.applicationSecretKey ? (at.assertArgument("string" == typeof t.applicationId, "applicationSecretKey requires an applicationId", "applicationId", t.applicationId), at.assertArgument("string" == typeof t.applicationSecretKey, "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]"), e.applicationId = t.applicationId, e.applicationSecretKey = t.applicationSecretKey, e.loadBalancer = !!t.loadBalancer) : t.applicationId ? (at.assertArgument("string" == typeof t.applicationId, "apiKey.applicationId must be a string", "apiKey.applicationId", t.applicationId), e.applicationId = t.applicationId, e.loadBalancer = !!t.loadBalancer) : at.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", t), e } static getUrl(t, e) { let n = null; switch (t ? t.name : "unknown") { case "homestead": n = "eth-mainnet.gateway.pokt.network"; break; case "ropsten": n = "eth-ropsten.gateway.pokt.network"; break; case "rinkeby": n = "eth-rinkeby.gateway.pokt.network"; break; case "goerli": n = "eth-goerli.gateway.pokt.network"; break; default: at.throwError("unsupported network", u.Logger.errors.INVALID_ARGUMENT, { argument: "network", value: t }) }let r = null; r = e.loadBalancer ? `https://${n}/v1/lb/${e.applicationId}` : `https://${n}/v1/${e.applicationId}`; const i = { url: r, headers: {} }; return null != e.applicationSecretKey && (i.user = "", i.password = e.applicationSecretKey), i } isCommunityResource() { return this.applicationId === lt[this.network.name] } } var ut = n(9267); const ht = new u.Logger(h.i); function dt(t, e) { if (null == t && (t = "homestead"), "string" == typeof t) { const e = t.match(/^(ws|http)s?:/i); if (e) switch (e[1]) { case "http": return new c.r(t); case "ws": return new g(t); default: ht.throwArgumentError("unsupported URL scheme", "network", t) } } const n = (0, i.H)(t); return n && n._defaultProvider || ht.throwError("unsupported getDefaultProvider network", u.Logger.errors.NETWORK_ERROR, { operation: "getDefaultProvider", network: t }), n._defaultProvider({ FallbackProvider: Q, AlchemyProvider: x, CloudflareProvider: E, EtherscanProvider: N, InfuraProvider: rt, JsonRpcProvider: c.r, NodesmithProvider: ot, PocketProvider: ct, Web3Provider: ut.Q, IpcProvider: $ }, e) } }, 1522: (t, e, n) => { "use strict"; n.d(e, { C: () => S, r: () => E }); var r = n(1221), i = n(2024), s = n(1488), o = n(2072), a = n(2275), l = n(8822), c = n(2701), u = n(3511), h = n(3898), d = n(5102), p = n(2645), f = function (t, e, n, r) { return new (n || (n = Promise))(function (i, s) { function o(t) { try { l(r.next(t)) } catch (e) { s(e) } } function a(t) { try { l(r.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } l((r = r.apply(t, e || [])).next()) }) }; const m = new h.Logger(d.i), g = ["call", "estimateGas"]; function v(t, e, n) { if ("call" === t && e.code === h.Logger.errors.SERVER_ERROR) { const t = e.error; if (t && t.message.match("reverted") && (0, s.isHexString)(t.data)) return t.data } let r = e.message; e.code === h.Logger.errors.SERVER_ERROR && e.error && "string" == typeof e.error.message ? r = e.error.message : "string" == typeof e.body ? r = e.body : "string" == typeof e.responseText && (r = e.responseText), r = (r || "").toLowerCase(); const i = n.transaction || n.signedTransaction; throw r.match(/insufficient funds/) && m.throwError("insufficient funds for intrinsic transaction cost", h.Logger.errors.INSUFFICIENT_FUNDS, { error: e, method: t, transaction: i }), r.match(/nonce too low/) && m.throwError("nonce has already been used", h.Logger.errors.NONCE_EXPIRED, { error: e, method: t, transaction: i }), r.match(/replacement transaction underpriced/) && m.throwError("replacement fee too low", h.Logger.errors.REPLACEMENT_UNDERPRICED, { error: e, method: t, transaction: i }), r.match(/only replay-protected/) && m.throwError("legacy pre-eip-155 transactions not supported", h.Logger.errors.UNSUPPORTED_OPERATION, { error: e, method: t, transaction: i }), g.indexOf(t) >= 0 && r.match(/gas required exceeds allowance|always failing transaction|execution reverted/) && m.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", h.Logger.errors.UNPREDICTABLE_GAS_LIMIT, { error: e, method: t, transaction: i }), e } function y(t) { return new Promise(function (e) { setTimeout(e, t) }) } function b(t) { if (t.error) { const e = new Error(t.error.message); throw e.code = t.error.code, e.data = t.error.data, e } return t.result } function _(t) { return t ? t.toLowerCase() : t } const w = {}; class S extends r.Signer { constructor(t, e, n) { if (m.checkNew(new.target, S), super(), t !== w) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner"); (0, a.defineReadOnly)(this, "provider", e), null == n && (n = 0), "string" == typeof n ? ((0, a.defineReadOnly)(this, "_address", this.provider.formatter.address(n)), (0, a.defineReadOnly)(this, "_index", null)) : "number" == typeof n ? ((0, a.defineReadOnly)(this, "_index", n), (0, a.defineReadOnly)(this, "_address", null)) : m.throwArgumentError("invalid address or index", "addressOrIndex", n) } connect(t) { return m.throwError("cannot alter JSON-RPC Signer connection", h.Logger.errors.UNSUPPORTED_OPERATION, { operation: "connect" }) } connectUnchecked() { return new x(w, this.provider, this._address || this._index) } getAddress() { return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then(t => (t.length <= this._index && m.throwError("unknown account #" + this._index, h.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getAddress" }), this.provider.formatter.address(t[this._index]))) } sendUncheckedTransaction(t) { t = (0, a.shallowCopy)(t); const e = this.getAddress().then(t => (t && (t = t.toLowerCase()), t)); if (null == t.gasLimit) { const n = (0, a.shallowCopy)(t); n.from = e, t.gasLimit = this.provider.estimateGas(n) } return (0, a.resolveProperties)({ tx: (0, a.resolveProperties)(t), sender: e }).then(({ tx: e, sender: n }) => { null != e.from ? e.from.toLowerCase() !== n && m.throwArgumentError("from address mismatch", "transaction", t) : e.from = n; const r = this.provider.constructor.hexlifyTransaction(e, { from: !0 }); return this.provider.send("eth_sendTransaction", [r]).then(t => t, t => v("sendTransaction", t, r)) }) } signTransaction(t) { return m.throwError("signing transactions is unsupported", h.Logger.errors.UNSUPPORTED_OPERATION, { operation: "signTransaction" }) } sendTransaction(t) { return this.sendUncheckedTransaction(t).then(t => (0, u.poll)(() => this.provider.getTransaction(t).then(e => { if (null !== e) return this.provider._wrapTransaction(e, t) }), { onceBlock: this.provider }).catch(e => { throw e.transactionHash = t, e })) } signMessage(t) { return f(this, void 0, void 0, function* () { const e = "string" == typeof t ? (0, l.Y0)(t) : t, n = yield this.getAddress(); return yield this.provider.send("eth_sign", [n.toLowerCase(), (0, s.hexlify)(e)]) }) } _signTypedData(t, e, n) { return f(this, void 0, void 0, function* () { const r = yield o.E.resolveNames(t, e, n, t => this.provider.resolveName(t)), i = yield this.getAddress(); return yield this.provider.send("eth_signTypedData_v4", [i.toLowerCase(), JSON.stringify(o.E.getPayload(r.domain, e, r.value))]) }) } unlock(t) { return f(this, void 0, void 0, function* () { const e = this.provider, n = yield this.getAddress(); return e.send("personal_unlockAccount", [n.toLowerCase(), t, null]) }) } } class x extends S { sendTransaction(t) { return this.sendUncheckedTransaction(t).then(t => ({ hash: t, nonce: null, gasLimit: null, gasPrice: null, data: null, value: null, chainId: null, confirmations: 0, from: null, wait: e => this.provider.waitForTransaction(t, e) })) } } const T = { chainId: !0, data: !0, gasLimit: !0, gasPrice: !0, nonce: !0, to: !0, value: !0, type: !0, accessList: !0 }; class E extends p.Zk { constructor(t, e) { m.checkNew(new.target, E); let n = e; null == n && (n = new Promise((t, e) => { setTimeout(() => { this.detectNetwork().then(e => { t(e) }, t => { e(t) }) }, 0) })), super(n), t || (t = (0, a.getStatic)(this.constructor, "defaultUrl")()), (0, a.defineReadOnly)(this, "connection", Object.freeze("string" == typeof t ? { url: t } : (0, a.shallowCopy)(t))), this._nextId = 42 } get _cache() { return null == this._eventLoopCache && (this._eventLoopCache = {}), this._eventLoopCache } static defaultUrl() { return "http://localhost:8545" } detectNetwork() { return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => { this._cache.detectNetwork = null }, 0)), this._cache.detectNetwork } _uncachedDetectNetwork() { return f(this, void 0, void 0, function* () { yield y(0); let t = null; try { t = yield this.send("eth_chainId", []) } catch (e) { try { t = yield this.send("net_version", []) } catch (e) { } } if (null != t) { const n = (0, a.getStatic)(this.constructor, "getNetwork"); try { return n(i.O$.from(t).toNumber()) } catch (e) { return m.throwError("could not detect network", h.Logger.errors.NETWORK_ERROR, { chainId: t, event: "invalidNetwork", serverError: e }) } } return m.throwError("could not detect network", h.Logger.errors.NETWORK_ERROR, { event: "noNetwork" }) }) } getSigner(t) { return new S(w, this, t) } getUncheckedSigner(t) { return this.getSigner(t).connectUnchecked() } listAccounts() { return this.send("eth_accounts", []).then(t => t.map(t => this.formatter.address(t))) } send(t, e) { const n = { method: t, params: e, id: this._nextId++, jsonrpc: "2.0" }; this.emit("debug", { action: "request", request: (0, a.deepCopy)(n), provider: this }); const r = ["eth_chainId", "eth_blockNumber"].indexOf(t) >= 0; if (r && this._cache[t]) return this._cache[t]; const i = (0, u.fetchJson)(this.connection, JSON.stringify(n), b).then(t => (this.emit("debug", { action: "response", request: n, response: t, provider: this }), t), t => { throw this.emit("debug", { action: "response", error: t, request: n, provider: this }), t }); return r && (this._cache[t] = i, setTimeout(() => { this._cache[t] = null }, 0)), i } prepareRequest(t, e) { switch (t) { case "getBlockNumber": return ["eth_blockNumber", []]; case "getGasPrice": return ["eth_gasPrice", []]; case "getBalance": return ["eth_getBalance", [_(e.address), e.blockTag]]; case "getTransactionCount": return ["eth_getTransactionCount", [_(e.address), e.blockTag]]; case "getCode": return ["eth_getCode", [_(e.address), e.blockTag]]; case "getStorageAt": return ["eth_getStorageAt", [_(e.address), e.position, e.blockTag]]; case "sendTransaction": return ["eth_sendRawTransaction", [e.signedTransaction]]; case "getBlock": return e.blockTag ? ["eth_getBlockByNumber", [e.blockTag, !!e.includeTransactions]] : e.blockHash ? ["eth_getBlockByHash", [e.blockHash, !!e.includeTransactions]] : null; case "getTransaction": return ["eth_getTransactionByHash", [e.transactionHash]]; case "getTransactionReceipt": return ["eth_getTransactionReceipt", [e.transactionHash]]; case "call": return ["eth_call", [(0, a.getStatic)(this.constructor, "hexlifyTransaction")(e.transaction, { from: !0 }), e.blockTag]]; case "estimateGas": return ["eth_estimateGas", [(0, a.getStatic)(this.constructor, "hexlifyTransaction")(e.transaction, { from: !0 })]]; case "getLogs": return e.filter && null != e.filter.address && (e.filter.address = _(e.filter.address)), ["eth_getLogs", [e.filter]] }return null } perform(t, e) { return f(this, void 0, void 0, function* () { const n = this.prepareRequest(t, e); null == n && m.throwError(t + " not implemented", h.Logger.errors.NOT_IMPLEMENTED, { operation: t }); try { return yield this.send(n[0], n[1]) } catch (r) { return v(t, r, e) } }) } _startEvent(t) { "pending" === t.tag && this._startPending(), super._startEvent(t) } _startPending() { if (null != this._pendingFilter) return; const t = this, e = this.send("eth_newPendingTransactionFilter", []); this._pendingFilter = e, e.then(function (n) { return function r() { t.send("eth_getFilterChanges", [n]).then(function (n) { if (t._pendingFilter != e) return null; let r = Promise.resolve(); return n.forEach(function (e) { t._emitted["t:" + e.toLowerCase()] = "pending", r = r.then(function () { return t.getTransaction(e).then(function (e) { return t.emit("pending", e), null }) }) }), r.then(function () { return y(1e3) }) }).then(function () { if (t._pendingFilter == e) return setTimeout(function () { r() }, 0), null; t.send("eth_uninstallFilter", [n]) }).catch(t => { }) }(), n }).catch(t => { }) } _stopEvent(t) { "pending" === t.tag && 0 === this.listenerCount("pending") && (this._pendingFilter = null), super._stopEvent(t) } static hexlifyTransaction(t, e) { const n = (0, a.shallowCopy)(T); if (e) for (const i in e) e[i] && (n[i] = !0); (0, a.checkProperties)(t, n); const r = {}; return ["gasLimit", "gasPrice", "type", "nonce", "value"].forEach(function (e) { if (null == t[e]) return; const n = (0, s.hexValue)(t[e]); "gasLimit" === e && (e = "gas"), r[e] = n }), ["from", "to", "data"].forEach(function (e) { null != t[e] && (r[e] = (0, s.hexlify)(t[e])) }), t.accessList && (r.accessList = (0, c.accessListify)(t.accessList)), r } } }, 9267: (t, e, n) => { "use strict"; n.d(e, { Q: () => u }); var r = n(2275), i = n(3898), s = n(5102), o = n(1522); const a = new i.Logger(s.i); let l = 1; function c(t, e) { return function (n, r) { "eth_sign" == n && (t.isMetaMask || t.isStatus) && (n = "personal_sign", r = [r[1], r[0]]); const i = { method: n, params: r, id: l++, jsonrpc: "2.0" }; return new Promise((t, n) => { e(i, function (e, r) { if (e) return n(e); if (r.error) { const t = new Error(r.error.message); return t.code = r.error.code, t.data = r.error.data, n(t) } t(r.result) }) }) } } class u extends o.r { constructor(t, e) { a.checkNew(new.target, u), null == t && a.throwArgumentError("missing provider", "provider", t); let n = null, i = null, s = null; "function" == typeof t ? (n = "unknown:", i = t) : (n = t.host || t.path || "", !n && t.isMetaMask && (n = "metamask"), s = t, t.request ? ("" === n && (n = "eip-1193:"), i = function (t) { return function (e, n) { return null == n && (n = []), "eth_sign" == e && (t.isMetaMask || t.isStatus) && (e = "personal_sign", n = [n[1], n[0]]), t.request({ method: e, params: n }) } }(t)) : t.sendAsync ? i = c(t, t.sendAsync.bind(t)) : t.send ? i = c(t, t.send.bind(t)) : a.throwArgumentError("unsupported provider", "provider", t), n || (n = "unknown:")), super(n, e), (0, r.defineReadOnly)(this, "jsonRpcFetchFunc", i), (0, r.defineReadOnly)(this, "provider", s) } send(t, e) { return this.jsonRpcFetchFunc(t, e) } } }, 8859: (t, e, n) => { "use strict"; n.r(e), n.d(e, { randomBytes: () => r.O, shuffled: () => i.y }); var r = n(2563), i = n(4820) }, 2563: (t, e, n) => { "use strict"; n.d(e, { O: () => l }); var r = n(1488), i = n(3898); const s = new i.Logger("random/5.1.0"); let o = null; try { if (o = window, null == o) throw new Error("try next") } catch (c) { try { if (o = global, null == o) throw new Error("try next") } catch (c) { o = {} } } let a = o.crypto || o.msCrypto; function l(t) { (t <= 0 || t > 1024 || t % 1) && s.throwArgumentError("invalid length", "length", t); const e = new Uint8Array(t); return a.getRandomValues(e), (0, r.arrayify)(e) } a && a.getRandomValues || (s.warn("WARNING: Missing strong random number source"), a = { getRandomValues: function (t) { return s.throwError("no secure random source avaialble", i.Logger.errors.UNSUPPORTED_OPERATION, { operation: "crypto.getRandomValues" }) } }) }, 4820: (t, e, n) => { "use strict"; function r(t) { for (let e = (t = t.slice()).length - 1; e > 0; e--) { const n = Math.floor(Math.random() * (e + 1)), r = t[e]; t[e] = t[n], t[n] = r } return t } n.d(e, { y: () => r }) }, 9276: (t, e, n) => { "use strict"; n.r(e), n.d(e, { decode: () => d, encode: () => c }); var r = n(1488), i = n(3898); const s = new i.Logger("rlp/5.1.0"); function o(t) { const e = []; for (; t;)e.unshift(255 & t), t >>= 8; return e } function a(t, e, n) { let r = 0; for (let i = 0; i < n; i++)r = 256 * r + t[e + i]; return r } function l(t) { if (Array.isArray(t)) { let e = []; if (t.forEach(function (t) { e = e.concat(l(t)) }), e.length <= 55) return e.unshift(192 + e.length), e; const n = o(e.length); return n.unshift(247 + n.length), n.concat(e) } (0, r.isBytesLike)(t) || s.throwArgumentError("RLP object must be BytesLike", "object", t); const e = Array.prototype.slice.call((0, r.arrayify)(t)); if (1 === e.length && e[0] <= 127) return e; if (e.length <= 55) return e.unshift(128 + e.length), e; const n = o(e.length); return n.unshift(183 + n.length), n.concat(e) } function c(t) { return (0, r.hexlify)(l(t)) } function u(t, e, n, r) { const o = []; for (; n < e + 1 + r;) { const a = h(t, n); o.push(a.result), (n += a.consumed) > e + 1 + r && s.throwError("child data too short", i.Logger.errors.BUFFER_OVERRUN, {}) } return { consumed: 1 + r, result: o } } function h(t, e) { if (0 === t.length && s.throwError("data too short", i.Logger.errors.BUFFER_OVERRUN, {}), t[e] >= 248) { const n = t[e] - 247; e + 1 + n > t.length && s.throwError("data short segment too short", i.Logger.errors.BUFFER_OVERRUN, {}); const r = a(t, e + 1, n); return e + 1 + n + r > t.length && s.throwError("data long segment too short", i.Logger.errors.BUFFER_OVERRUN, {}), u(t, e, e + 1 + n, n + r) } if (t[e] >= 192) { const n = t[e] - 192; return e + 1 + n > t.length && s.throwError("data array too short", i.Logger.errors.BUFFER_OVERRUN, {}), u(t, e, e + 1, n) } if (t[e] >= 184) { const n = t[e] - 183; e + 1 + n > t.length && s.throwError("data array too short", i.Logger.errors.BUFFER_OVERRUN, {}); const o = a(t, e + 1, n); return e + 1 + n + o > t.length && s.throwError("data array too short", i.Logger.errors.BUFFER_OVERRUN, {}), { consumed: 1 + n + o, result: (0, r.hexlify)(t.slice(e + 1 + n, e + 1 + n + o)) } } if (t[e] >= 128) { const n = t[e] - 128; return e + 1 + n > t.length && s.throwError("data too short", i.Logger.errors.BUFFER_OVERRUN, {}), { consumed: 1 + n, result: (0, r.hexlify)(t.slice(e + 1, e + 1 + n)) } } return { consumed: 1, result: (0, r.hexlify)(t[e]) } } function d(t) { const e = (0, r.arrayify)(t), n = h(e, 0); return n.consumed !== e.length && s.throwArgumentError("invalid rlp data", "data", t), n.result } }, 7591: (t, e, n) => { "use strict"; n.r(e), n.d(e, { computeHmac: () => r.Gy, ripemd160: () => r.bP, sha256: () => r.JQ, sha512: () => r.o, SupportedAlgorithm: () => i.p }); var r = n(5614), i = n(3389) }, 5614: (t, e, n) => { "use strict"; n.d(e, { Gy: () => d, bP: () => c, JQ: () => u, o: () => h }); var r = n(8347), i = n.n(r), s = n(1488), o = n(3389), a = n(3898); const l = new a.Logger("sha2/5.1.0"); function c(t) { return "0x" + i().ripemd160().update((0, s.arrayify)(t)).digest("hex") } function u(t) { return "0x" + i().sha256().update((0, s.arrayify)(t)).digest("hex") } function h(t) { return "0x" + i().sha512().update((0, s.arrayify)(t)).digest("hex") } function d(t, e, n) { return o.p[t] || l.throwError("unsupported algorithm " + t, a.Logger.errors.UNSUPPORTED_OPERATION, { operation: "hmac", algorithm: t }), "0x" + i().hmac(i()[t], (0, s.arrayify)(e)).update((0, s.arrayify)(n)).digest("hex") } }, 3389: (t, e, n) => { "use strict"; n.d(e, { p: () => r }); var r = (() => (function (t) { t.sha256 = "sha256", t.sha512 = "sha512" }(r || (r = {})), r))() }, 8347: (t, e, n) => { var r = e; r.utils = n(1235), r.common = n(665), r.sha = n(2358), r.ripemd = n(8510), r.hmac = n(4332), r.sha1 = r.sha.sha1, r.sha256 = r.sha.sha256, r.sha224 = r.sha.sha224, r.sha384 = r.sha.sha384, r.sha512 = r.sha.sha512, r.ripemd160 = r.ripemd.ripemd160 }, 665: (t, e, n) => { "use strict"; var r = n(1235), i = n(6055); function s() { this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32 } e.BlockHash = s, s.prototype.update = function (t, e) { if (t = r.toArray(t, e), this.pending = this.pending ? this.pending.concat(t) : t, this.pendingTotal += t.length, this.pending.length >= this._delta8) { var n = (t = this.pending).length % this._delta8; this.pending = t.slice(t.length - n, t.length), 0 === this.pending.length && (this.pending = null), t = r.join32(t, 0, t.length - n, this.endian); for (var i = 0; i < t.length; i += this._delta32)this._update(t, i, i + this._delta32) } return this }, s.prototype.digest = function (t) { return this.update(this._pad()), i(null === this.pending), this._digest(t) }, s.prototype._pad = function () { var t = this.pendingTotal, e = this._delta8, n = e - (t + this.padLength) % e, r = new Array(n + this.padLength); r[0] = 128; for (var i = 1; i < n; i++)r[i] = 0; if (t <<= 3, "big" === this.endian) { for (var s = 8; s < this.padLength; s++)r[i++] = 0; r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = t >>> 24 & 255, r[i++] = t >>> 16 & 255, r[i++] = t >>> 8 & 255, r[i++] = 255 & t } else for (r[i++] = 255 & t, r[i++] = t >>> 8 & 255, r[i++] = t >>> 16 & 255, r[i++] = t >>> 24 & 255, r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = 0, s = 8; s < this.padLength; s++)r[i++] = 0; return r } }, 4332: (t, e, n) => { "use strict"; var r = n(1235), i = n(6055); function s(t, e, n) { if (!(this instanceof s)) return new s(t, e, n); this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(r.toArray(e, n)) } t.exports = s, s.prototype._init = function (t) { t.length > this.blockSize && (t = (new this.Hash).update(t).digest()), i(t.length <= this.blockSize); for (var e = t.length; e < this.blockSize; e++)t.push(0); for (e = 0; e < t.length; e++)t[e] ^= 54; for (this.inner = (new this.Hash).update(t), e = 0; e < t.length; e++)t[e] ^= 106; this.outer = (new this.Hash).update(t) }, s.prototype.update = function (t, e) { return this.inner.update(t, e), this }, s.prototype.digest = function (t) { return this.outer.update(this.inner.digest()), this.outer.digest(t) } }, 8510: (t, e, n) => { "use strict"; var r = n(1235), i = n(665), s = r.rotl32, o = r.sum32, a = r.sum32_3, l = r.sum32_4, c = i.BlockHash; function u() { if (!(this instanceof u)) return new u; c.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little" } function h(t, e, n, r) { return t <= 15 ? e ^ n ^ r : t <= 31 ? e & n | ~e & r : t <= 47 ? (e | ~n) ^ r : t <= 63 ? e & r | n & ~r : e ^ (n | ~r) } function d(t) { return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838 } function p(t) { return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0 } r.inherits(u, c), e.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function (t, e) { for (var n = this.h[0], r = this.h[1], i = this.h[2], c = this.h[3], u = this.h[4], y = n, b = r, _ = i, w = c, S = u, x = 0; x < 80; x++) { var T = o(s(l(n, h(x, r, i, c), t[f[x] + e], d(x)), g[x]), u); n = u, u = c, c = s(i, 10), i = r, r = T, T = o(s(l(y, h(79 - x, b, _, w), t[m[x] + e], p(x)), v[x]), S), y = S, S = w, w = s(_, 10), _ = b, b = T } T = a(this.h[1], i, w), this.h[1] = a(this.h[2], c, S), this.h[2] = a(this.h[3], u, y), this.h[3] = a(this.h[4], n, b), this.h[4] = a(this.h[0], r, _), this.h[0] = T }, u.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h, "little") : r.split32(this.h, "little") }; var f = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], m = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], g = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], v = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11] }, 2358: (t, e, n) => { "use strict"; e.sha1 = n(4283), e.sha224 = n(6678), e.sha256 = n(2725), e.sha384 = n(1461), e.sha512 = n(8161) }, 4283: (t, e, n) => { "use strict"; var r = n(1235), i = n(665), s = n(7006), o = r.rotl32, a = r.sum32, l = r.sum32_5, c = s.ft_1, u = i.BlockHash, h = [1518500249, 1859775393, 2400959708, 3395469782]; function d() { if (!(this instanceof d)) return new d; u.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80) } r.inherits(d, u), t.exports = d, d.blockSize = 512, d.outSize = 160, d.hmacStrength = 80, d.padLength = 64, d.prototype._update = function (t, e) { for (var n = this.W, r = 0; r < 16; r++)n[r] = t[e + r]; for (; r < n.length; r++)n[r] = o(n[r - 3] ^ n[r - 8] ^ n[r - 14] ^ n[r - 16], 1); var i = this.h[0], s = this.h[1], u = this.h[2], d = this.h[3], p = this.h[4]; for (r = 0; r < n.length; r++) { var f = ~~(r / 20), m = l(o(i, 5), c(f, s, u, d), p, n[r], h[f]); p = d, d = u, u = o(s, 30), s = i, i = m } this.h[0] = a(this.h[0], i), this.h[1] = a(this.h[1], s), this.h[2] = a(this.h[2], u), this.h[3] = a(this.h[3], d), this.h[4] = a(this.h[4], p) }, d.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h, "big") : r.split32(this.h, "big") } }, 6678: (t, e, n) => { "use strict"; var r = n(1235), i = n(2725); function s() { if (!(this instanceof s)) return new s; i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428] } r.inherits(s, i), t.exports = s, s.blockSize = 512, s.outSize = 224, s.hmacStrength = 192, s.padLength = 64, s.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h.slice(0, 7), "big") : r.split32(this.h.slice(0, 7), "big") } }, 2725: (t, e, n) => { "use strict"; var r = n(1235), i = n(665), s = n(7006), o = n(6055), a = r.sum32, l = r.sum32_4, c = r.sum32_5, u = s.ch32, h = s.maj32, d = s.s0_256, p = s.s1_256, f = s.g0_256, m = s.g1_256, g = i.BlockHash, v = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]; function y() { if (!(this instanceof y)) return new y; g.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = v, this.W = new Array(64) } r.inherits(y, g), t.exports = y, y.blockSize = 512, y.outSize = 256, y.hmacStrength = 192, y.padLength = 64, y.prototype._update = function (t, e) { for (var n = this.W, r = 0; r < 16; r++)n[r] = t[e + r]; for (; r < n.length; r++)n[r] = l(m(n[r - 2]), n[r - 7], f(n[r - 15]), n[r - 16]); var i = this.h[0], s = this.h[1], g = this.h[2], v = this.h[3], y = this.h[4], b = this.h[5], _ = this.h[6], w = this.h[7]; for (o(this.k.length === n.length), r = 0; r < n.length; r++) { var S = c(w, p(y), u(y, b, _), this.k[r], n[r]), x = a(d(i), h(i, s, g)); w = _, _ = b, b = y, y = a(v, S), v = g, g = s, s = i, i = a(S, x) } this.h[0] = a(this.h[0], i), this.h[1] = a(this.h[1], s), this.h[2] = a(this.h[2], g), this.h[3] = a(this.h[3], v), this.h[4] = a(this.h[4], y), this.h[5] = a(this.h[5], b), this.h[6] = a(this.h[6], _), this.h[7] = a(this.h[7], w) }, y.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h, "big") : r.split32(this.h, "big") } }, 1461: (t, e, n) => { "use strict"; var r = n(1235), i = n(8161); function s() { if (!(this instanceof s)) return new s; i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428] } r.inherits(s, i), t.exports = s, s.blockSize = 1024, s.outSize = 384, s.hmacStrength = 192, s.padLength = 128, s.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h.slice(0, 12), "big") : r.split32(this.h.slice(0, 12), "big") } }, 8161: (t, e, n) => { "use strict"; var r = n(1235), i = n(665), s = n(6055), o = r.rotr64_hi, a = r.rotr64_lo, l = r.shr64_hi, c = r.shr64_lo, u = r.sum64, h = r.sum64_hi, d = r.sum64_lo, p = r.sum64_4_hi, f = r.sum64_4_lo, m = r.sum64_5_hi, g = r.sum64_5_lo, v = i.BlockHash, y = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]; function b() { if (!(this instanceof b)) return new b; v.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = y, this.W = new Array(160) } function _(t, e, n, r, i) { var s = t & n ^ ~t & i; return s < 0 && (s += 4294967296), s } function w(t, e, n, r, i, s) { var o = e & r ^ ~e & s; return o < 0 && (o += 4294967296), o } function S(t, e, n, r, i) { var s = t & n ^ t & i ^ n & i; return s < 0 && (s += 4294967296), s } function x(t, e, n, r, i, s) { var o = e & r ^ e & s ^ r & s; return o < 0 && (o += 4294967296), o } function T(t, e) { var n = o(t, e, 28) ^ o(e, t, 2) ^ o(e, t, 7); return n < 0 && (n += 4294967296), n } function E(t, e) { var n = a(t, e, 28) ^ a(e, t, 2) ^ a(e, t, 7); return n < 0 && (n += 4294967296), n } function M(t, e) { var n = a(t, e, 14) ^ a(t, e, 18) ^ a(e, t, 9); return n < 0 && (n += 4294967296), n } function A(t, e) { var n = o(t, e, 1) ^ o(t, e, 8) ^ l(t, e, 7); return n < 0 && (n += 4294967296), n } function C(t, e) { var n = a(t, e, 1) ^ a(t, e, 8) ^ c(t, e, 7); return n < 0 && (n += 4294967296), n } function P(t, e) { var n = a(t, e, 19) ^ a(e, t, 29) ^ c(t, e, 6); return n < 0 && (n += 4294967296), n } r.inherits(b, v), t.exports = b, b.blockSize = 1024, b.outSize = 512, b.hmacStrength = 192, b.padLength = 128, b.prototype._prepareBlock = function (t, e) { for (var n = this.W, r = 0; r < 32; r++)n[r] = t[e + r]; for (; r < n.length; r += 2) { var i = (y = void 0, (y = o(g = n[r - 4], v = n[r - 3], 19) ^ o(v, g, 29) ^ l(g, v, 6)) < 0 && (y += 4294967296), y), s = P(n[r - 4], n[r - 3]), a = n[r - 14], c = n[r - 13], u = A(n[r - 30], n[r - 29]), h = C(n[r - 30], n[r - 29]), d = n[r - 32], m = n[r - 31]; n[r] = p(i, s, a, c, u, h, d, m), n[r + 1] = f(i, s, a, c, u, h, d, m) } var g, v, y }, b.prototype._update = function (t, e) { this._prepareBlock(t, e); var n, r, i, a = this.W, l = this.h[0], c = this.h[1], p = this.h[2], f = this.h[3], v = this.h[4], y = this.h[5], b = this.h[6], A = this.h[7], C = this.h[8], P = this.h[9], R = this.h[10], L = this.h[11], k = this.h[12], D = this.h[13], I = this.h[14], O = this.h[15]; s(this.k.length === a.length); for (var F = 0; F < a.length; F += 2) { var N = I, B = O, H = (i = void 0, (i = o(n = C, r = P, 14) ^ o(n, r, 18) ^ o(r, n, 9)) < 0 && (i += 4294967296), i), U = M(C, P), G = _(C, 0, R, 0, k), V = w(0, P, 0, L, 0, D), z = this.k[F], j = this.k[F + 1], J = a[F], X = a[F + 1], W = m(N, B, H, U, G, V, z, j, J, X), q = g(N, B, H, U, G, V, z, j, J, X); N = T(l, c), B = E(l, c), H = S(l, 0, p, 0, v), U = x(0, c, 0, f, 0, y); var Z = h(N, B, H, U), K = d(N, B, H, U); I = k, O = D, k = R, D = L, R = C, L = P, C = h(b, A, W, q), P = d(A, A, W, q), b = v, A = y, v = p, y = f, p = l, f = c, l = h(W, q, Z, K), c = d(W, q, Z, K) } u(this.h, 0, l, c), u(this.h, 2, p, f), u(this.h, 4, v, y), u(this.h, 6, b, A), u(this.h, 8, C, P), u(this.h, 10, R, L), u(this.h, 12, k, D), u(this.h, 14, I, O) }, b.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h, "big") : r.split32(this.h, "big") } }, 7006: (t, e, n) => { "use strict"; var r = n(1235).rotr32; function i(t, e, n) { return t & e ^ ~t & n } function s(t, e, n) { return t & e ^ t & n ^ e & n } function o(t, e, n) { return t ^ e ^ n } e.ft_1 = function (t, e, n, r) { return 0 === t ? i(e, n, r) : 1 === t || 3 === t ? o(e, n, r) : 2 === t ? s(e, n, r) : void 0 }, e.ch32 = i, e.maj32 = s, e.p32 = o, e.s0_256 = function (t) { return r(t, 2) ^ r(t, 13) ^ r(t, 22) }, e.s1_256 = function (t) { return r(t, 6) ^ r(t, 11) ^ r(t, 25) }, e.g0_256 = function (t) { return r(t, 7) ^ r(t, 18) ^ t >>> 3 }, e.g1_256 = function (t) { return r(t, 17) ^ r(t, 19) ^ t >>> 10 } }, 1235: (t, e, n) => { "use strict"; var r = n(6055), i = n(9879); function s(t) { return (t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (255 & t) << 24) >>> 0 } function o(t) { return 1 === t.length ? "0" + t : t } function a(t) { return 7 === t.length ? "0" + t : 6 === t.length ? "00" + t : 5 === t.length ? "000" + t : 4 === t.length ? "0000" + t : 3 === t.length ? "00000" + t : 2 === t.length ? "000000" + t : 1 === t.length ? "0000000" + t : t } e.inherits = i, e.toArray = function (t, e) { if (Array.isArray(t)) return t.slice(); if (!t) return []; var n = []; if ("string" == typeof t) if (e) { if ("hex" === e) for ((t = t.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t = "0" + t), r = 0; r < t.length; r += 2)n.push(parseInt(t[r] + t[r + 1], 16)) } else for (var r = 0; r < t.length; r++) { var i = t.charCodeAt(r), s = i >> 8, o = 255 & i; s ? n.push(s, o) : n.push(o) } else for (r = 0; r < t.length; r++)n[r] = 0 | t[r]; return n }, e.toHex = function (t) { for (var e = "", n = 0; n < t.length; n++)e += o(t[n].toString(16)); return e }, e.htonl = s, e.toHex32 = function (t, e) { for (var n = "", r = 0; r < t.length; r++) { var i = t[r]; "little" === e && (i = s(i)), n += a(i.toString(16)) } return n }, e.zero2 = o, e.zero8 = a, e.join32 = function (t, e, n, i) { var s = n - e; r(s % 4 == 0); for (var o = new Array(s / 4), a = 0, l = e; a < o.length; a++, l += 4)o[a] = ("big" === i ? t[l] << 24 | t[l + 1] << 16 | t[l + 2] << 8 | t[l + 3] : t[l + 3] << 24 | t[l + 2] << 16 | t[l + 1] << 8 | t[l]) >>> 0; return o }, e.split32 = function (t, e) { for (var n = new Array(4 * t.length), r = 0, i = 0; r < t.length; r++, i += 4) { var s = t[r]; "big" === e ? (n[i] = s >>> 24, n[i + 1] = s >>> 16 & 255, n[i + 2] = s >>> 8 & 255, n[i + 3] = 255 & s) : (n[i + 3] = s >>> 24, n[i + 2] = s >>> 16 & 255, n[i + 1] = s >>> 8 & 255, n[i] = 255 & s) } return n }, e.rotr32 = function (t, e) { return t >>> e | t << 32 - e }, e.rotl32 = function (t, e) { return t << e | t >>> 32 - e }, e.sum32 = function (t, e) { return t + e >>> 0 }, e.sum32_3 = function (t, e, n) { return t + e + n >>> 0 }, e.sum32_4 = function (t, e, n, r) { return t + e + n + r >>> 0 }, e.sum32_5 = function (t, e, n, r, i) { return t + e + n + r + i >>> 0 }, e.sum64 = function (t, e, n, r) { var i = r + t[e + 1] >>> 0; t[e] = (i < r ? 1 : 0) + n + t[e] >>> 0, t[e + 1] = i }, e.sum64_hi = function (t, e, n, r) { return (e + r >>> 0 < e ? 1 : 0) + t + n >>> 0 }, e.sum64_lo = function (t, e, n, r) { return e + r >>> 0 }, e.sum64_4_hi = function (t, e, n, r, i, s, o, a) { var l = 0, c = e; return l += (c = c + r >>> 0) < e ? 1 : 0, l += (c = c + s >>> 0) < s ? 1 : 0, t + n + i + o + (l += (c = c + a >>> 0) < a ? 1 : 0) >>> 0 }, e.sum64_4_lo = function (t, e, n, r, i, s, o, a) { return e + r + s + a >>> 0 }, e.sum64_5_hi = function (t, e, n, r, i, s, o, a, l, c) { var u = 0, h = e; return u += (h = h + r >>> 0) < e ? 1 : 0, u += (h = h + s >>> 0) < s ? 1 : 0, u += (h = h + a >>> 0) < a ? 1 : 0, t + n + i + o + l + (u += (h = h + c >>> 0) < c ? 1 : 0) >>> 0 }, e.sum64_5_lo = function (t, e, n, r, i, s, o, a, l, c) { return e + r + s + a + c >>> 0 }, e.rotr64_hi = function (t, e, n) { return (e << 32 - n | t >>> n) >>> 0 }, e.rotr64_lo = function (t, e, n) { return (t << 32 - n | e >>> n) >>> 0 }, e.shr64_hi = function (t, e, n) { return t >>> n }, e.shr64_lo = function (t, e, n) { return (t << 32 - n | e >>> n) >>> 0 } }, 9596: (t, e, n) => { "use strict"; n.r(e), n.d(e, { SigningKey: () => q, computePublicKey: () => K, recoverPublicKey: () => Z }); var r = n(3061), i = n.n(r), s = n(7909), o = n.n(s); function a(t, e, n) { return t(n = { path: e, exports: {}, require: function (t, e) { return function () { throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs") }() } }, n.exports), n.exports } "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; var l = c; function c(t, e) { if (!t) throw new Error(e || "Assertion failed") } c.equal = function (t, e, n) { if (t != e) throw new Error(n || "Assertion failed: " + t + " != " + e) }; var u = a(function (t, e) { var n = e; function r(t) { return 1 === t.length ? "0" + t : t } function i(t) { for (var e = "", n = 0; n < t.length; n++)e += r(t[n].toString(16)); return e } n.toArray = function (t, e) { if (Array.isArray(t)) return t.slice(); if (!t) return []; var n = []; if ("string" != typeof t) { for (var r = 0; r < t.length; r++)n[r] = 0 | t[r]; return n } if ("hex" === e) for ((t = t.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t = "0" + t), r = 0; r < t.length; r += 2)n.push(parseInt(t[r] + t[r + 1], 16)); else for (r = 0; r < t.length; r++) { var i = t.charCodeAt(r), s = i >> 8, o = 255 & i; s ? n.push(s, o) : n.push(o) } return n }, n.zero2 = r, n.toHex = i, n.encode = function (t, e) { return "hex" === e ? i(t) : t } }), h = a(function (t, e) { var n = e; n.assert = l, n.toArray = u.toArray, n.zero2 = u.zero2, n.toHex = u.toHex, n.encode = u.encode, n.getNAF = function (t, e, n) { var r = new Array(Math.max(t.bitLength(), n) + 1); r.fill(0); for (var i = 1 << e + 1, s = t.clone(), o = 0; o < r.length; o++) { var a, l = s.andln(i - 1); s.isOdd() ? s.isubn(a = l > (i >> 1) - 1 ? (i >> 1) - l : l) : a = 0, r[o] = a, s.iushrn(1) } return r }, n.getJSF = function (t, e) { var n = [[], []]; t = t.clone(), e = e.clone(); for (var r, i = 0, s = 0; t.cmpn(-i) > 0 || e.cmpn(-s) > 0;) { var o, a, l = t.andln(3) + i & 3, c = e.andln(3) + s & 3; 3 === l && (l = -1), 3 === c && (c = -1), o = 0 == (1 & l) ? 0 : 3 != (r = t.andln(7) + i & 7) && 5 !== r || 2 !== c ? l : -l, n[0].push(o), a = 0 == (1 & c) ? 0 : 3 != (r = e.andln(7) + s & 7) && 5 !== r || 2 !== l ? c : -c, n[1].push(a), 2 * i === o + 1 && (i = 1 - i), 2 * s === a + 1 && (s = 1 - s), t.iushrn(1), e.iushrn(1) } return n }, n.cachedProperty = function (t, e, n) { var r = "_" + e; t.prototype[e] = function () { return void 0 !== this[r] ? this[r] : this[r] = n.call(this) } }, n.parseBytes = function (t) { return "string" == typeof t ? n.toArray(t, "hex") : t }, n.intFromLE = function (t) { return new (i())(t, "hex", "le") } }), d = h.getNAF, p = h.getJSF, f = h.assert; function m(t, e) { this.type = t, this.p = new (i())(e.p, 16), this.red = e.prime ? i().red(e.prime) : i().mont(this.p), this.zero = new (i())(0).toRed(this.red), this.one = new (i())(1).toRed(this.red), this.two = new (i())(2).toRed(this.red), this.n = e.n && new (i())(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0; var n = this.n && this.p.div(this.n); !n || n.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red)) } var g = m; function v(t, e) { this.curve = t, this.type = e, this.precomputed = null } m.prototype.point = function () { throw new Error("Not implemented") }, m.prototype.validate = function () { throw new Error("Not implemented") }, m.prototype._fixedNafMul = function (t, e) { f(t.precomputed); var n = t._getDoubles(), r = d(e, 1, this._bitLength), i = (1 << n.step + 1) - (n.step % 2 == 0 ? 2 : 1); i /= 3; var s, o, a = []; for (s = 0; s < r.length; s += n.step) { o = 0; for (var l = s + n.step - 1; l >= s; l--)o = (o << 1) + r[l]; a.push(o) } for (var c = this.jpoint(null, null, null), u = this.jpoint(null, null, null), h = i; h > 0; h--) { for (s = 0; s < a.length; s++)(o = a[s]) === h ? u = u.mixedAdd(n.points[s]) : o === -h && (u = u.mixedAdd(n.points[s].neg())); c = c.add(u) } return c.toP() }, m.prototype._wnafMul = function (t, e) { for (var n = 4, r = t._getNAFPoints(n), i = r.points, s = d(e, n = r.wnd, this._bitLength), o = this.jpoint(null, null, null), a = s.length - 1; a >= 0; a--) { for (var l = 0; a >= 0 && 0 === s[a]; a--)l++; if (a >= 0 && l++, o = o.dblp(l), a < 0) break; var c = s[a]; f(0 !== c), o = "affine" === t.type ? o.mixedAdd(c > 0 ? i[c - 1 >> 1] : i[-c - 1 >> 1].neg()) : o.add(c > 0 ? i[c - 1 >> 1] : i[-c - 1 >> 1].neg()) } return "affine" === t.type ? o.toP() : o }, m.prototype._wnafMulAdd = function (t, e, n, r, i) { var s, o, a, l = this._wnafT1, c = this._wnafT2, u = this._wnafT3, h = 0; for (s = 0; s < r; s++) { var f = (a = e[s])._getNAFPoints(t); l[s] = f.wnd, c[s] = f.points } for (s = r - 1; s >= 1; s -= 2) { var m = s - 1, g = s; if (1 === l[m] && 1 === l[g]) { var v = [e[m], null, null, e[g]]; 0 === e[m].y.cmp(e[g].y) ? (v[1] = e[m].add(e[g]), v[2] = e[m].toJ().mixedAdd(e[g].neg())) : 0 === e[m].y.cmp(e[g].y.redNeg()) ? (v[1] = e[m].toJ().mixedAdd(e[g]), v[2] = e[m].add(e[g].neg())) : (v[1] = e[m].toJ().mixedAdd(e[g]), v[2] = e[m].toJ().mixedAdd(e[g].neg())); var y = [-3, -1, -5, -7, 0, 7, 5, 1, 3], b = p(n[m], n[g]); for (h = Math.max(b[0].length, h), u[m] = new Array(h), u[g] = new Array(h), o = 0; o < h; o++)u[m][o] = y[3 * (1 + (0 | b[0][o])) + (1 + (0 | b[1][o]))], u[g][o] = 0, c[m] = v } else u[m] = d(n[m], l[m], this._bitLength), u[g] = d(n[g], l[g], this._bitLength), h = Math.max(u[m].length, h), h = Math.max(u[g].length, h) } var _ = this.jpoint(null, null, null), w = this._wnafT4; for (s = h; s >= 0; s--) { for (var S = 0; s >= 0;) { var x = !0; for (o = 0; o < r; o++)w[o] = 0 | u[o][s], 0 !== w[o] && (x = !1); if (!x) break; S++, s-- } if (s >= 0 && S++, _ = _.dblp(S), s < 0) break; for (o = 0; o < r; o++) { var T = w[o]; 0 !== T && (T > 0 ? a = c[o][T - 1 >> 1] : T < 0 && (a = c[o][-T - 1 >> 1].neg()), _ = "affine" === a.type ? _.mixedAdd(a) : _.add(a)) } } for (s = 0; s < r; s++)c[s] = null; return i ? _ : _.toP() }, m.BasePoint = v, v.prototype.eq = function () { throw new Error("Not implemented") }, v.prototype.validate = function () { return this.curve.validate(this) }, m.prototype.decodePoint = function (t, e) { t = h.toArray(t, e); var n = this.p.byteLength(); if ((4 === t[0] || 6 === t[0] || 7 === t[0]) && t.length - 1 == 2 * n) return 6 === t[0] ? f(t[t.length - 1] % 2 == 0) : 7 === t[0] && f(t[t.length - 1] % 2 == 1), this.point(t.slice(1, 1 + n), t.slice(1 + n, 1 + 2 * n)); if ((2 === t[0] || 3 === t[0]) && t.length - 1 === n) return this.pointFromX(t.slice(1, 1 + n), 3 === t[0]); throw new Error("Unknown point format") }, v.prototype.encodeCompressed = function (t) { return this.encode(t, !0) }, v.prototype._encode = function (t) { var e = this.curve.p.byteLength(), n = this.getX().toArray("be", e); return t ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", e)) }, v.prototype.encode = function (t, e) { return h.encode(this._encode(e), t) }, v.prototype.precompute = function (t) { if (this.precomputed) return this; var e = { doubles: null, naf: null, beta: null }; return e.naf = this._getNAFPoints(8), e.doubles = this._getDoubles(4, t), e.beta = this._getBeta(), this.precomputed = e, this }, v.prototype._hasDoubles = function (t) { if (!this.precomputed) return !1; var e = this.precomputed.doubles; return !!e && e.points.length >= Math.ceil((t.bitLength() + 1) / e.step) }, v.prototype._getDoubles = function (t, e) { if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles; for (var n = [this], r = this, i = 0; i < e; i += t) { for (var s = 0; s < t; s++)r = r.dbl(); n.push(r) } return { step: t, points: n } }, v.prototype._getNAFPoints = function (t) { if (this.precomputed && this.precomputed.naf) return this.precomputed.naf; for (var e = [this], n = (1 << t) - 1, r = 1 === n ? null : this.dbl(), i = 1; i < n; i++)e[i] = e[i - 1].add(r); return { wnd: t, points: e } }, v.prototype._getBeta = function () { return null }, v.prototype.dblp = function (t) { for (var e = this, n = 0; n < t; n++)e = e.dbl(); return e }; var y = a(function (t) { t.exports = "function" == typeof Object.create ? function (t, e) { e && (t.super_ = e, t.prototype = Object.create(e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } })) } : function (t, e) { if (e) { t.super_ = e; var n = function () { }; n.prototype = e.prototype, t.prototype = new n, t.prototype.constructor = t } } }), b = h.assert; function _(t) { g.call(this, "short", t), this.a = new (i())(t.a, 16).toRed(this.red), this.b = new (i())(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4) } y(_, g); var w = _; function S(t, e, n, r) { g.BasePoint.call(this, t, "affine"), null === e && null === n ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new (i())(e, 16), this.y = new (i())(n, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1) } function x(t, e, n, r) { g.BasePoint.call(this, t, "jacobian"), null === e && null === n && null === r ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new (i())(0)) : (this.x = new (i())(e, 16), this.y = new (i())(n, 16), this.z = new (i())(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one } _.prototype._getEndomorphism = function (t) { if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) { var e, n; if (t.beta) e = new (i())(t.beta, 16).toRed(this.red); else { var r = this._getEndoRoots(this.p); e = (e = r[0].cmp(r[1]) < 0 ? r[0] : r[1]).toRed(this.red) } if (t.lambda) n = new (i())(t.lambda, 16); else { var s = this._getEndoRoots(this.n); 0 === this.g.mul(s[0]).x.cmp(this.g.x.redMul(e)) ? n = s[0] : b(0 === this.g.mul(n = s[1]).x.cmp(this.g.x.redMul(e))) } return { beta: e, lambda: n, basis: t.basis ? t.basis.map(function (t) { return { a: new (i())(t.a, 16), b: new (i())(t.b, 16) } }) : this._getEndoBasis(n) } } }, _.prototype._getEndoRoots = function (t) { var e = t === this.p ? this.red : i().mont(t), n = new (i())(2).toRed(e).redInvm(), r = n.redNeg(), s = new (i())(3).toRed(e).redNeg().redSqrt().redMul(n); return [r.redAdd(s).fromRed(), r.redSub(s).fromRed()] }, _.prototype._getEndoBasis = function (t) { for (var e, n, r, s, o, a, l, c, u, h = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), d = t, p = this.n.clone(), f = new (i())(1), m = new (i())(0), g = new (i())(0), v = new (i())(1), y = 0; 0 !== d.cmpn(0);) { var b = p.div(d); c = p.sub(b.mul(d)), u = g.sub(b.mul(f)); var _ = v.sub(b.mul(m)); if (!r && c.cmp(h) < 0) e = l.neg(), n = f, r = c.neg(), s = u; else if (r && 2 == ++y) break; l = c, p = d, d = c, g = f, f = u, v = m, m = _ } o = c.neg(), a = u; var w = r.sqr().add(s.sqr()); return o.sqr().add(a.sqr()).cmp(w) >= 0 && (o = e, a = n), r.negative && (r = r.neg(), s = s.neg()), o.negative && (o = o.neg(), a = a.neg()), [{ a: r, b: s }, { a: o, b: a }] }, _.prototype._endoSplit = function (t) { var e = this.endo.basis, n = e[0], r = e[1], i = r.b.mul(t).divRound(this.n), s = n.b.neg().mul(t).divRound(this.n), o = i.mul(n.a), a = s.mul(r.a), l = i.mul(n.b), c = s.mul(r.b); return { k1: t.sub(o).sub(a), k2: l.add(c).neg() } }, _.prototype.pointFromX = function (t, e) { (t = new (i())(t, 16)).red || (t = t.toRed(this.red)); var n = t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b), r = n.redSqrt(); if (0 !== r.redSqr().redSub(n).cmp(this.zero)) throw new Error("invalid point"); var s = r.fromRed().isOdd(); return (e && !s || !e && s) && (r = r.redNeg()), this.point(t, r) }, _.prototype.validate = function (t) { if (t.inf) return !0; var e = t.x, n = t.y, r = this.a.redMul(e), i = e.redSqr().redMul(e).redIAdd(r).redIAdd(this.b); return 0 === n.redSqr().redISub(i).cmpn(0) }, _.prototype._endoWnafMulAdd = function (t, e, n) { for (var r = this._endoWnafT1, i = this._endoWnafT2, s = 0; s < t.length; s++) { var o = this._endoSplit(e[s]), a = t[s], l = a._getBeta(); o.k1.negative && (o.k1.ineg(), a = a.neg(!0)), o.k2.negative && (o.k2.ineg(), l = l.neg(!0)), r[2 * s] = a, r[2 * s + 1] = l, i[2 * s] = o.k1, i[2 * s + 1] = o.k2 } for (var c = this._wnafMulAdd(1, r, i, 2 * s, n), u = 0; u < 2 * s; u++)r[u] = null, i[u] = null; return c }, y(S, g.BasePoint), _.prototype.point = function (t, e, n) { return new S(this, t, e, n) }, _.prototype.pointFromJSON = function (t, e) { return S.fromJSON(this, t, e) }, S.prototype._getBeta = function () { if (this.curve.endo) { var t = this.precomputed; if (t && t.beta) return t.beta; var e = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y); if (t) { var n = this.curve, r = function (t) { return n.point(t.x.redMul(n.endo.beta), t.y) }; t.beta = e, e.precomputed = { beta: null, naf: t.naf && { wnd: t.naf.wnd, points: t.naf.points.map(r) }, doubles: t.doubles && { step: t.doubles.step, points: t.doubles.points.map(r) } } } return e } }, S.prototype.toJSON = function () { return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y] }, S.fromJSON = function (t, e, n) { "string" == typeof e && (e = JSON.parse(e)); var r = t.point(e[0], e[1], n); if (!e[2]) return r; function i(e) { return t.point(e[0], e[1], n) } var s = e[2]; return r.precomputed = { beta: null, doubles: s.doubles && { step: s.doubles.step, points: [r].concat(s.doubles.points.map(i)) }, naf: s.naf && { wnd: s.naf.wnd, points: [r].concat(s.naf.points.map(i)) } }, r }, S.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">" }, S.prototype.isInfinity = function () { return this.inf }, S.prototype.add = function (t) { if (this.inf) return t; if (t.inf) return this; if (this.eq(t)) return this.dbl(); if (this.neg().eq(t)) return this.curve.point(null, null); if (0 === this.x.cmp(t.x)) return this.curve.point(null, null); var e = this.y.redSub(t.y); 0 !== e.cmpn(0) && (e = e.redMul(this.x.redSub(t.x).redInvm())); var n = e.redSqr().redISub(this.x).redISub(t.x), r = e.redMul(this.x.redSub(n)).redISub(this.y); return this.curve.point(n, r) }, S.prototype.dbl = function () { if (this.inf) return this; var t = this.y.redAdd(this.y); if (0 === t.cmpn(0)) return this.curve.point(null, null); var e = this.curve.a, n = this.x.redSqr(), r = t.redInvm(), i = n.redAdd(n).redIAdd(n).redIAdd(e).redMul(r), s = i.redSqr().redISub(this.x.redAdd(this.x)), o = i.redMul(this.x.redSub(s)).redISub(this.y); return this.curve.point(s, o) }, S.prototype.getX = function () { return this.x.fromRed() }, S.prototype.getY = function () { return this.y.fromRed() }, S.prototype.mul = function (t) { return t = new (i())(t, 16), this.isInfinity() ? this : this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [t]) : this.curve._wnafMul(this, t) }, S.prototype.mulAdd = function (t, e, n) { var r = [this, e], i = [t, n]; return this.curve.endo ? this.curve._endoWnafMulAdd(r, i) : this.curve._wnafMulAdd(1, r, i, 2) }, S.prototype.jmulAdd = function (t, e, n) { var r = [this, e], i = [t, n]; return this.curve.endo ? this.curve._endoWnafMulAdd(r, i, !0) : this.curve._wnafMulAdd(1, r, i, 2, !0) }, S.prototype.eq = function (t) { return this === t || this.inf === t.inf && (this.inf || 0 === this.x.cmp(t.x) && 0 === this.y.cmp(t.y)) }, S.prototype.neg = function (t) { if (this.inf) return this; var e = this.curve.point(this.x, this.y.redNeg()); if (t && this.precomputed) { var n = this.precomputed, r = function (t) { return t.neg() }; e.precomputed = { naf: n.naf && { wnd: n.naf.wnd, points: n.naf.points.map(r) }, doubles: n.doubles && { step: n.doubles.step, points: n.doubles.points.map(r) } } } return e }, S.prototype.toJ = function () { return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one) }, y(x, g.BasePoint), _.prototype.jpoint = function (t, e, n) { return new x(this, t, e, n) }, x.prototype.toP = function () { if (this.isInfinity()) return this.curve.point(null, null); var t = this.z.redInvm(), e = t.redSqr(), n = this.x.redMul(e), r = this.y.redMul(e).redMul(t); return this.curve.point(n, r) }, x.prototype.neg = function () { return this.curve.jpoint(this.x, this.y.redNeg(), this.z) }, x.prototype.add = function (t) { if (this.isInfinity()) return t; if (t.isInfinity()) return this; var e = t.z.redSqr(), n = this.z.redSqr(), r = this.x.redMul(e), i = t.x.redMul(n), s = this.y.redMul(e.redMul(t.z)), o = t.y.redMul(n.redMul(this.z)), a = r.redSub(i), l = s.redSub(o); if (0 === a.cmpn(0)) return 0 !== l.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl(); var c = a.redSqr(), u = c.redMul(a), h = r.redMul(c), d = l.redSqr().redIAdd(u).redISub(h).redISub(h), p = l.redMul(h.redISub(d)).redISub(s.redMul(u)), f = this.z.redMul(t.z).redMul(a); return this.curve.jpoint(d, p, f) }, x.prototype.mixedAdd = function (t) { if (this.isInfinity()) return t.toJ(); if (t.isInfinity()) return this; var e = this.z.redSqr(), n = this.x, r = t.x.redMul(e), i = this.y, s = t.y.redMul(e).redMul(this.z), o = n.redSub(r), a = i.redSub(s); if (0 === o.cmpn(0)) return 0 !== a.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl(); var l = o.redSqr(), c = l.redMul(o), u = n.redMul(l), h = a.redSqr().redIAdd(c).redISub(u).redISub(u), d = a.redMul(u.redISub(h)).redISub(i.redMul(c)), p = this.z.redMul(o); return this.curve.jpoint(h, d, p) }, x.prototype.dblp = function (t) { if (0 === t) return this; if (this.isInfinity()) return this; if (!t) return this.dbl(); var e; if (this.curve.zeroA || this.curve.threeA) { var n = this; for (e = 0; e < t; e++)n = n.dbl(); return n } var r = this.curve.a, i = this.curve.tinv, s = this.x, o = this.y, a = this.z, l = a.redSqr().redSqr(), c = o.redAdd(o); for (e = 0; e < t; e++) { var u = s.redSqr(), h = c.redSqr(), d = h.redSqr(), p = u.redAdd(u).redIAdd(u).redIAdd(r.redMul(l)), f = s.redMul(h), m = p.redSqr().redISub(f.redAdd(f)), g = f.redISub(m), v = p.redMul(g); v = v.redIAdd(v).redISub(d); var y = c.redMul(a); e + 1 < t && (l = l.redMul(d)), s = m, a = y, c = v } return this.curve.jpoint(s, c.redMul(i), a) }, x.prototype.dbl = function () { return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl() }, x.prototype._zeroDbl = function () { var t, e, n; if (this.zOne) { var r = this.x.redSqr(), i = this.y.redSqr(), s = i.redSqr(), o = this.x.redAdd(i).redSqr().redISub(r).redISub(s); o = o.redIAdd(o); var a = r.redAdd(r).redIAdd(r), l = a.redSqr().redISub(o).redISub(o), c = s.redIAdd(s); c = (c = c.redIAdd(c)).redIAdd(c), t = l, e = a.redMul(o.redISub(l)).redISub(c), n = this.y.redAdd(this.y) } else { var u = this.x.redSqr(), h = this.y.redSqr(), d = h.redSqr(), p = this.x.redAdd(h).redSqr().redISub(u).redISub(d); p = p.redIAdd(p); var f = u.redAdd(u).redIAdd(u), m = f.redSqr(), g = d.redIAdd(d); g = (g = g.redIAdd(g)).redIAdd(g), t = m.redISub(p).redISub(p), e = f.redMul(p.redISub(t)).redISub(g), n = (n = this.y.redMul(this.z)).redIAdd(n) } return this.curve.jpoint(t, e, n) }, x.prototype._threeDbl = function () { var t, e, n; if (this.zOne) { var r = this.x.redSqr(), i = this.y.redSqr(), s = i.redSqr(), o = this.x.redAdd(i).redSqr().redISub(r).redISub(s); o = o.redIAdd(o); var a = r.redAdd(r).redIAdd(r).redIAdd(this.curve.a), l = a.redSqr().redISub(o).redISub(o); t = l; var c = s.redIAdd(s); c = (c = c.redIAdd(c)).redIAdd(c), e = a.redMul(o.redISub(l)).redISub(c), n = this.y.redAdd(this.y) } else { var u = this.z.redSqr(), h = this.y.redSqr(), d = this.x.redMul(h), p = this.x.redSub(u).redMul(this.x.redAdd(u)); p = p.redAdd(p).redIAdd(p); var f = d.redIAdd(d), m = (f = f.redIAdd(f)).redAdd(f); t = p.redSqr().redISub(m), n = this.y.redAdd(this.z).redSqr().redISub(h).redISub(u); var g = h.redSqr(); g = (g = (g = g.redIAdd(g)).redIAdd(g)).redIAdd(g), e = p.redMul(f.redISub(t)).redISub(g) } return this.curve.jpoint(t, e, n) }, x.prototype._dbl = function () { var t = this.curve.a, e = this.x, n = this.y, r = this.z, i = r.redSqr().redSqr(), s = e.redSqr(), o = n.redSqr(), a = s.redAdd(s).redIAdd(s).redIAdd(t.redMul(i)), l = e.redAdd(e), c = (l = l.redIAdd(l)).redMul(o), u = a.redSqr().redISub(c.redAdd(c)), h = c.redISub(u), d = o.redSqr(); d = (d = (d = d.redIAdd(d)).redIAdd(d)).redIAdd(d); var p = a.redMul(h).redISub(d), f = n.redAdd(n).redMul(r); return this.curve.jpoint(u, p, f) }, x.prototype.trpl = function () { if (!this.curve.zeroA) return this.dbl().add(this); var t = this.x.redSqr(), e = this.y.redSqr(), n = this.z.redSqr(), r = e.redSqr(), i = t.redAdd(t).redIAdd(t), s = i.redSqr(), o = this.x.redAdd(e).redSqr().redISub(t).redISub(r), a = (o = (o = (o = o.redIAdd(o)).redAdd(o).redIAdd(o)).redISub(s)).redSqr(), l = r.redIAdd(r); l = (l = (l = l.redIAdd(l)).redIAdd(l)).redIAdd(l); var c = i.redIAdd(o).redSqr().redISub(s).redISub(a).redISub(l), u = e.redMul(c); u = (u = u.redIAdd(u)).redIAdd(u); var h = this.x.redMul(a).redISub(u); h = (h = h.redIAdd(h)).redIAdd(h); var d = this.y.redMul(c.redMul(l.redISub(c)).redISub(o.redMul(a))); d = (d = (d = d.redIAdd(d)).redIAdd(d)).redIAdd(d); var p = this.z.redAdd(o).redSqr().redISub(n).redISub(a); return this.curve.jpoint(h, d, p) }, x.prototype.mul = function (t, e) { return t = new (i())(t, e), this.curve._wnafMul(this, t) }, x.prototype.eq = function (t) { if ("affine" === t.type) return this.eq(t.toJ()); if (this === t) return !0; var e = this.z.redSqr(), n = t.z.redSqr(); if (0 !== this.x.redMul(n).redISub(t.x.redMul(e)).cmpn(0)) return !1; var r = e.redMul(this.z), i = n.redMul(t.z); return 0 === this.y.redMul(i).redISub(t.y.redMul(r)).cmpn(0) }, x.prototype.eqXToP = function (t) { var e = this.z.redSqr(), n = t.toRed(this.curve.red).redMul(e); if (0 === this.x.cmp(n)) return !0; for (var r = t.clone(), i = this.curve.redN.redMul(e); ;) { if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1; if (n.redIAdd(i), 0 === this.x.cmp(n)) return !0 } }, x.prototype.inspect = function () { return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">" }, x.prototype.isInfinity = function () { return 0 === this.z.cmpn(0) }; var T = a(function (t, e) { var n = e; n.base = g, n.short = w, n.mont = null, n.edwards = null }), E = a(function (t, e) { var n, r = e, i = h.assert; function s(t) { this.curve = "short" === t.type ? new T.short(t) : "edwards" === t.type ? new T.edwards(t) : new T.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, i(this.g.validate(), "Invalid curve"), i(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O") } function a(t, e) { Object.defineProperty(r, t, { configurable: !0, enumerable: !0, get: function () { var n = new s(e); return Object.defineProperty(r, t, { configurable: !0, enumerable: !0, value: n }), n } }) } r.PresetCurve = s, a("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: o().sha256, gRed: !1, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), a("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: o().sha256, gRed: !1, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), a("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: o().sha256, gRed: !1, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), a("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: o().sha384, gRed: !1, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), a("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: o().sha512, gRed: !1, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), a("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: o().sha256, gRed: !1, g: ["9"] }), a("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: o().sha256, gRed: !1, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] }); try { n = null.crash() } catch (l) { n = void 0 } a("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: o().sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: !1, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", n] }) }); function M(t) { if (!(this instanceof M)) return new M(t); this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null; var e = u.toArray(t.entropy, t.entropyEnc || "hex"), n = u.toArray(t.nonce, t.nonceEnc || "hex"), r = u.toArray(t.pers, t.persEnc || "hex"); l(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, n, r) } var A = M; M.prototype._init = function (t, e, n) { var r = t.concat(e).concat(n); this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8); for (var i = 0; i < this.V.length; i++)this.K[i] = 0, this.V[i] = 1; this._update(r), this._reseed = 1, this.reseedInterval = 281474976710656 }, M.prototype._hmac = function () { return new (o().hmac)(this.hash, this.K) }, M.prototype._update = function (t) { var e = this._hmac().update(this.V).update([0]); t && (e = e.update(t)), this.K = e.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest()) }, M.prototype.reseed = function (t, e, n, r) { "string" != typeof e && (r = n, n = e, e = null), t = u.toArray(t, e), n = u.toArray(n, r), l(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t.concat(n || [])), this._reseed = 1 }, M.prototype.generate = function (t, e, n, r) { if (this._reseed > this.reseedInterval) throw new Error("Reseed is required"); "string" != typeof e && (r = n, n = e, e = null), n && (n = u.toArray(n, r || "hex"), this._update(n)); for (var i = []; i.length < t;)this.V = this._hmac().update(this.V).digest(), i = i.concat(this.V); var s = i.slice(0, t); return this._update(n), this._reseed++, u.encode(s, e) }; var C = h.assert; function P(t, e) { this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc) } var R = P; P.fromPublic = function (t, e, n) { return e instanceof P ? e : new P(t, { pub: e, pubEnc: n }) }, P.fromPrivate = function (t, e, n) { return e instanceof P ? e : new P(t, { priv: e, privEnc: n }) }, P.prototype.validate = function () { var t = this.getPublic(); return t.isInfinity() ? { result: !1, reason: "Invalid public key" } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" } }, P.prototype.getPublic = function (t, e) { return "string" == typeof t && (e = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), e ? this.pub.encode(e, t) : this.pub }, P.prototype.getPrivate = function (t) { return "hex" === t ? this.priv.toString(16, 2) : this.priv }, P.prototype._importPrivate = function (t, e) { this.priv = new (i())(t, e || 16), this.priv = this.priv.umod(this.ec.curve.n) }, P.prototype._importPublic = function (t, e) { if (t.x || t.y) return "mont" === this.ec.curve.type ? C(t.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || C(t.x && t.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(t.x, t.y)); this.pub = this.ec.curve.decodePoint(t, e) }, P.prototype.derive = function (t) { return t.validate() || C(t.validate(), "public point not validated"), t.mul(this.priv).getX() }, P.prototype.sign = function (t, e, n) { return this.ec.sign(t, this, e, n) }, P.prototype.verify = function (t, e) { return this.ec.verify(t, e, this) }, P.prototype.inspect = function () { return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >" }; var L = h.assert; function k(t, e) { if (t instanceof k) return t; this._importDER(t, e) || (L(t.r && t.s, "Signature without r or s"), this.r = new (i())(t.r, 16), this.s = new (i())(t.s, 16), this.recoveryParam = void 0 === t.recoveryParam ? null : t.recoveryParam) } var D = k; function I() { this.place = 0 } function O(t, e) { var n = t[e.place++]; if (!(128 & n)) return n; var r = 15 & n; if (0 === r || r > 4) return !1; for (var i = 0, s = 0, o = e.place; s < r; s++, o++)i <<= 8, i |= t[o], i >>>= 0; return !(i <= 127) && (e.place = o, i) } function F(t) { for (var e = 0, n = t.length - 1; !t[e] && !(128 & t[e + 1]) && e < n;)e++; return 0 === e ? t : t.slice(e) } function N(t, e) { if (e < 128) t.push(e); else { var n = 1 + (Math.log(e) / Math.LN2 >>> 3); for (t.push(128 | n); --n;)t.push(e >>> (n << 3) & 255); t.push(e) } } k.prototype._importDER = function (t, e) { t = h.toArray(t, e); var n = new I; if (48 !== t[n.place++]) return !1; var r = O(t, n); if (!1 === r) return !1; if (r + n.place !== t.length) return !1; if (2 !== t[n.place++]) return !1; var s = O(t, n); if (!1 === s) return !1; var o = t.slice(n.place, s + n.place); if (n.place += s, 2 !== t[n.place++]) return !1; var a = O(t, n); if (!1 === a) return !1; if (t.length !== a + n.place) return !1; var l = t.slice(n.place, a + n.place); if (0 === o[0]) { if (!(128 & o[1])) return !1; o = o.slice(1) } if (0 === l[0]) { if (!(128 & l[1])) return !1; l = l.slice(1) } return this.r = new (i())(o), this.s = new (i())(l), this.recoveryParam = null, !0 }, k.prototype.toDER = function (t) { var e = this.r.toArray(), n = this.s.toArray(); for (128 & e[0] && (e = [0].concat(e)), 128 & n[0] && (n = [0].concat(n)), e = F(e), n = F(n); !(n[0] || 128 & n[1]);)n = n.slice(1); var r = [2]; N(r, e.length), (r = r.concat(e)).push(2), N(r, n.length); var i = r.concat(n), s = [48]; return N(s, i.length), s = s.concat(i), h.encode(s, t) }; var B = function () { throw new Error("unsupported") }, H = h.assert; function U(t) { if (!(this instanceof U)) return new U(t); "string" == typeof t && (H(Object.prototype.hasOwnProperty.call(E, t), "Unknown curve " + t), t = E[t]), t instanceof E.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash } var G = U; U.prototype.keyPair = function (t) { return new R(this, t) }, U.prototype.keyFromPrivate = function (t, e) { return R.fromPrivate(this, t, e) }, U.prototype.keyFromPublic = function (t, e) { return R.fromPublic(this, t, e) }, U.prototype.genKeyPair = function (t) { t || (t = {}); for (var e = new A({ hash: this.hash, pers: t.pers, persEnc: t.persEnc || "utf8", entropy: t.entropy || B(), entropyEnc: t.entropy && t.entropyEnc || "utf8", nonce: this.n.toArray() }), n = this.n.byteLength(), r = this.n.sub(new (i())(2)); ;) { var s = new (i())(e.generate(n)); if (!(s.cmp(r) > 0)) return s.iaddn(1), this.keyFromPrivate(s) } }, U.prototype._truncateToN = function (t, e) { var n = 8 * t.byteLength() - this.n.bitLength(); return n > 0 && (t = t.ushrn(n)), !e && t.cmp(this.n) >= 0 ? t.sub(this.n) : t }, U.prototype.sign = function (t, e, n, r) { "object" == typeof n && (r = n, n = null), r || (r = {}), e = this.keyFromPrivate(e, n), t = this._truncateToN(new (i())(t, 16)); for (var s = this.n.byteLength(), o = e.getPrivate().toArray("be", s), a = t.toArray("be", s), l = new A({ hash: this.hash, entropy: o, nonce: a, pers: r.pers, persEnc: r.persEnc || "utf8" }), c = this.n.sub(new (i())(1)), u = 0; ; u++) { var h = r.k ? r.k(u) : new (i())(l.generate(this.n.byteLength())); if (!((h = this._truncateToN(h, !0)).cmpn(1) <= 0 || h.cmp(c) >= 0)) { var d = this.g.mul(h); if (!d.isInfinity()) { var p = d.getX(), f = p.umod(this.n); if (0 !== f.cmpn(0)) { var m = h.invm(this.n).mul(f.mul(e.getPrivate()).iadd(t)); if (0 !== (m = m.umod(this.n)).cmpn(0)) { var g = (d.getY().isOdd() ? 1 : 0) | (0 !== p.cmp(f) ? 2 : 0); return r.canonical && m.cmp(this.nh) > 0 && (m = this.n.sub(m), g ^= 1), new D({ r: f, s: m, recoveryParam: g }) } } } } } }, U.prototype.verify = function (t, e, n, r) { t = this._truncateToN(new (i())(t, 16)), n = this.keyFromPublic(n, r); var s = (e = new D(e, "hex")).r, o = e.s; if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return !1; if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1; var a, l = o.invm(this.n), c = l.mul(t).umod(this.n), u = l.mul(s).umod(this.n); return this.curve._maxwellTrick ? !(a = this.g.jmulAdd(c, n.getPublic(), u)).isInfinity() && a.eqXToP(s) : !(a = this.g.mulAdd(c, n.getPublic(), u)).isInfinity() && 0 === a.getX().umod(this.n).cmp(s) }, U.prototype.recoverPubKey = function (t, e, n, r) { H((3 & n) === n, "The recovery param is more than two bits"), e = new D(e, r); var s = this.n, o = new (i())(t), a = e.r, l = e.s, c = 1 & n, u = n >> 1; if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && u) throw new Error("Unable to find sencond key candinate"); a = this.curve.pointFromX(u ? a.add(this.curve.n) : a, c); var h = e.r.invm(s), d = s.sub(o).mul(h).umod(s), p = l.mul(h).umod(s); return this.g.mulAdd(d, a, p) }, U.prototype.getKeyRecoveryParam = function (t, e, n, r) { if (null !== (e = new D(e, r)).recoveryParam) return e.recoveryParam; for (var i = 0; i < 4; i++) { var s; try { s = this.recoverPubKey(t, e, i) } catch (t) { continue } if (s.eq(n)) return i } throw new Error("Unable to find valid recovery factor") }; var V = a(function (t, e) { var n = e; n.version = "6.5.4", n.utils = h, n.rand = function () { throw new Error("unsupported") }, n.curve = T, n.curves = E, n.ec = G, n.eddsa = null }).ec, z = n(1488), j = n(2275); const J = new (n(3898).Logger)("signing-key/5.1.0"); let X = null; function W() { return X || (X = new V("secp256k1")), X } class q { constructor(t) { (0, j.defineReadOnly)(this, "curve", "secp256k1"), (0, j.defineReadOnly)(this, "privateKey", (0, z.hexlify)(t)); const e = W().keyFromPrivate((0, z.arrayify)(this.privateKey)); (0, j.defineReadOnly)(this, "publicKey", "0x" + e.getPublic(!1, "hex")), (0, j.defineReadOnly)(this, "compressedPublicKey", "0x" + e.getPublic(!0, "hex")), (0, j.defineReadOnly)(this, "_isSigningKey", !0) } _addPoint(t) { const e = W().keyFromPublic((0, z.arrayify)(this.publicKey)), n = W().keyFromPublic((0, z.arrayify)(t)); return "0x" + e.pub.add(n.pub).encodeCompressed("hex") } signDigest(t) { const e = W().keyFromPrivate((0, z.arrayify)(this.privateKey)), n = (0, z.arrayify)(t); 32 !== n.length && J.throwArgumentError("bad digest length", "digest", t); const r = e.sign(n, { canonical: !0 }); return (0, z.splitSignature)({ recoveryParam: r.recoveryParam, r: (0, z.hexZeroPad)("0x" + r.r.toString(16), 32), s: (0, z.hexZeroPad)("0x" + r.s.toString(16), 32) }) } computeSharedSecret(t) { const e = W().keyFromPrivate((0, z.arrayify)(this.privateKey)), n = W().keyFromPublic((0, z.arrayify)(K(t))); return (0, z.hexZeroPad)("0x" + e.derive(n.getPublic()).toString(16), 32) } static isSigningKey(t) { return !(!t || !t._isSigningKey) } } function Z(t, e) { const n = (0, z.splitSignature)(e), r = { r: (0, z.arrayify)(n.r), s: (0, z.arrayify)(n.s) }; return "0x" + W().recoverPubKey((0, z.arrayify)(t), r, n.recoveryParam).encode("hex", !1) } function K(t, e) { const n = (0, z.arrayify)(t); if (32 === n.length) { const t = new q(n); return e ? "0x" + W().keyFromPrivate(n).getPublic(!0, "hex") : t.publicKey } return 33 === n.length ? e ? (0, z.hexlify)(n) : "0x" + W().keyFromPublic(n).getPublic(!1, "hex") : 65 === n.length ? e ? "0x" + W().keyFromPublic(n).getPublic(!0, "hex") : (0, z.hexlify)(n) : J.throwArgumentError("invalid public or private key", "key", "[REDACTED]") } }, 3061: function (t, e, n) { !function (t, e) { "use strict"; function r(t, e) { if (!t) throw new Error(e || "Assertion failed") } function i(t, e) { t.super_ = e; var n = function () { }; n.prototype = e.prototype, t.prototype = new n, t.prototype.constructor = t } function s(t, e, n) { if (s.isBN(t)) return t; this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== e && "be" !== e || (n = e, e = 10), this._init(t || 0, e || 10, n || "be")) } var o; "object" == typeof t ? t.exports = s : e.BN = s, s.BN = s, s.wordSize = 26; try { o = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : n(8677).Buffer } catch (E) { } function a(t, e) { var n = t.charCodeAt(e); return n >= 65 && n <= 70 ? n - 55 : n >= 97 && n <= 102 ? n - 87 : n - 48 & 15 } function l(t, e, n) { var r = a(t, n); return n - 1 >= e && (r |= a(t, n - 1) << 4), r } function c(t, e, n, r) { for (var i = 0, s = Math.min(t.length, n), o = e; o < s; o++) { var a = t.charCodeAt(o) - 48; i *= r, i += a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a } return i } s.isBN = function (t) { return t instanceof s || null !== t && "object" == typeof t && t.constructor.wordSize === s.wordSize && Array.isArray(t.words) }, s.max = function (t, e) { return t.cmp(e) > 0 ? t : e }, s.min = function (t, e) { return t.cmp(e) < 0 ? t : e }, s.prototype._init = function (t, e, n) { if ("number" == typeof t) return this._initNumber(t, e, n); if ("object" == typeof t) return this._initArray(t, e, n); "hex" === e && (e = 16), r(e === (0 | e) && e >= 2 && e <= 36); var i = 0; "-" === (t = t.toString().replace(/\s+/g, ""))[0] && (i++, this.negative = 1), i < t.length && (16 === e ? this._parseHex(t, i, n) : (this._parseBase(t, e, i), "le" === n && this._initArray(this.toArray(), e, n))) }, s.prototype._initNumber = function (t, e, n) { t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [67108863 & t], this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (r(t < 9007199254740992), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === n && this._initArray(this.toArray(), e, n) }, s.prototype._initArray = function (t, e, n) { if (r("number" == typeof t.length), t.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(t.length / 3), this.words = new Array(this.length); for (var i = 0; i < this.length; i++)this.words[i] = 0; var s, o, a = 0; if ("be" === n) for (i = t.length - 1, s = 0; i >= 0; i -= 3)this.words[s] |= (o = t[i] | t[i - 1] << 8 | t[i - 2] << 16) << a & 67108863, this.words[s + 1] = o >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, s++); else if ("le" === n) for (i = 0, s = 0; i < t.length; i += 3)this.words[s] |= (o = t[i] | t[i + 1] << 8 | t[i + 2] << 16) << a & 67108863, this.words[s + 1] = o >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, s++); return this.strip() }, s.prototype._parseHex = function (t, e, n) { this.length = Math.ceil((t.length - e) / 6), this.words = new Array(this.length); for (var r = 0; r < this.length; r++)this.words[r] = 0; var i, s = 0, o = 0; if ("be" === n) for (r = t.length - 1; r >= e; r -= 2)i = l(t, e, r) << s, this.words[o] |= 67108863 & i, s >= 18 ? (s -= 18, this.words[o += 1] |= i >>> 26) : s += 8; else for (r = (t.length - e) % 2 == 0 ? e + 1 : e; r < t.length; r += 2)i = l(t, e, r) << s, this.words[o] |= 67108863 & i, s >= 18 ? (s -= 18, this.words[o += 1] |= i >>> 26) : s += 8; this.strip() }, s.prototype._parseBase = function (t, e, n) { this.words = [0], this.length = 1; for (var r = 0, i = 1; i <= 67108863; i *= e)r++; r--, i = i / e | 0; for (var s = t.length - n, o = s % r, a = Math.min(s, s - o) + n, l = 0, u = n; u < a; u += r)l = c(t, u, u + r, e), this.imuln(i), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l); if (0 !== o) { var h = 1; for (l = c(t, u, t.length, e), u = 0; u < o; u++)h *= e; this.imuln(h), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l) } this.strip() }, s.prototype.copy = function (t) { t.words = new Array(this.length); for (var e = 0; e < this.length; e++)t.words[e] = this.words[e]; t.length = this.length, t.negative = this.negative, t.red = this.red }, s.prototype.clone = function () { var t = new s(null); return this.copy(t), t }, s.prototype._expand = function (t) { for (; this.length < t;)this.words[this.length++] = 0; return this }, s.prototype.strip = function () { for (; this.length > 1 && 0 === this.words[this.length - 1];)this.length--; return this._normSign() }, s.prototype._normSign = function () { return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this }, s.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" }; var u = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], d = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; function p(t, e, n) { n.negative = e.negative ^ t.negative; var r = t.length + e.length | 0; n.length = r, r = r - 1 | 0; var i = 0 | t.words[0], s = 0 | e.words[0], o = i * s, a = o / 67108864 | 0; n.words[0] = 67108863 & o; for (var l = 1; l < r; l++) { for (var c = a >>> 26, u = 67108863 & a, h = Math.min(l, e.length - 1), d = Math.max(0, l - t.length + 1); d <= h; d++)c += (o = (i = 0 | t.words[l - d | 0]) * (s = 0 | e.words[d]) + u) / 67108864 | 0, u = 67108863 & o; n.words[l] = 0 | u, a = 0 | c } return 0 !== a ? n.words[l] = 0 | a : n.length--, n.strip() } s.prototype.toString = function (t, e) { var n; if (e = 0 | e || 1, 16 === (t = t || 10) || "hex" === t) { n = ""; for (var i = 0, s = 0, o = 0; o < this.length; o++) { var a = this.words[o], l = (16777215 & (a << i | s)).toString(16); n = 0 != (s = a >>> 24 - i & 16777215) || o !== this.length - 1 ? u[6 - l.length] + l + n : l + n, (i += 2) >= 26 && (i -= 26, o--) } for (0 !== s && (n = s.toString(16) + n); n.length % e != 0;)n = "0" + n; return 0 !== this.negative && (n = "-" + n), n } if (t === (0 | t) && t >= 2 && t <= 36) { var c = h[t], p = d[t]; n = ""; var f = this.clone(); for (f.negative = 0; !f.isZero();) { var m = f.modn(p).toString(t); n = (f = f.idivn(p)).isZero() ? m + n : u[c - m.length] + m + n } for (this.isZero() && (n = "0" + n); n.length % e != 0;)n = "0" + n; return 0 !== this.negative && (n = "-" + n), n } r(!1, "Base should be between 2 and 36") }, s.prototype.toNumber = function () { var t = this.words[0]; return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t }, s.prototype.toJSON = function () { return this.toString(16) }, s.prototype.toBuffer = function (t, e) { return r(void 0 !== o), this.toArrayLike(o, t, e) }, s.prototype.toArray = function (t, e) { return this.toArrayLike(Array, t, e) }, s.prototype.toArrayLike = function (t, e, n) { var i = this.byteLength(), s = n || Math.max(1, i); r(i <= s, "byte array longer than desired length"), r(s > 0, "Requested array length <= 0"), this.strip(); var o, a, l = "le" === e, c = new t(s), u = this.clone(); if (l) { for (a = 0; !u.isZero(); a++)o = u.andln(255), u.iushrn(8), c[a] = o; for (; a < s; a++)c[a] = 0 } else { for (a = 0; a < s - i; a++)c[a] = 0; for (a = 0; !u.isZero(); a++)o = u.andln(255), u.iushrn(8), c[s - a - 1] = o } return c }, s.prototype._countBits = Math.clz32 ? function (t) { return 32 - Math.clz32(t) } : function (t) { var e = t, n = 0; return e >= 4096 && (n += 13, e >>>= 13), e >= 64 && (n += 7, e >>>= 7), e >= 8 && (n += 4, e >>>= 4), e >= 2 && (n += 2, e >>>= 2), n + e }, s.prototype._zeroBits = function (t) { if (0 === t) return 26; var e = t, n = 0; return 0 == (8191 & e) && (n += 13, e >>>= 13), 0 == (127 & e) && (n += 7, e >>>= 7), 0 == (15 & e) && (n += 4, e >>>= 4), 0 == (3 & e) && (n += 2, e >>>= 2), 0 == (1 & e) && n++, n }, s.prototype.bitLength = function () { var t = this._countBits(this.words[this.length - 1]); return 26 * (this.length - 1) + t }, s.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var t = 0, e = 0; e < this.length; e++) { var n = this._zeroBits(this.words[e]); if (t += n, 26 !== n) break } return t }, s.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, s.prototype.toTwos = function (t) { return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone() }, s.prototype.fromTwos = function (t) { return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone() }, s.prototype.isNeg = function () { return 0 !== this.negative }, s.prototype.neg = function () { return this.clone().ineg() }, s.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, s.prototype.iuor = function (t) { for (; this.length < t.length;)this.words[this.length++] = 0; for (var e = 0; e < t.length; e++)this.words[e] = this.words[e] | t.words[e]; return this.strip() }, s.prototype.ior = function (t) { return r(0 == (this.negative | t.negative)), this.iuor(t) }, s.prototype.or = function (t) { return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this) }, s.prototype.uor = function (t) { return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this) }, s.prototype.iuand = function (t) { var e; e = this.length > t.length ? t : this; for (var n = 0; n < e.length; n++)this.words[n] = this.words[n] & t.words[n]; return this.length = e.length, this.strip() }, s.prototype.iand = function (t) { return r(0 == (this.negative | t.negative)), this.iuand(t) }, s.prototype.and = function (t) { return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this) }, s.prototype.uand = function (t) { return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this) }, s.prototype.iuxor = function (t) { var e, n; this.length > t.length ? (e = this, n = t) : (e = t, n = this); for (var r = 0; r < n.length; r++)this.words[r] = e.words[r] ^ n.words[r]; if (this !== e) for (; r < e.length; r++)this.words[r] = e.words[r]; return this.length = e.length, this.strip() }, s.prototype.ixor = function (t) { return r(0 == (this.negative | t.negative)), this.iuxor(t) }, s.prototype.xor = function (t) { return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this) }, s.prototype.uxor = function (t) { return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this) }, s.prototype.inotn = function (t) { r("number" == typeof t && t >= 0); var e = 0 | Math.ceil(t / 26), n = t % 26; this._expand(e), n > 0 && e--; for (var i = 0; i < e; i++)this.words[i] = 67108863 & ~this.words[i]; return n > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - n), this.strip() }, s.prototype.notn = function (t) { return this.clone().inotn(t) }, s.prototype.setn = function (t, e) { r("number" == typeof t && t >= 0); var n = t / 26 | 0, i = t % 26; return this._expand(n + 1), this.words[n] = e ? this.words[n] | 1 << i : this.words[n] & ~(1 << i), this.strip() }, s.prototype.iadd = function (t) { var e, n, r; if (0 !== this.negative && 0 === t.negative) return this.negative = 0, e = this.isub(t), this.negative ^= 1, this._normSign(); if (0 === this.negative && 0 !== t.negative) return t.negative = 0, e = this.isub(t), t.negative = 1, e._normSign(); this.length > t.length ? (n = this, r = t) : (n = t, r = this); for (var i = 0, s = 0; s < r.length; s++)this.words[s] = 67108863 & (e = (0 | n.words[s]) + (0 | r.words[s]) + i), i = e >>> 26; for (; 0 !== i && s < n.length; s++)this.words[s] = 67108863 & (e = (0 | n.words[s]) + i), i = e >>> 26; if (this.length = n.length, 0 !== i) this.words[this.length] = i, this.length++; else if (n !== this) for (; s < n.length; s++)this.words[s] = n.words[s]; return this }, s.prototype.add = function (t) { var e; return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, e = this.sub(t), t.negative ^= 1, e) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, e = t.sub(this), this.negative = 1, e) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this) }, s.prototype.isub = function (t) { if (0 !== t.negative) { t.negative = 0; var e = this.iadd(t); return t.negative = 1, e._normSign() } if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign(); var n, r, i = this.cmp(t); if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this; i > 0 ? (n = this, r = t) : (n = t, r = this); for (var s = 0, o = 0; o < r.length; o++)s = (e = (0 | n.words[o]) - (0 | r.words[o]) + s) >> 26, this.words[o] = 67108863 & e; for (; 0 !== s && o < n.length; o++)s = (e = (0 | n.words[o]) + s) >> 26, this.words[o] = 67108863 & e; if (0 === s && o < n.length && n !== this) for (; o < n.length; o++)this.words[o] = n.words[o]; return this.length = Math.max(this.length, o), n !== this && (this.negative = 1), this.strip() }, s.prototype.sub = function (t) { return this.clone().isub(t) }; var f = function (t, e, n) { var r, i, s, o = t.words, a = e.words, l = n.words, c = 0, u = 0 | o[0], h = 8191 & u, d = u >>> 13, p = 0 | o[1], f = 8191 & p, m = p >>> 13, g = 0 | o[2], v = 8191 & g, y = g >>> 13, b = 0 | o[3], _ = 8191 & b, w = b >>> 13, S = 0 | o[4], x = 8191 & S, T = S >>> 13, E = 0 | o[5], M = 8191 & E, A = E >>> 13, C = 0 | o[6], P = 8191 & C, R = C >>> 13, L = 0 | o[7], k = 8191 & L, D = L >>> 13, I = 0 | o[8], O = 8191 & I, F = I >>> 13, N = 0 | o[9], B = 8191 & N, H = N >>> 13, U = 0 | a[0], G = 8191 & U, V = U >>> 13, z = 0 | a[1], j = 8191 & z, J = z >>> 13, X = 0 | a[2], W = 8191 & X, q = X >>> 13, Z = 0 | a[3], K = 8191 & Z, Y = Z >>> 13, Q = 0 | a[4], $ = 8191 & Q, tt = Q >>> 13, et = 0 | a[5], nt = 8191 & et, rt = et >>> 13, it = 0 | a[6], st = 8191 & it, ot = it >>> 13, at = 0 | a[7], lt = 8191 & at, ct = at >>> 13, ut = 0 | a[8], ht = 8191 & ut, dt = ut >>> 13, pt = 0 | a[9], ft = 8191 & pt, mt = pt >>> 13; n.negative = t.negative ^ e.negative, n.length = 19; var gt = (c + (r = Math.imul(h, G)) | 0) + ((8191 & (i = (i = Math.imul(h, V)) + Math.imul(d, G) | 0)) << 13) | 0; c = ((s = Math.imul(d, V)) + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, r = Math.imul(f, G), i = (i = Math.imul(f, V)) + Math.imul(m, G) | 0, s = Math.imul(m, V); var vt = (c + (r = r + Math.imul(h, j) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, J) | 0) + Math.imul(d, j) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, J) | 0) + (i >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, r = Math.imul(v, G), i = (i = Math.imul(v, V)) + Math.imul(y, G) | 0, s = Math.imul(y, V), r = r + Math.imul(f, j) | 0, i = (i = i + Math.imul(f, J) | 0) + Math.imul(m, j) | 0, s = s + Math.imul(m, J) | 0; var yt = (c + (r = r + Math.imul(h, W) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, q) | 0) + Math.imul(d, W) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, q) | 0) + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, r = Math.imul(_, G), i = (i = Math.imul(_, V)) + Math.imul(w, G) | 0, s = Math.imul(w, V), r = r + Math.imul(v, j) | 0, i = (i = i + Math.imul(v, J) | 0) + Math.imul(y, j) | 0, s = s + Math.imul(y, J) | 0, r = r + Math.imul(f, W) | 0, i = (i = i + Math.imul(f, q) | 0) + Math.imul(m, W) | 0, s = s + Math.imul(m, q) | 0; var bt = (c + (r = r + Math.imul(h, K) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, Y) | 0) + Math.imul(d, K) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, Y) | 0) + (i >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, r = Math.imul(x, G), i = (i = Math.imul(x, V)) + Math.imul(T, G) | 0, s = Math.imul(T, V), r = r + Math.imul(_, j) | 0, i = (i = i + Math.imul(_, J) | 0) + Math.imul(w, j) | 0, s = s + Math.imul(w, J) | 0, r = r + Math.imul(v, W) | 0, i = (i = i + Math.imul(v, q) | 0) + Math.imul(y, W) | 0, s = s + Math.imul(y, q) | 0, r = r + Math.imul(f, K) | 0, i = (i = i + Math.imul(f, Y) | 0) + Math.imul(m, K) | 0, s = s + Math.imul(m, Y) | 0; var _t = (c + (r = r + Math.imul(h, $) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, tt) | 0) + Math.imul(d, $) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, tt) | 0) + (i >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, r = Math.imul(M, G), i = (i = Math.imul(M, V)) + Math.imul(A, G) | 0, s = Math.imul(A, V), r = r + Math.imul(x, j) | 0, i = (i = i + Math.imul(x, J) | 0) + Math.imul(T, j) | 0, s = s + Math.imul(T, J) | 0, r = r + Math.imul(_, W) | 0, i = (i = i + Math.imul(_, q) | 0) + Math.imul(w, W) | 0, s = s + Math.imul(w, q) | 0, r = r + Math.imul(v, K) | 0, i = (i = i + Math.imul(v, Y) | 0) + Math.imul(y, K) | 0, s = s + Math.imul(y, Y) | 0, r = r + Math.imul(f, $) | 0, i = (i = i + Math.imul(f, tt) | 0) + Math.imul(m, $) | 0, s = s + Math.imul(m, tt) | 0; var wt = (c + (r = r + Math.imul(h, nt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, rt) | 0) + Math.imul(d, nt) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, rt) | 0) + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, r = Math.imul(P, G), i = (i = Math.imul(P, V)) + Math.imul(R, G) | 0, s = Math.imul(R, V), r = r + Math.imul(M, j) | 0, i = (i = i + Math.imul(M, J) | 0) + Math.imul(A, j) | 0, s = s + Math.imul(A, J) | 0, r = r + Math.imul(x, W) | 0, i = (i = i + Math.imul(x, q) | 0) + Math.imul(T, W) | 0, s = s + Math.imul(T, q) | 0, r = r + Math.imul(_, K) | 0, i = (i = i + Math.imul(_, Y) | 0) + Math.imul(w, K) | 0, s = s + Math.imul(w, Y) | 0, r = r + Math.imul(v, $) | 0, i = (i = i + Math.imul(v, tt) | 0) + Math.imul(y, $) | 0, s = s + Math.imul(y, tt) | 0, r = r + Math.imul(f, nt) | 0, i = (i = i + Math.imul(f, rt) | 0) + Math.imul(m, nt) | 0, s = s + Math.imul(m, rt) | 0; var St = (c + (r = r + Math.imul(h, st) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, ot) | 0) + Math.imul(d, st) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, ot) | 0) + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, r = Math.imul(k, G), i = (i = Math.imul(k, V)) + Math.imul(D, G) | 0, s = Math.imul(D, V), r = r + Math.imul(P, j) | 0, i = (i = i + Math.imul(P, J) | 0) + Math.imul(R, j) | 0, s = s + Math.imul(R, J) | 0, r = r + Math.imul(M, W) | 0, i = (i = i + Math.imul(M, q) | 0) + Math.imul(A, W) | 0, s = s + Math.imul(A, q) | 0, r = r + Math.imul(x, K) | 0, i = (i = i + Math.imul(x, Y) | 0) + Math.imul(T, K) | 0, s = s + Math.imul(T, Y) | 0, r = r + Math.imul(_, $) | 0, i = (i = i + Math.imul(_, tt) | 0) + Math.imul(w, $) | 0, s = s + Math.imul(w, tt) | 0, r = r + Math.imul(v, nt) | 0, i = (i = i + Math.imul(v, rt) | 0) + Math.imul(y, nt) | 0, s = s + Math.imul(y, rt) | 0, r = r + Math.imul(f, st) | 0, i = (i = i + Math.imul(f, ot) | 0) + Math.imul(m, st) | 0, s = s + Math.imul(m, ot) | 0; var xt = (c + (r = r + Math.imul(h, lt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, ct) | 0) + Math.imul(d, lt) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, ct) | 0) + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, r = Math.imul(O, G), i = (i = Math.imul(O, V)) + Math.imul(F, G) | 0, s = Math.imul(F, V), r = r + Math.imul(k, j) | 0, i = (i = i + Math.imul(k, J) | 0) + Math.imul(D, j) | 0, s = s + Math.imul(D, J) | 0, r = r + Math.imul(P, W) | 0, i = (i = i + Math.imul(P, q) | 0) + Math.imul(R, W) | 0, s = s + Math.imul(R, q) | 0, r = r + Math.imul(M, K) | 0, i = (i = i + Math.imul(M, Y) | 0) + Math.imul(A, K) | 0, s = s + Math.imul(A, Y) | 0, r = r + Math.imul(x, $) | 0, i = (i = i + Math.imul(x, tt) | 0) + Math.imul(T, $) | 0, s = s + Math.imul(T, tt) | 0, r = r + Math.imul(_, nt) | 0, i = (i = i + Math.imul(_, rt) | 0) + Math.imul(w, nt) | 0, s = s + Math.imul(w, rt) | 0, r = r + Math.imul(v, st) | 0, i = (i = i + Math.imul(v, ot) | 0) + Math.imul(y, st) | 0, s = s + Math.imul(y, ot) | 0, r = r + Math.imul(f, lt) | 0, i = (i = i + Math.imul(f, ct) | 0) + Math.imul(m, lt) | 0, s = s + Math.imul(m, ct) | 0; var Tt = (c + (r = r + Math.imul(h, ht) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, dt) | 0) + Math.imul(d, ht) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, dt) | 0) + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, r = Math.imul(B, G), i = (i = Math.imul(B, V)) + Math.imul(H, G) | 0, s = Math.imul(H, V), r = r + Math.imul(O, j) | 0, i = (i = i + Math.imul(O, J) | 0) + Math.imul(F, j) | 0, s = s + Math.imul(F, J) | 0, r = r + Math.imul(k, W) | 0, i = (i = i + Math.imul(k, q) | 0) + Math.imul(D, W) | 0, s = s + Math.imul(D, q) | 0, r = r + Math.imul(P, K) | 0, i = (i = i + Math.imul(P, Y) | 0) + Math.imul(R, K) | 0, s = s + Math.imul(R, Y) | 0, r = r + Math.imul(M, $) | 0, i = (i = i + Math.imul(M, tt) | 0) + Math.imul(A, $) | 0, s = s + Math.imul(A, tt) | 0, r = r + Math.imul(x, nt) | 0, i = (i = i + Math.imul(x, rt) | 0) + Math.imul(T, nt) | 0, s = s + Math.imul(T, rt) | 0, r = r + Math.imul(_, st) | 0, i = (i = i + Math.imul(_, ot) | 0) + Math.imul(w, st) | 0, s = s + Math.imul(w, ot) | 0, r = r + Math.imul(v, lt) | 0, i = (i = i + Math.imul(v, ct) | 0) + Math.imul(y, lt) | 0, s = s + Math.imul(y, ct) | 0, r = r + Math.imul(f, ht) | 0, i = (i = i + Math.imul(f, dt) | 0) + Math.imul(m, ht) | 0, s = s + Math.imul(m, dt) | 0; var Et = (c + (r = r + Math.imul(h, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(h, mt) | 0) + Math.imul(d, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(d, mt) | 0) + (i >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, r = Math.imul(B, j), i = (i = Math.imul(B, J)) + Math.imul(H, j) | 0, s = Math.imul(H, J), r = r + Math.imul(O, W) | 0, i = (i = i + Math.imul(O, q) | 0) + Math.imul(F, W) | 0, s = s + Math.imul(F, q) | 0, r = r + Math.imul(k, K) | 0, i = (i = i + Math.imul(k, Y) | 0) + Math.imul(D, K) | 0, s = s + Math.imul(D, Y) | 0, r = r + Math.imul(P, $) | 0, i = (i = i + Math.imul(P, tt) | 0) + Math.imul(R, $) | 0, s = s + Math.imul(R, tt) | 0, r = r + Math.imul(M, nt) | 0, i = (i = i + Math.imul(M, rt) | 0) + Math.imul(A, nt) | 0, s = s + Math.imul(A, rt) | 0, r = r + Math.imul(x, st) | 0, i = (i = i + Math.imul(x, ot) | 0) + Math.imul(T, st) | 0, s = s + Math.imul(T, ot) | 0, r = r + Math.imul(_, lt) | 0, i = (i = i + Math.imul(_, ct) | 0) + Math.imul(w, lt) | 0, s = s + Math.imul(w, ct) | 0, r = r + Math.imul(v, ht) | 0, i = (i = i + Math.imul(v, dt) | 0) + Math.imul(y, ht) | 0, s = s + Math.imul(y, dt) | 0; var Mt = (c + (r = r + Math.imul(f, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, mt) | 0) + Math.imul(m, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(m, mt) | 0) + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, r = Math.imul(B, W), i = (i = Math.imul(B, q)) + Math.imul(H, W) | 0, s = Math.imul(H, q), r = r + Math.imul(O, K) | 0, i = (i = i + Math.imul(O, Y) | 0) + Math.imul(F, K) | 0, s = s + Math.imul(F, Y) | 0, r = r + Math.imul(k, $) | 0, i = (i = i + Math.imul(k, tt) | 0) + Math.imul(D, $) | 0, s = s + Math.imul(D, tt) | 0, r = r + Math.imul(P, nt) | 0, i = (i = i + Math.imul(P, rt) | 0) + Math.imul(R, nt) | 0, s = s + Math.imul(R, rt) | 0, r = r + Math.imul(M, st) | 0, i = (i = i + Math.imul(M, ot) | 0) + Math.imul(A, st) | 0, s = s + Math.imul(A, ot) | 0, r = r + Math.imul(x, lt) | 0, i = (i = i + Math.imul(x, ct) | 0) + Math.imul(T, lt) | 0, s = s + Math.imul(T, ct) | 0, r = r + Math.imul(_, ht) | 0, i = (i = i + Math.imul(_, dt) | 0) + Math.imul(w, ht) | 0, s = s + Math.imul(w, dt) | 0; var At = (c + (r = r + Math.imul(v, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(v, mt) | 0) + Math.imul(y, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(y, mt) | 0) + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, r = Math.imul(B, K), i = (i = Math.imul(B, Y)) + Math.imul(H, K) | 0, s = Math.imul(H, Y), r = r + Math.imul(O, $) | 0, i = (i = i + Math.imul(O, tt) | 0) + Math.imul(F, $) | 0, s = s + Math.imul(F, tt) | 0, r = r + Math.imul(k, nt) | 0, i = (i = i + Math.imul(k, rt) | 0) + Math.imul(D, nt) | 0, s = s + Math.imul(D, rt) | 0, r = r + Math.imul(P, st) | 0, i = (i = i + Math.imul(P, ot) | 0) + Math.imul(R, st) | 0, s = s + Math.imul(R, ot) | 0, r = r + Math.imul(M, lt) | 0, i = (i = i + Math.imul(M, ct) | 0) + Math.imul(A, lt) | 0, s = s + Math.imul(A, ct) | 0, r = r + Math.imul(x, ht) | 0, i = (i = i + Math.imul(x, dt) | 0) + Math.imul(T, ht) | 0, s = s + Math.imul(T, dt) | 0; var Ct = (c + (r = r + Math.imul(_, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(_, mt) | 0) + Math.imul(w, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(w, mt) | 0) + (i >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, r = Math.imul(B, $), i = (i = Math.imul(B, tt)) + Math.imul(H, $) | 0, s = Math.imul(H, tt), r = r + Math.imul(O, nt) | 0, i = (i = i + Math.imul(O, rt) | 0) + Math.imul(F, nt) | 0, s = s + Math.imul(F, rt) | 0, r = r + Math.imul(k, st) | 0, i = (i = i + Math.imul(k, ot) | 0) + Math.imul(D, st) | 0, s = s + Math.imul(D, ot) | 0, r = r + Math.imul(P, lt) | 0, i = (i = i + Math.imul(P, ct) | 0) + Math.imul(R, lt) | 0, s = s + Math.imul(R, ct) | 0, r = r + Math.imul(M, ht) | 0, i = (i = i + Math.imul(M, dt) | 0) + Math.imul(A, ht) | 0, s = s + Math.imul(A, dt) | 0; var Pt = (c + (r = r + Math.imul(x, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(x, mt) | 0) + Math.imul(T, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(T, mt) | 0) + (i >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, r = Math.imul(B, nt), i = (i = Math.imul(B, rt)) + Math.imul(H, nt) | 0, s = Math.imul(H, rt), r = r + Math.imul(O, st) | 0, i = (i = i + Math.imul(O, ot) | 0) + Math.imul(F, st) | 0, s = s + Math.imul(F, ot) | 0, r = r + Math.imul(k, lt) | 0, i = (i = i + Math.imul(k, ct) | 0) + Math.imul(D, lt) | 0, s = s + Math.imul(D, ct) | 0, r = r + Math.imul(P, ht) | 0, i = (i = i + Math.imul(P, dt) | 0) + Math.imul(R, ht) | 0, s = s + Math.imul(R, dt) | 0; var Rt = (c + (r = r + Math.imul(M, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(M, mt) | 0) + Math.imul(A, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(A, mt) | 0) + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, r = Math.imul(B, st), i = (i = Math.imul(B, ot)) + Math.imul(H, st) | 0, s = Math.imul(H, ot), r = r + Math.imul(O, lt) | 0, i = (i = i + Math.imul(O, ct) | 0) + Math.imul(F, lt) | 0, s = s + Math.imul(F, ct) | 0, r = r + Math.imul(k, ht) | 0, i = (i = i + Math.imul(k, dt) | 0) + Math.imul(D, ht) | 0, s = s + Math.imul(D, dt) | 0; var Lt = (c + (r = r + Math.imul(P, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(P, mt) | 0) + Math.imul(R, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(R, mt) | 0) + (i >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, r = Math.imul(B, lt), i = (i = Math.imul(B, ct)) + Math.imul(H, lt) | 0, s = Math.imul(H, ct), r = r + Math.imul(O, ht) | 0, i = (i = i + Math.imul(O, dt) | 0) + Math.imul(F, ht) | 0, s = s + Math.imul(F, dt) | 0; var kt = (c + (r = r + Math.imul(k, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(k, mt) | 0) + Math.imul(D, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(D, mt) | 0) + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, r = Math.imul(B, ht), i = (i = Math.imul(B, dt)) + Math.imul(H, ht) | 0, s = Math.imul(H, dt); var Dt = (c + (r = r + Math.imul(O, ft) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(O, mt) | 0) + Math.imul(F, ft) | 0)) << 13) | 0; c = ((s = s + Math.imul(F, mt) | 0) + (i >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863; var It = (c + (r = Math.imul(B, ft)) | 0) + ((8191 & (i = (i = Math.imul(B, mt)) + Math.imul(H, ft) | 0)) << 13) | 0; return c = ((s = Math.imul(H, mt)) + (i >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, l[0] = gt, l[1] = vt, l[2] = yt, l[3] = bt, l[4] = _t, l[5] = wt, l[6] = St, l[7] = xt, l[8] = Tt, l[9] = Et, l[10] = Mt, l[11] = At, l[12] = Ct, l[13] = Pt, l[14] = Rt, l[15] = Lt, l[16] = kt, l[17] = Dt, l[18] = It, 0 !== c && (l[19] = c, n.length++), n }; function m(t, e, n) { return (new g).mulp(t, e, n) } function g(t, e) { this.x = t, this.y = e } Math.imul || (f = p), s.prototype.mulTo = function (t, e) { var n = this.length + t.length; return 10 === this.length && 10 === t.length ? f(this, t, e) : n < 63 ? p(this, t, e) : n < 1024 ? function (t, e, n) { n.negative = e.negative ^ t.negative, n.length = t.length + e.length; for (var r = 0, i = 0, s = 0; s < n.length - 1; s++) { var o = i; i = 0; for (var a = 67108863 & r, l = Math.min(s, e.length - 1), c = Math.max(0, s - t.length + 1); c <= l; c++) { var u = (0 | t.words[s - c]) * (0 | e.words[c]), h = 67108863 & u; a = 67108863 & (h = h + a | 0), i += (o = (o = o + (u / 67108864 | 0) | 0) + (h >>> 26) | 0) >>> 26, o &= 67108863 } n.words[s] = a, r = o, o = i } return 0 !== r ? n.words[s] = r : n.length--, n.strip() }(this, t, e) : m(this, t, e) }, g.prototype.makeRBT = function (t) { for (var e = new Array(t), n = s.prototype._countBits(t) - 1, r = 0; r < t; r++)e[r] = this.revBin(r, n, t); return e }, g.prototype.revBin = function (t, e, n) { if (0 === t || t === n - 1) return t; for (var r = 0, i = 0; i < e; i++)r |= (1 & t) << e - i - 1, t >>= 1; return r }, g.prototype.permute = function (t, e, n, r, i, s) { for (var o = 0; o < s; o++)r[o] = e[t[o]], i[o] = n[t[o]] }, g.prototype.transform = function (t, e, n, r, i, s) { this.permute(s, t, e, n, r, i); for (var o = 1; o < i; o <<= 1)for (var a = o << 1, l = Math.cos(2 * Math.PI / a), c = Math.sin(2 * Math.PI / a), u = 0; u < i; u += a)for (var h = l, d = c, p = 0; p < o; p++) { var f = n[u + p], m = r[u + p], g = n[u + p + o], v = r[u + p + o], y = h * g - d * v; v = h * v + d * g, n[u + p] = f + (g = y), r[u + p] = m + v, n[u + p + o] = f - g, r[u + p + o] = m - v, p !== a && (y = l * h - c * d, d = l * d + c * h, h = y) } }, g.prototype.guessLen13b = function (t, e) { var n = 1 | Math.max(e, t), r = 1 & n, i = 0; for (n = n / 2 | 0; n; n >>>= 1)i++; return 1 << i + 1 + r }, g.prototype.conjugate = function (t, e, n) { if (!(n <= 1)) for (var r = 0; r < n / 2; r++) { var i = t[r]; t[r] = t[n - r - 1], t[n - r - 1] = i, i = e[r], e[r] = -e[n - r - 1], e[n - r - 1] = -i } }, g.prototype.normalize13b = function (t, e) { for (var n = 0, r = 0; r < e / 2; r++) { var i = 8192 * Math.round(t[2 * r + 1] / e) + Math.round(t[2 * r] / e) + n; t[r] = 67108863 & i, n = i < 67108864 ? 0 : i / 67108864 | 0 } return t }, g.prototype.convert13b = function (t, e, n, i) { for (var s = 0, o = 0; o < e; o++)n[2 * o] = 8191 & (s += 0 | t[o]), n[2 * o + 1] = 8191 & (s >>>= 13), s >>>= 13; for (o = 2 * e; o < i; ++o)n[o] = 0; r(0 === s), r(0 == (-8192 & s)) }, g.prototype.stub = function (t) { for (var e = new Array(t), n = 0; n < t; n++)e[n] = 0; return e }, g.prototype.mulp = function (t, e, n) { var r = 2 * this.guessLen13b(t.length, e.length), i = this.makeRBT(r), s = this.stub(r), o = new Array(r), a = new Array(r), l = new Array(r), c = new Array(r), u = new Array(r), h = new Array(r), d = n.words; d.length = r, this.convert13b(t.words, t.length, o, r), this.convert13b(e.words, e.length, c, r), this.transform(o, s, a, l, r, i), this.transform(c, s, u, h, r, i); for (var p = 0; p < r; p++) { var f = a[p] * u[p] - l[p] * h[p]; l[p] = a[p] * h[p] + l[p] * u[p], a[p] = f } return this.conjugate(a, l, r), this.transform(a, l, d, s, r, i), this.conjugate(d, s, r), this.normalize13b(d, r), n.negative = t.negative ^ e.negative, n.length = t.length + e.length, n.strip() }, s.prototype.mul = function (t) { var e = new s(null); return e.words = new Array(this.length + t.length), this.mulTo(t, e) }, s.prototype.mulf = function (t) { var e = new s(null); return e.words = new Array(this.length + t.length), m(this, t, e) }, s.prototype.imul = function (t) { return this.clone().mulTo(t, this) }, s.prototype.imuln = function (t) { r("number" == typeof t), r(t < 67108864); for (var e = 0, n = 0; n < this.length; n++) { var i = (0 | this.words[n]) * t, s = (67108863 & i) + (67108863 & e); e >>= 26, e += i / 67108864 | 0, e += s >>> 26, this.words[n] = 67108863 & s } return 0 !== e && (this.words[n] = e, this.length++), this }, s.prototype.muln = function (t) { return this.clone().imuln(t) }, s.prototype.sqr = function () { return this.mul(this) }, s.prototype.isqr = function () { return this.imul(this.clone()) }, s.prototype.pow = function (t) { var e = function (t) { for (var e = new Array(t.bitLength()), n = 0; n < e.length; n++) { var r = n % 26; e[n] = (t.words[n / 26 | 0] & 1 << r) >>> r } return e }(t); if (0 === e.length) return new s(1); for (var n = this, r = 0; r < e.length && 0 === e[r]; r++, n = n.sqr()); if (++r < e.length) for (var i = n.sqr(); r < e.length; r++, i = i.sqr())0 !== e[r] && (n = n.mul(i)); return n }, s.prototype.iushln = function (t) { r("number" == typeof t && t >= 0); var e, n = t % 26, i = (t - n) / 26, s = 67108863 >>> 26 - n << 26 - n; if (0 !== n) { var o = 0; for (e = 0; e < this.length; e++) { var a = this.words[e] & s; this.words[e] = (0 | this.words[e]) - a << n | o, o = a >>> 26 - n } o && (this.words[e] = o, this.length++) } if (0 !== i) { for (e = this.length - 1; e >= 0; e--)this.words[e + i] = this.words[e]; for (e = 0; e < i; e++)this.words[e] = 0; this.length += i } return this.strip() }, s.prototype.ishln = function (t) { return r(0 === this.negative), this.iushln(t) }, s.prototype.iushrn = function (t, e, n) { var i; r("number" == typeof t && t >= 0), i = e ? (e - e % 26) / 26 : 0; var s = t % 26, o = Math.min((t - s) / 26, this.length), a = 67108863 ^ 67108863 >>> s << s, l = n; if (i -= o, i = Math.max(0, i), l) { for (var c = 0; c < o; c++)l.words[c] = this.words[c]; l.length = o } if (0 === o); else if (this.length > o) for (this.length -= o, c = 0; c < this.length; c++)this.words[c] = this.words[c + o]; else this.words[0] = 0, this.length = 1; var u = 0; for (c = this.length - 1; c >= 0 && (0 !== u || c >= i); c--) { var h = 0 | this.words[c]; this.words[c] = u << 26 - s | h >>> s, u = h & a } return l && 0 !== u && (l.words[l.length++] = u), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip() }, s.prototype.ishrn = function (t, e, n) { return r(0 === this.negative), this.iushrn(t, e, n) }, s.prototype.shln = function (t) { return this.clone().ishln(t) }, s.prototype.ushln = function (t) { return this.clone().iushln(t) }, s.prototype.shrn = function (t) { return this.clone().ishrn(t) }, s.prototype.ushrn = function (t) { return this.clone().iushrn(t) }, s.prototype.testn = function (t) { r("number" == typeof t && t >= 0); var e = t % 26, n = (t - e) / 26; return !(this.length <= n || !(this.words[n] & 1 << e)) }, s.prototype.imaskn = function (t) { r("number" == typeof t && t >= 0); var e = t % 26, n = (t - e) / 26; return r(0 === this.negative, "imaskn works only with positive numbers"), this.length <= n ? this : (0 !== e && n++, this.length = Math.min(n, this.length), 0 !== e && (this.words[this.length - 1] &= 67108863 ^ 67108863 >>> e << e), this.strip()) }, s.prototype.maskn = function (t) { return this.clone().imaskn(t) }, s.prototype.iaddn = function (t) { return r("number" == typeof t), r(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t) }, s.prototype._iaddn = function (t) { this.words[0] += t; for (var e = 0; e < this.length && this.words[e] >= 67108864; e++)this.words[e] -= 67108864, e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++; return this.length = Math.max(this.length, e + 1), this }, s.prototype.isubn = function (t) { if (r("number" == typeof t), r(t < 67108864), t < 0) return this.iaddn(-t); if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this; if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var e = 0; e < this.length && this.words[e] < 0; e++)this.words[e] += 67108864, this.words[e + 1] -= 1; return this.strip() }, s.prototype.addn = function (t) { return this.clone().iaddn(t) }, s.prototype.subn = function (t) { return this.clone().isubn(t) }, s.prototype.iabs = function () { return this.negative = 0, this }, s.prototype.abs = function () { return this.clone().iabs() }, s.prototype._ishlnsubmul = function (t, e, n) { var i, s; this._expand(t.length + n); var o = 0; for (i = 0; i < t.length; i++) { s = (0 | this.words[i + n]) + o; var a = (0 | t.words[i]) * e; o = ((s -= 67108863 & a) >> 26) - (a / 67108864 | 0), this.words[i + n] = 67108863 & s } for (; i < this.length - n; i++)o = (s = (0 | this.words[i + n]) + o) >> 26, this.words[i + n] = 67108863 & s; if (0 === o) return this.strip(); for (r(-1 === o), o = 0, i = 0; i < this.length; i++)o = (s = -(0 | this.words[i]) + o) >> 26, this.words[i] = 67108863 & s; return this.negative = 1, this.strip() }, s.prototype._wordDiv = function (t, e) { var n, r = this.clone(), i = t, o = 0 | i.words[i.length - 1]; 0 != (n = 26 - this._countBits(o)) && (i = i.ushln(n), r.iushln(n), o = 0 | i.words[i.length - 1]); var a, l = r.length - i.length; if ("mod" !== e) { (a = new s(null)).length = l + 1, a.words = new Array(a.length); for (var c = 0; c < a.length; c++)a.words[c] = 0 } var u = r.clone()._ishlnsubmul(i, 1, l); 0 === u.negative && (r = u, a && (a.words[l] = 1)); for (var h = l - 1; h >= 0; h--) { var d = 67108864 * (0 | r.words[i.length + h]) + (0 | r.words[i.length + h - 1]); for (d = Math.min(d / o | 0, 67108863), r._ishlnsubmul(i, d, h); 0 !== r.negative;)d--, r.negative = 0, r._ishlnsubmul(i, 1, h), r.isZero() || (r.negative ^= 1); a && (a.words[h] = d) } return a && a.strip(), r.strip(), "div" !== e && 0 !== n && r.iushrn(n), { div: a || null, mod: r } }, s.prototype.divmod = function (t, e, n) { return r(!t.isZero()), this.isZero() ? { div: new s(0), mod: new s(0) } : 0 !== this.negative && 0 === t.negative ? (a = this.neg().divmod(t, e), "mod" !== e && (i = a.div.neg()), "div" !== e && (o = a.mod.neg(), n && 0 !== o.negative && o.iadd(t)), { div: i, mod: o }) : 0 === this.negative && 0 !== t.negative ? (a = this.divmod(t.neg(), e), "mod" !== e && (i = a.div.neg()), { div: i, mod: a.mod }) : 0 != (this.negative & t.negative) ? (a = this.neg().divmod(t.neg(), e), "div" !== e && (o = a.mod.neg(), n && 0 !== o.negative && o.isub(t)), { div: a.div, mod: o }) : t.length > this.length || this.cmp(t) < 0 ? { div: new s(0), mod: this } : 1 === t.length ? "div" === e ? { div: this.divn(t.words[0]), mod: null } : "mod" === e ? { div: null, mod: new s(this.modn(t.words[0])) } : { div: this.divn(t.words[0]), mod: new s(this.modn(t.words[0])) } : this._wordDiv(t, e); var i, o, a }, s.prototype.div = function (t) { return this.divmod(t, "div", !1).div }, s.prototype.mod = function (t) { return this.divmod(t, "mod", !1).mod }, s.prototype.umod = function (t) { return this.divmod(t, "mod", !0).mod }, s.prototype.divRound = function (t) { var e = this.divmod(t); if (e.mod.isZero()) return e.div; var n = 0 !== e.div.negative ? e.mod.isub(t) : e.mod, r = t.ushrn(1), i = t.andln(1), s = n.cmp(r); return s < 0 || 1 === i && 0 === s ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1) }, s.prototype.modn = function (t) { r(t <= 67108863); for (var e = (1 << 26) % t, n = 0, i = this.length - 1; i >= 0; i--)n = (e * n + (0 | this.words[i])) % t; return n }, s.prototype.idivn = function (t) { r(t <= 67108863); for (var e = 0, n = this.length - 1; n >= 0; n--) { var i = (0 | this.words[n]) + 67108864 * e; this.words[n] = i / t | 0, e = i % t } return this.strip() }, s.prototype.divn = function (t) { return this.clone().idivn(t) }, s.prototype.egcd = function (t) { r(0 === t.negative), r(!t.isZero()); var e = this, n = t.clone(); e = 0 !== e.negative ? e.umod(t) : e.clone(); for (var i = new s(1), o = new s(0), a = new s(0), l = new s(1), c = 0; e.isEven() && n.isEven();)e.iushrn(1), n.iushrn(1), ++c; for (var u = n.clone(), h = e.clone(); !e.isZero();) { for (var d = 0, p = 1; 0 == (e.words[0] & p) && d < 26; ++d, p <<= 1); if (d > 0) for (e.iushrn(d); d-- > 0;)(i.isOdd() || o.isOdd()) && (i.iadd(u), o.isub(h)), i.iushrn(1), o.iushrn(1); for (var f = 0, m = 1; 0 == (n.words[0] & m) && f < 26; ++f, m <<= 1); if (f > 0) for (n.iushrn(f); f-- > 0;)(a.isOdd() || l.isOdd()) && (a.iadd(u), l.isub(h)), a.iushrn(1), l.iushrn(1); e.cmp(n) >= 0 ? (e.isub(n), i.isub(a), o.isub(l)) : (n.isub(e), a.isub(i), l.isub(o)) } return { a: a, b: l, gcd: n.iushln(c) } }, s.prototype._invmp = function (t) { r(0 === t.negative), r(!t.isZero()); var e = this, n = t.clone(); e = 0 !== e.negative ? e.umod(t) : e.clone(); for (var i, o = new s(1), a = new s(0), l = n.clone(); e.cmpn(1) > 0 && n.cmpn(1) > 0;) { for (var c = 0, u = 1; 0 == (e.words[0] & u) && c < 26; ++c, u <<= 1); if (c > 0) for (e.iushrn(c); c-- > 0;)o.isOdd() && o.iadd(l), o.iushrn(1); for (var h = 0, d = 1; 0 == (n.words[0] & d) && h < 26; ++h, d <<= 1); if (h > 0) for (n.iushrn(h); h-- > 0;)a.isOdd() && a.iadd(l), a.iushrn(1); e.cmp(n) >= 0 ? (e.isub(n), o.isub(a)) : (n.isub(e), a.isub(o)) } return (i = 0 === e.cmpn(1) ? o : a).cmpn(0) < 0 && i.iadd(t), i }, s.prototype.gcd = function (t) { if (this.isZero()) return t.abs(); if (t.isZero()) return this.abs(); var e = this.clone(), n = t.clone(); e.negative = 0, n.negative = 0; for (var r = 0; e.isEven() && n.isEven(); r++)e.iushrn(1), n.iushrn(1); for (; ;) { for (; e.isEven();)e.iushrn(1); for (; n.isEven();)n.iushrn(1); var i = e.cmp(n); if (i < 0) { var s = e; e = n, n = s } else if (0 === i || 0 === n.cmpn(1)) break; e.isub(n) } return n.iushln(r) }, s.prototype.invm = function (t) { return this.egcd(t).a.umod(t) }, s.prototype.isEven = function () { return 0 == (1 & this.words[0]) }, s.prototype.isOdd = function () { return 1 == (1 & this.words[0]) }, s.prototype.andln = function (t) { return this.words[0] & t }, s.prototype.bincn = function (t) { r("number" == typeof t); var e = t % 26, n = (t - e) / 26, i = 1 << e; if (this.length <= n) return this._expand(n + 1), this.words[n] |= i, this; for (var s = i, o = n; 0 !== s && o < this.length; o++) { var a = 0 | this.words[o]; s = (a += s) >>> 26, this.words[o] = a &= 67108863 } return 0 !== s && (this.words[o] = s, this.length++), this }, s.prototype.isZero = function () { return 1 === this.length && 0 === this.words[0] }, s.prototype.cmpn = function (t) { var e, n = t < 0; if (0 !== this.negative && !n) return -1; if (0 === this.negative && n) return 1; if (this.strip(), this.length > 1) e = 1; else { n && (t = -t), r(t <= 67108863, "Number is too big"); var i = 0 | this.words[0]; e = i === t ? 0 : i < t ? -1 : 1 } return 0 !== this.negative ? 0 | -e : e }, s.prototype.cmp = function (t) { if (0 !== this.negative && 0 === t.negative) return -1; if (0 === this.negative && 0 !== t.negative) return 1; var e = this.ucmp(t); return 0 !== this.negative ? 0 | -e : e }, s.prototype.ucmp = function (t) { if (this.length > t.length) return 1; if (this.length < t.length) return -1; for (var e = 0, n = this.length - 1; n >= 0; n--) { var r = 0 | this.words[n], i = 0 | t.words[n]; if (r !== i) { r < i ? e = -1 : r > i && (e = 1); break } } return e }, s.prototype.gtn = function (t) { return 1 === this.cmpn(t) }, s.prototype.gt = function (t) { return 1 === this.cmp(t) }, s.prototype.gten = function (t) { return this.cmpn(t) >= 0 }, s.prototype.gte = function (t) { return this.cmp(t) >= 0 }, s.prototype.ltn = function (t) { return -1 === this.cmpn(t) }, s.prototype.lt = function (t) { return -1 === this.cmp(t) }, s.prototype.lten = function (t) { return this.cmpn(t) <= 0 }, s.prototype.lte = function (t) { return this.cmp(t) <= 0 }, s.prototype.eqn = function (t) { return 0 === this.cmpn(t) }, s.prototype.eq = function (t) { return 0 === this.cmp(t) }, s.red = function (t) { return new x(t) }, s.prototype.toRed = function (t) { return r(!this.red, "Already a number in reduction context"), r(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t) }, s.prototype.fromRed = function () { return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, s.prototype._forceRed = function (t) { return this.red = t, this }, s.prototype.forceRed = function (t) { return r(!this.red, "Already a number in reduction context"), this._forceRed(t) }, s.prototype.redAdd = function (t) { return r(this.red, "redAdd works only with red numbers"), this.red.add(this, t) }, s.prototype.redIAdd = function (t) { return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t) }, s.prototype.redSub = function (t) { return r(this.red, "redSub works only with red numbers"), this.red.sub(this, t) }, s.prototype.redISub = function (t) { return r(this.red, "redISub works only with red numbers"), this.red.isub(this, t) }, s.prototype.redShl = function (t) { return r(this.red, "redShl works only with red numbers"), this.red.shl(this, t) }, s.prototype.redMul = function (t) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t) }, s.prototype.redIMul = function (t) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t) }, s.prototype.redSqr = function () { return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, s.prototype.redISqr = function () { return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, s.prototype.redSqrt = function () { return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, s.prototype.redInvm = function () { return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, s.prototype.redNeg = function () { return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, s.prototype.redPow = function (t) { return r(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t) }; var v = { k256: null, p224: null, p192: null, p25519: null }; function y(t, e) { this.name = t, this.p = new s(e, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } function b() { y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } function _() { y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } function w() { y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } function S() { y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } function x(t) { if ("string" == typeof t) { var e = s._prime(t); this.m = e.p, this.prime = e } else r(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null } function T(t) { x.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } y.prototype._tmp = function () { var t = new s(null); return t.words = new Array(Math.ceil(this.n / 13)), t }, y.prototype.ireduce = function (t) { var e, n = t; do { this.split(n, this.tmp), e = (n = (n = this.imulK(n)).iadd(this.tmp)).bitLength() } while (e > this.n); var r = e < this.n ? -1 : n.ucmp(this.p); return 0 === r ? (n.words[0] = 0, n.length = 1) : r > 0 ? n.isub(this.p) : void 0 !== n.strip ? n.strip() : n._strip(), n }, y.prototype.split = function (t, e) { t.iushrn(this.n, 0, e) }, y.prototype.imulK = function (t) { return t.imul(this.k) }, i(b, y), b.prototype.split = function (t, e) { for (var n = 4194303, r = Math.min(t.length, 9), i = 0; i < r; i++)e.words[i] = t.words[i]; if (e.length = r, t.length <= 9) return t.words[0] = 0, void (t.length = 1); var s = t.words[9]; for (e.words[e.length++] = s & n, i = 10; i < t.length; i++) { var o = 0 | t.words[i]; t.words[i - 10] = (o & n) << 4 | s >>> 22, s = o } t.words[i - 10] = s >>>= 22, t.length -= 0 === s && t.length > 10 ? 10 : 9 }, b.prototype.imulK = function (t) { t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2; for (var e = 0, n = 0; n < t.length; n++) { var r = 0 | t.words[n]; t.words[n] = 67108863 & (e += 977 * r), e = 64 * r + (e / 67108864 | 0) } return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t }, i(_, y), i(w, y), i(S, y), S.prototype.imulK = function (t) { for (var e = 0, n = 0; n < t.length; n++) { var r = 19 * (0 | t.words[n]) + e, i = 67108863 & r; r >>>= 26, t.words[n] = i, e = r } return 0 !== e && (t.words[t.length++] = e), t }, s._prime = function (t) { if (v[t]) return v[t]; var e; if ("k256" === t) e = new b; else if ("p224" === t) e = new _; else if ("p192" === t) e = new w; else { if ("p25519" !== t) throw new Error("Unknown prime " + t); e = new S } return v[t] = e, e }, x.prototype._verify1 = function (t) { r(0 === t.negative, "red works only with positives"), r(t.red, "red works only with red numbers") }, x.prototype._verify2 = function (t, e) { r(0 == (t.negative | e.negative), "red works only with positives"), r(t.red && t.red === e.red, "red works only with red numbers") }, x.prototype.imod = function (t) { return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this) }, x.prototype.neg = function (t) { return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this) }, x.prototype.add = function (t, e) { this._verify2(t, e); var n = t.add(e); return n.cmp(this.m) >= 0 && n.isub(this.m), n._forceRed(this) }, x.prototype.iadd = function (t, e) { this._verify2(t, e); var n = t.iadd(e); return n.cmp(this.m) >= 0 && n.isub(this.m), n }, x.prototype.sub = function (t, e) { this._verify2(t, e); var n = t.sub(e); return n.cmpn(0) < 0 && n.iadd(this.m), n._forceRed(this) }, x.prototype.isub = function (t, e) { this._verify2(t, e); var n = t.isub(e); return n.cmpn(0) < 0 && n.iadd(this.m), n }, x.prototype.shl = function (t, e) { return this._verify1(t), this.imod(t.ushln(e)) }, x.prototype.imul = function (t, e) { return this._verify2(t, e), this.imod(t.imul(e)) }, x.prototype.mul = function (t, e) { return this._verify2(t, e), this.imod(t.mul(e)) }, x.prototype.isqr = function (t) { return this.imul(t, t.clone()) }, x.prototype.sqr = function (t) { return this.mul(t, t) }, x.prototype.sqrt = function (t) { if (t.isZero()) return t.clone(); var e = this.m.andln(3); if (r(e % 2 == 1), 3 === e) { var n = this.m.add(new s(1)).iushrn(2); return this.pow(t, n) } for (var i = this.m.subn(1), o = 0; !i.isZero() && 0 === i.andln(1);)o++, i.iushrn(1); r(!i.isZero()); var a = new s(1).toRed(this), l = a.redNeg(), c = this.m.subn(1).iushrn(1), u = this.m.bitLength(); for (u = new s(2 * u * u).toRed(this); 0 !== this.pow(u, c).cmp(l);)u.redIAdd(l); for (var h = this.pow(u, i), d = this.pow(t, i.addn(1).iushrn(1)), p = this.pow(t, i), f = o; 0 !== p.cmp(a);) { for (var m = p, g = 0; 0 !== m.cmp(a); g++)m = m.redSqr(); r(g < f); var v = this.pow(h, new s(1).iushln(f - g - 1)); d = d.redMul(v), h = v.redSqr(), p = p.redMul(h), f = g } return d }, x.prototype.invm = function (t) { var e = t._invmp(this.m); return 0 !== e.negative ? (e.negative = 0, this.imod(e).redNeg()) : this.imod(e) }, x.prototype.pow = function (t, e) { if (e.isZero()) return new s(1).toRed(this); if (0 === e.cmpn(1)) return t.clone(); var n = new Array(16); n[0] = new s(1).toRed(this), n[1] = t; for (var r = 2; r < n.length; r++)n[r] = this.mul(n[r - 1], t); var i = n[0], o = 0, a = 0, l = e.bitLength() % 26; for (0 === l && (l = 26), r = e.length - 1; r >= 0; r--) { for (var c = e.words[r], u = l - 1; u >= 0; u--) { var h = c >> u & 1; i !== n[0] && (i = this.sqr(i)), 0 !== h || 0 !== o ? (o <<= 1, o |= h, (4 == ++a || 0 === r && 0 === u) && (i = this.mul(i, n[o]), a = 0, o = 0)) : a = 0 } l = 26 } return i }, x.prototype.convertTo = function (t) { var e = t.umod(this.m); return e === t ? e.clone() : e }, x.prototype.convertFrom = function (t) { var e = t.clone(); return e.red = null, e }, s.mont = function (t) { return new T(t) }, i(T, x), T.prototype.convertTo = function (t) { return this.imod(t.ushln(this.shift)) }, T.prototype.convertFrom = function (t) { var e = this.imod(t.mul(this.rinv)); return e.red = null, e }, T.prototype.imul = function (t, e) { if (t.isZero() || e.isZero()) return t.words[0] = 0, t.length = 1, t; var n = t.imul(e), r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i = n.isub(r).iushrn(this.shift), s = i; return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this) }, T.prototype.mul = function (t, e) { if (t.isZero() || e.isZero()) return new s(0)._forceRed(this); var n = t.mul(e), r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), i = n.isub(r).iushrn(this.shift), o = i; return i.cmp(this.m) >= 0 ? o = i.isub(this.m) : i.cmpn(0) < 0 && (o = i.iadd(this.m)), o._forceRed(this) }, T.prototype.invm = function (t) { return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this) } }(t = n.nmd(t), this) }, 1985: (t, e, n) => { "use strict"; n.r(e), n.d(e, { pack: () => d, keccak256: () => p, sha256: () => f }); var r = n(2024), i = n(1488), s = n(8518), o = n(5614), a = n(8822); const l = new RegExp("^bytes([0-9]+)$"), c = new RegExp("^(u?int)([0-9]*)$"), u = new RegExp("^(.*)\\[([0-9]*)\\]$"); function h(t, e, n) { switch (t) { case "address": return n ? (0, i.zeroPad)(e, 32) : (0, i.arrayify)(e); case "string": return (0, a.Y0)(e); case "bytes": return (0, i.arrayify)(e); case "bool": return e = e ? "0x01" : "0x00", n ? (0, i.zeroPad)(e, 32) : (0, i.arrayify)(e) }let s = t.match(c); if (s) { let o = parseInt(s[2] || "256"); if (s[2] && String(o) !== s[2] || o % 8 != 0 || 0 === o || o > 256) throw new Error("invalid number type - " + t); return n && (o = 256), e = r.O$.from(e).toTwos(o), (0, i.zeroPad)(e, o / 8) } if (s = t.match(l), s) { const r = parseInt(s[1]); if (String(r) !== s[1] || 0 === r || r > 32) throw new Error("invalid bytes type - " + t); if ((0, i.arrayify)(e).byteLength !== r) throw new Error("invalid value for " + t); return n ? (0, i.arrayify)((e + "0000000000000000000000000000000000000000000000000000000000000000").substring(0, 66)) : e } if (s = t.match(u), s && Array.isArray(e)) { const n = s[1]; if (parseInt(s[2] || String(e.length)) != e.length) throw new Error("invalid value for " + t); const r = []; return e.forEach(function (t) { r.push(h(n, t, !0)) }), (0, i.concat)(r) } throw new Error("invalid type - " + t) } function d(t, e) { if (t.length != e.length) throw new Error("type/value count mismatch"); const n = []; return t.forEach(function (t, r) { n.push(h(t, e[r])) }), (0, i.hexlify)((0, i.concat)(n)) } function p(t, e) { return (0, s.keccak256)(d(t, e)) } function f(t, e) { return (0, o.JQ)(d(t, e)) } }, 7188: (t, e, n) => { "use strict"; n.d(e, { Ll: () => f }); var r = n(8822); function i(t, e) { e || (e = function (t) { return [parseInt(t, 16)] }); let n = 0, r = {}; return t.split(",").forEach(t => { let i = t.split(":"); n += parseInt(i[0], 16), r[n] = e(i[1]) }), r } function s(t) { let e = 0; return t.split(",").map(t => { let n = t.split("-"); 1 === n.length ? n[1] = "0" : "" === n[1] && (n[1] = "1"); let r = e + parseInt(n[0], 16); return e = parseInt(n[1], 16), { l: r, h: e } }) } function o(t, e) { let n = 0; for (let r = 0; r < e.length; r++) { let i = e[r]; if (n += i.l, t >= n && t <= n + i.h && (t - n) % (i.d || 1) == 0) { if (i.e && -1 !== i.e.indexOf(t - n)) continue; return i } } return null } const a = s("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"), l = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(t => parseInt(t, 16)), c = [{ h: 25, s: 32, l: 65 }, { h: 30, s: 32, e: [23], l: 127 }, { h: 54, s: 1, e: [48], l: 64, d: 2 }, { h: 14, s: 1, l: 57, d: 2 }, { h: 44, s: 1, l: 17, d: 2 }, { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 }, { h: 16, s: 1, l: 68, d: 2 }, { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 }, { h: 26, s: 32, e: [17], l: 435 }, { h: 22, s: 1, l: 71, d: 2 }, { h: 15, s: 80, l: 40 }, { h: 31, s: 32, l: 16 }, { h: 32, s: 1, l: 80, d: 2 }, { h: 52, s: 1, l: 42, d: 2 }, { h: 12, s: 1, l: 55, d: 2 }, { h: 40, s: 1, e: [38], l: 15, d: 2 }, { h: 14, s: 1, l: 48, d: 2 }, { h: 37, s: 48, l: 49 }, { h: 148, s: 1, l: 6351, d: 2 }, { h: 88, s: 1, l: 160, d: 2 }, { h: 15, s: 16, l: 704 }, { h: 25, s: 26, l: 854 }, { h: 25, s: 32, l: 55915 }, { h: 37, s: 40, l: 1247 }, { h: 25, s: -119711, l: 53248 }, { h: 25, s: -119763, l: 52 }, { h: 25, s: -119815, l: 52 }, { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 }, { h: 25, s: -119919, l: 52 }, { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 }, { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 }, { h: 25, s: -120075, l: 52 }, { h: 25, s: -120127, l: 52 }, { h: 25, s: -120179, l: 52 }, { h: 25, s: -120231, l: 52 }, { h: 25, s: -120283, l: 52 }, { h: 25, s: -120335, l: 52 }, { h: 24, s: -119543, e: [17], l: 56 }, { h: 24, s: -119601, e: [17], l: 58 }, { h: 24, s: -119659, e: [17], l: 58 }, { h: 24, s: -119717, e: [17], l: 58 }, { h: 24, s: -119775, e: [17], l: 58 }], u = i("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"), h = i("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"), d = i("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", function (t) { if (t.length % 4 != 0) throw new Error("bad data"); let e = []; for (let n = 0; n < t.length; n += 4)e.push(parseInt(t.substring(n, n + 4), 16)); return e }), p = s("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001"); function f(t) { if (t.match(/^[a-z0-9-]*$/i) && t.length <= 59) return t.toLowerCase(); let e = (0, r.XL)(t); var n; n = e.map(t => l.indexOf(t) >= 0 || t >= 65024 && t <= 65039 ? [] : function (t) { let e = o(t, c); if (e) return [t + e.s]; let n = u[t]; if (n) return n; let r = h[t]; return r ? [t + r[0]] : d[t] || null }(t) || [t]), e = n.reduce((t, e) => (e.forEach(e => { t.push(e) }), t), []), e = (0, r.XL)((0, r.uu)(e), r.Uj.NFKC), e.forEach(t => { if (o(t, p)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED") }), e.forEach(t => { if (o(t, a)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED") }); let i = (0, r.uu)(e); if ("-" === i.substring(0, 1) || "--" === i.substring(2, 4) || "-" === i.substring(i.length - 1)) throw new Error("invalid hyphen"); if (i.length > 63) throw new Error("too long"); return i } }, 2838: (t, e, n) => { "use strict"; n.r(e), n.d(e, { UnicodeNormalizationForm: () => s.Uj, Utf8ErrorFuncs: () => s.te, Utf8ErrorReason: () => s.Uw, _toEscapedUtf8String: () => s.U$, formatBytes32String: () => o, nameprep: () => l.Ll, parseBytes32String: () => a, toUtf8Bytes: () => s.Y0, toUtf8CodePoints: () => s.XL, toUtf8String: () => s.ZN }); var r = n(5052), i = n(1488), s = n(8822); function o(t) { const e = (0, s.Y0)(t); if (e.length > 31) throw new Error("bytes32 string must be less than 32 bytes"); return (0, i.hexlify)((0, i.concat)([e, r.R]).slice(0, 32)) } function a(t) { const e = (0, i.arrayify)(t); if (32 !== e.length) throw new Error("invalid bytes32 - not 32 bytes long"); if (0 !== e[31]) throw new Error("invalid bytes32 string - no null terminator"); let n = 31; for (; 0 === e[n - 1];)n--; return (0, s.ZN)(e.slice(0, n)) } var l = n(7188) }, 8822: (t, e, n) => { "use strict"; n.d(e, { Uj: () => s, te: () => l, Uw: () => o, U$: () => d, uu: () => p, Y0: () => u, XL: () => m, ZN: () => f }); var r = n(1488); const i = new (n(3898).Logger)("strings/5.1.0"); var s = (() => (function (t) { t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD" }(s || (s = {})), s))(), o = (() => (function (t) { t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation" }(o || (o = {})), o))(); function a(t, e, n, r, i) { if (t === o.BAD_PREFIX || t === o.UNEXPECTED_CONTINUE) { let t = 0; for (let r = e + 1; r < n.length && n[r] >> 6 == 2; r++)t++; return t } return t === o.OVERRUN ? n.length - e - 1 : 0 } const l = Object.freeze({ error: function (t, e, n, r, s) { return i.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", n) }, ignore: a, replace: function (t, e, n, r, i) { return t === o.OVERLONG ? (r.push(i), 0) : (r.push(65533), a(t, e, n)) } }); function c(t, e) { null == e && (e = l.error), t = (0, r.arrayify)(t); const n = []; let i = 0; for (; i < t.length;) { const r = t[i++]; if (r >> 7 == 0) { n.push(r); continue } let s = null, a = null; if (192 == (224 & r)) s = 1, a = 127; else if (224 == (240 & r)) s = 2, a = 2047; else { if (240 != (248 & r)) { i += e(128 == (192 & r) ? o.UNEXPECTED_CONTINUE : o.BAD_PREFIX, i - 1, t, n); continue } s = 3, a = 65535 } if (i - 1 + s >= t.length) { i += e(o.OVERRUN, i - 1, t, n); continue } let l = r & (1 << 8 - s - 1) - 1; for (let c = 0; c < s; c++) { let r = t[i]; if (128 != (192 & r)) { i += e(o.MISSING_CONTINUE, i, t, n), l = null; break } l = l << 6 | 63 & r, i++ } null !== l && (l > 1114111 ? i += e(o.OUT_OF_RANGE, i - 1 - s, t, n, l) : l >= 55296 && l <= 57343 ? i += e(o.UTF16_SURROGATE, i - 1 - s, t, n, l) : l <= a ? i += e(o.OVERLONG, i - 1 - s, t, n, l) : n.push(l)) } return n } function u(t, e = s.current) { e != s.current && (i.checkNormalize(), t = t.normalize(e)); let n = []; for (let r = 0; r < t.length; r++) { const e = t.charCodeAt(r); if (e < 128) n.push(e); else if (e < 2048) n.push(e >> 6 | 192), n.push(63 & e | 128); else if (55296 == (64512 & e)) { r++; const i = t.charCodeAt(r); if (r >= t.length || 56320 != (64512 & i)) throw new Error("invalid utf-8 string"); const s = 65536 + ((1023 & e) << 10) + (1023 & i); n.push(s >> 18 | 240), n.push(s >> 12 & 63 | 128), n.push(s >> 6 & 63 | 128), n.push(63 & s | 128) } else n.push(e >> 12 | 224), n.push(e >> 6 & 63 | 128), n.push(63 & e | 128) } return (0, r.arrayify)(n) } function h(t) { const e = "0000" + t.toString(16); return "\\u" + e.substring(e.length - 4) } function d(t, e) { return '"' + c(t, e).map(t => { if (t < 256) { switch (t) { case 8: return "\\b"; case 9: return "\\t"; case 10: return "\\n"; case 13: return "\\r"; case 34: return '\\"'; case 92: return "\\\\" }if (t >= 32 && t < 127) return String.fromCharCode(t) } return t <= 65535 ? h(t) : h(55296 + ((t -= 65536) >> 10 & 1023)) + h(56320 + (1023 & t)) }).join("") + '"' } function p(t) { return t.map(t => t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10 & 1023), 56320 + (1023 & t)))).join("") } function f(t, e) { return p(c(t, e)) } function m(t, e = s.current) { return c(u(t, e)) } }, 2701: (t, e, n) => { "use strict"; n.r(e), n.d(e, { accessListify: () => w, computeAddress: () => v, parse: () => T, recoverAddress: () => y, serialize: () => x }); var r = n(2885), i = n(2024), s = n(1488), o = n(6659), a = n(8518), l = n(2275), c = n(9276), u = n(9596), h = n(3898); const d = new h.Logger("transactions/5.1.1"); function p(t) { return "0x" === t ? null : (0, r.getAddress)(t) } function f(t) { return "0x" === t ? o._Y : i.O$.from(t) } const m = [{ name: "nonce", maxLength: 32, numeric: !0 }, { name: "gasPrice", maxLength: 32, numeric: !0 }, { name: "gasLimit", maxLength: 32, numeric: !0 }, { name: "to", length: 20 }, { name: "value", maxLength: 32, numeric: !0 }, { name: "data" }], g = { chainId: !0, data: !0, gasLimit: !0, gasPrice: !0, nonce: !0, to: !0, value: !0 }; function v(t) { const e = (0, u.computePublicKey)(t); return (0, r.getAddress)((0, s.hexDataSlice)((0, a.keccak256)((0, s.hexDataSlice)(e, 1)), 12)) } function y(t, e) { return v((0, u.recoverPublicKey)((0, s.arrayify)(t), e)) } function b(t, e) { const n = (0, s.stripZeros)(i.O$.from(t).toHexString()); return n.length > 32 && d.throwArgumentError("invalid length for " + e, "transaction:" + e, t), n } function _(t, e) { return { address: (0, r.getAddress)(t), storageKeys: (e || []).map((e, n) => (32 !== (0, s.hexDataLength)(e) && d.throwArgumentError("invalid access list storageKey", `accessList[${t}:${n}]`, e), e.toLowerCase())) } } function w(t) { if (Array.isArray(t)) return t.map((t, e) => Array.isArray(t) ? (t.length > 2 && d.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${e}]`, t), _(t[0], t[1])) : _(t.address, t.storageKeys)); const e = Object.keys(t).map(e => { const n = t[e].reduce((t, e) => (t[e] = !0, t), {}); return _(e, Object.keys(n).sort()) }); return e.sort((t, e) => t.address.localeCompare(e.address)), e } function S(t, e) { const n = [b(t.chainId || 0, "chainId"), b(t.nonce || 0, "nonce"), b(t.gasPrice || 0, "gasPrice"), b(t.gasLimit || 0, "gasLimit"), null != t.to ? (0, r.getAddress)(t.to) : "0x", b(t.value || 0, "value"), t.data || "0x", (i = t.accessList || [], w(i).map(t => [t.address, t.storageKeys]))]; var i; if (e) { const t = (0, s.splitSignature)(e); n.push(b(t.recoveryParam, "recoveryParam")), n.push((0, s.stripZeros)(t.r)), n.push((0, s.stripZeros)(t.s)) } return (0, s.hexConcat)(["0x01", c.encode(n)]) } function x(t, e) { if (null == t.type) return null != t.accessList && d.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", t), function (t, e) { (0, l.checkProperties)(t, g); const n = []; m.forEach(function (e) { let r = t[e.name] || []; const i = {}; e.numeric && (i.hexPad = "left"), r = (0, s.arrayify)((0, s.hexlify)(r, i)), e.length && r.length !== e.length && r.length > 0 && d.throwArgumentError("invalid length for " + e.name, "transaction:" + e.name, r), e.maxLength && (r = (0, s.stripZeros)(r), r.length > e.maxLength && d.throwArgumentError("invalid length for " + e.name, "transaction:" + e.name, r)), n.push((0, s.hexlify)(r)) }); let r = 0; if (null != t.chainId ? (r = t.chainId, "number" != typeof r && d.throwArgumentError("invalid transaction.chainId", "transaction", t)) : e && !(0, s.isBytesLike)(e) && e.v > 28 && (r = Math.floor((e.v - 35) / 2)), 0 !== r && (n.push((0, s.hexlify)(r)), n.push("0x"), n.push("0x")), !e) return c.encode(n); const i = (0, s.splitSignature)(e); let o = 27 + i.recoveryParam; return 0 !== r ? (n.pop(), n.pop(), n.pop(), o += 2 * r + 8, i.v > 28 && i.v !== o && d.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e)) : i.v !== o && d.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e), n.push((0, s.hexlify)(o)), n.push((0, s.stripZeros)((0, s.arrayify)(i.r))), n.push((0, s.stripZeros)((0, s.arrayify)(i.s))), c.encode(n) }(t, e); switch (t.type) { case 1: return S(t, e) }return d.throwError(`unsupported transaction type: ${t.type}`, h.Logger.errors.UNSUPPORTED_OPERATION, { operation: "serializeTransaction", transactionType: t.type }) } function T(t) { const e = (0, s.arrayify)(t); if (e[0] > 127) return function (t) { const e = c.decode(t); 9 !== e.length && 6 !== e.length && d.throwArgumentError("invalid raw transaction", "rawTransaction", t); const n = { nonce: f(e[0]).toNumber(), gasPrice: f(e[1]), gasLimit: f(e[2]), to: p(e[3]), value: f(e[4]), data: e[5], chainId: 0 }; if (6 === e.length) return n; try { n.v = i.O$.from(e[6]).toNumber() } catch (r) { return console.log(r), n } if (n.r = (0, s.hexZeroPad)(e[7], 32), n.s = (0, s.hexZeroPad)(e[8], 32), i.O$.from(n.r).isZero() && i.O$.from(n.s).isZero()) n.chainId = n.v, n.v = 0; else { n.chainId = Math.floor((n.v - 35) / 2), n.chainId < 0 && (n.chainId = 0); let i = n.v - 27; const o = e.slice(0, 6); 0 !== n.chainId && (o.push((0, s.hexlify)(n.chainId)), o.push("0x"), o.push("0x"), i -= 2 * n.chainId + 8); const l = (0, a.keccak256)(c.encode(o)); try { n.from = y(l, { r: (0, s.hexlify)(n.r), s: (0, s.hexlify)(n.s), recoveryParam: i }) } catch (r) { console.log(r) } n.hash = (0, a.keccak256)(t) } return n.type = null, n }(e); switch (e[0]) { case 1: return function (t) { const e = c.decode(t.slice(1)); 8 !== e.length && 11 !== e.length && d.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, s.hexlify)(t)); const n = { type: 1, chainId: f(e[0]).toNumber(), nonce: f(e[1]).toNumber(), gasPrice: f(e[2]), gasLimit: f(e[3]), to: p(e[4]), value: f(e[5]), data: e[6], accessList: w(e[7]) }; if (8 === e.length) return n; try { const t = f(e[8]).toNumber(); if (0 !== t && 1 !== t) throw new Error("bad recid"); n.v = t } catch (r) { d.throwArgumentError("invalid v for transaction type: 1", "v", e[8]) } n.r = (0, s.hexZeroPad)(e[9], 32), n.s = (0, s.hexZeroPad)(e[10], 32); try { const t = (0, a.keccak256)(S(n)); n.from = y(t, { r: n.r, s: n.s, recoveryParam: n.v }) } catch (r) { console.log(r) } return n.hash = (0, a.keccak256)(t), n }(e) }return d.throwError(`unsupported transaction type: ${e[0]}`, h.Logger.errors.UNSUPPORTED_OPERATION, { operation: "parseTransaction", transactionType: e[0] }) } }, 2519: (t, e, n) => { "use strict"; n.r(e), n.d(e, { commify: () => o, formatEther: () => c, formatUnits: () => a, parseEther: () => u, parseUnits: () => l }); var r = n(1677); const i = new (n(3898).Logger)("units/5.1.0"), s = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"]; function o(t) { const e = String(t).split("."); (e.length > 2 || !e[0].match(/^-?[0-9]*$/) || e[1] && !e[1].match(/^[0-9]*$/) || "." === t || "-." === t) && i.throwArgumentError("invalid value", "value", t); let n = e[0], r = ""; for ("-" === n.substring(0, 1) && (r = "-", n = n.substring(1)); "0" === n.substring(0, 1);)n = n.substring(1); "" === n && (n = "0"); let s = ""; for (2 === e.length && (s = "." + (e[1] || "0")); s.length > 2 && "0" === s[s.length - 1];)s = s.substring(0, s.length - 1); const o = []; for (; n.length;) { if (n.length <= 3) { o.unshift(n); break } { const t = n.length - 3; o.unshift(n.substring(t)), n = n.substring(0, t) } } return r + o.join(",") + s } function a(t, e) { if ("string" == typeof e) { const t = s.indexOf(e); -1 !== t && (e = 3 * t) } return (0, r.S5)(t, null != e ? e : 18) } function l(t, e) { if ("string" != typeof t && i.throwArgumentError("value must be a string", "value", t), "string" == typeof e) { const t = s.indexOf(e); -1 !== t && (e = 3 * t) } return (0, r.Ox)(t, null != e ? e : 18) } function c(t) { return a(t, 18) } function u(t) { return l(t, 18) } }, 6846: (t, e, n) => { "use strict"; n.r(e), n.d(e, { Wallet: () => _, verifyMessage: () => w, verifyTypedData: () => S }); var r = n(2885), i = n(1527), s = n(1221), o = n(1488), a = n(8429), l = n(2072), c = n(9593), u = n(8518), h = n(2275), d = n(2563), p = n(9596), f = n(9799), m = n(6484), g = n(2701), v = n(3898), y = function (t, e, n, r) { return new (n || (n = Promise))(function (i, s) { function o(t) { try { l(r.next(t)) } catch (e) { s(e) } } function a(t) { try { l(r.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } l((r = r.apply(t, e || [])).next()) }) }; const b = new v.Logger("wallet/5.1.0"); class _ extends s.Signer { constructor(t, e) { if (b.checkNew(new.target, _), super(), null != (n = t) && (0, o.isHexString)(n.privateKey, 32) && null != n.address) { const e = new p.SigningKey(t.privateKey); if ((0, h.defineReadOnly)(this, "_signingKey", () => e), (0, h.defineReadOnly)(this, "address", (0, g.computeAddress)(this.publicKey)), this.address !== (0, r.getAddress)(t.address) && b.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), function (t) { const e = t.mnemonic; return e && e.phrase }(t)) { const e = t.mnemonic; (0, h.defineReadOnly)(this, "_mnemonic", () => ({ phrase: e.phrase, path: e.path || c.defaultPath, locale: e.locale || "en" })); const n = this.mnemonic, r = c.HDNode.fromMnemonic(n.phrase, null, n.locale).derivePath(n.path); (0, g.computeAddress)(r.privateKey) !== this.address && b.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]") } else (0, h.defineReadOnly)(this, "_mnemonic", () => null) } else { if (p.SigningKey.isSigningKey(t)) "secp256k1" !== t.curve && b.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), (0, h.defineReadOnly)(this, "_signingKey", () => t); else { "string" == typeof t && t.match(/^[0-9a-f]*$/i) && 64 === t.length && (t = "0x" + t); const e = new p.SigningKey(t); (0, h.defineReadOnly)(this, "_signingKey", () => e) } (0, h.defineReadOnly)(this, "_mnemonic", () => null), (0, h.defineReadOnly)(this, "address", (0, g.computeAddress)(this.publicKey)) } var n; e && !i.zt.isProvider(e) && b.throwArgumentError("invalid provider", "provider", e), (0, h.defineReadOnly)(this, "provider", e || null) } get mnemonic() { return this._mnemonic() } get privateKey() { return this._signingKey().privateKey } get publicKey() { return this._signingKey().publicKey } getAddress() { return Promise.resolve(this.address) } connect(t) { return new _(this, t) } signTransaction(t) { return (0, h.resolveProperties)(t).then(e => { null != e.from && ((0, r.getAddress)(e.from) !== this.address && b.throwArgumentError("transaction from address mismatch", "transaction.from", t.from), delete e.from); const n = this._signingKey().signDigest((0, u.keccak256)((0, g.serialize)(e))); return (0, g.serialize)(e, n) }) } signMessage(t) { return y(this, void 0, void 0, function* () { return (0, o.joinSignature)(this._signingKey().signDigest((0, a.r)(t))) }) } _signTypedData(t, e, n) { return y(this, void 0, void 0, function* () { const r = yield l.E.resolveNames(t, e, n, t => (null == this.provider && b.throwError("cannot resolve ENS names without a provider", v.Logger.errors.UNSUPPORTED_OPERATION, { operation: "resolveName", value: t }), this.provider.resolveName(t))); return (0, o.joinSignature)(this._signingKey().signDigest(l.E.hash(r.domain, e, r.value))) }) } encrypt(t, e, n) { if ("function" != typeof e || n || (n = e, e = {}), n && "function" != typeof n) throw new Error("invalid callback"); return e || (e = {}), (0, m.HI)(this, t, e, n) } static createRandom(t) { let e = (0, d.O)(16); t || (t = {}), t.extraEntropy && (e = (0, o.arrayify)((0, o.hexDataSlice)((0, u.keccak256)((0, o.concat)([e, t.extraEntropy])), 0, 16))); const n = (0, c.entropyToMnemonic)(e, t.locale); return _.fromMnemonic(n, t.path, t.locale) } static fromEncryptedJson(t, e, n) { return (0, f.decryptJsonWallet)(t, e, n).then(t => new _(t)) } static fromEncryptedJsonSync(t, e) { return new _((0, f.decryptJsonWalletSync)(t, e)) } static fromMnemonic(t, e, n) { return e || (e = c.defaultPath), new _(c.HDNode.fromMnemonic(t, null, n).derivePath(e)) } } function w(t, e) { return (0, g.recoverAddress)((0, a.r)(t), e) } function S(t, e, n, r) { return (0, g.recoverAddress)(l.E.hash(t, e, n), r) } }, 3511: (t, e, n) => { "use strict"; n.r(e), n.d(e, { _fetchData: () => d, fetchJson: () => p, poll: () => f }); var r = n(7530), i = n(1488), s = n(2275), o = n(8822), a = n(3898); function l(t, e) { return n = this, void 0, s = function* () { null == e && (e = {}); const n = { method: e.method || "GET", headers: e.headers || {}, body: e.body || void 0, mode: "cors", cache: "no-cache", credentials: "same-origin", redirect: "follow", referrer: "client" }, r = yield fetch(t, n), s = yield r.arrayBuffer(), o = {}; return r.headers.forEach ? r.headers.forEach((t, e) => { o[e.toLowerCase()] = t }) : r.headers.keys().forEach(t => { o[t.toLowerCase()] = r.headers.get(t) }), { headers: o, statusCode: r.status, statusMessage: r.statusText, body: (0, i.arrayify)(new Uint8Array(s)) } }, new ((r = void 0) || (r = Promise))(function (t, e) { function i(t) { try { a(s.next(t)) } catch (n) { e(n) } } function o(t) { try { a(s.throw(t)) } catch (n) { e(n) } } function a(e) { var n; e.done ? t(e.value) : (n = e.value, n instanceof r ? n : new r(function (t) { t(n) })).then(i, o) } a((s = s.apply(n, [])).next()) }); var n, r, s } const c = new a.Logger("web/5.1.0"); function u(t) { return new Promise(e => { setTimeout(e, t) }) } function h(t, e) { if (null == t) return null; if ("string" == typeof t) return t; if ((0, i.isBytesLike)(t)) { if (e && ("text" === e.split("/")[0] || "application/json" === e.split(";")[0].trim())) try { return (0, o.ZN)(t) } catch (n) { } return (0, i.hexlify)(t) } return t } function d(t, e, n) { const i = "object" == typeof t && null != t.throttleLimit ? t.throttleLimit : 12; c.assertArgument(i > 0 && i % 1 == 0, "invalid connection throttle limit", "connection.throttleLimit", i); const s = "object" == typeof t ? t.throttleCallback : null, d = "object" == typeof t && "number" == typeof t.throttleSlotInterval ? t.throttleSlotInterval : 100; c.assertArgument(d > 0 && d % 1 == 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", d); const p = {}; let f = null; const m = { method: "GET" }; let g = !1, v = 12e4; if ("string" == typeof t) f = t; else if ("object" == typeof t) { if (null != t && null != t.url || c.throwArgumentError("missing URL", "connection.url", t), f = t.url, "number" == typeof t.timeout && t.timeout > 0 && (v = t.timeout), t.headers) for (const e in t.headers) p[e.toLowerCase()] = { key: e, value: String(t.headers[e]) }, ["if-none-match", "if-modified-since"].indexOf(e.toLowerCase()) >= 0 && (g = !0); m.allowGzip = !!t.allowGzip, null != t.user && null != t.password && ("https:" !== f.substring(0, 6) && !0 !== t.allowInsecureAuthentication && c.throwError("basic authentication requires a secure https url", a.Logger.errors.INVALID_ARGUMENT, { argument: "url", url: f, user: t.user, password: "[REDACTED]" }), p.authorization = { key: "Authorization", value: "Basic " + (0, r.c)((0, o.Y0)(t.user + ":" + t.password)) }) } e && (m.method = "POST", m.body = e, null == p["content-type"] && (p["content-type"] = { key: "Content-Type", value: "application/octet-stream" }), null == p["content-length"] && (p["content-length"] = { key: "Content-Length", value: String(e.length) })); const y = {}; Object.keys(p).forEach(t => { const e = p[t]; y[e.key] = e.value }), m.headers = y; const b = function () { let t = null; return { promise: new Promise(function (e, n) { v && (t = setTimeout(() => { null != t && (t = null, n(c.makeError("timeout", a.Logger.errors.TIMEOUT, { requestBody: h(m.body, y["content-type"]), requestMethod: m.method, timeout: v, url: f }))) }, v)) }), cancel: function () { null != t && (clearTimeout(t), t = null) } } }(), _ = function () { return t = this, void 0, r = function* () { for (let e = 0; e < i; e++) { let r = null; try { if (r = yield l(f, m), 429 === r.statusCode && e < i) { let t = !0; if (s && (t = yield s(e, f)), t) { let t = 0; const n = r.headers["retry-after"]; t = "string" == typeof n && n.match(/^[1-9][0-9]*$/) ? 1e3 * parseInt(n) : d * parseInt(String(Math.random() * Math.pow(2, e))), yield u(t); continue } } } catch (t) { r = t.response, null == r && (b.cancel(), c.throwError("missing response", a.Logger.errors.SERVER_ERROR, { requestBody: h(m.body, y["content-type"]), requestMethod: m.method, serverError: t, url: f })) } let o = r.body; if (g && 304 === r.statusCode ? o = null : (r.statusCode < 200 || r.statusCode >= 300) && (b.cancel(), c.throwError("bad response", a.Logger.errors.SERVER_ERROR, { status: r.statusCode, headers: r.headers, body: h(o, r.headers ? r.headers["content-type"] : null), requestBody: h(m.body, y["content-type"]), requestMethod: m.method, url: f })), n) try { const t = yield n(o, r); return b.cancel(), t } catch (t) { if (t.throttleRetry && e < i) { let t = !0; if (s && (t = yield s(e, f)), t) { const t = d * parseInt(String(Math.random() * Math.pow(2, e))); yield u(t); continue } } b.cancel(), c.throwError("processing response error", a.Logger.errors.SERVER_ERROR, { body: h(o, r.headers ? r.headers["content-type"] : null), error: t, requestBody: h(m.body, y["content-type"]), requestMethod: m.method, url: f }) } return b.cancel(), o } return c.throwError("failed response", a.Logger.errors.SERVER_ERROR, { requestBody: h(m.body, y["content-type"]), requestMethod: m.method, url: f }) }, new ((e = void 0) || (e = Promise))(function (n, i) { function s(t) { try { a(r.next(t)) } catch (e) { i(e) } } function o(t) { try { a(r.throw(t)) } catch (e) { i(e) } } function a(t) { var r; t.done ? n(t.value) : (r = t.value, r instanceof e ? r : new e(function (t) { t(r) })).then(s, o) } a((r = r.apply(t, [])).next()) }); var t, e, r }(); return Promise.race([b.promise, _]) } function p(t, e, n) { let r = null; if (null != e) { r = (0, o.Y0)(e); const n = "string" == typeof t ? { url: t } : (0, s.shallowCopy)(t); n.headers ? 0 !== Object.keys(n.headers).filter(t => "content-type" === t.toLowerCase()).length || (n.headers = (0, s.shallowCopy)(n.headers), n.headers["content-type"] = "application/json") : n.headers = { "content-type": "application/json" }, t = n } return d(t, r, (t, e) => { let r = null; if (null != t) try { r = JSON.parse((0, o.ZN)(t)) } catch (i) { c.throwError("invalid JSON", a.Logger.errors.SERVER_ERROR, { body: t, error: i }) } return n && (r = n(r, e)), r }) } function f(t, e) { return e || (e = {}), null == (e = (0, s.shallowCopy)(e)).floor && (e.floor = 0), null == e.ceiling && (e.ceiling = 1e4), null == e.interval && (e.interval = 250), new Promise(function (n, r) { let i = null, s = !1; const o = () => !s && (s = !0, i && clearTimeout(i), !0); e.timeout && (i = setTimeout(() => { o() && r(new Error("timeout")) }, e.timeout)); const a = e.retryLimit; let l = 0; !function i() { return t().then(function (t) { if (void 0 !== t) o() && n(t); else if (e.oncePoll) e.oncePoll.once("poll", i); else if (e.onceBlock) e.onceBlock.once("block", i); else if (!s) { if (l++, l > a) return void (o() && r(new Error("retry limit reached"))); let t = e.interval * parseInt(String(Math.random() * Math.pow(2, l))); t < e.floor && (t = e.floor), t > e.ceiling && (t = e.ceiling), setTimeout(i, t) } return null }, function (t) { o() && r(t) }) }() }) } }, 4501: (t, e, n) => { "use strict"; n.r(e), n.d(e, { logger: () => r.k, Wordlist: () => r.D, wordlists: () => i.E }); var r = n(4667), i = n(7887) }, 4667: (t, e, n) => { "use strict"; n.d(e, { D: () => o, k: () => s }); var r = n(7475), i = n(2275); const s = new (n(3898).Logger)("wordlists/5.1.0"); class o { constructor(t) { s.checkAbstract(new.target, o), (0, i.defineReadOnly)(this, "locale", t) } split(t) { return t.toLowerCase().split(/ +/g) } join(t) { return t.join(" ") } static check(t) { const e = []; for (let n = 0; n < 2048; n++) { const r = t.getWord(n); if (n !== t.getWordIndex(r)) return "0x"; e.push(r) } return (0, r.id)(e.join("\n") + "\n") } static register(t, e) { e || (e = t.locale) } } }, 7887: (t, e, n) => { "use strict"; n.d(e, { E: () => V }); var r = n(4667); let i = null; function s(t) { if (null == i && (i = "AbdikaceAbecedaAdresaAgreseAkceAktovkaAlejAlkoholAmputaceAnanasAndulkaAnekdotaAnketaAntikaAnulovatArchaAroganceAsfaltAsistentAspiraceAstmaAstronomAtlasAtletikaAtolAutobusAzylBabkaBachorBacilBaculkaBadatelBagetaBagrBahnoBakterieBaladaBaletkaBalkonBalonekBalvanBalzaBambusBankomatBarbarBaretBarmanBarokoBarvaBaterkaBatohBavlnaBazalkaBazilikaBazukaBednaBeranBesedaBestieBetonBezinkaBezmocBeztakBicyklBidloBiftekBikinyBilanceBiografBiologBitvaBizonBlahobytBlatouchBlechaBleduleBleskBlikatBliznaBlokovatBlouditBludBobekBobrBodlinaBodnoutBohatostBojkotBojovatBokorysBolestBorecBoroviceBotaBoubelBouchatBoudaBouleBouratBoxerBradavkaBramboraBrankaBratrBreptaBriketaBrkoBrlohBronzBroskevBrunetkaBrusinkaBrzdaBrzyBublinaBubnovatBuchtaBuditelBudkaBudovaBufetBujarostBukviceBuldokBulvaBundaBunkrBurzaButikBuvolBuzolaBydletBylinaBytovkaBzukotCapartCarevnaCedrCeduleCejchCejnCelaCelerCelkemCelniceCeninaCennostCenovkaCentrumCenzorCestopisCetkaChalupaChapadloCharitaChataChechtatChemieChichotChirurgChladChlebaChlubitChmelChmuraChobotChocholChodbaCholeraChomoutChopitChorobaChovChrapotChrlitChrtChrupChtivostChudinaChutnatChvatChvilkaChvostChybaChystatChytitCibuleCigaretaCihelnaCihlaCinkotCirkusCisternaCitaceCitrusCizinecCizostClonaCokolivCouvatCtitelCtnostCudnostCuketaCukrCupotCvaknoutCvalCvikCvrkotCyklistaDalekoDarebaDatelDatumDceraDebataDechovkaDecibelDeficitDeflaceDeklDekretDemokratDepreseDerbyDeskaDetektivDikobrazDiktovatDiodaDiplomDiskDisplejDivadloDivochDlahaDlouhoDluhopisDnesDobroDobytekDocentDochutitDodnesDohledDohodaDohraDojemDojniceDokladDokolaDoktorDokumentDolarDolevaDolinaDomaDominantDomluvitDomovDonutitDopadDopisDoplnitDoposudDoprovodDopustitDorazitDorostDortDosahDoslovDostatekDosudDosytaDotazDotekDotknoutDoufatDoutnatDovozceDozaduDoznatDozorceDrahotaDrakDramatikDravecDrazeDrdolDrobnostDrogerieDrozdDrsnostDrtitDrzostDubenDuchovnoDudekDuhaDuhovkaDusitDusnoDutostDvojiceDvorecDynamitEkologEkonomieElektronElipsaEmailEmiseEmoceEmpatieEpizodaEpochaEpopejEposEsejEsenceEskortaEskymoEtiketaEuforieEvoluceExekuceExkurzeExpediceExplozeExportExtraktFackaFajfkaFakultaFanatikFantazieFarmacieFavoritFazoleFederaceFejetonFenkaFialkaFigurantFilozofFiltrFinanceFintaFixaceFjordFlanelFlirtFlotilaFondFosforFotbalFotkaFotonFrakceFreskaFrontaFukarFunkceFyzikaGalejeGarantGenetikaGeologGilotinaGlazuraGlejtGolemGolfistaGotikaGrafGramofonGranuleGrepGrilGrogGroteskaGumaHadiceHadrHalaHalenkaHanbaHanopisHarfaHarpunaHavranHebkostHejkalHejnoHejtmanHektarHelmaHematomHerecHernaHesloHezkyHistorikHladovkaHlasivkyHlavaHledatHlenHlodavecHlohHloupostHltatHlubinaHluchotaHmatHmotaHmyzHnisHnojivoHnoutHoblinaHobojHochHodinyHodlatHodnotaHodovatHojnostHokejHolinkaHolkaHolubHomoleHonitbaHonoraceHoralHordaHorizontHorkoHorlivecHormonHorninaHoroskopHorstvoHospodaHostinaHotovostHoubaHoufHoupatHouskaHovorHradbaHraniceHravostHrazdaHrbolekHrdinaHrdloHrdostHrnekHrobkaHromadaHrotHroudaHrozenHrstkaHrubostHryzatHubenostHubnoutHudbaHukotHumrHusitaHustotaHvozdHybnostHydrantHygienaHymnaHysterikIdylkaIhnedIkonaIluzeImunitaInfekceInflaceInkasoInovaceInspekceInternetInvalidaInvestorInzerceIronieJablkoJachtaJahodaJakmileJakostJalovecJantarJarmarkJaroJasanJasnoJatkaJavorJazykJedinecJedleJednatelJehlanJekotJelenJelitoJemnostJenomJepiceJeseterJevitJezdecJezeroJinakJindyJinochJiskraJistotaJitrniceJizvaJmenovatJogurtJurtaKabaretKabelKabinetKachnaKadetKadidloKahanKajakKajutaKakaoKaktusKalamitaKalhotyKalibrKalnostKameraKamkolivKamnaKanibalKanoeKantorKapalinaKapelaKapitolaKapkaKapleKapotaKaprKapustaKapybaraKaramelKarotkaKartonKasaKatalogKatedraKauceKauzaKavalecKazajkaKazetaKazivostKdekolivKdesiKedlubenKempKeramikaKinoKlacekKladivoKlamKlapotKlasikaKlaunKlecKlenbaKlepatKlesnoutKlidKlimaKlisnaKloboukKlokanKlopaKloubKlubovnaKlusatKluzkostKmenKmitatKmotrKnihaKnotKoaliceKoberecKobkaKoblihaKobylaKocourKohoutKojenecKokosKoktejlKolapsKoledaKolizeKoloKomandoKometaKomikKomnataKomoraKompasKomunitaKonatKonceptKondiceKonecKonfeseKongresKoninaKonkursKontaktKonzervaKopanecKopieKopnoutKoprovkaKorbelKorektorKormidloKoroptevKorpusKorunaKorytoKorzetKosatecKostkaKotelKotletaKotoulKoukatKoupelnaKousekKouzloKovbojKozaKozorohKrabiceKrachKrajinaKralovatKrasopisKravataKreditKrejcarKresbaKrevetaKriketKritikKrizeKrkavecKrmelecKrmivoKrocanKrokKronikaKropitKroupaKrovkaKrtekKruhadloKrupiceKrutostKrvinkaKrychleKryptaKrystalKrytKudlankaKufrKujnostKuklaKulajdaKulichKulkaKulometKulturaKunaKupodivuKurtKurzorKutilKvalitaKvasinkaKvestorKynologKyselinaKytaraKyticeKytkaKytovecKyvadloLabradorLachtanLadnostLaikLakomecLamelaLampaLanovkaLasiceLasoLasturaLatinkaLavinaLebkaLeckdyLedenLedniceLedovkaLedvinaLegendaLegieLegraceLehceLehkostLehnoutLektvarLenochodLentilkaLepenkaLepidloLetadloLetecLetmoLetokruhLevhartLevitaceLevobokLibraLichotkaLidojedLidskostLihovinaLijavecLilekLimetkaLinieLinkaLinoleumListopadLitinaLitovatLobistaLodivodLogikaLogopedLokalitaLoketLomcovatLopataLopuchLordLososLotrLoudalLouhLoukaLouskatLovecLstivostLucernaLuciferLumpLuskLustraceLviceLyraLyrikaLysinaMadamMadloMagistrMahagonMajetekMajitelMajoritaMakakMakoviceMakrelaMalbaMalinaMalovatMalviceMaminkaMandleMankoMarnostMasakrMaskotMasopustMaticeMatrikaMaturitaMazanecMazivoMazlitMazurkaMdlobaMechanikMeditaceMedovinaMelasaMelounMentolkaMetlaMetodaMetrMezeraMigraceMihnoutMihuleMikinaMikrofonMilenecMilimetrMilostMimikaMincovnaMinibarMinometMinulostMiskaMistrMixovatMladostMlhaMlhovinaMlokMlsatMluvitMnichMnohemMobilMocnostModelkaModlitbaMohylaMokroMolekulaMomentkaMonarchaMonoklMonstrumMontovatMonzunMosazMoskytMostMotivaceMotorkaMotykaMouchaMoudrostMozaikaMozekMozolMramorMravenecMrkevMrtvolaMrzetMrzutostMstitelMudrcMuflonMulatMumieMuniceMusetMutaceMuzeumMuzikantMyslivecMzdaNabouratNachytatNadaceNadbytekNadhozNadobroNadpisNahlasNahnatNahodileNahraditNaivitaNajednouNajistoNajmoutNaklonitNakonecNakrmitNalevoNamazatNamluvitNanometrNaokoNaopakNaostroNapadatNapevnoNaplnitNapnoutNaposledNaprostoNaroditNarubyNarychloNasaditNasekatNaslepoNastatNatolikNavenekNavrchNavzdoryNazvatNebeNechatNeckyNedalekoNedbatNeduhNegaceNehetNehodaNejenNejprveNeklidNelibostNemilostNemocNeochotaNeonkaNepokojNerostNervNesmyslNesouladNetvorNeuronNevinaNezvykleNicotaNijakNikamNikdyNiklNikterakNitroNoclehNohaviceNominaceNoraNorekNositelNosnostNouzeNovinyNovotaNozdraNudaNudleNugetNutitNutnostNutrieNymfaObalObarvitObavaObdivObecObehnatObejmoutObezitaObhajobaObilniceObjasnitObjektObklopitOblastOblekOblibaOblohaObludaObnosObohatitObojekOboutObrazecObrnaObrubaObrysObsahObsluhaObstaratObuvObvazObvinitObvodObvykleObyvatelObzorOcasOcelOcenitOchladitOchotaOchranaOcitnoutOdbojOdbytOdchodOdcizitOdebratOdeslatOdevzdatOdezvaOdhadceOdhoditOdjetOdjinudOdkazOdkoupitOdlivOdlukaOdmlkaOdolnostOdpadOdpisOdploutOdporOdpustitOdpykatOdrazkaOdsouditOdstupOdsunOdtokOdtudOdvahaOdvetaOdvolatOdvracetOdznakOfinaOfsajdOhlasOhniskoOhradaOhrozitOhryzekOkapOkeniceOklikaOknoOkouzlitOkovyOkrasaOkresOkrsekOkruhOkupantOkurkaOkusitOlejninaOlizovatOmakOmeletaOmezitOmladinaOmlouvatOmluvaOmylOnehdyOpakovatOpasekOperaceOpiceOpilostOpisovatOporaOpoziceOpravduOprotiOrbitalOrchestrOrgieOrliceOrlojOrtelOsadaOschnoutOsikaOsivoOslavaOslepitOslnitOslovitOsnovaOsobaOsolitOspalecOstenOstrahaOstudaOstychOsvojitOteplitOtiskOtopOtrhatOtrlostOtrokOtrubyOtvorOvanoutOvarOvesOvlivnitOvoceOxidOzdobaPachatelPacientPadouchPahorekPaktPalandaPalecPalivoPalubaPamfletPamlsekPanenkaPanikaPannaPanovatPanstvoPantoflePaprikaParketaParodiePartaParukaParybaPasekaPasivitaPastelkaPatentPatronaPavoukPaznehtPazourekPeckaPedagogPejsekPekloPelotonPenaltaPendrekPenzePeriskopPeroPestrostPetardaPeticePetrolejPevninaPexesoPianistaPihaPijavicePiklePiknikPilinaPilnostPilulkaPinzetaPipetaPisatelPistolePitevnaPivnicePivovarPlacentaPlakatPlamenPlanetaPlastikaPlatitPlavidloPlazPlechPlemenoPlentaPlesPletivoPlevelPlivatPlnitPlnoPlochaPlodinaPlombaPloutPlukPlynPobavitPobytPochodPocitPoctivecPodatPodcenitPodepsatPodhledPodivitPodkladPodmanitPodnikPodobaPodporaPodrazPodstataPodvodPodzimPoeziePohankaPohnutkaPohovorPohromaPohybPointaPojistkaPojmoutPokazitPoklesPokojPokrokPokutaPokynPolednePolibekPolknoutPolohaPolynomPomaluPominoutPomlkaPomocPomstaPomysletPonechatPonorkaPonurostPopadatPopelPopisekPoplachPoprositPopsatPopudPoradcePorcePorodPoruchaPoryvPosaditPosedPosilaPoskokPoslanecPosouditPospoluPostavaPosudekPosypPotahPotkanPotleskPotomekPotravaPotupaPotvoraPoukazPoutoPouzdroPovahaPovidlaPovlakPovozPovrchPovstatPovykPovzdechPozdravPozemekPoznatekPozorPozvatPracovatPrahoryPraktikaPralesPraotecPraporekPrasePravdaPrincipPrknoProbuditProcentoProdejProfeseProhraProjektProlomitPromilePronikatPropadProrokProsbaProtonProutekProvazPrskavkaPrstenPrudkostPrutPrvekPrvohoryPsanecPsovodPstruhPtactvoPubertaPuchPudlPukavecPuklinaPukrlePultPumpaPuncPupenPusaPusinkaPustinaPutovatPutykaPyramidaPyskPytelRacekRachotRadiaceRadniceRadonRaftRagbyRaketaRakovinaRamenoRampouchRandeRarachRaritaRasovnaRastrRatolestRazanceRazidloReagovatReakceReceptRedaktorReferentReflexRejnokReklamaRekordRekrutRektorReputaceRevizeRevmaRevolverRezervaRiskovatRizikoRobotikaRodokmenRohovkaRokleRokokoRomanetoRopovodRopuchaRorejsRosolRostlinaRotmistrRotopedRotundaRoubenkaRouchoRoupRouraRovinaRovniceRozborRozchodRozdatRozeznatRozhodceRozinkaRozjezdRozkazRozlohaRozmarRozpadRozruchRozsahRoztokRozumRozvodRubrikaRuchadloRukaviceRukopisRybaRybolovRychlostRydloRypadloRytinaRyzostSadistaSahatSakoSamecSamizdatSamotaSanitkaSardinkaSasankaSatelitSazbaSazeniceSborSchovatSebrankaSeceseSedadloSedimentSedloSehnatSejmoutSekeraSektaSekundaSekvojeSemenoSenoServisSesaditSeshoraSeskokSeslatSestraSesuvSesypatSetbaSetinaSetkatSetnoutSetrvatSeverSeznamShodaShrnoutSifonSilniceSirkaSirotekSirupSituaceSkafandrSkaliskoSkanzenSkautSkeptikSkicaSkladbaSkleniceSkloSkluzSkobaSkokanSkoroSkriptaSkrzSkupinaSkvostSkvrnaSlabikaSladidloSlaninaSlastSlavnostSledovatSlepecSlevaSlezinaSlibSlinaSlizniceSlonSloupekSlovoSluchSluhaSlunceSlupkaSlzaSmaragdSmetanaSmilstvoSmlouvaSmogSmradSmrkSmrtkaSmutekSmyslSnadSnahaSnobSobotaSochaSodovkaSokolSopkaSotvaSoubojSoucitSoudceSouhlasSouladSoumrakSoupravaSousedSoutokSouvisetSpalovnaSpasitelSpisSplavSpodekSpojenecSpoluSponzorSpornostSpoustaSprchaSpustitSrandaSrazSrdceSrnaSrnecSrovnatSrpenSrstSrubStaniceStarostaStatikaStavbaStehnoStezkaStodolaStolekStopaStornoStoupatStrachStresStrhnoutStromStrunaStudnaStupniceStvolStykSubjektSubtropySucharSudostSuknoSundatSunoutSurikataSurovinaSvahSvalstvoSvetrSvatbaSvazekSvisleSvitekSvobodaSvodidloSvorkaSvrabSykavkaSykotSynekSynovecSypatSypkostSyrovostSyselSytostTabletkaTabuleTahounTajemnoTajfunTajgaTajitTajnostTaktikaTamhleTamponTancovatTanecTankerTapetaTaveninaTazatelTechnikaTehdyTekutinaTelefonTemnotaTendenceTenistaTenorTeplotaTepnaTeprveTerapieTermoskaTextilTichoTiskopisTitulekTkadlecTkaninaTlapkaTleskatTlukotTlupaTmelToaletaTopinkaTopolTorzoTouhaToulecTradiceTraktorTrampTrasaTraverzaTrefitTrestTrezorTrhavinaTrhlinaTrochuTrojiceTroskaTroubaTrpceTrpitelTrpkostTrubecTruchlitTruhliceTrusTrvatTudyTuhnoutTuhostTundraTuristaTurnajTuzemskoTvarohTvorbaTvrdostTvrzTygrTykevUbohostUbozeUbratUbrousekUbrusUbytovnaUchoUctivostUdivitUhraditUjednatUjistitUjmoutUkazatelUklidnitUklonitUkotvitUkrojitUliceUlitaUlovitUmyvadloUnavitUniformaUniknoutUpadnoutUplatnitUplynoutUpoutatUpravitUranUrazitUsednoutUsilovatUsmrtitUsnadnitUsnoutUsouditUstlatUstrnoutUtahovatUtkatUtlumitUtonoutUtopenecUtrousitUvalitUvolnitUvozovkaUzdravitUzelUzeninaUzlinaUznatVagonValchaValounVanaVandalVanilkaVaranVarhanyVarovatVcelkuVchodVdovaVedroVegetaceVejceVelbloudVeletrhVelitelVelmocVelrybaVenkovVerandaVerzeVeselkaVeskrzeVesniceVespoduVestaVeterinaVeverkaVibraceVichrVideohraVidinaVidleVilaViniceVisetVitalitaVizeVizitkaVjezdVkladVkusVlajkaVlakVlasecVlevoVlhkostVlivVlnovkaVloupatVnucovatVnukVodaVodivostVodoznakVodstvoVojenskyVojnaVojskoVolantVolbaVolitVolnoVoskovkaVozidloVozovnaVpravoVrabecVracetVrahVrataVrbaVrcholekVrhatVrstvaVrtuleVsaditVstoupitVstupVtipVybavitVybratVychovatVydatVydraVyfotitVyhledatVyhnoutVyhoditVyhraditVyhubitVyjasnitVyjetVyjmoutVyklopitVykonatVylekatVymazatVymezitVymizetVymysletVynechatVynikatVynutitVypadatVyplatitVypravitVypustitVyrazitVyrovnatVyrvatVyslovitVysokoVystavitVysunoutVysypatVytasitVytesatVytratitVyvinoutVyvolatVyvrhelVyzdobitVyznatVzaduVzbuditVzchopitVzdorVzduchVzdychatVzestupVzhledemVzkazVzlykatVznikVzorekVzpouraVztahVztekXylofonZabratZabydletZachovatZadarmoZadusitZafoukatZahltitZahoditZahradaZahynoutZajatecZajetZajistitZaklepatZakoupitZalepitZamezitZamotatZamysletZanechatZanikatZaplatitZapojitZapsatZarazitZastavitZasunoutZatajitZatemnitZatknoutZaujmoutZavalitZaveletZavinitZavolatZavrtatZazvonitZbavitZbrusuZbudovatZbytekZdalekaZdarmaZdatnostZdivoZdobitZdrojZdvihZdymadloZeleninaZemanZeminaZeptatZezaduZezdolaZhatitZhltnoutZhlubokaZhotovitZhrubaZimaZimniceZjemnitZklamatZkoumatZkratkaZkumavkaZlatoZlehkaZlobaZlomZlostZlozvykZmapovatZmarZmatekZmijeZmizetZmocnitZmodratZmrzlinaZmutovatZnakZnalostZnamenatZnovuZobrazitZotavitZoubekZoufaleZploditZpomalitZpravaZprostitZprudkaZprvuZradaZranitZrcadloZrnitostZrnoZrovnaZrychlitZrzavostZtichaZtratitZubovinaZubrZvednoutZvenkuZveselaZvonZvratZvukovodZvyk".replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a" !== r.D.check(t))) throw i = null, new Error("BIP39 Wordlist for en (English) FAILED") } const o = new class extends r.D { constructor() { super("cz") } getWord(t) { return s(this), i[t] } getWordIndex(t) { return s(this), i.indexOf(t) } }; r.D.register(o); let a = null; function l(t) { if (null == a && (a = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo".replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60" !== r.D.check(t))) throw a = null, new Error("BIP39 Wordlist for en (English) FAILED") } const c = new class extends r.D { constructor() { super("en") } getWord(t) { return l(this), a[t] } getWordIndex(t) { return l(this), a.indexOf(t) } }; r.D.register(c); var u = n(8822); const h = {}; let d = null; function p(t) { return r.k.checkNormalize(), (0, u.ZN)(Array.prototype.filter.call((0, u.Y0)(t.normalize("NFD").toLowerCase()), t => t >= 65 && t <= 90 || t >= 97 && t <= 123)) } function f(t) { if (null == d && (d = "A/bacoAbdomenAbejaAbiertoAbogadoAbonoAbortoAbrazoAbrirAbueloAbusoAcabarAcademiaAccesoAccio/nAceiteAcelgaAcentoAceptarA/cidoAclararAcne/AcogerAcosoActivoActoActrizActuarAcudirAcuerdoAcusarAdictoAdmitirAdoptarAdornoAduanaAdultoAe/reoAfectarAficio/nAfinarAfirmarA/gilAgitarAgoni/aAgostoAgotarAgregarAgrioAguaAgudoA/guilaAgujaAhogoAhorroAireAislarAjedrezAjenoAjusteAlacra/nAlambreAlarmaAlbaA/lbumAlcaldeAldeaAlegreAlejarAlertaAletaAlfilerAlgaAlgodo/nAliadoAlientoAlivioAlmaAlmejaAlmi/barAltarAltezaAltivoAltoAlturaAlumnoAlzarAmableAmanteAmapolaAmargoAmasarA/mbarA/mbitoAmenoAmigoAmistadAmorAmparoAmplioAnchoAncianoAnclaAndarAnde/nAnemiaA/nguloAnilloA/nimoAni/sAnotarAntenaAntiguoAntojoAnualAnularAnuncioA~adirA~ejoA~oApagarAparatoApetitoApioAplicarApodoAporteApoyoAprenderAprobarApuestaApuroAradoAra~aArarA/rbitroA/rbolArbustoArchivoArcoArderArdillaArduoA/reaA/ridoAriesArmoni/aArne/sAromaArpaArpo/nArregloArrozArrugaArteArtistaAsaAsadoAsaltoAscensoAsegurarAseoAsesorAsientoAsiloAsistirAsnoAsombroA/speroAstillaAstroAstutoAsumirAsuntoAtajoAtaqueAtarAtentoAteoA/ticoAtletaA/tomoAtraerAtrozAtu/nAudazAudioAugeAulaAumentoAusenteAutorAvalAvanceAvaroAveAvellanaAvenaAvestruzAvio/nAvisoAyerAyudaAyunoAzafra/nAzarAzoteAzu/carAzufreAzulBabaBaborBacheBahi/aBaileBajarBalanzaBalco/nBaldeBambu/BancoBandaBa~oBarbaBarcoBarnizBarroBa/sculaBasto/nBasuraBatallaBateri/aBatirBatutaBau/lBazarBebe/BebidaBelloBesarBesoBestiaBichoBienBingoBlancoBloqueBlusaBoaBobinaBoboBocaBocinaBodaBodegaBoinaBolaBoleroBolsaBombaBondadBonitoBonoBonsa/iBordeBorrarBosqueBoteBoti/nBo/vedaBozalBravoBrazoBrechaBreveBrilloBrincoBrisaBrocaBromaBronceBroteBrujaBruscoBrutoBuceoBucleBuenoBueyBufandaBufo/nBu/hoBuitreBultoBurbujaBurlaBurroBuscarButacaBuzo/nCaballoCabezaCabinaCabraCacaoCada/verCadenaCaerCafe/Cai/daCaima/nCajaCajo/nCalCalamarCalcioCaldoCalidadCalleCalmaCalorCalvoCamaCambioCamelloCaminoCampoCa/ncerCandilCanelaCanguroCanicaCantoCa~aCa~o/nCaobaCaosCapazCapita/nCapoteCaptarCapuchaCaraCarbo/nCa/rcelCaretaCargaCari~oCarneCarpetaCarroCartaCasaCascoCaseroCaspaCastorCatorceCatreCaudalCausaCazoCebollaCederCedroCeldaCe/lebreCelosoCe/lulaCementoCenizaCentroCercaCerdoCerezaCeroCerrarCertezaCe/spedCetroChacalChalecoChampu/ChanclaChapaCharlaChicoChisteChivoChoqueChozaChuletaChuparCiclo/nCiegoCieloCienCiertoCifraCigarroCimaCincoCineCintaCipre/sCircoCiruelaCisneCitaCiudadClamorClanClaroClaseClaveClienteClimaCli/nicaCobreCoccio/nCochinoCocinaCocoCo/digoCodoCofreCogerCoheteCoji/nCojoColaColchaColegioColgarColinaCollarColmoColumnaCombateComerComidaCo/modoCompraCondeConejoCongaConocerConsejoContarCopaCopiaCorazo/nCorbataCorchoCordo/nCoronaCorrerCoserCosmosCostaCra/neoCra/terCrearCrecerCrei/doCremaCri/aCrimenCriptaCrisisCromoCro/nicaCroquetaCrudoCruzCuadroCuartoCuatroCuboCubrirCucharaCuelloCuentoCuerdaCuestaCuevaCuidarCulebraCulpaCultoCumbreCumplirCunaCunetaCuotaCupo/nCu/pulaCurarCuriosoCursoCurvaCutisDamaDanzaDarDardoDa/tilDeberDe/bilDe/cadaDecirDedoDefensaDefinirDejarDelfi/nDelgadoDelitoDemoraDensoDentalDeporteDerechoDerrotaDesayunoDeseoDesfileDesnudoDestinoDesvi/oDetalleDetenerDeudaDi/aDiabloDiademaDiamanteDianaDiarioDibujoDictarDienteDietaDiezDifi/cilDignoDilemaDiluirDineroDirectoDirigirDiscoDise~oDisfrazDivaDivinoDobleDoceDolorDomingoDonDonarDoradoDormirDorsoDosDosisDrago/nDrogaDuchaDudaDueloDue~oDulceDu/oDuqueDurarDurezaDuroE/banoEbrioEcharEcoEcuadorEdadEdicio/nEdificioEditorEducarEfectoEficazEjeEjemploElefanteElegirElementoElevarElipseE/liteElixirElogioEludirEmbudoEmitirEmocio/nEmpateEmpe~oEmpleoEmpresaEnanoEncargoEnchufeEnci/aEnemigoEneroEnfadoEnfermoEnga~oEnigmaEnlaceEnormeEnredoEnsayoEnse~arEnteroEntrarEnvaseEnvi/oE/pocaEquipoErizoEscalaEscenaEscolarEscribirEscudoEsenciaEsferaEsfuerzoEspadaEspejoEspi/aEsposaEspumaEsqui/EstarEsteEstiloEstufaEtapaEternoE/ticaEtniaEvadirEvaluarEventoEvitarExactoExamenExcesoExcusaExentoExigirExilioExistirE/xitoExpertoExplicarExponerExtremoFa/bricaFa/bulaFachadaFa/cilFactorFaenaFajaFaldaFalloFalsoFaltarFamaFamiliaFamosoFarao/nFarmaciaFarolFarsaFaseFatigaFaunaFavorFaxFebreroFechaFelizFeoFeriaFerozFe/rtilFervorFesti/nFiableFianzaFiarFibraFiccio/nFichaFideoFiebreFielFieraFiestaFiguraFijarFijoFilaFileteFilialFiltroFinFincaFingirFinitoFirmaFlacoFlautaFlechaFlorFlotaFluirFlujoFlu/orFobiaFocaFogataFogo/nFolioFolletoFondoFormaForroFortunaForzarFosaFotoFracasoFra/gilFranjaFraseFraudeFrei/rFrenoFresaFri/oFritoFrutaFuegoFuenteFuerzaFugaFumarFuncio/nFundaFurgo/nFuriaFusilFu/tbolFuturoGacelaGafasGaitaGajoGalaGaleri/aGalloGambaGanarGanchoGangaGansoGarajeGarzaGasolinaGastarGatoGavila/nGemeloGemirGenGe/neroGenioGenteGeranioGerenteGermenGestoGiganteGimnasioGirarGiroGlaciarGloboGloriaGolGolfoGolosoGolpeGomaGordoGorilaGorraGotaGoteoGozarGradaGra/ficoGranoGrasaGratisGraveGrietaGrilloGripeGrisGritoGrosorGru/aGruesoGrumoGrupoGuanteGuapoGuardiaGuerraGui/aGui~oGuionGuisoGuitarraGusanoGustarHaberHa/bilHablarHacerHachaHadaHallarHamacaHarinaHazHaza~aHebillaHebraHechoHeladoHelioHembraHerirHermanoHe/roeHervirHieloHierroHi/gadoHigieneHijoHimnoHistoriaHocicoHogarHogueraHojaHombreHongoHonorHonraHoraHormigaHornoHostilHoyoHuecoHuelgaHuertaHuesoHuevoHuidaHuirHumanoHu/medoHumildeHumoHundirHuraca/nHurtoIconoIdealIdiomaI/doloIglesiaIglu/IgualIlegalIlusio/nImagenIma/nImitarImparImperioImponerImpulsoIncapazI/ndiceInerteInfielInformeIngenioInicioInmensoInmuneInnatoInsectoInstanteIntere/sI/ntimoIntuirInu/tilInviernoIraIrisIroni/aIslaIsloteJabali/Jabo/nJamo/nJarabeJardi/nJarraJaulaJazmi/nJefeJeringaJineteJornadaJorobaJovenJoyaJuergaJuevesJuezJugadorJugoJugueteJuicioJuncoJunglaJunioJuntarJu/piterJurarJustoJuvenilJuzgarKiloKoalaLabioLacioLacraLadoLadro/nLagartoLa/grimaLagunaLaicoLamerLa/minaLa/mparaLanaLanchaLangostaLanzaLa/pizLargoLarvaLa/stimaLataLa/texLatirLaurelLavarLazoLealLeccio/nLecheLectorLeerLegio/nLegumbreLejanoLenguaLentoLe~aLeo/nLeopardoLesio/nLetalLetraLeveLeyendaLibertadLibroLicorLi/derLidiarLienzoLigaLigeroLimaLi/miteLimo/nLimpioLinceLindoLi/neaLingoteLinoLinternaLi/quidoLisoListaLiteraLitioLitroLlagaLlamaLlantoLlaveLlegarLlenarLlevarLlorarLloverLluviaLoboLocio/nLocoLocuraLo/gicaLogroLombrizLomoLonjaLoteLuchaLucirLugarLujoLunaLunesLupaLustroLutoLuzMacetaMachoMaderaMadreMaduroMaestroMafiaMagiaMagoMai/zMaldadMaletaMallaMaloMama/MamboMamutMancoMandoManejarMangaManiqui/ManjarManoMansoMantaMa~anaMapaMa/quinaMarMarcoMareaMarfilMargenMaridoMa/rmolMarro/nMartesMarzoMasaMa/scaraMasivoMatarMateriaMatizMatrizMa/ximoMayorMazorcaMechaMedallaMedioMe/dulaMejillaMejorMelenaMelo/nMemoriaMenorMensajeMenteMenu/MercadoMerengueMe/ritoMesMeso/nMetaMeterMe/todoMetroMezclaMiedoMielMiembroMigaMilMilagroMilitarMillo/nMimoMinaMineroMi/nimoMinutoMiopeMirarMisaMiseriaMisilMismoMitadMitoMochilaMocio/nModaModeloMohoMojarMoldeMolerMolinoMomentoMomiaMonarcaMonedaMonjaMontoMo~oMoradaMorderMorenoMorirMorroMorsaMortalMoscaMostrarMotivoMoverMo/vilMozoMuchoMudarMuebleMuelaMuerteMuestraMugreMujerMulaMuletaMultaMundoMu~ecaMuralMuroMu/sculoMuseoMusgoMu/sicaMusloNa/carNacio/nNadarNaipeNaranjaNarizNarrarNasalNatalNativoNaturalNa/useaNavalNaveNavidadNecioNe/ctarNegarNegocioNegroNeo/nNervioNetoNeutroNevarNeveraNichoNidoNieblaNietoNi~ezNi~oNi/tidoNivelNoblezaNocheNo/minaNoriaNormaNorteNotaNoticiaNovatoNovelaNovioNubeNucaNu/cleoNudilloNudoNueraNueveNuezNuloNu/meroNutriaOasisObesoObispoObjetoObraObreroObservarObtenerObvioOcaOcasoOce/anoOchentaOchoOcioOcreOctavoOctubreOcultoOcuparOcurrirOdiarOdioOdiseaOesteOfensaOfertaOficioOfrecerOgroOi/doOi/rOjoOlaOleadaOlfatoOlivoOllaOlmoOlorOlvidoOmbligoOndaOnzaOpacoOpcio/nO/peraOpinarOponerOptarO/pticaOpuestoOracio/nOradorOralO/rbitaOrcaOrdenOrejaO/rganoOrgi/aOrgulloOrienteOrigenOrillaOroOrquestaOrugaOsadi/aOscuroOseznoOsoOstraOto~oOtroOvejaO/vuloO/xidoOxi/genoOyenteOzonoPactoPadrePaellaPa/ginaPagoPai/sPa/jaroPalabraPalcoPaletaPa/lidoPalmaPalomaPalparPanPanalPa/nicoPanteraPa~ueloPapa/PapelPapillaPaquetePararParcelaParedParirParoPa/rpadoParquePa/rrafoPartePasarPaseoPasio/nPasoPastaPataPatioPatriaPausaPautaPavoPayasoPeato/nPecadoPeceraPechoPedalPedirPegarPeinePelarPelda~oPeleaPeligroPellejoPeloPelucaPenaPensarPe~o/nPeo/nPeorPepinoPeque~oPeraPerchaPerderPerezaPerfilPericoPerlaPermisoPerroPersonaPesaPescaPe/simoPesta~aPe/taloPetro/leoPezPezu~aPicarPicho/nPiePiedraPiernaPiezaPijamaPilarPilotoPimientaPinoPintorPinzaPi~aPiojoPipaPirataPisarPiscinaPisoPistaPito/nPizcaPlacaPlanPlataPlayaPlazaPleitoPlenoPlomoPlumaPluralPobrePocoPoderPodioPoemaPoesi/aPoetaPolenPolici/aPolloPolvoPomadaPomeloPomoPompaPonerPorcio/nPortalPosadaPoseerPosiblePostePotenciaPotroPozoPradoPrecozPreguntaPremioPrensaPresoPrevioPrimoPri/ncipePrisio/nPrivarProaProbarProcesoProductoProezaProfesorProgramaProlePromesaProntoPropioPro/ximoPruebaPu/blicoPucheroPudorPuebloPuertaPuestoPulgaPulirPulmo/nPulpoPulsoPumaPuntoPu~alPu~oPupaPupilaPure/QuedarQuejaQuemarQuererQuesoQuietoQui/micaQuinceQuitarRa/banoRabiaRaboRacio/nRadicalRai/zRamaRampaRanchoRangoRapazRa/pidoRaptoRasgoRaspaRatoRayoRazaRazo/nReaccio/nRealidadReba~oReboteRecaerRecetaRechazoRecogerRecreoRectoRecursoRedRedondoReducirReflejoReformaRefra/nRefugioRegaloRegirReglaRegresoRehe/nReinoRei/rRejaRelatoRelevoRelieveRellenoRelojRemarRemedioRemoRencorRendirRentaRepartoRepetirReposoReptilResRescateResinaRespetoRestoResumenRetiroRetornoRetratoReunirReve/sRevistaReyRezarRicoRiegoRiendaRiesgoRifaRi/gidoRigorRinco/nRi~o/nRi/oRiquezaRisaRitmoRitoRizoRobleRoceRociarRodarRodeoRodillaRoerRojizoRojoRomeroRomperRonRoncoRondaRopaRoperoRosaRoscaRostroRotarRubi/RuborRudoRuedaRugirRuidoRuinaRuletaRuloRumboRumorRupturaRutaRutinaSa/badoSaberSabioSableSacarSagazSagradoSalaSaldoSaleroSalirSalmo/nSalo/nSalsaSaltoSaludSalvarSambaSancio/nSandi/aSanearSangreSanidadSanoSantoSapoSaqueSardinaSarte/nSastreSata/nSaunaSaxofo/nSeccio/nSecoSecretoSectaSedSeguirSeisSelloSelvaSemanaSemillaSendaSensorSe~alSe~orSepararSepiaSequi/aSerSerieSermo/nServirSesentaSesio/nSetaSetentaSeveroSexoSextoSidraSiestaSieteSigloSignoSi/labaSilbarSilencioSillaSi/mboloSimioSirenaSistemaSitioSituarSobreSocioSodioSolSolapaSoldadoSoledadSo/lidoSoltarSolucio/nSombraSondeoSonidoSonoroSonrisaSopaSoplarSoporteSordoSorpresaSorteoSoste/nSo/tanoSuaveSubirSucesoSudorSuegraSueloSue~oSuerteSufrirSujetoSulta/nSumarSuperarSuplirSuponerSupremoSurSurcoSure~oSurgirSustoSutilTabacoTabiqueTablaTabu/TacoTactoTajoTalarTalcoTalentoTallaTalo/nTama~oTamborTangoTanqueTapaTapeteTapiaTapo/nTaquillaTardeTareaTarifaTarjetaTarotTarroTartaTatuajeTauroTazaTazo/nTeatroTechoTeclaTe/cnicaTejadoTejerTejidoTelaTele/fonoTemaTemorTemploTenazTenderTenerTenisTensoTeori/aTerapiaTercoTe/rminoTernuraTerrorTesisTesoroTestigoTeteraTextoTezTibioTiburo/nTiempoTiendaTierraTiesoTigreTijeraTildeTimbreTi/midoTimoTintaTi/oTi/picoTipoTiraTiro/nTita/nTi/tereTi/tuloTizaToallaTobilloTocarTocinoTodoTogaToldoTomarTonoTontoToparTopeToqueTo/raxToreroTormentaTorneoToroTorpedoTorreTorsoTortugaTosToscoToserTo/xicoTrabajoTractorTraerTra/ficoTragoTrajeTramoTranceTratoTraumaTrazarTre/bolTreguaTreintaTrenTreparTresTribuTrigoTripaTristeTriunfoTrofeoTrompaTroncoTropaTroteTrozoTrucoTruenoTrufaTuberi/aTuboTuertoTumbaTumorTu/nelTu/nicaTurbinaTurismoTurnoTutorUbicarU/lceraUmbralUnidadUnirUniversoUnoUntarU~aUrbanoUrbeUrgenteUrnaUsarUsuarioU/tilUtopi/aUvaVacaVaci/oVacunaVagarVagoVainaVajillaValeVa/lidoValleValorVa/lvulaVampiroVaraVariarVaro/nVasoVecinoVectorVehi/culoVeinteVejezVelaVeleroVelozVenaVencerVendaVenenoVengarVenirVentaVenusVerVeranoVerboVerdeVeredaVerjaVersoVerterVi/aViajeVibrarVicioVi/ctimaVidaVi/deoVidrioViejoViernesVigorVilVillaVinagreVinoVi~edoVioli/nViralVirgoVirtudVisorVi/speraVistaVitaminaViudoVivazViveroVivirVivoVolca/nVolumenVolverVorazVotarVotoVozVueloVulgarYacerYateYeguaYemaYernoYesoYodoYogaYogurZafiroZanjaZapatoZarzaZonaZorroZumoZurdo".replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(t => function (t) { const e = []; return Array.prototype.forEach.call((0, u.Y0)(t), t => { 47 === t ? (e.push(204), e.push(129)) : 126 === t ? (e.push(110), e.push(204), e.push(131)) : e.push(t) }), (0, u.ZN)(e) }(t)), d.forEach((t, e) => { h[p(t)] = e }), "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300" !== r.D.check(t))) throw d = null, new Error("BIP39 Wordlist for es (Spanish) FAILED") } const m = new class extends r.D { constructor() { super("es") } getWord(t) { return f(this), d[t] } getWordIndex(t) { return f(this), h[p(t)] } }; r.D.register(m); let g = null; const v = {}; function y(t) { return r.k.checkNormalize(), (0, u.ZN)(Array.prototype.filter.call((0, u.Y0)(t.normalize("NFD").toLowerCase()), t => t >= 65 && t <= 90 || t >= 97 && t <= 123)) } function b(t) { if (null == g && (g = "AbaisserAbandonAbdiquerAbeilleAbolirAborderAboutirAboyerAbrasifAbreuverAbriterAbrogerAbruptAbsenceAbsoluAbsurdeAbusifAbyssalAcade/mieAcajouAcarienAccablerAccepterAcclamerAccoladeAccrocheAccuserAcerbeAchatAcheterAcidulerAcierAcompteAcque/rirAcronymeActeurActifActuelAdepteAde/quatAdhe/sifAdjectifAdjugerAdmettreAdmirerAdopterAdorerAdoucirAdresseAdroitAdulteAdverbeAe/rerAe/ronefAffaireAffecterAfficheAffreuxAffublerAgacerAgencerAgileAgiterAgraferAgre/ableAgrumeAiderAiguilleAilierAimableAisanceAjouterAjusterAlarmerAlchimieAlerteAlge-breAlgueAlie/nerAlimentAlle/gerAlliageAllouerAllumerAlourdirAlpagaAltesseAlve/oleAmateurAmbiguAmbreAme/nagerAmertumeAmidonAmiralAmorcerAmourAmovibleAmphibieAmpleurAmusantAnalyseAnaphoreAnarchieAnatomieAncienAne/antirAngleAngoisseAnguleuxAnimalAnnexerAnnonceAnnuelAnodinAnomalieAnonymeAnormalAntenneAntidoteAnxieuxApaiserApe/ritifAplanirApologieAppareilAppelerApporterAppuyerAquariumAqueducArbitreArbusteArdeurArdoiseArgentArlequinArmatureArmementArmoireArmureArpenterArracherArriverArroserArsenicArte/rielArticleAspectAsphalteAspirerAssautAsservirAssietteAssocierAssurerAsticotAstreAstuceAtelierAtomeAtriumAtroceAttaqueAttentifAttirerAttraperAubaineAubergeAudaceAudibleAugurerAuroreAutomneAutrucheAvalerAvancerAvariceAvenirAverseAveugleAviateurAvideAvionAviserAvoineAvouerAvrilAxialAxiomeBadgeBafouerBagageBaguetteBaignadeBalancerBalconBaleineBalisageBambinBancaireBandageBanlieueBannie-reBanquierBarbierBarilBaronBarqueBarrageBassinBastionBatailleBateauBatterieBaudrierBavarderBeletteBe/lierBeloteBe/ne/ficeBerceauBergerBerlineBermudaBesaceBesogneBe/tailBeurreBiberonBicycleBiduleBijouBilanBilingueBillardBinaireBiologieBiopsieBiotypeBiscuitBisonBistouriBitumeBizarreBlafardBlagueBlanchirBlessantBlinderBlondBloquerBlousonBobardBobineBoireBoiserBolideBonbonBondirBonheurBonifierBonusBordureBorneBotteBoucleBoueuxBougieBoulonBouquinBourseBoussoleBoutiqueBoxeurBrancheBrasierBraveBrebisBre-cheBreuvageBricolerBrigadeBrillantBriocheBriqueBrochureBroderBronzerBrousseBroyeurBrumeBrusqueBrutalBruyantBuffleBuissonBulletinBureauBurinBustierButinerButoirBuvableBuvetteCabanonCabineCachetteCadeauCadreCafe/ineCaillouCaissonCalculerCalepinCalibreCalmerCalomnieCalvaireCamaradeCame/raCamionCampagneCanalCanetonCanonCantineCanularCapableCaporalCapriceCapsuleCapterCapucheCarabineCarboneCaresserCaribouCarnageCarotteCarreauCartonCascadeCasierCasqueCassureCauserCautionCavalierCaverneCaviarCe/dilleCeintureCe/lesteCelluleCendrierCensurerCentralCercleCe/re/bralCeriseCernerCerveauCesserChagrinChaiseChaleurChambreChanceChapitreCharbonChasseurChatonChaussonChavirerChemiseChenilleChe/quierChercherChevalChienChiffreChignonChime-reChiotChlorureChocolatChoisirChoseChouetteChromeChuteCigareCigogneCimenterCine/maCintrerCirculerCirerCirqueCiterneCitoyenCitronCivilClaironClameurClaquerClasseClavierClientClignerClimatClivageClocheClonageCloporteCobaltCobraCocasseCocotierCoderCodifierCoffreCognerCohe/sionCoifferCoincerCole-reColibriCollineColmaterColonelCombatCome/dieCommandeCompactConcertConduireConfierCongelerConnoterConsonneContactConvexeCopainCopieCorailCorbeauCordageCornicheCorpusCorrectCorte-geCosmiqueCostumeCotonCoudeCoupureCourageCouteauCouvrirCoyoteCrabeCrainteCravateCrayonCre/atureCre/diterCre/meuxCreuserCrevetteCriblerCrierCristalCrite-reCroireCroquerCrotaleCrucialCruelCrypterCubiqueCueillirCuille-reCuisineCuivreCulminerCultiverCumulerCupideCuratifCurseurCyanureCycleCylindreCyniqueDaignerDamierDangerDanseurDauphinDe/battreDe/biterDe/borderDe/briderDe/butantDe/calerDe/cembreDe/chirerDe/ciderDe/clarerDe/corerDe/crireDe/cuplerDe/daleDe/ductifDe/esseDe/fensifDe/filerDe/frayerDe/gagerDe/givrerDe/glutirDe/graferDe/jeunerDe/liceDe/logerDemanderDemeurerDe/molirDe/nicherDe/nouerDentelleDe/nuderDe/partDe/penserDe/phaserDe/placerDe/poserDe/rangerDe/roberDe/sastreDescenteDe/sertDe/signerDe/sobe/irDessinerDestrierDe/tacherDe/testerDe/tourerDe/tresseDevancerDevenirDevinerDevoirDiableDialogueDiamantDicterDiffe/rerDige/rerDigitalDigneDiluerDimancheDiminuerDioxydeDirectifDirigerDiscuterDisposerDissiperDistanceDivertirDiviserDocileDocteurDogmeDoigtDomaineDomicileDompterDonateurDonjonDonnerDopamineDortoirDorureDosageDoseurDossierDotationDouanierDoubleDouceurDouterDoyenDragonDraperDresserDribblerDroitureDuperieDuplexeDurableDurcirDynastieE/blouirE/carterE/charpeE/chelleE/clairerE/clipseE/cloreE/cluseE/coleE/conomieE/corceE/couterE/craserE/cre/merE/crivainE/crouE/cumeE/cureuilE/difierE/duquerEffacerEffectifEffigieEffortEffrayerEffusionE/galiserE/garerE/jecterE/laborerE/largirE/lectronE/le/gantE/le/phantE/le-veE/ligibleE/litismeE/logeE/luciderE/luderEmballerEmbellirEmbryonE/meraudeE/missionEmmenerE/motionE/mouvoirEmpereurEmployerEmporterEmpriseE/mulsionEncadrerEnche-reEnclaveEncocheEndiguerEndosserEndroitEnduireE/nergieEnfanceEnfermerEnfouirEngagerEnginEngloberE/nigmeEnjamberEnjeuEnleverEnnemiEnnuyeuxEnrichirEnrobageEnseigneEntasserEntendreEntierEntourerEntraverE/nume/rerEnvahirEnviableEnvoyerEnzymeE/olienE/paissirE/pargneE/patantE/pauleE/picerieE/pide/mieE/pierE/pilogueE/pineE/pisodeE/pitapheE/poqueE/preuveE/prouverE/puisantE/querreE/quipeE/rigerE/rosionErreurE/ruptionEscalierEspadonEspe-ceEspie-gleEspoirEspritEsquiverEssayerEssenceEssieuEssorerEstimeEstomacEstradeE/tage-reE/talerE/tancheE/tatiqueE/teindreE/tendoirE/ternelE/thanolE/thiqueEthnieE/tirerE/tofferE/toileE/tonnantE/tourdirE/trangeE/troitE/tudeEuphorieE/valuerE/vasionE/ventailE/videnceE/viterE/volutifE/voquerExactExage/rerExaucerExcellerExcitantExclusifExcuseExe/cuterExempleExercerExhalerExhorterExigenceExilerExisterExotiqueExpe/dierExplorerExposerExprimerExquisExtensifExtraireExulterFableFabuleuxFacetteFacileFactureFaiblirFalaiseFameuxFamilleFarceurFarfeluFarineFaroucheFascinerFatalFatigueFauconFautifFaveurFavoriFe/brileFe/conderFe/de/rerFe/linFemmeFe/murFendoirFe/odalFermerFe/roceFerveurFestivalFeuilleFeutreFe/vrierFiascoFicelerFictifFide-leFigureFilatureFiletageFilie-reFilleulFilmerFilouFiltrerFinancerFinirFioleFirmeFissureFixerFlairerFlammeFlasqueFlatteurFle/auFle-cheFleurFlexionFloconFloreFluctuerFluideFluvialFolieFonderieFongibleFontaineForcerForgeronFormulerFortuneFossileFoudreFouge-reFouillerFoulureFourmiFragileFraiseFranchirFrapperFrayeurFre/gateFreinerFrelonFre/mirFre/ne/sieFre-reFriableFrictionFrissonFrivoleFroidFromageFrontalFrotterFruitFugitifFuiteFureurFurieuxFurtifFusionFuturGagnerGalaxieGalerieGambaderGarantirGardienGarnirGarrigueGazelleGazonGe/antGe/latineGe/luleGendarmeGe/ne/ralGe/nieGenouGentilGe/ologieGe/ome-treGe/raniumGermeGestuelGeyserGibierGiclerGirafeGivreGlaceGlaiveGlisserGlobeGloireGlorieuxGolfeurGommeGonflerGorgeGorilleGoudronGouffreGoulotGoupilleGourmandGoutteGraduelGraffitiGraineGrandGrappinGratuitGravirGrenatGriffureGrillerGrimperGrognerGronderGrotteGroupeGrugerGrutierGruye-reGue/pardGuerrierGuideGuimauveGuitareGustatifGymnasteGyrostatHabitudeHachoirHalteHameauHangarHannetonHaricotHarmonieHarponHasardHe/liumHe/matomeHerbeHe/rissonHermineHe/ronHe/siterHeureuxHibernerHibouHilarantHistoireHiverHomardHommageHomoge-neHonneurHonorerHonteuxHordeHorizonHorlogeHormoneHorribleHouleuxHousseHublotHuileuxHumainHumbleHumideHumourHurlerHydromelHygie-neHymneHypnoseIdylleIgnorerIguaneIlliciteIllusionImageImbiberImiterImmenseImmobileImmuableImpactImpe/rialImplorerImposerImprimerImputerIncarnerIncendieIncidentInclinerIncoloreIndexerIndiceInductifIne/ditIneptieInexactInfiniInfligerInformerInfusionInge/rerInhalerInhiberInjecterInjureInnocentInoculerInonderInscrireInsecteInsigneInsoliteInspirerInstinctInsulterIntactIntenseIntimeIntrigueIntuitifInutileInvasionInventerInviterInvoquerIroniqueIrradierIrre/elIrriterIsolerIvoireIvresseJaguarJaillirJambeJanvierJardinJaugerJauneJavelotJetableJetonJeudiJeunesseJoindreJoncherJonglerJoueurJouissifJournalJovialJoyauJoyeuxJubilerJugementJuniorJuponJuristeJusticeJuteuxJuve/nileKayakKimonoKiosqueLabelLabialLabourerLace/rerLactoseLaguneLaineLaisserLaitierLambeauLamelleLampeLanceurLangageLanterneLapinLargeurLarmeLaurierLavaboLavoirLectureLe/galLe/gerLe/gumeLessiveLettreLevierLexiqueLe/zardLiasseLibe/rerLibreLicenceLicorneLie-geLie-vreLigatureLigoterLigueLimerLimiteLimonadeLimpideLine/aireLingotLionceauLiquideLisie-reListerLithiumLitigeLittoralLivreurLogiqueLointainLoisirLombricLoterieLouerLourdLoutreLouveLoyalLubieLucideLucratifLueurLugubreLuisantLumie-reLunaireLundiLuronLutterLuxueuxMachineMagasinMagentaMagiqueMaigreMaillonMaintienMairieMaisonMajorerMalaxerMale/ficeMalheurMaliceMalletteMammouthMandaterManiableManquantManteauManuelMarathonMarbreMarchandMardiMaritimeMarqueurMarronMartelerMascotteMassifMate/rielMatie-reMatraqueMaudireMaussadeMauveMaximalMe/chantMe/connuMe/dailleMe/decinMe/diterMe/duseMeilleurMe/langeMe/lodieMembreMe/moireMenacerMenerMenhirMensongeMentorMercrediMe/riteMerleMessagerMesureMe/talMe/te/oreMe/thodeMe/tierMeubleMiaulerMicrobeMietteMignonMigrerMilieuMillionMimiqueMinceMine/ralMinimalMinorerMinuteMiracleMiroiterMissileMixteMobileModerneMoelleuxMondialMoniteurMonnaieMonotoneMonstreMontagneMonumentMoqueurMorceauMorsureMortierMoteurMotifMoucheMoufleMoulinMoussonMoutonMouvantMultipleMunitionMurailleMure-neMurmureMuscleMuse/umMusicienMutationMuterMutuelMyriadeMyrtilleMyste-reMythiqueNageurNappeNarquoisNarrerNatationNationNatureNaufrageNautiqueNavireNe/buleuxNectarNe/fasteNe/gationNe/gligerNe/gocierNeigeNerveuxNettoyerNeuroneNeutronNeveuNicheNickelNitrateNiveauNobleNocifNocturneNoirceurNoisetteNomadeNombreuxNommerNormatifNotableNotifierNotoireNourrirNouveauNovateurNovembreNoviceNuageNuancerNuireNuisibleNume/roNuptialNuqueNutritifObe/irObjectifObligerObscurObserverObstacleObtenirObturerOccasionOccuperOce/anOctobreOctroyerOctuplerOculaireOdeurOdorantOffenserOfficierOffrirOgiveOiseauOisillonOlfactifOlivierOmbrageOmettreOnctueuxOndulerOne/reuxOniriqueOpaleOpaqueOpe/rerOpinionOpportunOpprimerOpterOptiqueOrageuxOrangeOrbiteOrdonnerOreilleOrganeOrgueilOrificeOrnementOrqueOrtieOscillerOsmoseOssatureOtarieOuraganOursonOutilOutragerOuvrageOvationOxydeOxyge-neOzonePaisiblePalacePalmare-sPalourdePalperPanachePandaPangolinPaniquerPanneauPanoramaPantalonPapayePapierPapoterPapyrusParadoxeParcelleParesseParfumerParlerParoleParrainParsemerPartagerParureParvenirPassionPaste-quePaternelPatiencePatronPavillonPavoiserPayerPaysagePeignePeintrePelagePe/licanPellePelousePeluchePendulePe/ne/trerPe/niblePensifPe/nuriePe/pitePe/plumPerdrixPerforerPe/riodePermuterPerplexePersilPertePeserPe/talePetitPe/trirPeuplePharaonPhobiePhoquePhotonPhrasePhysiquePianoPicturalPie-cePierrePieuvrePilotePinceauPipettePiquerPiroguePiscinePistonPivoterPixelPizzaPlacardPlafondPlaisirPlanerPlaquePlastronPlateauPleurerPlexusPliagePlombPlongerPluiePlumagePochettePoe/siePoe-tePointePoirierPoissonPoivrePolairePolicierPollenPolygonePommadePompierPonctuelPonde/rerPoneyPortiquePositionPosse/derPosturePotagerPoteauPotionPoucePoulainPoumonPourprePoussinPouvoirPrairiePratiquePre/cieuxPre/direPre/fixePre/ludePre/nomPre/sencePre/textePre/voirPrimitifPrincePrisonPriverProble-meProce/derProdigeProfondProgre-sProieProjeterProloguePromenerPropreProspe-reProte/gerProuesseProverbePrudencePruneauPsychosePublicPuceronPuiserPulpePulsarPunaisePunitifPupitrePurifierPuzzlePyramideQuasarQuerelleQuestionQuie/tudeQuitterQuotientRacineRaconterRadieuxRagondinRaideurRaisinRalentirRallongeRamasserRapideRasageRatisserRavagerRavinRayonnerRe/actifRe/agirRe/aliserRe/animerRecevoirRe/citerRe/clamerRe/colterRecruterReculerRecyclerRe/digerRedouterRefaireRe/flexeRe/formerRefrainRefugeRe/galienRe/gionRe/glageRe/gulierRe/ite/rerRejeterRejouerRelatifReleverReliefRemarqueReme-deRemiseRemonterRemplirRemuerRenardRenfortReniflerRenoncerRentrerRenvoiReplierReporterRepriseReptileRequinRe/serveRe/sineuxRe/soudreRespectResterRe/sultatRe/tablirRetenirRe/ticuleRetomberRetracerRe/unionRe/ussirRevancheRevivreRe/volteRe/vulsifRichesseRideauRieurRigideRigolerRincerRiposterRisibleRisqueRituelRivalRivie-reRocheuxRomanceRompreRonceRondinRoseauRosierRotatifRotorRotuleRougeRouilleRouleauRoutineRoyaumeRubanRubisRucheRuelleRugueuxRuinerRuisseauRuserRustiqueRythmeSablerSaboterSabreSacocheSafariSagesseSaisirSaladeSaliveSalonSaluerSamediSanctionSanglierSarcasmeSardineSaturerSaugrenuSaumonSauterSauvageSavantSavonnerScalpelScandaleSce/le/ratSce/narioSceptreSche/maScienceScinderScoreScrutinSculpterSe/anceSe/cableSe/cherSecouerSe/cre/terSe/datifSe/duireSeigneurSe/jourSe/lectifSemaineSemblerSemenceSe/minalSe/nateurSensibleSentenceSe/parerSe/quenceSereinSergentSe/rieuxSerrureSe/rumServiceSe/sameSe/virSevrageSextupleSide/ralSie-cleSie/gerSifflerSigleSignalSilenceSiliciumSimpleSince-reSinistreSiphonSiropSismiqueSituerSkierSocialSocleSodiumSoigneuxSoldatSoleilSolitudeSolubleSombreSommeilSomnolerSondeSongeurSonnetteSonoreSorcierSortirSosieSottiseSoucieuxSoudureSouffleSouleverSoupapeSourceSoutirerSouvenirSpacieuxSpatialSpe/cialSphe-reSpiralStableStationSternumStimulusStipulerStrictStudieuxStupeurStylisteSublimeSubstratSubtilSubvenirSucce-sSucreSuffixeSugge/rerSuiveurSulfateSuperbeSupplierSurfaceSuricateSurmenerSurpriseSursautSurvieSuspectSyllabeSymboleSyme/trieSynapseSyntaxeSyste-meTabacTablierTactileTaillerTalentTalismanTalonnerTambourTamiserTangibleTapisTaquinerTarderTarifTartineTasseTatamiTatouageTaupeTaureauTaxerTe/moinTemporelTenailleTendreTeneurTenirTensionTerminerTerneTerribleTe/tineTexteThe-meThe/orieThe/rapieThoraxTibiaTie-deTimideTirelireTiroirTissuTitaneTitreTituberTobogganTole/rantTomateToniqueTonneauToponymeTorcheTordreTornadeTorpilleTorrentTorseTortueTotemToucherTournageTousserToxineTractionTraficTragiqueTrahirTrainTrancherTravailTre-fleTremperTre/sorTreuilTriageTribunalTricoterTrilogieTriompheTriplerTriturerTrivialTromboneTroncTropicalTroupeauTuileTulipeTumulteTunnelTurbineTuteurTutoyerTuyauTympanTyphonTypiqueTyranUbuesqueUltimeUltrasonUnanimeUnifierUnionUniqueUnitaireUniversUraniumUrbainUrticantUsageUsineUsuelUsureUtileUtopieVacarmeVaccinVagabondVagueVaillantVaincreVaisseauValableValiseVallonValveVampireVanilleVapeurVarierVaseuxVassalVasteVecteurVedetteVe/ge/talVe/hiculeVeinardVe/loceVendrediVe/ne/rerVengerVenimeuxVentouseVerdureVe/rinVernirVerrouVerserVertuVestonVe/te/ranVe/tusteVexantVexerViaducViandeVictoireVidangeVide/oVignetteVigueurVilainVillageVinaigreViolonVipe-reVirementVirtuoseVirusVisageViseurVisionVisqueuxVisuelVitalVitesseViticoleVitrineVivaceVivipareVocationVoguerVoileVoisinVoitureVolailleVolcanVoltigerVolumeVoraceVortexVoterVouloirVoyageVoyelleWagonXe/nonYachtZe-breZe/nithZesteZoologie".replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ").map(t => function (t) { const e = []; return Array.prototype.forEach.call((0, u.Y0)(t), t => { 47 === t ? (e.push(204), e.push(129)) : 45 === t ? (e.push(204), e.push(128)) : e.push(t) }), (0, u.ZN)(e) }(t)), g.forEach((t, e) => { v[y(t)] = e }), "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045" !== r.D.check(t))) throw g = null, new Error("BIP39 Wordlist for fr (French) FAILED") } const _ = new class extends r.D { constructor() { super("fr") } getWord(t) { return b(this), g[t] } getWordIndex(t) { return b(this), v[y(t)] } }; r.D.register(_); var w = n(1488); const S = ["AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR", "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR", "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm", "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC", "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD", "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD", "IJBEJqXZJ"]; let x = null; function T(t) { return (0, w.hexlify)((0, u.Y0)(t)) } function E(t) { if (null !== x) return; x = []; const e = {}; function n(t) { let n = ""; for (let r = 0; r < t.length; r++) { let i = t[r]; const s = e[i]; !1 !== s && (s && (i = s), n += i) } return n } e[(0, u.ZN)([227, 130, 154])] = !1, e[(0, u.ZN)([227, 130, 153])] = !1, e[(0, u.ZN)([227, 130, 133])] = (0, u.ZN)([227, 130, 134]), e[(0, u.ZN)([227, 129, 163])] = (0, u.ZN)([227, 129, 164]), e[(0, u.ZN)([227, 130, 131])] = (0, u.ZN)([227, 130, 132]), e[(0, u.ZN)([227, 130, 135])] = (0, u.ZN)([227, 130, 136]); for (let r = 3; r <= 9; r++) { const t = S[r - 3]; for (let e = 0; e < t.length; e += r) { const n = []; for (let i = 0; i < r; i++) { const r = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt".indexOf(t[e + i]); n.push(227), n.push(64 & r ? 130 : 129), n.push(128 + (63 & r)) } x.push((0, u.ZN)(n)) } } if (x.sort(function (t, e) { return (t = n(t)) < (e = n(e)) ? -1 : t > e ? 1 : 0 }), "0xe3818de38284e3818f" === T(x[442]) && "0xe3818de38283e3818f" === T(x[443])) { const t = x[442]; x[442] = x[443], x[443] = t } if ("0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600" !== r.D.check(t)) throw x = null, new Error("BIP39 Wordlist for ja (Japanese) FAILED") } const M = new class extends r.D { constructor() { super("ja") } getWord(t) { return E(this), x[t] } getWordIndex(t) { return E(this), x.indexOf(t) } split(t) { return r.k.checkNormalize(), t.split(/(?:\u3000| )+/g) } join(t) { return t.join("\u3000") } }; r.D.register(M); const A = ["OYAa", "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8", "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6", "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv", "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo", "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg", "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb", "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"]; let C = null; function P(t) { if (null == C && (C = [], A.forEach((t, e) => { e += 4; for (let r = 0; r < t.length; r += e) { let i = ""; for (let s = 0; s < e; s++)i += ((n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*".indexOf(t[r + s])) >= 40 ? n = n + 168 - 40 : n >= 19 && (n = n + 97 - 19), (0, u.ZN)([225, 132 + (n >> 6), 128 + (63 & n)])); C.push(i) } var n }), C.sort(), "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a" !== r.D.check(t))) throw C = null, new Error("BIP39 Wordlist for ko (Korean) FAILED") } const R = new class extends r.D { constructor() { super("ko") } getWord(t) { return P(this), C[t] } getWordIndex(t) { return P(this), C.indexOf(t) } }; r.D.register(R); let L = null; function k(t) { if (null == L && (L = "AbacoAbbaglioAbbinatoAbeteAbissoAbolireAbrasivoAbrogatoAccadereAccennoAccusatoAcetoneAchilleAcidoAcquaAcreAcrilicoAcrobataAcutoAdagioAddebitoAddomeAdeguatoAderireAdipeAdottareAdulareAffabileAffettoAffissoAffrantoAforismaAfosoAfricanoAgaveAgenteAgevoleAggancioAgireAgitareAgonismoAgricoloAgrumetoAguzzoAlabardaAlatoAlbatroAlberatoAlboAlbumeAlceAlcolicoAlettoneAlfaAlgebraAlianteAlibiAlimentoAllagatoAllegroAllievoAllodolaAllusivoAlmenoAlogenoAlpacaAlpestreAltalenaAlternoAlticcioAltroveAlunnoAlveoloAlzareAmalgamaAmanitaAmarenaAmbitoAmbratoAmebaAmericaAmetistaAmicoAmmassoAmmendaAmmirareAmmonitoAmoreAmpioAmpliareAmuletoAnacardoAnagrafeAnalistaAnarchiaAnatraAncaAncellaAncoraAndareAndreaAnelloAngeloAngolareAngustoAnimaAnnegareAnnidatoAnnoAnnuncioAnonimoAnticipoAnziApaticoAperturaApodeApparireAppetitoAppoggioApprodoAppuntoAprileArabicaArachideAragostaAraldicaArancioAraturaArazzoArbitroArchivioArditoArenileArgentoArgineArgutoAriaArmoniaArneseArredatoArringaArrostoArsenicoArsoArteficeArzilloAsciuttoAscoltoAsepsiAsetticoAsfaltoAsinoAsolaAspiratoAsproAssaggioAsseAssolutoAssurdoAstaAstenutoAsticeAstrattoAtavicoAteismoAtomicoAtonoAttesaAttivareAttornoAttritoAttualeAusilioAustriaAutistaAutonomoAutunnoAvanzatoAvereAvvenireAvvisoAvvolgereAzioneAzotoAzzimoAzzurroBabeleBaccanoBacinoBacoBadessaBadilataBagnatoBaitaBalconeBaldoBalenaBallataBalzanoBambinoBandireBaraondaBarbaroBarcaBaritonoBarlumeBaroccoBasilicoBassoBatostaBattutoBauleBavaBavosaBeccoBeffaBelgioBelvaBendaBenevoleBenignoBenzinaBereBerlinaBetaBibitaBiciBidoneBifidoBigaBilanciaBimboBinocoloBiologoBipedeBipolareBirbanteBirraBiscottoBisestoBisnonnoBisonteBisturiBizzarroBlandoBlattaBollitoBonificoBordoBoscoBotanicoBottinoBozzoloBraccioBradipoBramaBrancaBravuraBretellaBrevettoBrezzaBrigliaBrillanteBrindareBroccoloBrodoBronzinaBrulloBrunoBubboneBucaBudinoBuffoneBuioBulboBuonoBurloneBurrascaBussolaBustaCadettoCaducoCalamaroCalcoloCalesseCalibroCalmoCaloriaCambusaCamerataCamiciaCamminoCamolaCampaleCanapaCandelaCaneCaninoCanottoCantinaCapaceCapelloCapitoloCapogiroCapperoCapraCapsulaCarapaceCarcassaCardoCarismaCarovanaCarrettoCartolinaCasaccioCascataCasermaCasoCassoneCastelloCasualeCatastaCatenaCatrameCautoCavilloCedibileCedrataCefaloCelebreCellulareCenaCenoneCentesimoCeramicaCercareCertoCerumeCervelloCesoiaCespoCetoChelaChiaroChiccaChiedereChimeraChinaChirurgoChitarraCiaoCiclismoCifrareCignoCilindroCiottoloCircaCirrosiCitricoCittadinoCiuffoCivettaCivileClassicoClinicaCloroCoccoCodardoCodiceCoerenteCognomeCollareColmatoColoreColposoColtivatoColzaComaCometaCommandoComodoComputerComuneConcisoCondurreConfermaCongelareConiugeConnessoConoscereConsumoContinuoConvegnoCopertoCopioneCoppiaCopricapoCorazzaCordataCoricatoCorniceCorollaCorpoCorredoCorsiaCorteseCosmicoCostanteCotturaCovatoCratereCravattaCreatoCredereCremosoCrescitaCretaCricetoCrinaleCrisiCriticoCroceCronacaCrostataCrucialeCruscaCucireCuculoCuginoCullatoCupolaCuratoreCursoreCurvoCuscinoCustodeDadoDainoDalmataDamerinoDanielaDannosoDanzareDatatoDavantiDavveroDebuttoDecennioDecisoDeclinoDecolloDecretoDedicatoDefinitoDeformeDegnoDelegareDelfinoDelirioDeltaDemenzaDenotatoDentroDepositoDerapataDerivareDerogaDescrittoDesertoDesiderioDesumereDetersivoDevotoDiametroDicembreDiedroDifesoDiffusoDigerireDigitaleDiluvioDinamicoDinnanziDipintoDiplomaDipoloDiradareDireDirottoDirupoDisagioDiscretoDisfareDisgeloDispostoDistanzaDisumanoDitoDivanoDiveltoDividereDivoratoDobloneDocenteDoganaleDogmaDolceDomatoDomenicaDominareDondoloDonoDormireDoteDottoreDovutoDozzinaDragoDruidoDubbioDubitareDucaleDunaDuomoDupliceDuraturoEbanoEccessoEccoEclissiEconomiaEderaEdicolaEdileEditoriaEducareEgemoniaEgliEgoismoEgregioElaboratoElargireEleganteElencatoElettoElevareElficoElicaElmoElsaElusoEmanatoEmblemaEmessoEmiroEmotivoEmozioneEmpiricoEmuloEndemicoEnduroEnergiaEnfasiEnotecaEntrareEnzimaEpatiteEpilogoEpisodioEpocaleEppureEquatoreErarioErbaErbosoEredeEremitaErigereErmeticoEroeErosivoErranteEsagonoEsameEsanimeEsaudireEscaEsempioEsercitoEsibitoEsigenteEsistereEsitoEsofagoEsortatoEsosoEspansoEspressoEssenzaEssoEstesoEstimareEstoniaEstrosoEsultareEtilicoEtnicoEtruscoEttoEuclideoEuropaEvasoEvidenzaEvitatoEvolutoEvvivaFabbricaFaccendaFachiroFalcoFamigliaFanaleFanfaraFangoFantasmaFareFarfallaFarinosoFarmacoFasciaFastosoFasulloFaticareFatoFavolosoFebbreFecolaFedeFegatoFelpaFeltroFemminaFendereFenomenoFermentoFerroFertileFessuraFestivoFettaFeudoFiabaFiduciaFifaFiguratoFiloFinanzaFinestraFinireFioreFiscaleFisicoFiumeFlaconeFlamencoFleboFlemmaFloridoFluenteFluoroFobicoFocacciaFocosoFoderatoFoglioFolataFolcloreFolgoreFondenteFoneticoFoniaFontanaForbitoForchettaForestaFormicaFornaioForoFortezzaForzareFosfatoFossoFracassoFranaFrassinoFratelloFreccettaFrenataFrescoFrigoFrollinoFrondeFrugaleFruttaFucilataFucsiaFuggenteFulmineFulvoFumanteFumettoFumosoFuneFunzioneFuocoFurboFurgoneFuroreFusoFutileGabbianoGaffeGalateoGallinaGaloppoGamberoGammaGaranziaGarboGarofanoGarzoneGasdottoGasolioGastricoGattoGaudioGazeboGazzellaGecoGelatinaGelsoGemelloGemmatoGeneGenitoreGennaioGenotipoGergoGhepardoGhiaccioGhisaGialloGildaGineproGiocareGioielloGiornoGioveGiratoGironeGittataGiudizioGiuratoGiustoGlobuloGlutineGnomoGobbaGolfGomitoGommoneGonfioGonnaGovernoGracileGradoGraficoGrammoGrandeGrattareGravosoGraziaGrecaGreggeGrifoneGrigioGrinzaGrottaGruppoGuadagnoGuaioGuantoGuardareGufoGuidareIbernatoIconaIdenticoIdillioIdoloIdraIdricoIdrogenoIgieneIgnaroIgnoratoIlareIllesoIllogicoIlludereImballoImbevutoImboccoImbutoImmaneImmersoImmolatoImpaccoImpetoImpiegoImportoImprontaInalareInarcareInattivoIncantoIncendioInchinoIncisivoInclusoIncontroIncrocioIncuboIndagineIndiaIndoleIneditoInfattiInfilareInflittoIngaggioIngegnoIngleseIngordoIngrossoInnescoInodoreInoltrareInondatoInsanoInsettoInsiemeInsonniaInsulinaIntasatoInteroIntonacoIntuitoInumidireInvalidoInveceInvitoIperboleIpnoticoIpotesiIppicaIrideIrlandaIronicoIrrigatoIrrorareIsolatoIsotopoIstericoIstitutoIstriceItaliaIterareLabbroLabirintoLaccaLaceratoLacrimaLacunaLaddoveLagoLampoLancettaLanternaLardosoLargaLaringeLastraLatenzaLatinoLattugaLavagnaLavoroLegaleLeggeroLemboLentezzaLenzaLeoneLepreLesivoLessatoLestoLetteraleLevaLevigatoLiberoLidoLievitoLillaLimaturaLimitareLimpidoLineareLinguaLiquidoLiraLiricaLiscaLiteLitigioLivreaLocandaLodeLogicaLombareLondraLongevoLoquaceLorenzoLotoLotteriaLuceLucidatoLumacaLuminosoLungoLupoLuppoloLusingaLussoLuttoMacabroMacchinaMaceroMacinatoMadamaMagicoMagliaMagneteMagroMaiolicaMalafedeMalgradoMalintesoMalsanoMaltoMalumoreManaManciaMandorlaMangiareManifestoMannaroManovraMansardaMantideManubrioMappaMaratonaMarcireMarettaMarmoMarsupioMascheraMassaiaMastinoMaterassoMatricolaMattoneMaturoMazurcaMeandroMeccanicoMecenateMedesimoMeditareMegaMelassaMelisMelodiaMeningeMenoMensolaMercurioMerendaMerloMeschinoMeseMessereMestoloMetalloMetodoMettereMiagolareMicaMicelioMicheleMicroboMidolloMieleMiglioreMilanoMiliteMimosaMineraleMiniMinoreMirinoMirtilloMiscelaMissivaMistoMisurareMitezzaMitigareMitraMittenteMnemonicoModelloModificaModuloMoganoMogioMoleMolossoMonasteroMoncoMondinaMonetarioMonileMonotonoMonsoneMontatoMonvisoMoraMordereMorsicatoMostroMotivatoMotosegaMottoMovenzaMovimentoMozzoMuccaMucosaMuffaMughettoMugnaioMulattoMulinelloMultiploMummiaMuntoMuovereMuraleMusaMuscoloMusicaMutevoleMutoNababboNaftaNanometroNarcisoNariceNarratoNascereNastrareNaturaleNauticaNaviglioNebulosaNecrosiNegativoNegozioNemmenoNeofitaNerettoNervoNessunoNettunoNeutraleNeveNevroticoNicchiaNinfaNitidoNobileNocivoNodoNomeNominaNordicoNormaleNorvegeseNostranoNotareNotiziaNotturnoNovellaNucleoNullaNumeroNuovoNutrireNuvolaNuzialeOasiObbedireObbligoObeliscoOblioOboloObsoletoOccasioneOcchioOccidenteOccorrereOccultareOcraOculatoOdiernoOdorareOffertaOffrireOffuscatoOggettoOggiOgnunoOlandeseOlfattoOliatoOlivaOlogrammaOltreOmaggioOmbelicoOmbraOmegaOmissioneOndosoOnereOniceOnnivoroOnorevoleOntaOperatoOpinioneOppostoOracoloOrafoOrdineOrecchinoOreficeOrfanoOrganicoOrigineOrizzonteOrmaOrmeggioOrnativoOrologioOrrendoOrribileOrtensiaOrticaOrzataOrzoOsareOscurareOsmosiOspedaleOspiteOssaOssidareOstacoloOsteOtiteOtreOttagonoOttimoOttobreOvaleOvestOvinoOviparoOvocitoOvunqueOvviareOzioPacchettoPacePacificoPadellaPadronePaesePagaPaginaPalazzinaPalesarePallidoPaloPaludePandoroPannelloPaoloPaonazzoPapricaParabolaParcellaParerePargoloPariParlatoParolaPartireParvenzaParzialePassivoPasticcaPataccaPatologiaPattumePavonePeccatoPedalarePedonalePeggioPelosoPenarePendicePenisolaPennutoPenombraPensarePentolaPepePepitaPerbenePercorsoPerdonatoPerforarePergamenaPeriodoPermessoPernoPerplessoPersuasoPertugioPervasoPesatorePesistaPesoPestiferoPetaloPettinePetulantePezzoPiacerePiantaPiattinoPiccinoPicozzaPiegaPietraPifferoPigiamaPigolioPigroPilaPiliferoPillolaPilotaPimpantePinetaPinnaPinoloPioggiaPiomboPiramidePireticoPiritePirolisiPitonePizzicoPlaceboPlanarePlasmaPlatanoPlenarioPochezzaPoderosoPodismoPoesiaPoggiarePolentaPoligonoPollicePolmonitePolpettaPolsoPoltronaPolverePomicePomodoroPontePopolosoPorfidoPorosoPorporaPorrePortataPosaPositivoPossessoPostulatoPotassioPoterePranzoPrassiPraticaPreclusoPredicaPrefissoPregiatoPrelievoPremerePrenotarePreparatoPresenzaPretestoPrevalsoPrimaPrincipePrivatoProblemaProcuraProdurreProfumoProgettoProlungaPromessaPronomePropostaProrogaProtesoProvaPrudentePrugnaPruritoPsichePubblicoPudicaPugilatoPugnoPulcePulitoPulsantePuntarePupazzoPupillaPuroQuadroQualcosaQuasiQuerelaQuotaRaccoltoRaddoppioRadicaleRadunatoRafficaRagazzoRagioneRagnoRamarroRamingoRamoRandagioRantolareRapatoRapinaRappresoRasaturaRaschiatoRasenteRassegnaRastrelloRataRavvedutoRealeRecepireRecintoReclutaReconditoRecuperoRedditoRedimereRegalatoRegistroRegolaRegressoRelazioneRemareRemotoRennaReplicaReprimereReputareResaResidenteResponsoRestauroReteRetinaRetoricaRettificaRevocatoRiassuntoRibadireRibelleRibrezzoRicaricaRiccoRicevereRiciclatoRicordoRicredutoRidicoloRidurreRifasareRiflessoRiformaRifugioRigareRigettatoRighelloRilassatoRilevatoRimanereRimbalzoRimedioRimorchioRinascitaRincaroRinforzoRinnovoRinomatoRinsavitoRintoccoRinunciaRinvenireRiparatoRipetutoRipienoRiportareRipresaRipulireRisataRischioRiservaRisibileRisoRispettoRistoroRisultatoRisvoltoRitardoRitegnoRitmicoRitrovoRiunioneRivaRiversoRivincitaRivoltoRizomaRobaRoboticoRobustoRocciaRocoRodaggioRodereRoditoreRogitoRollioRomanticoRompereRonzioRosolareRospoRotanteRotondoRotulaRovescioRubizzoRubricaRugaRullinoRumineRumorosoRuoloRupeRussareRusticoSabatoSabbiareSabotatoSagomaSalassoSaldaturaSalgemmaSalivareSalmoneSaloneSaltareSalutoSalvoSapereSapidoSaporitoSaracenoSarcasmoSartoSassosoSatelliteSatiraSatolloSaturnoSavanaSavioSaziatoSbadiglioSbalzoSbancatoSbarraSbattereSbavareSbendareSbirciareSbloccatoSbocciatoSbrinareSbruffoneSbuffareScabrosoScadenzaScalaScambiareScandaloScapolaScarsoScatenareScavatoSceltoScenicoScettroSchedaSchienaSciarpaScienzaScindereScippoSciroppoScivoloSclerareScodellaScolpitoScompartoSconfortoScoprireScortaScossoneScozzeseScribaScrollareScrutinioScuderiaScultoreScuolaScuroScusareSdebitareSdoganareSeccaturaSecondoSedanoSeggiolaSegnalatoSegregatoSeguitoSelciatoSelettivoSellaSelvaggioSemaforoSembrareSemeSeminatoSempreSensoSentireSepoltoSequenzaSerataSerbatoSerenoSerioSerpenteSerraglioServireSestinaSetolaSettimanaSfaceloSfaldareSfamatoSfarzosoSfaticatoSferaSfidaSfilatoSfingeSfocatoSfoderareSfogoSfoltireSforzatoSfrattoSfruttatoSfuggitoSfumareSfusoSgabelloSgarbatoSgonfiareSgorbioSgrassatoSguardoSibiloSiccomeSierraSiglaSignoreSilenzioSillabaSimboloSimpaticoSimulatoSinfoniaSingoloSinistroSinoSintesiSinusoideSiparioSismaSistoleSituatoSlittaSlogaturaSlovenoSmarritoSmemoratoSmentitoSmeraldoSmilzoSmontareSmottatoSmussatoSnellireSnervatoSnodoSobbalzoSobrioSoccorsoSocialeSodaleSoffittoSognoSoldatoSolenneSolidoSollazzoSoloSolubileSolventeSomaticoSommaSondaSonettoSonniferoSopireSoppesoSopraSorgereSorpassoSorrisoSorsoSorteggioSorvolatoSospiroSostaSottileSpadaSpallaSpargereSpatolaSpaventoSpazzolaSpecieSpedireSpegnereSpelaturaSperanzaSpessoreSpettraleSpezzatoSpiaSpigolosoSpillatoSpinosoSpiraleSplendidoSportivoSposoSprangaSprecareSpronatoSpruzzoSpuntinoSquilloSradicareSrotolatoStabileStaccoStaffaStagnareStampatoStantioStarnutoStaseraStatutoSteloSteppaSterzoStilettoStimaStirpeStivaleStizzosoStonatoStoricoStrappoStregatoStriduloStrozzareStruttoStuccareStufoStupendoSubentroSuccosoSudoreSuggeritoSugoSultanoSuonareSuperboSupportoSurgelatoSurrogatoSussurroSuturaSvagareSvedeseSveglioSvelareSvenutoSveziaSviluppoSvistaSvizzeraSvoltaSvuotareTabaccoTabulatoTacciareTaciturnoTaleTalismanoTamponeTanninoTaraTardivoTargatoTariffaTarpareTartarugaTastoTatticoTavernaTavolataTazzaTecaTecnicoTelefonoTemerarioTempoTemutoTendoneTeneroTensioneTentacoloTeoremaTermeTerrazzoTerzettoTesiTesseratoTestatoTetroTettoiaTifareTigellaTimbroTintoTipicoTipografoTiraggioTiroTitanioTitoloTitubanteTizioTizzoneToccareTollerareToltoTombolaTomoTonfoTonsillaTopazioTopologiaToppaTorbaTornareTorroneTortoraToscanoTossireTostaturaTotanoTraboccoTracheaTrafilaTragediaTralcioTramontoTransitoTrapanoTrarreTraslocoTrattatoTraveTrecciaTremolioTrespoloTributoTrichecoTrifoglioTrilloTrinceaTrioTristezzaTrituratoTrivellaTrombaTronoTroppoTrottolaTrovareTruccatoTubaturaTuffatoTulipanoTumultoTunisiaTurbareTurchinoTutaTutelaUbicatoUccelloUccisoreUdireUditivoUffaUfficioUgualeUlisseUltimatoUmanoUmileUmorismoUncinettoUngereUnghereseUnicornoUnificatoUnisonoUnitarioUnteUovoUpupaUraganoUrgenzaUrloUsanzaUsatoUscitoUsignoloUsuraioUtensileUtilizzoUtopiaVacanteVaccinatoVagabondoVagliatoValangaValgoValicoVallettaValorosoValutareValvolaVampataVangareVanitosoVanoVantaggioVanveraVaporeVaranoVarcatoVarianteVascaVedettaVedovaVedutoVegetaleVeicoloVelcroVelinaVellutoVeloceVenatoVendemmiaVentoVeraceVerbaleVergognaVerificaVeroVerrucaVerticaleVescicaVessilloVestaleVeteranoVetrinaVetustoViandanteVibranteVicendaVichingoVicinanzaVidimareVigiliaVignetoVigoreVileVillanoViminiVincitoreViolaViperaVirgolaVirologoVirulentoViscosoVisioneVispoVissutoVisuraVitaVitelloVittimaVivandaVividoViziareVoceVogaVolatileVolereVolpeVoragineVulcanoZampognaZannaZappatoZatteraZavorraZefiroZelanteZeloZenzeroZerbinoZibettoZincoZirconeZittoZollaZoticoZuccheroZufoloZuluZuppa".replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620" !== r.D.check(t))) throw L = null, new Error("BIP39 Wordlist for it (Italian) FAILED") } const D = new class extends r.D { constructor() { super("it") } getWord(t) { return k(this), L[t] } getWordIndex(t) { return k(this), L.indexOf(t) } }; r.D.register(D); const I = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH", O = { zh_cn: null, zh_tw: null }, F = { zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1", zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d" }, N = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; function B(t) { if (null !== O[t.locale]) return; O[t.locale] = []; let e = 0; for (let n = 0; n < 2048; n++) { const r = "~!@#$%^&*_-=[]{}|;:,.()<>?".indexOf(I[3 * n]), i = [228 + (r >> 2), 128 + N.indexOf(I[3 * n + 1]), 128 + N.indexOf(I[3 * n + 2])]; if ("zh_tw" === t.locale) for (let t = r % 4; t < 3; t++)i[t] = N.indexOf("FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL"[e++]) + (0 == t ? 228 : 128); O[t.locale].push((0, u.ZN)(i)) } if (r.D.check(t) !== F[t.locale]) throw O[t.locale] = null, new Error("BIP39 Wordlist for " + t.locale + " (Chinese) FAILED") } class H extends r.D { constructor(t) { super("zh_" + t) } getWord(t) { return B(this), O[this.locale][t] } getWordIndex(t) { return B(this), O[this.locale].indexOf(t) } split(t) { return (t = t.replace(/(?:\u3000| )+/g, "")).split("") } } const U = new H("cn"); r.D.register(U), r.D.register(U, "zh"); const G = new H("tw"); r.D.register(G); const V = { cz: o, en: c, es: m, fr: _, it: D, ja: M, ko: R, zh: U, zh_cn: U, zh_tw: G } }, 6347: function (t, e) { var n, r; "undefined" == typeof self || self, void 0 === (r = "function" == typeof (n = function () { var t = function (t, e) { if (!t || "string" != typeof t) throw new SyntaxError("Not enough arguments"); this.URL = t, this.setOptions(e); var n = this; setTimeout(function () { n.poll() }, 0) }; if (t.prototype = { CONNECTING: 0, OPEN: 1, CLOSED: 2, defaultOptions: { loggingEnabled: !1, loggingPrefix: "eventsource", interval: 500, bufferSizeLimit: 262144, silentTimeout: 3e5, getArgs: { evs_buffer_size_limit: 262144 }, xhrHeaders: { Accept: "text/event-stream", "Cache-Control": "no-cache", "X-Requested-With": "XMLHttpRequest" } }, setOptions: function (t) { var e, n = this.defaultOptions; for (e in n) n.hasOwnProperty(e) && (this[e] = n[e]); for (e in t) e in n && t.hasOwnProperty(e) && (this[e] = t[e]); this.getArgs && this.bufferSizeLimit && (this.getArgs.evs_buffer_size_limit = this.bufferSizeLimit), "undefined" != typeof console && void 0 !== console.log || (this.loggingEnabled = !1) }, log: function (t) { this.loggingEnabled && console.log("[" + this.loggingPrefix + "]:" + t) }, poll: function () { try { if (this.readyState == this.CLOSED) return; this.cleanup(), this.readyState = this.CONNECTING, this.cursor = 0, this.cache = "", this._xhr = new this.XHR(this), this.resetNoActivityTimer() } catch (t) { this.log("There were errors inside the pool try-catch"), this.dispatchEvent("error", { type: "error", data: t.message }) } }, pollAgain: function (t) { var e = this; e.readyState = e.CONNECTING, e.dispatchEvent("error", { type: "error", data: "Reconnecting " }), this._pollTimer = setTimeout(function () { e.poll() }, t || 0) }, cleanup: function () { this.log("evs cleaning up"), this._pollTimer && (clearInterval(this._pollTimer), this._pollTimer = null), this._noActivityTimer && (clearInterval(this._noActivityTimer), this._noActivityTimer = null), this._xhr && (this._xhr.abort(), this._xhr = null) }, resetNoActivityTimer: function () { if (this.silentTimeout) { this._noActivityTimer && clearInterval(this._noActivityTimer); var t = this; this._noActivityTimer = setTimeout(function () { t.log("Timeout! silentTImeout:" + t.silentTimeout), t.pollAgain() }, this.silentTimeout) } }, close: function () { this.readyState = this.CLOSED, this.log("Closing connection. readyState: " + this.readyState), this.cleanup() }, _onxhrdata: function () { var t = this._xhr; if (t.isReady() && !t.hasError()) { this.resetNoActivityTimer(), this.readyState == this.CONNECTING && (this.readyState = this.OPEN, this.dispatchEvent("open", { type: "open" })); var e = t.getBuffer(); e.length > this.bufferSizeLimit && (this.log("buffer.length > this.bufferSizeLimit"), this.pollAgain()), 0 == this.cursor && e.length > 0 && "\ufeff" == e.substring(0, 1) && (this.cursor = 1); var n = this.lastMessageIndex(e); if (n[0] >= this.cursor) { var r = n[1], i = e.substring(this.cursor, r); this.parseStream(i), this.cursor = r } t.isDone() && (this.log("request.isDone(). reopening the connection"), this.pollAgain(this.interval)) } else this.readyState !== this.CLOSED && (this.log("this.readyState !== this.CLOSED"), this.pollAgain(this.interval)) }, parseStream: function (t) { var e, r, i, s, o, a, l = (t = this.cache + this.normalizeToLF(t)).split("\n\n"); for (e = 0; e < l.length - 1; e++) { i = "message", s = []; var c = l[e].split("\n"); for (r = 0; r < c.length; r++)0 == (o = this.trimWhiteSpace(c[r])).indexOf("event") ? i = o.replace(/event:?\s*/, "") : 0 == o.indexOf("retry") ? (a = parseInt(o.replace(/retry:?\s*/, ""), 10), isNaN(a) || (this.interval = a)) : 0 == o.indexOf("data") ? s.push(o.replace(/data:?\s*/, "")) : 0 == o.indexOf("id:") ? this.lastEventId = o.replace(/id:?\s*/, "") : 0 == o.indexOf("id") && (this.lastEventId = null); if (s.length && this.readyState != this.CLOSED) { var u = new n(i, s.join("\n"), "undefined" != typeof window && void 0 !== window.location ? window.location.origin : null, this.lastEventId); this.dispatchEvent(i, u) } } this.cache = l[l.length - 1] }, dispatchEvent: function (t, e) { var n = this["_" + t + "Handlers"]; if (n) for (var r = 0; r < n.length; r++)n[r].call(this, e); this["on" + t] && this["on" + t].call(this, e) }, addEventListener: function (t, e) { this["_" + t + "Handlers"] || (this["_" + t + "Handlers"] = []), this["_" + t + "Handlers"].push(e) }, removeEventListener: function (t, e) { var n = this["_" + t + "Handlers"]; if (n) for (var r = n.length - 1; r >= 0; --r)if (n[r] === e) { n.splice(r, 1); break } }, _pollTimer: null, _noactivityTimer: null, _xhr: null, lastEventId: null, cache: "", cursor: 0, onerror: null, onmessage: null, onopen: null, readyState: 0, urlWithParams: function (t, e) { var n = []; if (e) { var r, i, s = encodeURIComponent; for (r in e) e.hasOwnProperty(r) && (i = s(r) + "=" + s(e[r]), n.push(i)) } return n.length > 0 ? -1 == t.indexOf("?") ? t + "?" + n.join("&") : t + "&" + n.join("&") : t }, lastMessageIndex: function (t) { var e = t.lastIndexOf("\n\n"), n = t.lastIndexOf("\r\r"), r = t.lastIndexOf("\r\n\r\n"); return r > Math.max(e, n) ? [r, r + 4] : [Math.max(e, n), Math.max(e, n) + 2] }, trimWhiteSpace: function (t) { return t.replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, "") }, normalizeToLF: function (t) { return t.replace(/\r\n|\r/g, "\n") } }, Boolean("undefined" != typeof window && window.XDomainRequest && window.XMLHttpRequest && void 0 === (new XMLHttpRequest).responseType)) { t.isPolyfill = "IE_8-9"; var e = t.prototype.defaultOptions; e.xhrHeaders = null, e.getArgs.evs_preamble = 2056, (t.prototype.XHR = function (t) { var e = new XDomainRequest; this._request = e, e.onprogress = function () { e._ready = !0, t._onxhrdata() }, e.onload = function () { this._loaded = !0, t._onxhrdata() }, e.onerror = function () { this._failed = !0, t.readyState = t.CLOSED, t.dispatchEvent("error", { type: "error", data: "XDomainRequest error" }) }, e.ontimeout = function () { this._failed = !0, t.readyState = t.CLOSED, t.dispatchEvent("error", { type: "error", data: "XDomainRequest timed out" }) }; var n = {}; if (t.getArgs) { var r = t.getArgs; for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i]); t.lastEventId && (n.evs_last_event_id = t.lastEventId) } e.open("GET", t.urlWithParams(t.URL, n)), e.send() }).prototype = { useXDomainRequest: !0, _request: null, _ready: !1, _loaded: !1, _failed: !1, isReady: function () { return this._request._ready }, isDone: function () { return this._request._loaded }, hasError: function () { return this._request._failed }, getBuffer: function () { var t = ""; try { t = this._request.responseText || "" } catch (e) { } return t }, abort: function () { this._request && this._request.abort() } } } else t.isPolyfill = "XHR", (t.prototype.XHR = function (t) { var e = new XMLHttpRequest; this._request = e, t._xhr = this, e.onreadystatechange = function () { e.readyState > 1 && t.readyState != t.CLOSED && (200 == e.status || e.status >= 300 && e.status < 400 ? t._onxhrdata() : (e._failed = !0, t.readyState = t.CLOSED, t.dispatchEvent("error", { type: "error", data: "The server responded with " + e.status }), t.close())) }, e.onprogress = function () { }, e.open("GET", t.urlWithParams(t.URL, t.getArgs), !0); var n = t.xhrHeaders; for (var r in n) n.hasOwnProperty(r) && e.setRequestHeader(r, n[r]); t.lastEventId && e.setRequestHeader("Last-Event-Id", t.lastEventId), e.send() }).prototype = { useXDomainRequest: !1, _request: null, _failed: !1, isReady: function () { return this._request.readyState >= 2 }, isDone: function () { return 4 == this._request.readyState }, hasError: function () { return this._failed || this._request.status >= 400 }, getBuffer: function () { var t = ""; try { t = this._request.responseText || "" } catch (e) { } return t }, abort: function () { this._request && this._request.abort() } }; function n(t, e, n, r) { this.bubbles = !1, this.cancelBubble = !1, this.cancelable = !1, this.data = e || null, this.origin = n || "", this.lastEventId = r || "", this.type = t || "message" } return t }) ? n.apply(e, []) : n) || (t.exports = r) }, 4585: (t, e, n) => { "use strict"; var r = n(6969), i = r.renderNode, s = function (t) { var e = r(t); return e.outerHTML || e }; s.defaultSerializers = r.defaultSerializers, s.getImageUrl = r.getImageUrl, s.renderNode = i, s.h = i, t.exports = s }, 3246: (t, e, n) => { "use strict"; var r = n(8228), i = n(748), s = n(8453), o = n(4242), a = n(402), l = ["projectId", "dataset", "imageOptions", "ignoreUnknownTypes"], c = { imageOptions: {}, ignoreUnknownTypes: !0 }; function u(t) { return "block" === t._type && t.listItem } t.exports = function (t, e, n, h) { var d = r({}, c, e), p = Array.isArray(d.blocks) ? d.blocks : [d.blocks], f = o(p), m = s(f, d.listNestMode), g = a(n, d.serializers || {}), v = l.reduce(function (t, e) { var n = d[e]; return void 0 !== n && (t[e] = n), t }, {}), y = Boolean(d.renderContainerOnSingleChild), b = m.map(function e(n, r, s, o) { return "list" === (f = n)._type && f.listItem ? (l = (a = n).listItem, c = a.level, d = a._key, p = a.children.map(e), t(g.list, { key: d, level: c, type: l, options: v }, p)) : u(n) ? function (n, r) { var s = n._key, o = i(n).map(e); return t(g.listItem, { node: n, serializers: g, index: r, key: s, options: v }, o) }(n, function (t, e) { for (var n = 0, r = 0; r < e.length; r++) { if (e[r] === t) return n; u(e[r]) && n++ } return n }(n, s)) : function (t) { return "string" == typeof t || t.marks || "span" === t._type }(n) ? h(n, g, r, { serializeNode: e }) : function (n, r, s) { var o = i(n).map(function (t, n, r) { return e(t, n, r, !0) }), a = { key: n._key || "block-".concat(r), node: n, isInline: s, serializers: g, options: v }; return t(g.block, a, o) }(n, r, o); var a, l, c, d, p, f }); return y || b.length > 1 ? t(g.container, d.className ? { className: d.className } : {}, b) : b[0] ? b[0] : "function" == typeof g.empty ? t(g.empty) : g.empty } }, 748: t => { "use strict"; var e = ["strong", "em", "code", "underline", "strike-through"]; function n(t, e, n) { if (!t.marks || 0 === t.marks.length) return t.marks || []; var i = t.marks.reduce(function (t, r) { t[r] = t[r] ? t[r] + 1 : 1; for (var i = e + 1; i < n.length; i++) { var s = n[i]; if (!s.marks || !Array.isArray(s.marks) || -1 === s.marks.indexOf(r)) break; t[r]++ } return t }, {}), s = r.bind(null, i); return t.marks.slice().sort(s) } function r(t, n, r) { var i = t[n] || 0, s = t[r] || 0; if (i !== s) return s - i; var o = e.indexOf(n), a = e.indexOf(r); return o !== a ? o - a : n < r ? -1 : n > r ? 1 : 0 } t.exports = function (t) { var e = t.children, r = t.markDefs; if (!e || !e.length) return []; var i = e.map(n), s = { _type: "span", children: [] }, o = [s]; return e.forEach(function (t, e) { var n = i[e]; if (n) { var s = 1; if (o.length > 1) for (; s < o.length; s++) { var a = n.indexOf(o[s].markKey); if (-1 === a) break; n.splice(a, 1) } var l, c = function (t) { for (var e = t.length - 1; e >= 0; e--) { var n = t[e]; if ("span" === n._type && n.children) return n } }(o = o.slice(0, s)); if (n.forEach(function (e) { var n = { _type: "span", _key: t._key, children: [], mark: r.find(function (t) { return t._key === e }) || e, markKey: e }; c.children.push(n), o.push(n), c = n }), "span" !== (l = t)._type || "string" != typeof l.text || !Array.isArray(l.marks) && void 0 !== l.marks) c.children = c.children.concat(t); else { for (var u = t.text.split("\n"), h = u.length; h-- > 1;)u.splice(h, 0, "\n"); c.children = c.children.concat(u) } } else o[o.length - 1].children.push(t) }), s.children } }, 4242: (t, e, n) => { "use strict"; var r = n(8228); function i(t) { var e = 0, n = t.length; if (0 === n) return e; for (var r = 0; r < n; r++)e = (e << 5) - e + t.charCodeAt(r), e &= e; return e } t.exports = function (t) { return t.map(function (t) { return t._key ? t : r({ _key: (e = t, i(JSON.stringify(e)).toString(36).replace(/[^A-Za-z0-9]/g, "")) }, t); var e }) } }, 3846: (t, e, n) => { "use strict"; var r = n(7448), i = n(5188), s = n(8228), o = encodeURIComponent, a = "You must either:\n  - Pass `projectId` and `dataset` to the block renderer\n  - Materialize images to include the `url` field.\n\nFor more information, see ".concat(r("block-content-image-materializing")); t.exports = function (t) { var e = t.node, n = t.options, r = n.projectId, l = n.dataset, c = e.asset; if (!c) throw new Error("Image does not have required `asset` property"); if (c.url) return c.url + function (t) { var e = t.imageOptions, n = Object.keys(e); if (!n.length) return ""; var r = n.map(function (t) { return "".concat(o(t), "=").concat(o(e[t])) }); return "?".concat(r.join("&")) }(n); if (!r || !l) throw new Error(a); if (!c._ref) throw new Error("Invalid image reference in block, no `_ref` found on `asset`"); return i(s({ projectId: r, dataset: l }, n.imageOptions || {})).image(e).toString() } }, 6969: (t, e, n) => { "use strict"; var r = n(5517), i = n(8228), s = n(3846), o = n(3246), a = n(5374), l = function (t, e, n) { var s = e || {}; return "function" == typeof t ? t(i({}, s, { children: n })) : r(t, s, s.children || n) }, c = a(l, { useDashedStyles: !0 }), u = c.defaultSerializers, h = c.serializeSpan, d = function (t) { return o(l, t, u, h) }; d.defaultSerializers = u, d.getImageUrl = s, d.renderNode = l, t.exports = d }, 402: (t, e, n) => { "use strict"; function r(t) { return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } var i = n(8228); t.exports = function (t, e) { return Object.keys(t).reduce(function (n, s) { var o = r(t[s]); return n[s] = "function" === o ? void 0 !== e[s] ? e[s] : t[s] : "object" === o ? i({}, t[s], e[s]) : void 0 === e[s] ? t[s] : e[s], n }, {}) } }, 8453: (t, e, n) => { "use strict"; var r = n(8228); function i(t) { return Boolean(t.listItem) } function s(t, e) { return t.level === e.level && t.listItem === e.listItem } function o(t) { return { _type: "list", _key: "".concat(t._key, "-parent"), level: t.level, listItem: t.listItem, children: [t] } } function a(t) { return t.children && t.children[t.children.length - 1] } function l(t, e) { if ("list" === t._type && t.level === e.level && "string" == typeof e.listItem && t.listItem === e.listItem) return t; var n = a(t); return !!n && l(n, e) } t.exports = function (t) { for (var e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "html", c = [], u = 0; u < t.length; u++) { var h = t[u]; if (i(h)) if (e) if (s(h, e)) e.children.push(h); else if (h.level > e.level) { var d = o(h); if ("html" === n) { var p = a(e), f = r({}, p, { children: p.children.concat(d) }); e.children[e.children.length - 1] = f } else e.children.push(d); e = d } else if (h.level < e.level) { var m = l(c[c.length - 1], h); if (m) { (e = m).children.push(h); continue } e = o(h), c.push(e) } else if (h.listItem === e.listItem) console.warn("Unknown state encountered for block", h), c.push(h); else { var g = l(c[c.length - 1], { level: h.level }); if (g && g.listItem === h.listItem) { (e = g).children.push(h); continue } e = o(h), c.push(e) } else e = o(h), c.push(e); else c.push(h), e = null } return c } }, 5374: (t, e, n) => { "use strict"; var r = n(8228), i = n(3846); t.exports = function (t, e) { var n = e || { useDashedStyles: !1 }; function s(e, n) { return t(e, null, n.children) } return { defaultSerializers: { types: { block: function (e) { var n = e.node.style || "normal"; return /^h\d/.test(n) ? t(n, null, e.children) : t("blockquote" === n ? "blockquote" : "p", null, e.children) }, image: function (e) { if (!e.node.asset) return null; var n = t("img", { src: i(e) }); return e.isInline ? n : t("figure", null, n) } }, marks: { strong: s.bind(null, "strong"), em: s.bind(null, "em"), code: s.bind(null, "code"), underline: function (e) { return t("span", { style: n.useDashedStyles ? { "text-decoration": "underline" } : { textDecoration: "underline" } }, e.children) }, "strike-through": function (e) { return t("del", null, e.children) }, link: function (e) { return t("a", { href: e.mark.href }, e.children) } }, list: function (e) { return t("bullet" === e.type ? "ul" : "ol", null, e.children) }, listItem: function (e) { var n = e.node.style && "normal" !== e.node.style ? t(e.serializers.types.block, e, e.children) : e.children; return t("li", null, n) }, block: function (e) { var n = e.node, r = e.serializers, i = e.options, s = e.isInline, o = e.children, a = n._type, l = r.types[a]; if (!l) { if (i.ignoreUnknownTypes) return console.warn('Unknown block type "'.concat(a, '", please specify a serializer for it in the `serializers.types` prop')), t(r.unknownType, { node: n, options: i, isInline: s }, o); throw new Error('Unknown block type "'.concat(a, '", please specify a serializer for it in the `serializers.types` prop')) } return t(l, { node: n, options: i, isInline: s }, o) }, span: function (e) { var n = e.node, r = n.mark, i = n.children, s = "string" == typeof r ? r : r._type, o = e.serializers.marks[s]; return o ? t(o, e.node, i) : (console.warn('Unknown mark type "'.concat(s, '", please specify a serializer for it in the `serializers.marks` prop')), t(e.serializers.unknownMark, null, i)) }, hardBreak: function () { return t("br") }, unknownType: function (e) { return t("div", { style: { display: "none" } }, 'Unknown block type "'.concat(e.node._type, '", please specify a serializer for it in the `serializers.types` prop')) }, unknownMark: "span", container: "div", text: void 0, empty: "" }, serializeSpan: function (e, n, i, s) { if ("\n" === e && n.hardBreak) return t(n.hardBreak, { key: "hb-".concat(i) }); if ("string" == typeof e) return n.text ? t(n.text, { key: "text-".concat(i) }, e) : e; var o; e.children && (o = { children: e.children.map(function (t, n) { return s.serializeNode(t, n, e.children, !0) }) }); var a = r({}, e, o); return t(n.span, { key: e._key || "span-".concat(i), node: a, serializers: n }) } } } }, 7448: t => { t.exports = function (t) { return "https://docs.sanity.io/help/" + t } }, 5661: (t, e, n) => { "use strict"; function r(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var i = n(8228), s = n(8325).map, o = n(3253).filter, a = n(1098), l = n(5082); function c(t) { this.client = t } function u(t) { var e = t.document; return Object.defineProperty(e, "document", { enumerable: !1, get: function () { return console.warn("The promise returned from client.asset.upload(...) now resolves with the asset document"), e } }), e } function h(t, e) { return "undefined" != typeof window && e instanceof window.File ? i({ filename: !1 === t.preserveFilename ? void 0 : e.name, contentType: e.type }, t) : t } i(c.prototype, { upload: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; l.validateAssetType(t); var r = n.extract || void 0; r && !r.length && (r = ["none"]); var i = l.hasDataset(this.client.clientConfig), a = "image" === t ? "images" : "files", c = h(n, e), d = c.label, p = c.title, f = c.description, m = c.creditLine, g = c.filename, v = c.source, y = { label: d, title: p, description: f, filename: g, meta: r, creditLine: m }; v && (y.sourceId = v.id, y.sourceName = v.name, y.sourceUrl = v.url); var b = this.client._requestObservable({ method: "POST", timeout: c.timeout || 0, uri: "/assets/".concat(a, "/").concat(i), headers: c.contentType ? { "Content-Type": c.contentType } : {}, query: y, body: e }); return this.client.isPromiseAPI() ? b.pipe(o(function (t) { return "response" === t.type }), s(function (t) { return u(t.body) })).toPromise() : b }, delete: function (t, e) { console.warn("client.assets.delete() is deprecated, please use client.delete(<document-id>)"); var n = e || ""; return /^(image|file)-/.test(n) ? t._id && (n = t._id) : n = "".concat(t, "-").concat(n), l.hasDataset(this.client.clientConfig), this.client.delete(n) }, getImageUrl: function (t, e) { var n = t._ref || t; if ("string" != typeof n) throw new Error("getImageUrl() needs either an object with a _ref, or a string with an asset document ID"); if (!/^image-[A-Za-z0-9_]+-\d+x\d+-[a-z]{1,5}$/.test(n)) throw new Error('Unsupported asset ID "'.concat(n, '". URL generation only works for auto-generated IDs.')); var i, s = (4, function (t) { if (Array.isArray(t)) return t }(i = n.split("-")) || function (t, e) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) { var n = [], r = !0, i = !1, s = void 0; try { for (var o, a = t[Symbol.iterator](); !(r = (o = a.next()).done) && (n.push(o.value), 4 !== n.length); r = !0); } catch (l) { i = !0, s = l } finally { try { r || null == a.return || a.return() } finally { if (i) throw s } } return n } }(i) || function (t, e) { if (t) { if ("string" == typeof t) return r(t, 4); var n = Object.prototype.toString.call(t).slice(8, -1); return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? r(t, 4) : void 0 } }(i) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }()), o = s[1], c = s[2], u = s[3]; l.hasDataset(this.client.clientConfig); var h = this.client.clientConfig, d = h.projectId, p = h.dataset, f = e ? a(e) : ""; return "https://cdn.sanity.io/images/".concat(d, "/").concat(p, "/").concat(o, "-").concat(c, ".").concat(u).concat(f) } }), t.exports = c }, 9958: (t, e, n) => { "use strict"; function r(t) { this.client = t } n(8228)(r.prototype, { getLoginProviders: function () { return this.client.request({ uri: "/auth/providers" }) }, logout: function () { return this.client.request({ uri: "/auth/logout", method: "POST" }) } }), t.exports = r }, 7712: (t, e, n) => { "use strict"; var r = n(3178), i = n(8228), s = n(5082), o = n(4387), a = { apiHost: "https://api.sanity.io", apiVersion: "1", useProjectHostname: !0, gradientMode: !1, isPromiseAPI: !0 }, l = ["localhost", "127.0.0.1", "0.0.0.0"]; e.defaultConfig = a, e.initConfig = function (t, n) { var c = i({}, n, t); c.apiVersion || o.printNoApiVersionSpecifiedWarning(); var u = i({}, a, c), h = u.gradientMode, d = !h && u.useProjectHostname; if ("undefined" == typeof Promise) { var p = r("js-client-promise-polyfill"); throw new Error("No native Promise-implementation found, polyfill needed - see ".concat(p)) } if (h && !u.namespace) throw new Error("Configuration must contain `namespace` when running in gradient mode"); if (d && !u.projectId) throw new Error("Configuration must contain `projectId`"); var f = "undefined" != typeof window && window.location && window.location.hostname, m = f && function (t) { return -1 !== l.indexOf(t) }(window.location.hostname); if (f && m && u.token && !0 !== u.ignoreBrowserTokenWarning ? o.printBrowserTokenWarning() : (!f || m) && u.useCdn && u.token ? o.printCdnTokenWarning() : void 0 === u.useCdn && o.printCdnWarning(), d && s.projectId(u.projectId), !h && u.dataset && s.dataset(u.dataset, u.gradientMode), u.apiVersion = "".concat(u.apiVersion).replace(/^v/, ""), u.isDefaultApi = u.apiHost === a.apiHost, u.useCdn = Boolean(u.useCdn) && !u.token && !u.withCredentials, e.validateApiVersion(u.apiVersion), u.gradientMode) u.url = u.apiHost, u.cdnUrl = u.apiHost; else { var g = u.apiHost.split("://", 2), v = g[0], y = g[1], b = u.isDefaultApi ? "apicdn.sanity.io" : y; u.useProjectHostname ? (u.url = "".concat(v, "://").concat(u.projectId, ".").concat(y, "/v").concat(u.apiVersion), u.cdnUrl = "".concat(v, "://").concat(u.projectId, ".").concat(b, "/v").concat(u.apiVersion)) : (u.url = "".concat(u.apiHost, "/v").concat(u.apiVersion), u.cdnUrl = u.url) } return u }, e.validateApiVersion = function (t) { if ("1" !== t && "X" !== t) { var e = new Date(t); if (!(/^\d{4}-\d{2}-\d{2}$/.test(t) && e instanceof Date && e.getTime() > 0)) throw new Error("Invalid API version string, expected `1` or date in format `YYYY-MM-DD`") } } }, 6975: (t, e, n) => { "use strict"; function r(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var i = n(8228), s = n(3253).filter, o = n(8325).map, a = n(5082), l = n(7817), c = n(3631), u = n(8205), h = n(167), d = n(8880), p = function (t, e) { return !1 === t ? void 0 : void 0 === t ? e : t }, f = function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return { returnIds: !0, returnDocuments: p(t.returnDocuments, !0), visibility: t.visibility || "sync" } }, m = function (t) { return "response" === t.type }, g = function (t) { return t.body }, v = function (t) { return t.toPromise() }; t.exports = { listen: d, getDataUrl: function (t, e) { var n = this.clientConfig, r = n.gradientMode ? n.namespace : a.hasDataset(n), i = "/".concat(t, "/").concat(r), s = e ? "".concat(i, "/").concat(e) : i; return (this.clientConfig.gradientMode ? s : "/data".concat(s)).replace(/\/($|\?)/, "$1") }, fetch: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = !1 === n.filterResponse ? function (t) { return t } : function (t) { return t.result }, i = this._dataRequest("query", { query: t, params: e }, n).pipe(o(r)); return this.isPromiseAPI() ? v(i) : i }, getDocument: function (t) { var e = { uri: this.getDataUrl("doc", t), json: !0 }, n = this._requestObservable(e).pipe(s(m), o(function (t) { return t.body.documents && t.body.documents[0] })); return this.isPromiseAPI() ? v(n) : n }, getDocuments: function (t) { var e = { uri: this.getDataUrl("doc", t.join(",")), json: !0 }, n = this._requestObservable(e).pipe(s(m), o(function (e) { var n, r = (n = function (t) { return t._id }, (e.body.documents || []).reduce(function (t, e) { return t[n(e)] = e, t }, Object.create(null))); return t.map(function (t) { return r[t] || null }) })); return this.isPromiseAPI() ? v(n) : n }, create: function (t, e) { return this._create(t, "create", e) }, createIfNotExists: function (t, e) { return a.requireDocumentId("createIfNotExists", t), this._create(t, "createIfNotExists", e) }, createOrReplace: function (t, e) { return a.requireDocumentId("createOrReplace", t), this._create(t, "createOrReplace", e) }, patch: function (t, e) { return new h(t, e, this) }, delete: function (t, e) { return this.dataRequest("mutate", { mutations: [{ delete: l(t) }] }, e) }, mutate: function (t, e) { var n = t instanceof h || t instanceof u ? t.serialize() : t, r = Array.isArray(n) ? n : [n]; return this.dataRequest("mutate", { mutations: r, transactionId: e && e.transactionId }, e) }, transaction: function (t) { return new u(t, this) }, dataRequest: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = this._dataRequest(t, e, n); return this.isPromiseAPI() ? v(r) : r }, _dataRequest: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = "mutate" === t, a = !i && c(e), l = !i && a.length < 11264, u = l ? a : "", h = n.returnFirst, d = n.timeout, p = n.token, v = this.getDataUrl(t, u), y = { method: l ? "GET" : "POST", uri: v, json: !0, body: l ? void 0 : e, query: i && f(n), timeout: d, token: p }; return this._requestObservable(y).pipe(s(m), o(g), o(function (t) { if (!i) return t; var e = t.results || []; if (n.returnDocuments) return h ? e[0] && e[0].document : e.map(function (t) { return t.document }); var s = h ? "documentId" : "documentIds", o = h ? e[0] && e[0].id : e.map(function (t) { return t.id }); return r({ transactionId: t.transactionId, results: e }, s, o) })) }, _create: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, s = r({}, e, t), o = i({ returnFirst: !0, returnDocuments: !0 }, n); return this.dataRequest("mutate", { mutations: [s] }, o) } } }, 3631: t => { "use strict"; var e = encodeURIComponent; t.exports = function (t) { var n = t.params, r = void 0 === n ? {} : n, i = t.options, s = void 0 === i ? {} : i, o = "?query=".concat(e(t.query)), a = Object.keys(r).reduce(function (t, n) { return "".concat(t, "&").concat(e("$".concat(n)), "=").concat(e(JSON.stringify(r[n]))) }, o); return Object.keys(s).reduce(function (t, n) { return s[n] ? "".concat(t, "&").concat(e(n), "=").concat(e(s[n])) : t }, a) } }, 8880: (t, e, n) => { "use strict"; var r = n(8228), i = n(4131), s = n(9196), o = n(9636), a = n(7049), l = n(3631), c = n(3178), u = n(7464), h = ["Using token with listeners is not supported in browsers. ", "For more info, see ".concat(c("js-client-listener-tokens-browser"), ".")], d = u(function () { return console.warn(h.join(" ")) }), p = Boolean("undefined" != typeof window && window.EventSource), f = p ? window.EventSource : s, m = ["includePreviousRevision", "includeResult", "visibility", "effectFormat"], g = { includeResult: !0 }; function v(t) { try { var e = t.data && JSON.parse(t.data) || {}; return r({ type: t.type }, e) } catch (n) { return n } } function y(t) { if (t instanceof Error) return t; var e = v(t); return e instanceof Error ? e : new Error(function (t) { return t.error ? t.error.description ? t.error.description : "string" == typeof t.error ? t.error : JSON.stringify(t.error, null, 2) : t.message || "Unknown listener error" }(e)) } t.exports = function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = a(n, g), s = o(r, m), c = l({ query: t, params: e, options: s }), u = this.clientConfig, h = u.url, b = u.token, _ = u.withCredentials, w = "".concat(h).concat(this.getDataUrl("listen", c)), S = r.events ? r.events : ["mutation"], x = -1 !== S.indexOf("reconnect"); b && p && d(); var T = {}; return (b || _) && (T.withCredentials = !0), b && (T.headers = { Authorization: "Bearer ".concat(b) }), new i(function (t) { var e, n = c(), r = !1; function i() { r || (x && t.next({ type: "reconnect" }), r || n.readyState === f.CLOSED && (l(), clearTimeout(e), e = setTimeout(u, 100))) } function s(e) { t.error(y(e)) } function o(e) { var n = v(e); return n instanceof Error ? t.error(n) : t.next(n) } function a(e) { r = !0, l(), t.complete() } function l() { n.removeEventListener("error", i, !1), n.removeEventListener("channelError", s, !1), n.removeEventListener("disconnect", a, !1), S.forEach(function (t) { return n.removeEventListener(t, o, !1) }), n.close() } function c() { var t = new f(w, T); return t.addEventListener("error", i, !1), t.addEventListener("channelError", s, !1), t.addEventListener("disconnect", a, !1), S.forEach(function (e) { return t.addEventListener(e, o, !1) }), t } function u() { n = c() } return function () { r = !0, l() } }) } }, 167: (t, e, n) => { "use strict"; function r(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var i = n(6585), s = n(8228), o = n(7817), a = n(5082), l = a.validateObject, c = a.validateInsert; function u(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null; this.selection = t, this.operations = s({}, e), this.client = n } s(u.prototype, { clone: function () { return new u(this.selection, s({}, this.operations), this.client) }, merge: function (t) { l("merge", t); var e = (new Error).stack.toString().split("\n").filter(function (t) { return t.trim() }).slice(2); return console.warn('The "merge" patch has been deprecated and will be removed in the future\n'.concat(e.join("\n"))), this._assign("merge", i(this.operations.merge || {}, t)) }, set: function (t) { return this._assign("set", t) }, diffMatchPatch: function (t) { return l("diffMatchPatch", t), this._assign("diffMatchPatch", t) }, unset: function (t) { if (!Array.isArray(t)) throw new Error("unset(attrs) takes an array of attributes to unset, non-array given"); return this.operations = s({}, this.operations, { unset: t }), this }, setIfMissing: function (t) { return this._assign("setIfMissing", t) }, replace: function (t) { return l("replace", t), this._set("set", { $: t }) }, inc: function (t) { return this._assign("inc", t) }, dec: function (t) { return this._assign("dec", t) }, insert: function (t, e, n) { var i; return c(t, e, n), this._assign("insert", (r(i = {}, t, e), r(i, "items", n), i)) }, append: function (t, e) { return this.insert("after", "".concat(t, "[-1]"), e) }, prepend: function (t, e) { return this.insert("before", "".concat(t, "[0]"), e) }, splice: function (t, e, n, r) { var i = e < 0 ? e - 1 : e, s = void 0 === n || -1 === n ? -1 : Math.max(0, e + n), o = i < 0 && s >= 0 ? "" : s, a = "".concat(t, "[").concat(i, ":").concat(o, "]"); return this.insert("replace", a, r || []) }, ifRevisionId: function (t) { return this.operations.ifRevisionID = t, this }, serialize: function () { return s(o(this.selection), this.operations) }, toJSON: function () { return this.serialize() }, commit: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (!this.client) throw new Error("No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method"); var e = "string" == typeof this.selection, n = s({ returnFirst: e, returnDocuments: !0 }, t); return this.client.mutate({ patch: this.serialize() }, n) }, reset: function () { return this.operations = {}, this }, _set: function (t, e) { return this._assign(t, e, !1) }, _assign: function (t, e) { var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; return l(t, e), this.operations = s({}, this.operations, r({}, t, s({}, n && this.operations[t] || {}, e))), this } }), t.exports = u }, 8205: (t, e, n) => { "use strict"; function r(t, e, n) { return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } var i = n(8228), s = n(5082), o = n(167), a = { returnDocuments: !1 }; function l() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 ? arguments[2] : void 0; this.trxId = n, this.operations = t, this.client = e } i(l.prototype, { clone: function () { return new l(this.operations.slice(0), this.client, this.trxId) }, create: function (t) { return s.validateObject("create", t), this._add({ create: t }) }, createIfNotExists: function (t) { var e = "createIfNotExists"; return s.validateObject(e, t), s.requireDocumentId(e, t), this._add(r({}, e, t)) }, createOrReplace: function (t) { var e = "createOrReplace"; return s.validateObject(e, t), s.requireDocumentId(e, t), this._add(r({}, e, t)) }, delete: function (t) { return s.validateDocumentId("delete", t), this._add({ delete: { id: t } }) }, patch: function (t, e) { var n = "function" == typeof e; if (t instanceof o) return this._add({ patch: t.serialize() }); if (n) { var r = e(new o(t, {}, this.client)); if (!(r instanceof o)) throw new Error("function passed to `patch()` must return the patch"); return this._add({ patch: r.serialize() }) } return this._add({ patch: i({ id: t }, e) }) }, transactionId: function (t) { return t ? (this.trxId = t, this) : this.trxId }, serialize: function () { return this.operations.slice() }, toJSON: function () { return this.serialize() }, commit: function (t) { if (!this.client) throw new Error("No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method"); return this.client.mutate(this.serialize(), i({ transactionId: this.trxId }, a, t || {})) }, reset: function () { return this.operations = [], this }, _add: function (t) { return this.operations.push(t), this } }), t.exports = l }, 3673: (t, e, n) => { "use strict"; var r = n(8228), i = n(5082); function s(t) { this.request = t.request.bind(t) } r(s.prototype, { create: function (t, e) { return this._modify("PUT", t, e) }, edit: function (t, e) { return this._modify("PATCH", t, e) }, delete: function (t) { return this._modify("DELETE", t) }, list: function () { return this.request({ uri: "/datasets" }) }, _modify: function (t, e, n) { return i.dataset(e), this.request({ method: t, uri: "/datasets/".concat(e), body: n }) } }), t.exports = s }, 5320: t => { "use strict"; t.exports = [] }, 1834: (t, e, n) => { "use strict"; var r = n(7726), i = n(8228); function s(t) { var e = a(t); s.super.call(this, e.message), i(this, e) } function o(t) { var e = a(t); o.super.call(this, e.message), i(this, e) } function a(t) { var e = t.body, n = { response: t, statusCode: t.statusCode, responseBody: l(e, t) }; return e.error && e.message ? (n.message = "".concat(e.error, " - ").concat(e.message), n) : e.error && e.error.description ? (n.message = e.error.description, n.details = e.error, n) : (n.message = e.error || e.message || function (t) { var e = t.statusMessage ? " ".concat(t.statusMessage) : ""; return "".concat(t.method, "-request to ").concat(t.url, " resulted in HTTP ").concat(t.statusCode).concat(e) }(t), n) } function l(t, e) { return -1 !== (e.headers["content-type"] || "").toLowerCase().indexOf("application/json") ? JSON.stringify(t, null, 2) : t } r(s), r(o), e.ClientError = s, e.ServerError = o }, 1098: t => { "use strict"; t.exports = function (t) { var e = []; for (var n in t) t.hasOwnProperty(n) && e.push("".concat(encodeURIComponent(n), "=").concat(encodeURIComponent(t[n]))); return e.length > 0 ? "?".concat(e.join("&")) : "" } }, 5122: (t, e, n) => { "use strict"; var r = n(9609), i = n(8228), s = n(6791), o = n(9442), a = n(1024), l = n(9753), c = n(4131), u = n(1834), h = u.ClientError, d = u.ServerError, p = { onResponse: function (t) { if (t.statusCode >= 500) throw new d(t); if (t.statusCode >= 400) throw new h(t); return t } }, f = { onResponse: function (t) { var e = t.headers["x-sanity-warning"]; return (Array.isArray(e) ? e : [e]).filter(Boolean).forEach(function (t) { return console.warn(t) }), t } }, m = r(n(5320).concat([f, o(), a(), l(), p, s({ implementation: c })])); function g(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m; return e(i({ maxRedirects: 0 }, t)) } g.defaultRequester = m, g.ClientError = h, g.ServerError = d, t.exports = g }, 5618: (t, e, n) => { "use strict"; var r = n(8228), i = "X-Sanity-Project-ID"; t.exports = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = {}, s = e.token || t.token; s && (n.Authorization = "Bearer ".concat(s)), e.useGlobalApi || t.useProjectHostname || !t.projectId || (n[i] = t.projectId); var o = Boolean(void 0 === e.withCredentials ? t.token || t.withCredentials : e.withCredentials), a = void 0 === e.timeout ? t.timeout : e.timeout; return r({}, e, { headers: r({}, n, e.headers || {}), timeout: void 0 === a ? 3e5 : a, json: !0, withCredentials: o }) } }, 6289: (t, e, n) => { "use strict"; function r(t) { this.client = t } n(8228)(r.prototype, { list: function () { return this.client.request({ uri: "/projects" }) }, getById: function (t) { return this.client.request({ uri: "/projects/".concat(t) }) } }), t.exports = r }, 9555: (t, e, n) => { "use strict"; var r = n(8228), i = n(3253).filter, s = n(8325).map, o = n(167), a = n(8205), l = n(6975), c = n(3673), u = n(6289), h = n(5661), d = n(3687), p = n(9958), f = n(5122), m = n(5618), g = n(7712), v = g.defaultConfig, y = g.initConfig; function b() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v; if (!(this instanceof b)) return new b(t); if (this.config(t), this.assets = new h(this), this.datasets = new c(this), this.projects = new u(this), this.users = new d(this), this.auth = new p(this), this.clientConfig.isPromiseAPI) { var e = r({}, this.clientConfig, { isPromiseAPI: !1 }); this.observable = new b(e) } } r(b.prototype, l), r(b.prototype, { clone: function () { return new b(this.config()) }, config: function (t) { if (void 0 === t) return r({}, this.clientConfig); if (this.observable) { var e = r({}, t, { isPromiseAPI: !1 }); this.observable.config(e) } return this.clientConfig = y(t, this.clientConfig || {}), this }, withConfig: function (t) { return this.clone().config(t) }, getUrl: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = e ? this.clientConfig.cdnUrl : this.clientConfig.url; return "".concat(n, "/").concat(t.replace(/^\//, "")) }, isPromiseAPI: function () { return this.clientConfig.isPromiseAPI }, _requestObservable: function (t) { var e = t.url || t.uri, n = this.clientConfig.useCdn && ["GET", "HEAD"].indexOf(t.method || "GET") >= 0 && 0 === e.indexOf("/data/"), i = m(this.clientConfig, r({}, t, { url: this.getUrl(e, n) })); return f(i, this.clientConfig.requester) }, request: function (t) { var e = this._requestObservable(t).pipe(i(function (t) { return "response" === t.type }), s(function (t) { return t.body })); return this.isPromiseAPI() ? function (t) { return t.toPromise() }(e) : e } }), b.Patch = o, b.Transaction = a, b.ClientError = f.ClientError, b.ServerError = f.ServerError, b.requester = f.defaultRequester, t.exports = b }, 3687: (t, e, n) => { "use strict"; function r(t) { this.client = t } n(8228)(r.prototype, { getById: function (t) { return this.client.request({ uri: "/users/".concat(t) }) } }), t.exports = r }, 7049: t => { "use strict"; t.exports = function (t, e) { return Object.keys(e).concat(Object.keys(t)).reduce(function (n, r) { return n[r] = void 0 === t[r] ? e[r] : t[r], n }, {}) } }, 7817: t => { "use strict"; t.exports = function (t) { if ("string" == typeof t || Array.isArray(t)) return { id: t }; if (t && t.query) return { query: t.query }; var e = ["* Document ID (<docId>)", "* Array of document IDs", "* Object containing `query`"].join("\n"); throw new Error("Unknown selection - must be one of:\n\n".concat(e)) } }, 7464: t => { "use strict"; t.exports = function (t) { var e, n = !1; return function () { return n || (e = t.apply(void 0, arguments), n = !0), e } } }, 9636: t => { "use strict"; t.exports = function (t, e) { return e.reduce(function (e, n) { return void 0 === t[n] || (e[n] = t[n]), e }, {}) } }, 5082: (t, e) => { "use strict"; function n(t) { return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } var r = ["image", "file"], i = ["before", "after", "replace"]; e.dataset = function (t) { if (!/^(~[a-z0-9]{1}[-\w]{0,25}|[a-z0-9]{1}[-\w]{0,19})$/.test(t)) throw new Error("Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 20 characters") }, e.projectId = function (t) { if (!/^[-a-z0-9]+$/i.test(t)) throw new Error("`projectId` can only contain only a-z, 0-9 and dashes") }, e.validateAssetType = function (t) { if (-1 === r.indexOf(t)) throw new Error("Invalid asset type: ".concat(t, ". Must be one of ").concat(r.join(", "))) }, e.validateObject = function (t, e) { if (null === e || "object" !== n(e) || Array.isArray(e)) throw new Error("".concat(t, "() takes an object of properties")) }, e.requireDocumentId = function (t, n) { if (!n._id) throw new Error("".concat(t, '() requires that the document contains an ID ("_id" property)')); e.validateDocumentId(t, n._id) }, e.validateDocumentId = function (t, e) { if ("string" != typeof e || !/^[a-z0-9_.-]+$/i.test(e)) throw new Error("".concat(t, '(): "').concat(e, '" is not a valid document ID')) }, e.validateInsert = function (t, e, n) { var r = "insert(at, selector, items)"; if (-1 === i.indexOf(t)) { var s = i.map(function (t) { return '"'.concat(t, '"') }).join(", "); throw new Error("".concat(r, ' takes an "at"-argument which is one of: ').concat(s)) } if ("string" != typeof e) throw new Error("".concat(r, ' takes a "selector"-argument which must be a string')); if (!Array.isArray(n)) throw new Error("".concat(r, ' takes an "items"-argument which must be an array')) }, e.hasDataset = function (t) { if (!t.gradientMode && !t.dataset) throw new Error("`dataset` must be provided to perform queries"); return t.dataset || "" } }, 4387: (t, e, n) => { "use strict"; var r = n(3178), i = n(7464), s = function (t) { return i(function () { for (var e, n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; return (e = console).warn.apply(e, [t.join(" ")].concat(r)) }) }; e.printCdnWarning = s(["You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and", "cheaper. Think about it! For more info, see ".concat(r("js-client-cdn-configuration"), "."), "To hide this warning, please set the `useCdn` option to either `true` or `false` when creating", "the client."]), e.printBrowserTokenWarning = s(["You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.", "See ".concat(r("js-client-browser-token"), " for more information and how to hide this warning.")]), e.printCdnTokenWarning = s(["You have set `useCdn` to `true` while also specifying a token. This is usually not what you", "want. The CDN cannot be used with an authorization token, since private data cannot be cached.", "See ".concat(r("js-client-usecdn-token"), " for more information.")]), e.printNoApiVersionSpecifiedWarning = s(["Using the Sanity client without specifying an API version is deprecated.", "See ".concat(r("js-client-api-version"))]) }, 9196: (t, e, n) => { var r = n(6347); t.exports = window.EventSource || r.EventSource }, 3178: t => { t.exports = function (t) { return "https://docs.sanity.io/help/" + t } }, 5188: function (t) { t.exports = function () { function t() { return (t = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }).apply(this, arguments) } function e(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } var n = "image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg"; function r(t) { return ("image-" + t.split("/").slice(-1)[0]).replace(/\.([a-z]+)$/, "-$1") } var i = [["width", "w"], ["height", "h"], ["format", "fm"], ["download", "dl"], ["blur", "blur"], ["sharpen", "sharp"], ["invert", "invert"], ["orientation", "or"], ["minHeight", "min-h"], ["maxHeight", "max-h"], ["minWidth", "min-w"], ["maxWidth", "max-w"], ["quality", "q"], ["fit", "fit"], ["crop", "crop"], ["saturation", "sat"], ["auto", "auto"], ["dpr", "dpr"], ["pad", "pad"]]; function s(e) { var s = t({}, e || {}), o = s.source; delete s.source; var a = function (e) { if (!e) return null; var n, i; if ("string" == typeof e && /^https?:\/\//.test("" + e)) n = { asset: { _ref: r(e) } }; else if ("string" == typeof e) n = { asset: { _ref: e } }; else if ((i = e) && "string" == typeof i._ref) n = { asset: e }; else if (function (t) { return !!t && "string" == typeof t._id }(e)) n = { asset: { _ref: e._id || "" } }; else if (function (t) { return !(!t || !t.asset) && "string" == typeof t.asset.url }(e)) n = { asset: { _ref: r(e.asset.url) } }; else { if ("object" != typeof e.asset) return null; n = e } var s = e; return s.crop && (n.crop = s.crop), s.hotspot && (n.hotspot = s.hotspot), function (e) { if (e.crop && e.hotspot) return e; var n = t({}, e); return n.crop || (n.crop = { left: 0, top: 0, bottom: 0, right: 0 }), n.hotspot || (n.hotspot = { x: .5, y: .5, height: 1, width: 1 }), n }(n) }(o); if (!a) return null; var l = function (t) { var e = t.split("-"), r = e[1], i = e[2], s = e[3]; if (!r || !i || !s) throw new Error("Malformed asset _ref '" + t + "'. Expected an id like \"" + n + '".'); var o = i.split("x"), a = +o[0], l = +o[1]; if (!isFinite(a) || !isFinite(l)) throw new Error("Malformed asset _ref '" + t + "'. Expected an id like \"" + n + '".'); return { id: r, width: a, height: l, format: s } }(a.asset._ref || a.asset._id || ""), c = Math.round(a.crop.left * l.width), u = Math.round(a.crop.top * l.height), h = { left: c, top: u, width: Math.round(l.width - a.crop.right * l.width - c), height: Math.round(l.height - a.crop.bottom * l.height - u) }, d = a.hotspot.height * l.height / 2, p = a.hotspot.width * l.width / 2, f = a.hotspot.x * l.width, m = a.hotspot.y * l.height, g = { left: f - p, top: m - d, right: f + p, bottom: m + d }; return s.rect || s.focalPoint || s.ignoreImageParams || s.crop || (s = t(t({}, s), function (t, e) { var n, r = e.width, i = e.height; if (!r || !i) return { width: r, height: i, rect: t.crop }; var s = t.crop, o = t.hotspot, a = r / i; if (s.width / s.height > a) { var l = s.height, c = l * a, u = s.top, h = (o.right - o.left) / 2 + o.left - c / 2; h < s.left ? h = s.left : h + c > s.left + s.width && (h = s.left + s.width - c), n = { left: Math.round(h), top: Math.round(u), width: Math.round(c), height: Math.round(l) } } else { var d = s.width, p = d / a, f = (o.bottom - o.top) / 2 + o.top - p / 2; f < s.top ? f = s.top : f + p > s.top + s.height && (f = s.top + s.height - p), n = { left: Math.max(0, Math.floor(s.left)), top: Math.max(0, Math.floor(f)), width: Math.round(d), height: Math.round(p) } } return { width: r, height: i, rect: n } }({ crop: h, hotspot: g }, s))), function (t) { var e = (t.baseUrl || "https://cdn.sanity.io") + "/images/" + t.projectId + "/" + t.dataset + "/" + t.asset.id + "-" + t.asset.width + "x" + t.asset.height + "." + t.asset.format, n = []; if (t.rect) { var r = t.rect, s = r.left, o = r.top, a = r.width, l = r.height; (0 !== s || 0 !== o || l !== t.asset.height || a !== t.asset.width) && n.push("rect=" + s + "," + o + "," + a + "," + l) } t.bg && n.push("bg=" + t.bg), t.focalPoint && (n.push("fp-x=" + t.focalPoint.x), n.push("fp-y=" + t.focalPoint.y)); var c = [t.flipHorizontal && "h", t.flipVertical && "v"].filter(Boolean).join(""); return c && n.push("flip=" + c), i.forEach(function (e) { var r = e[0], i = e[1]; void 0 !== t[r] ? n.push(i + "=" + encodeURIComponent(t[r])) : void 0 !== t[i] && n.push(i + "=" + encodeURIComponent(t[i])) }), 0 === n.length ? e : e + "?" + n.join("&") }(t(t({}, s), {}, { asset: l })) } var o = ["clip", "crop", "fill", "fillmax", "max", "scale", "min"], a = ["top", "bottom", "left", "right", "center", "focalpoint", "entropy"], l = ["format"]; function c(t) { for (var n, r = function (t) { var n = 0; if ("undefined" == typeof Symbol || null == t[Symbol.iterator]) { if (Array.isArray(t) || (t = function (t, n) { if (t) { if ("string" == typeof t) return e(t, n); var r = Object.prototype.toString.call(t).slice(8, -1); return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? e(t, n) : void 0 } }(t))) return function () { return n >= t.length ? { done: !0 } : { done: !1, value: t[n++] } }; throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } return (n = t[Symbol.iterator]()).next.bind(n) }(i); !(n = r()).done;) { var s = n.value, o = s[0]; if (t === o || t === s[1]) return o } return t } var u = function () { function e(e, n) { this.options = t(e ? t({}, e.options || {}) : {}, n || {}) } var n = e.prototype; return n.withOptions = function (n) { var r = n.baseUrl || this.options.baseUrl, i = { baseUrl: r }; for (var s in n) n.hasOwnProperty(s) && (i[c(s)] = n[s]); return new e(this, t({ baseUrl: r }, i)) }, n.image = function (t) { return this.withOptions({ source: t }) }, n.dataset = function (t) { return this.withOptions({ dataset: t }) }, n.projectId = function (t) { return this.withOptions({ projectId: t }) }, n.bg = function (t) { return this.withOptions({ bg: t }) }, n.dpr = function (t) { return this.withOptions({ dpr: t }) }, n.width = function (t) { return this.withOptions({ width: t }) }, n.height = function (t) { return this.withOptions({ height: t }) }, n.focalPoint = function (t, e) { return this.withOptions({ focalPoint: { x: t, y: e } }) }, n.maxWidth = function (t) { return this.withOptions({ maxWidth: t }) }, n.minWidth = function (t) { return this.withOptions({ minWidth: t }) }, n.maxHeight = function (t) { return this.withOptions({ maxHeight: t }) }, n.minHeight = function (t) { return this.withOptions({ minHeight: t }) }, n.size = function (t, e) { return this.withOptions({ width: t, height: e }) }, n.blur = function (t) { return this.withOptions({ blur: t }) }, n.sharpen = function (t) { return this.withOptions({ sharpen: t }) }, n.rect = function (t, e, n, r) { return this.withOptions({ rect: { left: t, top: e, width: n, height: r } }) }, n.format = function (t) { return this.withOptions({ format: t }) }, n.invert = function (t) { return this.withOptions({ invert: t }) }, n.orientation = function (t) { return this.withOptions({ orientation: t }) }, n.quality = function (t) { return this.withOptions({ quality: t }) }, n.forceDownload = function (t) { return this.withOptions({ download: t }) }, n.flipHorizontal = function () { return this.withOptions({ flipHorizontal: !0 }) }, n.flipVertical = function () { return this.withOptions({ flipVertical: !0 }) }, n.ignoreImageParams = function () { return this.withOptions({ ignoreImageParams: !0 }) }, n.fit = function (t) { if (-1 === o.indexOf(t)) throw new Error('Invalid fit mode "' + t + '"'); return this.withOptions({ fit: t }) }, n.crop = function (t) { if (-1 === a.indexOf(t)) throw new Error('Invalid crop mode "' + t + '"'); return this.withOptions({ crop: t }) }, n.saturation = function (t) { return this.withOptions({ saturation: t }) }, n.auto = function (t) { if (-1 === l.indexOf(t)) throw new Error('Invalid auto mode "' + t + '"'); return this.withOptions({ auto: t }) }, n.pad = function (t) { return this.withOptions({ pad: t }) }, n.url = function () { return s(this.options) }, n.toString = function () { return this.url() }, e }(); return function (t) { var e = t; if (function (t) { return !!t && "object" == typeof t.clientConfig }(e)) { var n = e.clientConfig, r = n.projectId, i = n.dataset; return new u(null, { baseUrl: (n.apiHost || "https://api.sanity.io").replace(/^https:\/\/api\./, "https://cdn."), projectId: r, dataset: i }) } return new u(null, t) } }() }, 7840: (t, e, n) => { "use strict"; var r = n(3576).Observable, i = n(8228), s = n(8325).map, o = n(3253).filter, a = n(136).reduce; function l() { r.apply(this, arguments) } function c(t, e) { var n = !1; return function () { return n || (n = !0, console.warn(new Error("Calling observable.".concat(t, "(...) is deprecated. Please use observable.pipe(").concat(t, "(...)) instead")))), this.pipe(e.apply(this, arguments)) } } l.prototype = Object.create(i(Object.create(null), r.prototype)), Object.defineProperty(l.prototype, "constructor", { value: l, enumerable: !1, writable: !0, configurable: !0 }), l.prototype.lift = function (t) { var e = new l; return e.source = this, e.operator = t, e }, l.prototype.map = c("map", s), l.prototype.filter = c("filter", o), l.prototype.reduce = c("filter", a), t.exports = l }, 4131: (t, e, n) => { t.exports = n(7840) }, 3253: (t, e, n) => { e.filter = n(6179).filter }, 8325: (t, e, n) => { e.map = n(1156).map }, 136: (t, e, n) => { e.reduce = n(4589).reduce }, 2280: function (t) { "use strict"; !function (e) { function n(t) { return parseInt(t) === t } function r(t) { if (!n(t.length)) return !1; for (var e = 0; e < t.length; e++)if (!n(t[e]) || t[e] < 0 || t[e] > 255) return !1; return !0 } function i(t, e) { if (t.buffer && ArrayBuffer.isView(t) && "Uint8Array" === t.name) return e && (t = t.slice ? t.slice() : Array.prototype.slice.call(t)), t; if (Array.isArray(t)) { if (!r(t)) throw new Error("Array contains invalid value: " + t); return new Uint8Array(t) } if (n(t.length) && r(t)) return new Uint8Array(t); throw new Error("unsupported array-like object") } function s(t) { return new Uint8Array(t) } function o(t, e, n, r, i) { null == r && null == i || (t = t.slice ? t.slice(r, i) : Array.prototype.slice.call(t, r, i)), e.set(t, n) } var a, l = { toBytes: function (t) { var e = [], n = 0; for (t = encodeURI(t); n < t.length;) { var r = t.charCodeAt(n++); 37 === r ? (e.push(parseInt(t.substr(n, 2), 16)), n += 2) : e.push(r) } return i(e) }, fromBytes: function (t) { for (var e = [], n = 0; n < t.length;) { var r = t[n]; r < 128 ? (e.push(String.fromCharCode(r)), n++) : r > 191 && r < 224 ? (e.push(String.fromCharCode((31 & r) << 6 | 63 & t[n + 1])), n += 2) : (e.push(String.fromCharCode((15 & r) << 12 | (63 & t[n + 1]) << 6 | 63 & t[n + 2])), n += 3) } return e.join("") } }, c = (a = "0123456789abcdef", { toBytes: function (t) { for (var e = [], n = 0; n < t.length; n += 2)e.push(parseInt(t.substr(n, 2), 16)); return e }, fromBytes: function (t) { for (var e = [], n = 0; n < t.length; n++) { var r = t[n]; e.push(a[(240 & r) >> 4] + a[15 & r]) } return e.join("") } }), u = { 16: 10, 24: 12, 32: 14 }, h = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145], d = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], p = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], f = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986], m = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766], g = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126], v = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436], y = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890], b = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935], _ = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600], w = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480], S = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795], x = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855], T = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150], E = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925]; function M(t) { for (var e = [], n = 0; n < t.length; n += 4)e.push(t[n] << 24 | t[n + 1] << 16 | t[n + 2] << 8 | t[n + 3]); return e } var A = function (t) { if (!(this instanceof A)) throw Error("AES must be instanitated with `new`"); Object.defineProperty(this, "key", { value: i(t, !0) }), this._prepare() }; A.prototype._prepare = function () { var t = u[this.key.length]; if (null == t) throw new Error("invalid key size (must be 16, 24 or 32 bytes)"); this._Ke = [], this._Kd = []; for (var e = 0; e <= t; e++)this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]); var n, r = 4 * (t + 1), i = this.key.length / 4, s = M(this.key); for (e = 0; e < i; e++)this._Ke[n = e >> 2][e % 4] = s[e], this._Kd[t - n][e % 4] = s[e]; for (var o, a = 0, l = i; l < r;) { if (s[0] ^= d[(o = s[i - 1]) >> 16 & 255] << 24 ^ d[o >> 8 & 255] << 16 ^ d[255 & o] << 8 ^ d[o >> 24 & 255] ^ h[a] << 24, a += 1, 8 != i) for (e = 1; e < i; e++)s[e] ^= s[e - 1]; else { for (e = 1; e < i / 2; e++)s[e] ^= s[e - 1]; for (s[i / 2] ^= d[255 & (o = s[i / 2 - 1])] ^ d[o >> 8 & 255] << 8 ^ d[o >> 16 & 255] << 16 ^ d[o >> 24 & 255] << 24, e = i / 2 + 1; e < i; e++)s[e] ^= s[e - 1] } for (e = 0; e < i && l < r;)this._Ke[c = l >> 2][p = l % 4] = s[e], this._Kd[t - c][p] = s[e++], l++ } for (var c = 1; c < t; c++)for (var p = 0; p < 4; p++)this._Kd[c][p] = S[(o = this._Kd[c][p]) >> 24 & 255] ^ x[o >> 16 & 255] ^ T[o >> 8 & 255] ^ E[255 & o] }, A.prototype.encrypt = function (t) { if (16 != t.length) throw new Error("invalid plaintext size (must be 16 bytes)"); for (var e = this._Ke.length - 1, n = [0, 0, 0, 0], r = M(t), i = 0; i < 4; i++)r[i] ^= this._Ke[0][i]; for (var o = 1; o < e; o++) { for (i = 0; i < 4; i++)n[i] = f[r[i] >> 24 & 255] ^ m[r[(i + 1) % 4] >> 16 & 255] ^ g[r[(i + 2) % 4] >> 8 & 255] ^ v[255 & r[(i + 3) % 4]] ^ this._Ke[o][i]; r = n.slice() } var a, l = s(16); for (i = 0; i < 4; i++)l[4 * i] = 255 & (d[r[i] >> 24 & 255] ^ (a = this._Ke[e][i]) >> 24), l[4 * i + 1] = 255 & (d[r[(i + 1) % 4] >> 16 & 255] ^ a >> 16), l[4 * i + 2] = 255 & (d[r[(i + 2) % 4] >> 8 & 255] ^ a >> 8), l[4 * i + 3] = 255 & (d[255 & r[(i + 3) % 4]] ^ a); return l }, A.prototype.decrypt = function (t) { if (16 != t.length) throw new Error("invalid ciphertext size (must be 16 bytes)"); for (var e = this._Kd.length - 1, n = [0, 0, 0, 0], r = M(t), i = 0; i < 4; i++)r[i] ^= this._Kd[0][i]; for (var o = 1; o < e; o++) { for (i = 0; i < 4; i++)n[i] = y[r[i] >> 24 & 255] ^ b[r[(i + 3) % 4] >> 16 & 255] ^ _[r[(i + 2) % 4] >> 8 & 255] ^ w[255 & r[(i + 1) % 4]] ^ this._Kd[o][i]; r = n.slice() } var a, l = s(16); for (i = 0; i < 4; i++)l[4 * i] = 255 & (p[r[i] >> 24 & 255] ^ (a = this._Kd[e][i]) >> 24), l[4 * i + 1] = 255 & (p[r[(i + 3) % 4] >> 16 & 255] ^ a >> 16), l[4 * i + 2] = 255 & (p[r[(i + 2) % 4] >> 8 & 255] ^ a >> 8), l[4 * i + 3] = 255 & (p[255 & r[(i + 1) % 4]] ^ a); return l }; var C = function (t) { if (!(this instanceof C)) throw Error("AES must be instanitated with `new`"); this.description = "Electronic Code Block", this.name = "ecb", this._aes = new A(t) }; C.prototype.encrypt = function (t) { if ((t = i(t)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)"); for (var e = s(t.length), n = s(16), r = 0; r < t.length; r += 16)o(t, n, 0, r, r + 16), o(n = this._aes.encrypt(n), e, r); return e }, C.prototype.decrypt = function (t) { if ((t = i(t)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)"); for (var e = s(t.length), n = s(16), r = 0; r < t.length; r += 16)o(t, n, 0, r, r + 16), o(n = this._aes.decrypt(n), e, r); return e }; var P = function (t, e) { if (!(this instanceof P)) throw Error("AES must be instanitated with `new`"); if (this.description = "Cipher Block Chaining", this.name = "cbc", e) { if (16 != e.length) throw new Error("invalid initialation vector size (must be 16 bytes)") } else e = s(16); this._lastCipherblock = i(e, !0), this._aes = new A(t) }; P.prototype.encrypt = function (t) { if ((t = i(t)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)"); for (var e = s(t.length), n = s(16), r = 0; r < t.length; r += 16) { o(t, n, 0, r, r + 16); for (var a = 0; a < 16; a++)n[a] ^= this._lastCipherblock[a]; this._lastCipherblock = this._aes.encrypt(n), o(this._lastCipherblock, e, r) } return e }, P.prototype.decrypt = function (t) { if ((t = i(t)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)"); for (var e = s(t.length), n = s(16), r = 0; r < t.length; r += 16) { o(t, n, 0, r, r + 16), n = this._aes.decrypt(n); for (var a = 0; a < 16; a++)e[r + a] = n[a] ^ this._lastCipherblock[a]; o(t, this._lastCipherblock, 0, r, r + 16) } return e }; var R = function (t, e, n) { if (!(this instanceof R)) throw Error("AES must be instanitated with `new`"); if (this.description = "Cipher Feedback", this.name = "cfb", e) { if (16 != e.length) throw new Error("invalid initialation vector size (must be 16 size)") } else e = s(16); n || (n = 1), this.segmentSize = n, this._shiftRegister = i(e, !0), this._aes = new A(t) }; R.prototype.encrypt = function (t) { if (t.length % this.segmentSize != 0) throw new Error("invalid plaintext size (must be segmentSize bytes)"); for (var e, n = i(t, !0), r = 0; r < n.length; r += this.segmentSize) { e = this._aes.encrypt(this._shiftRegister); for (var s = 0; s < this.segmentSize; s++)n[r + s] ^= e[s]; o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(n, this._shiftRegister, 16 - this.segmentSize, r, r + this.segmentSize) } return n }, R.prototype.decrypt = function (t) { if (t.length % this.segmentSize != 0) throw new Error("invalid ciphertext size (must be segmentSize bytes)"); for (var e, n = i(t, !0), r = 0; r < n.length; r += this.segmentSize) { e = this._aes.encrypt(this._shiftRegister); for (var s = 0; s < this.segmentSize; s++)n[r + s] ^= e[s]; o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(t, this._shiftRegister, 16 - this.segmentSize, r, r + this.segmentSize) } return n }; var L = function (t, e) { if (!(this instanceof L)) throw Error("AES must be instanitated with `new`"); if (this.description = "Output Feedback", this.name = "ofb", e) { if (16 != e.length) throw new Error("invalid initialation vector size (must be 16 bytes)") } else e = s(16); this._lastPrecipher = i(e, !0), this._lastPrecipherIndex = 16, this._aes = new A(t) }; L.prototype.encrypt = function (t) { for (var e = i(t, !0), n = 0; n < e.length; n++)16 === this._lastPrecipherIndex && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), e[n] ^= this._lastPrecipher[this._lastPrecipherIndex++]; return e }, L.prototype.decrypt = L.prototype.encrypt; var k = function (t) { if (!(this instanceof k)) throw Error("Counter must be instanitated with `new`"); 0 === t || t || (t = 1), "number" == typeof t ? (this._counter = s(16), this.setValue(t)) : this.setBytes(t) }; k.prototype.setValue = function (t) { if ("number" != typeof t || parseInt(t) != t) throw new Error("invalid counter value (must be an integer)"); for (var e = 15; e >= 0; --e)this._counter[e] = t % 256, t >>= 8 }, k.prototype.setBytes = function (t) { if (16 != (t = i(t, !0)).length) throw new Error("invalid counter bytes size (must be 16 bytes)"); this._counter = t }, k.prototype.increment = function () { for (var t = 15; t >= 0; t--) { if (255 !== this._counter[t]) { this._counter[t]++; break } this._counter[t] = 0 } }; var D = function (t, e) { if (!(this instanceof D)) throw Error("AES must be instanitated with `new`"); this.description = "Counter", this.name = "ctr", e instanceof k || (e = new k(e)), this._counter = e, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new A(t) }; D.prototype.encrypt = function (t) { for (var e = i(t, !0), n = 0; n < e.length; n++)16 === this._remainingCounterIndex && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), e[n] ^= this._remainingCounter[this._remainingCounterIndex++]; return e }, D.prototype.decrypt = D.prototype.encrypt, t.exports = { AES: A, Counter: k, ModeOfOperation: { ecb: C, cbc: P, cfb: R, ofb: L, ctr: D }, utils: { hex: c, utf8: l }, padding: { pkcs7: { pad: function (t) { var e = 16 - (t = i(t, !0)).length % 16, n = s(t.length + e); o(t, n); for (var r = t.length; r < n.length; r++)n[r] = e; return n }, strip: function (t) { if ((t = i(t, !0)).length < 16) throw new Error("PKCS#7 invalid length"); var e = t[t.length - 1]; if (e > 16) throw new Error("PKCS#7 padding byte out of range"); for (var n = t.length - e, r = 0; r < e; r++)if (t[n + r] !== e) throw new Error("PKCS#7 invalid padding byte"); var a = s(n); return o(t, a, 0, 0, n), a } } }, _arrayTest: { coerceArray: i, createArray: s, copyArray: o } } }() }, 9901: t => { "use strict"; for (var e = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", n = {}, r = 0; r < e.length; r++) { var i = e.charAt(r); if (void 0 !== n[i]) throw new TypeError(i + " is ambiguous"); n[i] = r } function s(t) { var e = t >> 25; return (33554431 & t) << 5 ^ 996825010 & -(e >> 0 & 1) ^ 642813549 & -(e >> 1 & 1) ^ 513874426 & -(e >> 2 & 1) ^ 1027748829 & -(e >> 3 & 1) ^ 705979059 & -(e >> 4 & 1) } function o(t) { for (var e = 1, n = 0; n < t.length; ++n) { var r = t.charCodeAt(n); if (r < 33 || r > 126) return "Invalid prefix (" + t + ")"; e = s(e) ^ r >> 5 } for (e = s(e), n = 0; n < t.length; ++n) { var i = t.charCodeAt(n); e = s(e) ^ 31 & i } return e } function a(t, e) { if (t.length < 8) return t + " too short"; if (t.length > (e = e || 90)) return "Exceeds length limit"; var r = t.toLowerCase(), i = t.toUpperCase(); if (t !== r && t !== i) return "Mixed-case string " + t; var a = (t = r).lastIndexOf("1"); if (-1 === a) return "No separator character for " + t; if (0 === a) return "Missing prefix for " + t; var l = t.slice(0, a), c = t.slice(a + 1); if (c.length < 6) return "Data too short"; var u = o(l); if ("string" == typeof u) return u; for (var h = [], d = 0; d < c.length; ++d) { var p = c.charAt(d), f = n[p]; if (void 0 === f) return "Unknown character " + p; u = s(u) ^ f, d + 6 >= c.length || h.push(f) } return 1 !== u ? "Invalid checksum for " + t : { prefix: l, words: h } } function l(t, e, n, r) { for (var i = 0, s = 0, o = (1 << n) - 1, a = [], l = 0; l < t.length; ++l)for (i = i << e | t[l], s += e; s >= n;)a.push(i >> (s -= n) & o); if (r) s > 0 && a.push(i << n - s & o); else { if (s >= e) return "Excess padding"; if (i << n - s & o) return "Non-zero padding" } return a } t.exports = { decodeUnsafe: function () { var t = a.apply(null, arguments); if ("object" == typeof t) return t }, decode: function (t) { var e = a.apply(null, arguments); if ("object" == typeof e) return e; throw new Error(e) }, encode: function (t, n, r) { if (t.length + 7 + n.length > (r = r || 90)) throw new TypeError("Exceeds length limit"); var i = o(t = t.toLowerCase()); if ("string" == typeof i) throw new Error(i); for (var a = t + "1", l = 0; l < n.length; ++l) { var c = n[l]; if (c >> 5 != 0) throw new Error("Non 5-bit word"); i = s(i) ^ c, a += e.charAt(c) } for (l = 0; l < 6; ++l)i = s(i); for (i ^= 1, l = 0; l < 6; ++l)a += e.charAt(i >> 5 * (5 - l) & 31); return a }, toWordsUnsafe: function (t) { var e = l(t, 8, 5, !0); if (Array.isArray(e)) return e }, toWords: function (t) { var e = l(t, 8, 5, !0); if (Array.isArray(e)) return e; throw new Error(e) }, fromWordsUnsafe: function (t) { var e = l(t, 5, 8, !1); if (Array.isArray(e)) return e }, fromWords: function (t) { var e = l(t, 5, 8, !1); if (Array.isArray(e)) return e; throw new Error(e) } } }, 3313: t => { var e, n, r; t.exports = (n = String.prototype.split, r = /()??/.exec("")[1] === e, function (t, i, s) { if ("[object RegExp]" !== Object.prototype.toString.call(i)) return n.call(t, i, s); var o, a, l, c, u = [], h = (i.ignoreCase ? "i" : "") + (i.multiline ? "m" : "") + (i.extended ? "x" : "") + (i.sticky ? "y" : ""), d = 0; for (i = new RegExp(i.source, h + "g"), t += "", r || (o = new RegExp("^" + i.source + "$(?!\\s)", h)), s = s === e ? -1 >>> 0 : s >>> 0; (a = i.exec(t)) && !((l = a.index + a[0].length) > d && (u.push(t.slice(d, a.index)), !r && a.length > 1 && a[0].replace(o, function () { for (var t = 1; t < arguments.length - 2; t++)arguments[t] === e && (a[t] = e) }), a.length > 1 && a.index < t.length && Array.prototype.push.apply(u, a.slice(1)), c = a[0].length, d = l, u.length >= s));)i.lastIndex === a.index && i.lastIndex++; return d === t.length ? !c && i.test("") || u.push("") : u.push(t.slice(d)), u.length > s ? u.slice(0, s) : u }) }, 5617: (t, e, n) => { var r = n(7736); function i(t) { return !!t } t.exports = function (t) { var e = t.classList; if (e) return e; var n = { add: s, remove: o, contains: a, toggle: function (t) { return a(t) ? (o(t), !1) : (s(t), !0) }, toString: function () { return t.className }, length: 0, item: function (t) { return l()[t] || null } }; return n; function s(t) { var e = l(); r(e, t) > -1 || (e.push(t), c(e)) } function o(t) { var e = l(), n = r(e, t); -1 !== n && (e.splice(n, 1), c(e)) } function a(t) { return r(l(), t) > -1 } function l() { return function (t, e) { for (var n = [], r = 0; r < t.length; r++)e(t[r]) && n.push(t[r]); return n }(t.className.split(" "), i) } function c(e) { var r = e.length; t.className = e.join(" "), n.length = r; for (var i = 0; i < e.length; i++)n[i] = e[i]; delete e[r] } } }, 6585: (t, e, n) => { "use strict"; var r = n(6019), i = Object.prototype.hasOwnProperty, s = Object.prototype.propertyIsEnumerable; function o(t) { if (null == t) throw new TypeError("Sources cannot be null or undefined"); return Object(t) } function a(t, e, n) { var s = e[n]; if (null != s) { if (i.call(t, n) && null == t[n]) throw new TypeError("Cannot convert undefined or null to object (" + n + ")"); t[n] = i.call(t, n) && r(s) ? l(Object(t[n]), e[n]) : s } } function l(t, e) { if (t === e) return t; for (var n in e = Object(e)) i.call(e, n) && a(t, e, n); if (Object.getOwnPropertySymbols) for (var r = Object.getOwnPropertySymbols(e), o = 0; o < r.length; o++)s.call(e, r[o]) && a(t, e, r[o]); return t } t.exports = function (t) { t = o(t); for (var e = 1; e < arguments.length; e++)l(t, arguments[e]); return t } }, 6019: t => { "use strict"; t.exports = function (t) { var e = typeof t; return null !== t && ("object" === e || "function" === e) } }, 420: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.version = void 0, e.version = "ethers/5.1.3" }, 7682: function (t, e, n) { "use strict"; var r = this && this.__createBinding || (Object.create ? function (t, e, n, r) { void 0 === r && (r = n), Object.defineProperty(t, r, { enumerable: !0, get: function () { return e[n] } }) } : function (t, e, n, r) { void 0 === r && (r = n), t[r] = e[n] }), i = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var n in t) "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && r(e, t, n); return i(e, t), e }; Object.defineProperty(e, "__esModule", { value: !0 }), e.Wordlist = e.version = e.wordlists = e.utils = e.logger = e.errors = e.constants = e.FixedNumber = e.BigNumber = e.ContractFactory = e.Contract = e.BaseContract = e.providers = e.getDefaultProvider = e.VoidSigner = e.Wallet = e.Signer = void 0; var o = n(6776); Object.defineProperty(e, "BaseContract", { enumerable: !0, get: function () { return o.BaseContract } }), Object.defineProperty(e, "Contract", { enumerable: !0, get: function () { return o.Contract } }), Object.defineProperty(e, "ContractFactory", { enumerable: !0, get: function () { return o.ContractFactory } }); var a = n(4078); Object.defineProperty(e, "BigNumber", { enumerable: !0, get: function () { return a.BigNumber } }), Object.defineProperty(e, "FixedNumber", { enumerable: !0, get: function () { return a.FixedNumber } }); var l = n(1221); Object.defineProperty(e, "Signer", { enumerable: !0, get: function () { return l.Signer } }), Object.defineProperty(e, "VoidSigner", { enumerable: !0, get: function () { return l.VoidSigner } }); var c = n(6846); Object.defineProperty(e, "Wallet", { enumerable: !0, get: function () { return c.Wallet } }); var u = s(n(1843)); e.constants = u; var h = s(n(3456)); e.providers = h; var d = n(3456); Object.defineProperty(e, "getDefaultProvider", { enumerable: !0, get: function () { return d.getDefaultProvider } }); var p = n(4501); Object.defineProperty(e, "Wordlist", { enumerable: !0, get: function () { return p.Wordlist } }), Object.defineProperty(e, "wordlists", { enumerable: !0, get: function () { return p.wordlists } }); var f = s(n(2673)); e.utils = f; var m = n(3898); Object.defineProperty(e, "errors", { enumerable: !0, get: function () { return m.ErrorCode } }); var g = n(420); Object.defineProperty(e, "version", { enumerable: !0, get: function () { return g.version } }); var v = new m.Logger(g.version); e.logger = v }, 2673: function (t, e, n) { "use strict"; var r = this && this.__createBinding || (Object.create ? function (t, e, n, r) { void 0 === r && (r = n), Object.defineProperty(t, r, { enumerable: !0, get: function () { return e[n] } }) } : function (t, e, n, r) { void 0 === r && (r = n), t[r] = e[n] }), i = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var n in t) "default" !== n && Object.prototype.hasOwnProperty.call(t, n) && r(e, t, n); return i(e, t), e }; Object.defineProperty(e, "__esModule", { value: !0 }), e.hashMessage = e.parseBytes32String = e.formatBytes32String = e.Utf8ErrorFuncs = e.toUtf8String = e.toUtf8CodePoints = e.toUtf8Bytes = e._toEscapedUtf8String = e.nameprep = e.hexDataSlice = e.hexDataLength = e.hexZeroPad = e.hexValue = e.hexStripZeros = e.hexConcat = e.isHexString = e.hexlify = e.base64 = e.base58 = e.TransactionDescription = e.LogDescription = e.Interface = e.SigningKey = e.HDNode = e.defaultPath = e.isBytesLike = e.isBytes = e.zeroPad = e.stripZeros = e.concat = e.arrayify = e.shallowCopy = e.resolveProperties = e.getStatic = e.defineReadOnly = e.deepCopy = e.checkProperties = e.poll = e.fetchJson = e._fetchData = e.RLP = e.Logger = e.checkResultErrors = e.FormatTypes = e.ParamType = e.FunctionFragment = e.EventFragment = e.Fragment = e.defaultAbiCoder = e.AbiCoder = void 0, e.Indexed = e.Utf8ErrorReason = e.UnicodeNormalizationForm = e.SupportedAlgorithm = e.mnemonicToSeed = e.isValidMnemonic = e.entropyToMnemonic = e.mnemonicToEntropy = e.verifyTypedData = e.verifyMessage = e.recoverPublicKey = e.computePublicKey = e.recoverAddress = e.computeAddress = e.getJsonWalletAddress = e.serializeTransaction = e.parseTransaction = e.accessListify = e.joinSignature = e.splitSignature = e.soliditySha256 = e.solidityKeccak256 = e.solidityPack = e.shuffled = e.randomBytes = e.sha512 = e.sha256 = e.ripemd160 = e.keccak256 = e.computeHmac = e.commify = e.parseUnits = e.formatUnits = e.parseEther = e.formatEther = e.isAddress = e.getCreate2Address = e.getContractAddress = e.getIcapAddress = e.getAddress = e._TypedDataEncoder = e.id = e.isValidName = e.namehash = void 0; var o = n(7910); Object.defineProperty(e, "AbiCoder", { enumerable: !0, get: function () { return o.AbiCoder } }), Object.defineProperty(e, "checkResultErrors", { enumerable: !0, get: function () { return o.checkResultErrors } }), Object.defineProperty(e, "defaultAbiCoder", { enumerable: !0, get: function () { return o.defaultAbiCoder } }), Object.defineProperty(e, "EventFragment", { enumerable: !0, get: function () { return o.EventFragment } }), Object.defineProperty(e, "FormatTypes", { enumerable: !0, get: function () { return o.FormatTypes } }), Object.defineProperty(e, "Fragment", { enumerable: !0, get: function () { return o.Fragment } }), Object.defineProperty(e, "FunctionFragment", { enumerable: !0, get: function () { return o.FunctionFragment } }), Object.defineProperty(e, "Indexed", { enumerable: !0, get: function () { return o.Indexed } }), Object.defineProperty(e, "Interface", { enumerable: !0, get: function () { return o.Interface } }), Object.defineProperty(e, "LogDescription", { enumerable: !0, get: function () { return o.LogDescription } }), Object.defineProperty(e, "ParamType", { enumerable: !0, get: function () { return o.ParamType } }), Object.defineProperty(e, "TransactionDescription", { enumerable: !0, get: function () { return o.TransactionDescription } }); var a = n(2885); Object.defineProperty(e, "getAddress", { enumerable: !0, get: function () { return a.getAddress } }), Object.defineProperty(e, "getCreate2Address", { enumerable: !0, get: function () { return a.getCreate2Address } }), Object.defineProperty(e, "getContractAddress", { enumerable: !0, get: function () { return a.getContractAddress } }), Object.defineProperty(e, "getIcapAddress", { enumerable: !0, get: function () { return a.getIcapAddress } }), Object.defineProperty(e, "isAddress", { enumerable: !0, get: function () { return a.isAddress } }); var l = s(n(2220)); e.base64 = l; var c = n(3744); Object.defineProperty(e, "base58", { enumerable: !0, get: function () { return c.Base58 } }); var u = n(1488); Object.defineProperty(e, "arrayify", { enumerable: !0, get: function () { return u.arrayify } }), Object.defineProperty(e, "concat", { enumerable: !0, get: function () { return u.concat } }), Object.defineProperty(e, "hexConcat", { enumerable: !0, get: function () { return u.hexConcat } }), Object.defineProperty(e, "hexDataSlice", { enumerable: !0, get: function () { return u.hexDataSlice } }), Object.defineProperty(e, "hexDataLength", { enumerable: !0, get: function () { return u.hexDataLength } }), Object.defineProperty(e, "hexlify", { enumerable: !0, get: function () { return u.hexlify } }), Object.defineProperty(e, "hexStripZeros", { enumerable: !0, get: function () { return u.hexStripZeros } }), Object.defineProperty(e, "hexValue", { enumerable: !0, get: function () { return u.hexValue } }), Object.defineProperty(e, "hexZeroPad", { enumerable: !0, get: function () { return u.hexZeroPad } }), Object.defineProperty(e, "isBytes", { enumerable: !0, get: function () { return u.isBytes } }), Object.defineProperty(e, "isBytesLike", { enumerable: !0, get: function () { return u.isBytesLike } }), Object.defineProperty(e, "isHexString", { enumerable: !0, get: function () { return u.isHexString } }), Object.defineProperty(e, "joinSignature", { enumerable: !0, get: function () { return u.joinSignature } }), Object.defineProperty(e, "zeroPad", { enumerable: !0, get: function () { return u.zeroPad } }), Object.defineProperty(e, "splitSignature", { enumerable: !0, get: function () { return u.splitSignature } }), Object.defineProperty(e, "stripZeros", { enumerable: !0, get: function () { return u.stripZeros } }); var h = n(778); Object.defineProperty(e, "_TypedDataEncoder", { enumerable: !0, get: function () { return h._TypedDataEncoder } }), Object.defineProperty(e, "hashMessage", { enumerable: !0, get: function () { return h.hashMessage } }), Object.defineProperty(e, "id", { enumerable: !0, get: function () { return h.id } }), Object.defineProperty(e, "isValidName", { enumerable: !0, get: function () { return h.isValidName } }), Object.defineProperty(e, "namehash", { enumerable: !0, get: function () { return h.namehash } }); var d = n(9593); Object.defineProperty(e, "defaultPath", { enumerable: !0, get: function () { return d.defaultPath } }), Object.defineProperty(e, "entropyToMnemonic", { enumerable: !0, get: function () { return d.entropyToMnemonic } }), Object.defineProperty(e, "HDNode", { enumerable: !0, get: function () { return d.HDNode } }), Object.defineProperty(e, "isValidMnemonic", { enumerable: !0, get: function () { return d.isValidMnemonic } }), Object.defineProperty(e, "mnemonicToEntropy", { enumerable: !0, get: function () { return d.mnemonicToEntropy } }), Object.defineProperty(e, "mnemonicToSeed", { enumerable: !0, get: function () { return d.mnemonicToSeed } }); var p = n(9799); Object.defineProperty(e, "getJsonWalletAddress", { enumerable: !0, get: function () { return p.getJsonWalletAddress } }); var f = n(8518); Object.defineProperty(e, "keccak256", { enumerable: !0, get: function () { return f.keccak256 } }); var m = n(3898); Object.defineProperty(e, "Logger", { enumerable: !0, get: function () { return m.Logger } }); var g = n(7591); Object.defineProperty(e, "computeHmac", { enumerable: !0, get: function () { return g.computeHmac } }), Object.defineProperty(e, "ripemd160", { enumerable: !0, get: function () { return g.ripemd160 } }), Object.defineProperty(e, "sha256", { enumerable: !0, get: function () { return g.sha256 } }), Object.defineProperty(e, "sha512", { enumerable: !0, get: function () { return g.sha512 } }); var v = n(1985); Object.defineProperty(e, "solidityKeccak256", { enumerable: !0, get: function () { return v.keccak256 } }), Object.defineProperty(e, "solidityPack", { enumerable: !0, get: function () { return v.pack } }), Object.defineProperty(e, "soliditySha256", { enumerable: !0, get: function () { return v.sha256 } }); var y = n(8859); Object.defineProperty(e, "randomBytes", { enumerable: !0, get: function () { return y.randomBytes } }), Object.defineProperty(e, "shuffled", { enumerable: !0, get: function () { return y.shuffled } }); var b = n(2275); Object.defineProperty(e, "checkProperties", { enumerable: !0, get: function () { return b.checkProperties } }), Object.defineProperty(e, "deepCopy", { enumerable: !0, get: function () { return b.deepCopy } }), Object.defineProperty(e, "defineReadOnly", { enumerable: !0, get: function () { return b.defineReadOnly } }), Object.defineProperty(e, "getStatic", { enumerable: !0, get: function () { return b.getStatic } }), Object.defineProperty(e, "resolveProperties", { enumerable: !0, get: function () { return b.resolveProperties } }), Object.defineProperty(e, "shallowCopy", { enumerable: !0, get: function () { return b.shallowCopy } }); var _ = s(n(9276)); e.RLP = _; var w = n(9596); Object.defineProperty(e, "computePublicKey", { enumerable: !0, get: function () { return w.computePublicKey } }), Object.defineProperty(e, "recoverPublicKey", { enumerable: !0, get: function () { return w.recoverPublicKey } }), Object.defineProperty(e, "SigningKey", { enumerable: !0, get: function () { return w.SigningKey } }); var S = n(2838); Object.defineProperty(e, "formatBytes32String", { enumerable: !0, get: function () { return S.formatBytes32String } }), Object.defineProperty(e, "nameprep", { enumerable: !0, get: function () { return S.nameprep } }), Object.defineProperty(e, "parseBytes32String", { enumerable: !0, get: function () { return S.parseBytes32String } }), Object.defineProperty(e, "_toEscapedUtf8String", { enumerable: !0, get: function () { return S._toEscapedUtf8String } }), Object.defineProperty(e, "toUtf8Bytes", { enumerable: !0, get: function () { return S.toUtf8Bytes } }), Object.defineProperty(e, "toUtf8CodePoints", { enumerable: !0, get: function () { return S.toUtf8CodePoints } }), Object.defineProperty(e, "toUtf8String", { enumerable: !0, get: function () { return S.toUtf8String } }), Object.defineProperty(e, "Utf8ErrorFuncs", { enumerable: !0, get: function () { return S.Utf8ErrorFuncs } }); var x = n(2701); Object.defineProperty(e, "accessListify", { enumerable: !0, get: function () { return x.accessListify } }), Object.defineProperty(e, "computeAddress", { enumerable: !0, get: function () { return x.computeAddress } }), Object.defineProperty(e, "parseTransaction", { enumerable: !0, get: function () { return x.parse } }), Object.defineProperty(e, "recoverAddress", { enumerable: !0, get: function () { return x.recoverAddress } }), Object.defineProperty(e, "serializeTransaction", { enumerable: !0, get: function () { return x.serialize } }); var T = n(2519); Object.defineProperty(e, "commify", { enumerable: !0, get: function () { return T.commify } }), Object.defineProperty(e, "formatEther", { enumerable: !0, get: function () { return T.formatEther } }), Object.defineProperty(e, "parseEther", { enumerable: !0, get: function () { return T.parseEther } }), Object.defineProperty(e, "formatUnits", { enumerable: !0, get: function () { return T.formatUnits } }), Object.defineProperty(e, "parseUnits", { enumerable: !0, get: function () { return T.parseUnits } }); var E = n(6846); Object.defineProperty(e, "verifyMessage", { enumerable: !0, get: function () { return E.verifyMessage } }), Object.defineProperty(e, "verifyTypedData", { enumerable: !0, get: function () { return E.verifyTypedData } }); var M = n(3511); Object.defineProperty(e, "_fetchData", { enumerable: !0, get: function () { return M._fetchData } }), Object.defineProperty(e, "fetchJson", { enumerable: !0, get: function () { return M.fetchJson } }), Object.defineProperty(e, "poll", { enumerable: !0, get: function () { return M.poll } }); var A = n(7591); Object.defineProperty(e, "SupportedAlgorithm", { enumerable: !0, get: function () { return A.SupportedAlgorithm } }); var C = n(2838); Object.defineProperty(e, "UnicodeNormalizationForm", { enumerable: !0, get: function () { return C.UnicodeNormalizationForm } }), Object.defineProperty(e, "Utf8ErrorReason", { enumerable: !0, get: function () { return C.Utf8ErrorReason } }) }, 9609: (t, e, n) => { t.exports = n(4410) }, 4410: (t, e, n) => { "use strict"; var r = n(8180), i = n(7546), s = n(1850), o = n(8184), a = n(7422), l = ["request", "response", "progress", "error", "abort"], c = ["processOptions", "validateOptions", "interceptRequest", "finalizeOptions", "onRequest", "onResponse", "onError", "onReturn", "onHeaders"]; t.exports = function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n = [], u = c.reduce(function (t, e) { return t[e] = t[e] || [], t }, { processOptions: [s], validateOptions: [o] }); function h(t) { var e = l.reduce(function (t, e) { return t[e] = r(), t }, {}), n = i(u), s = n("processOptions", t); n("validateOptions", s); var o = { options: s, channels: e, applyMiddleware: n }, c = null, h = e.request.subscribe(function (t) { c = a(t, function (r, i) { return function (t, i, s) { var o = t, a = i; if (!o) try { a = n("onResponse", i, s) } catch (r) { a = null, o = r } (o = o && n("onError", o, s)) ? e.error.publish(o) : a && e.response.publish(a) }(r, i, t) }) }); e.abort.subscribe(function () { h(), c && c.abort() }); var d = n("onReturn", e, o); return d === e && e.request.publish(o), d } return h.use = function (t) { if (!t) throw new Error("Tried to add middleware that resolved to falsey value"); if ("function" == typeof t) throw new Error("Tried to add middleware that was a function. It probably expects you to pass options to it."); if (t.onReturn && u.onReturn.length > 0) throw new Error("Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event"); return c.forEach(function (e) { t[e] && u[e].push(t[e]) }), n.push(t), h }, h.clone = function () { return t(n) }, e.forEach(h.use), h } }, 1850: (t, e, n) => { "use strict"; var r = n(8228), i = n(2135), s = "undefined" != typeof navigator && "ReactNative" === navigator.product, o = Object.prototype.hasOwnProperty, a = { timeout: s ? 6e4 : 12e4 }; function l(t) { var e = []; for (var n in t) o.call(t, n) && r(n, t[n]); return e.length ? e.join("&") : ""; function r(t, n) { Array.isArray(n) ? n.forEach(function (e) { return r(t, e) }) : e.push([t, n].map(encodeURIComponent).join("=")) } } function c(t) { if (!1 === t || 0 === t) return !1; if (t.connect || t.socket) return t; var e = Number(t); return isNaN(e) ? c(a.timeout) : { connect: e, socket: e } } t.exports = function (t) { var e = "string" == typeof t ? r({ url: t }, a) : r({}, a, t), n = i(e.url, {}, !0); return e.timeout = c(e.timeout), e.query && (n.query = r({}, n.query, function (t) { var e = {}; for (var n in t) void 0 !== t[n] && (e[n] = t[n]); return e }(e.query))), e.method = e.body && !e.method ? "POST" : (e.method || "GET").toUpperCase(), e.url = n.toString(l), e } }, 8184: t => { "use strict"; var e = /^https?:\/\//i; t.exports = function (t) { if (!e.test(t.url)) throw new Error('"' + t.url + '" is not a valid URL') } }, 9442: (t, e, n) => { "use strict"; var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, i = n(8228), s = n(1299), o = ["boolean", "string", "number"]; t.exports = function () { return { processOptions: function (t) { var e, n = t.body; return !n || "function" == typeof n.pipe || (e = n).constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e) || -1 === o.indexOf(void 0 === n ? "undefined" : r(n)) && !Array.isArray(n) && !s(n) ? t : i({}, t, { body: JSON.stringify(t.body), headers: i({}, t.headers, { "Content-Type": "application/json" }) }) } } } }, 1024: (t, e, n) => { "use strict"; var r = n(8228); function i(t) { try { return JSON.parse(t) } catch (e) { throw e.message = "Failed to parsed response body as JSON: " + e.message, e } } t.exports = function (t) { return { onResponse: function (e) { var n = e.headers["content-type"] || "", s = t && t.force || -1 !== n.indexOf("application/json"); return e.body && n && s ? r({}, e, { body: i(e.body) }) : e }, processOptions: function (t) { return r({}, t, { headers: r({ Accept: "application/json" }, t.headers) }) } } } }, 6791: (t, e, n) => { "use strict"; var r = n(6269), i = n(8228); t.exports = function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = t.implementation || r.Observable; if (!e) throw new Error("`Observable` is not available in global scope, and no implementation was passed"); return { onReturn: function (t, n) { return new e(function (e) { return t.error.subscribe(function (t) { return e.error(t) }), t.progress.subscribe(function (t) { return e.next(i({ type: "progress" }, t)) }), t.response.subscribe(function (t) { e.next(i({ type: "response" }, t)), e.complete() }), t.request.publish(n), function () { return t.abort.publish() } }) } } } }, 8454: t => { "use strict"; t.exports = function () { return { onRequest: function (t) { if ("xhr" === t.adapter) { var e = t.request, n = t.context; "upload" in e && "onprogress" in e.upload && (e.upload.onprogress = r("upload")), "onprogress" in e && (e.onprogress = r("download")) } function r(t) { return function (e) { n.channels.progress.publish({ stage: t, percent: e.lengthComputable ? e.loaded / e.total * 100 : -1, total: e.total, loaded: e.loaded, lengthComputable: e.lengthComputable }) } } } } } }, 9753: (t, e, n) => { "use strict"; t.exports = n(8454) }, 4262: (t, e, n) => { "use strict"; var r = n(7385), i = n(7999), s = window, o = s.XMLHttpRequest || function () { }, a = "withCredentials" in new o ? o : s.XDomainRequest; t.exports = function (t, e) { var n = t.applyMiddleware("finalizeOptions", t.options), l = {}, c = s && s.location && !r(s.location.href, n.url), u = t.applyMiddleware("interceptRequest", void 0, { adapter: "xhr", context: t }); if (u) { var h = setTimeout(e, 0, null, u); return { abort: function () { return clearTimeout(h) } } } var d = c ? new a : new o, p = s.XDomainRequest && d instanceof s.XDomainRequest, f = n.headers, m = !1, g = !1, v = !1; if (d.onerror = S, d.ontimeout = S, d.onabort = function () { m = !0 }, d.onprogress = function () { }, d[p ? "onload" : "onreadystatechange"] = function () { b && (w(), l.socket = setTimeout(function () { return _("ESOCKETTIMEDOUT") }, b.socket)), m || 4 !== d.readyState && !p || 0 !== d.status && (m || g || v || (0 !== d.status ? (w(), g = !0, e(null, function () { var t = d.status, e = d.statusText; if (p && void 0 === t) t = 200; else { if (t > 12e3 && t < 12156) return S(); t = 1223 === d.status ? 204 : d.status, e = 1223 === d.status ? "No Content" : e } return { body: d.response || d.responseText, url: n.url, method: n.method, headers: p ? {} : i(d.getAllResponseHeaders()), statusCode: t, statusMessage: e } }())) : S(new Error("Unknown XHR error")))) }, d.open(n.method, n.url, !0), d.withCredentials = !!n.withCredentials, f && d.setRequestHeader) for (var y in f) f.hasOwnProperty(y) && d.setRequestHeader(y, f[y]); else if (f && p) throw new Error("Headers cannot be set on an XDomainRequest object"); n.rawBody && (d.responseType = "arraybuffer"), t.applyMiddleware("onRequest", { options: n, adapter: "xhr", request: d, context: t }), d.send(n.body || null); var b = n.timeout; return b && (l.connect = setTimeout(function () { return _("ETIMEDOUT") }, b.connect)), { abort: function () { m = !0, d && d.abort() } }; function _(e) { v = !0, d.abort(); var r = new Error("ESOCKETTIMEDOUT" === e ? "Socket timed out on request to " + n.url : "Connection timed out on request to " + n.url); r.code = e, t.channels.error.publish(r) } function w() { (m || d.readyState >= 2 && l.connect) && clearTimeout(l.connect), l.socket && clearTimeout(l.socket) } function S() { if (!g) { w(), g = !0, d = null; var t = new Error("Network error while attempting to reach " + n.url); t.isNetworkError = !0, t.request = n, e(t) } } } }, 7422: (t, e, n) => { "use strict"; t.exports = n(4262) }, 6269: t => { "use strict"; t.exports = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {} }, 7546: t => { "use strict"; t.exports = function (t) { return function (e, n) { for (var r = arguments.length, i = Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++)i[s - 2] = arguments[s]; for (var o = "onError" === e, a = n, l = 0; l < t[e].length; l++) { var c = t[e][l]; if (a = c.apply(void 0, [a].concat(i)), o && !a) break } return a } } }, 7909: (t, e, n) => { var r = e; r.utils = n(8291), r.common = n(1393), r.sha = n(2221), r.ripemd = n(1960), r.hmac = n(1905), r.sha1 = r.sha.sha1, r.sha256 = r.sha.sha256, r.sha224 = r.sha.sha224, r.sha384 = r.sha.sha384, r.sha512 = r.sha.sha512, r.ripemd160 = r.ripemd.ripemd160 }, 1393: (t, e, n) => { "use strict"; var r = n(8291), i = n(6055); function s() { this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32 } e.BlockHash = s, s.prototype.update = function (t, e) { if (t = r.toArray(t, e), this.pending = this.pending ? this.pending.concat(t) : t, this.pendingTotal += t.length, this.pending.length >= this._delta8) { var n = (t = this.pending).length % this._delta8; this.pending = t.slice(t.length - n, t.length), 0 === this.pending.length && (this.pending = null), t = r.join32(t, 0, t.length - n, this.endian); for (var i = 0; i < t.length; i += this._delta32)this._update(t, i, i + this._delta32) } return this }, s.prototype.digest = function (t) { return this.update(this._pad()), i(null === this.pending), this._digest(t) }, s.prototype._pad = function () { var t = this.pendingTotal, e = this._delta8, n = e - (t + this.padLength) % e, r = new Array(n + this.padLength); r[0] = 128; for (var i = 1; i < n; i++)r[i] = 0; if (t <<= 3, "big" === this.endian) { for (var s = 8; s < this.padLength; s++)r[i++] = 0; r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = t >>> 24 & 255, r[i++] = t >>> 16 & 255, r[i++] = t >>> 8 & 255, r[i++] = 255 & t } else for (r[i++] = 255 & t, r[i++] = t >>> 8 & 255, r[i++] = t >>> 16 & 255, r[i++] = t >>> 24 & 255, r[i++] = 0, r[i++] = 0, r[i++] = 0, r[i++] = 0, s = 8; s < this.padLength; s++)r[i++] = 0; return r } }, 1905: (t, e, n) => { "use strict"; var r = n(8291), i = n(6055); function s(t, e, n) { if (!(this instanceof s)) return new s(t, e, n); this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(r.toArray(e, n)) } t.exports = s, s.prototype._init = function (t) { t.length > this.blockSize && (t = (new this.Hash).update(t).digest()), i(t.length <= this.blockSize); for (var e = t.length; e < this.blockSize; e++)t.push(0); for (e = 0; e < t.length; e++)t[e] ^= 54; for (this.inner = (new this.Hash).update(t), e = 0; e < t.length; e++)t[e] ^= 106; this.outer = (new this.Hash).update(t) }, s.prototype.update = function (t, e) { return this.inner.update(t, e), this }, s.prototype.digest = function (t) { return this.outer.update(this.inner.digest()), this.outer.digest(t) } }, 1960: (t, e, n) => { "use strict"; var r = n(8291), i = n(1393), s = r.rotl32, o = r.sum32, a = r.sum32_3, l = r.sum32_4, c = i.BlockHash; function u() { if (!(this instanceof u)) return new u; c.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little" } function h(t, e, n, r) { return t <= 15 ? e ^ n ^ r : t <= 31 ? e & n | ~e & r : t <= 47 ? (e | ~n) ^ r : t <= 63 ? e & r | n & ~r : e ^ (n | ~r) } function d(t) { return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838 } function p(t) { return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0 } r.inherits(u, c), e.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function (t, e) { for (var n = this.h[0], r = this.h[1], i = this.h[2], c = this.h[3], u = this.h[4], y = n, b = r, _ = i, w = c, S = u, x = 0; x < 80; x++) { var T = o(s(l(n, h(x, r, i, c), t[f[x] + e], d(x)), g[x]), u); n = u, u = c, c = s(i, 10), i = r, r = T, T = o(s(l(y, h(79 - x, b, _, w), t[m[x] + e], p(x)), v[x]), S), y = S, S = w, w = s(_, 10), _ = b, b = T } T = a(this.h[1], i, w), this.h[1] = a(this.h[2], c, S), this.h[2] = a(this.h[3], u, y), this.h[3] = a(this.h[4], n, b), this.h[4] = a(this.h[0], r, _), this.h[0] = T }, u.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h, "little") : r.split32(this.h, "little") }; var f = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], m = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], g = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], v = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11] }, 2221: (t, e, n) => { "use strict"; e.sha1 = n(3605), e.sha224 = n(9643), e.sha256 = n(6021), e.sha384 = n(3513), e.sha512 = n(4958) }, 3605: (t, e, n) => { "use strict"; var r = n(8291), i = n(1393), s = n(8491), o = r.rotl32, a = r.sum32, l = r.sum32_5, c = s.ft_1, u = i.BlockHash, h = [1518500249, 1859775393, 2400959708, 3395469782]; function d() { if (!(this instanceof d)) return new d; u.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80) } r.inherits(d, u), t.exports = d, d.blockSize = 512, d.outSize = 160, d.hmacStrength = 80, d.padLength = 64, d.prototype._update = function (t, e) { for (var n = this.W, r = 0; r < 16; r++)n[r] = t[e + r]; for (; r < n.length; r++)n[r] = o(n[r - 3] ^ n[r - 8] ^ n[r - 14] ^ n[r - 16], 1); var i = this.h[0], s = this.h[1], u = this.h[2], d = this.h[3], p = this.h[4]; for (r = 0; r < n.length; r++) { var f = ~~(r / 20), m = l(o(i, 5), c(f, s, u, d), p, n[r], h[f]); p = d, d = u, u = o(s, 30), s = i, i = m } this.h[0] = a(this.h[0], i), this.h[1] = a(this.h[1], s), this.h[2] = a(this.h[2], u), this.h[3] = a(this.h[3], d), this.h[4] = a(this.h[4], p) }, d.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h, "big") : r.split32(this.h, "big") } }, 9643: (t, e, n) => { "use strict"; var r = n(8291), i = n(6021); function s() { if (!(this instanceof s)) return new s; i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428] } r.inherits(s, i), t.exports = s, s.blockSize = 512, s.outSize = 224, s.hmacStrength = 192, s.padLength = 64, s.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h.slice(0, 7), "big") : r.split32(this.h.slice(0, 7), "big") } }, 6021: (t, e, n) => { "use strict"; var r = n(8291), i = n(1393), s = n(8491), o = n(6055), a = r.sum32, l = r.sum32_4, c = r.sum32_5, u = s.ch32, h = s.maj32, d = s.s0_256, p = s.s1_256, f = s.g0_256, m = s.g1_256, g = i.BlockHash, v = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]; function y() { if (!(this instanceof y)) return new y; g.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = v, this.W = new Array(64) } r.inherits(y, g), t.exports = y, y.blockSize = 512, y.outSize = 256, y.hmacStrength = 192, y.padLength = 64, y.prototype._update = function (t, e) { for (var n = this.W, r = 0; r < 16; r++)n[r] = t[e + r]; for (; r < n.length; r++)n[r] = l(m(n[r - 2]), n[r - 7], f(n[r - 15]), n[r - 16]); var i = this.h[0], s = this.h[1], g = this.h[2], v = this.h[3], y = this.h[4], b = this.h[5], _ = this.h[6], w = this.h[7]; for (o(this.k.length === n.length), r = 0; r < n.length; r++) { var S = c(w, p(y), u(y, b, _), this.k[r], n[r]), x = a(d(i), h(i, s, g)); w = _, _ = b, b = y, y = a(v, S), v = g, g = s, s = i, i = a(S, x) } this.h[0] = a(this.h[0], i), this.h[1] = a(this.h[1], s), this.h[2] = a(this.h[2], g), this.h[3] = a(this.h[3], v), this.h[4] = a(this.h[4], y), this.h[5] = a(this.h[5], b), this.h[6] = a(this.h[6], _), this.h[7] = a(this.h[7], w) }, y.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h, "big") : r.split32(this.h, "big") } }, 3513: (t, e, n) => { "use strict"; var r = n(8291), i = n(4958); function s() { if (!(this instanceof s)) return new s; i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428] } r.inherits(s, i), t.exports = s, s.blockSize = 1024, s.outSize = 384, s.hmacStrength = 192, s.padLength = 128, s.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h.slice(0, 12), "big") : r.split32(this.h.slice(0, 12), "big") } }, 4958: (t, e, n) => { "use strict"; var r = n(8291), i = n(1393), s = n(6055), o = r.rotr64_hi, a = r.rotr64_lo, l = r.shr64_hi, c = r.shr64_lo, u = r.sum64, h = r.sum64_hi, d = r.sum64_lo, p = r.sum64_4_hi, f = r.sum64_4_lo, m = r.sum64_5_hi, g = r.sum64_5_lo, v = i.BlockHash, y = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]; function b() { if (!(this instanceof b)) return new b; v.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = y, this.W = new Array(160) } function _(t, e, n, r, i) { var s = t & n ^ ~t & i; return s < 0 && (s += 4294967296), s } function w(t, e, n, r, i, s) { var o = e & r ^ ~e & s; return o < 0 && (o += 4294967296), o } function S(t, e, n, r, i) { var s = t & n ^ t & i ^ n & i; return s < 0 && (s += 4294967296), s } function x(t, e, n, r, i, s) { var o = e & r ^ e & s ^ r & s; return o < 0 && (o += 4294967296), o } function T(t, e) { var n = o(t, e, 28) ^ o(e, t, 2) ^ o(e, t, 7); return n < 0 && (n += 4294967296), n } function E(t, e) { var n = a(t, e, 28) ^ a(e, t, 2) ^ a(e, t, 7); return n < 0 && (n += 4294967296), n } function M(t, e) { var n = a(t, e, 14) ^ a(t, e, 18) ^ a(e, t, 9); return n < 0 && (n += 4294967296), n } function A(t, e) { var n = o(t, e, 1) ^ o(t, e, 8) ^ l(t, e, 7); return n < 0 && (n += 4294967296), n } function C(t, e) { var n = a(t, e, 1) ^ a(t, e, 8) ^ c(t, e, 7); return n < 0 && (n += 4294967296), n } function P(t, e) { var n = a(t, e, 19) ^ a(e, t, 29) ^ c(t, e, 6); return n < 0 && (n += 4294967296), n } r.inherits(b, v), t.exports = b, b.blockSize = 1024, b.outSize = 512, b.hmacStrength = 192, b.padLength = 128, b.prototype._prepareBlock = function (t, e) { for (var n = this.W, r = 0; r < 32; r++)n[r] = t[e + r]; for (; r < n.length; r += 2) { var i = (y = void 0, (y = o(g = n[r - 4], v = n[r - 3], 19) ^ o(v, g, 29) ^ l(g, v, 6)) < 0 && (y += 4294967296), y), s = P(n[r - 4], n[r - 3]), a = n[r - 14], c = n[r - 13], u = A(n[r - 30], n[r - 29]), h = C(n[r - 30], n[r - 29]), d = n[r - 32], m = n[r - 31]; n[r] = p(i, s, a, c, u, h, d, m), n[r + 1] = f(i, s, a, c, u, h, d, m) } var g, v, y }, b.prototype._update = function (t, e) { this._prepareBlock(t, e); var n, r, i, a = this.W, l = this.h[0], c = this.h[1], p = this.h[2], f = this.h[3], v = this.h[4], y = this.h[5], b = this.h[6], A = this.h[7], C = this.h[8], P = this.h[9], R = this.h[10], L = this.h[11], k = this.h[12], D = this.h[13], I = this.h[14], O = this.h[15]; s(this.k.length === a.length); for (var F = 0; F < a.length; F += 2) { var N = I, B = O, H = (i = void 0, (i = o(n = C, r = P, 14) ^ o(n, r, 18) ^ o(r, n, 9)) < 0 && (i += 4294967296), i), U = M(C, P), G = _(C, 0, R, 0, k), V = w(0, P, 0, L, 0, D), z = this.k[F], j = this.k[F + 1], J = a[F], X = a[F + 1], W = m(N, B, H, U, G, V, z, j, J, X), q = g(N, B, H, U, G, V, z, j, J, X); N = T(l, c), B = E(l, c), H = S(l, 0, p, 0, v), U = x(0, c, 0, f, 0, y); var Z = h(N, B, H, U), K = d(N, B, H, U); I = k, O = D, k = R, D = L, R = C, L = P, C = h(b, A, W, q), P = d(A, A, W, q), b = v, A = y, v = p, y = f, p = l, f = c, l = h(W, q, Z, K), c = d(W, q, Z, K) } u(this.h, 0, l, c), u(this.h, 2, p, f), u(this.h, 4, v, y), u(this.h, 6, b, A), u(this.h, 8, C, P), u(this.h, 10, R, L), u(this.h, 12, k, D), u(this.h, 14, I, O) }, b.prototype._digest = function (t) { return "hex" === t ? r.toHex32(this.h, "big") : r.split32(this.h, "big") } }, 8491: (t, e, n) => { "use strict"; var r = n(8291).rotr32; function i(t, e, n) { return t & e ^ ~t & n } function s(t, e, n) { return t & e ^ t & n ^ e & n } function o(t, e, n) { return t ^ e ^ n } e.ft_1 = function (t, e, n, r) { return 0 === t ? i(e, n, r) : 1 === t || 3 === t ? o(e, n, r) : 2 === t ? s(e, n, r) : void 0 }, e.ch32 = i, e.maj32 = s, e.p32 = o, e.s0_256 = function (t) { return r(t, 2) ^ r(t, 13) ^ r(t, 22) }, e.s1_256 = function (t) { return r(t, 6) ^ r(t, 11) ^ r(t, 25) }, e.g0_256 = function (t) { return r(t, 7) ^ r(t, 18) ^ t >>> 3 }, e.g1_256 = function (t) { return r(t, 17) ^ r(t, 19) ^ t >>> 10 } }, 8291: (t, e, n) => { "use strict"; var r = n(6055), i = n(9879); function s(t, e) { return 55296 == (64512 & t.charCodeAt(e)) && !(e < 0 || e + 1 >= t.length) && 56320 == (64512 & t.charCodeAt(e + 1)) } function o(t) { return (t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (255 & t) << 24) >>> 0 } function a(t) { return 1 === t.length ? "0" + t : t } function l(t) { return 7 === t.length ? "0" + t : 6 === t.length ? "00" + t : 5 === t.length ? "000" + t : 4 === t.length ? "0000" + t : 3 === t.length ? "00000" + t : 2 === t.length ? "000000" + t : 1 === t.length ? "0000000" + t : t } e.inherits = i, e.toArray = function (t, e) { if (Array.isArray(t)) return t.slice(); if (!t) return []; var n = []; if ("string" == typeof t) if (e) { if ("hex" === e) for ((t = t.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (t = "0" + t), i = 0; i < t.length; i += 2)n.push(parseInt(t[i] + t[i + 1], 16)) } else for (var r = 0, i = 0; i < t.length; i++) { var o = t.charCodeAt(i); o < 128 ? n[r++] = o : o < 2048 ? (n[r++] = o >> 6 | 192, n[r++] = 63 & o | 128) : s(t, i) ? (o = 65536 + ((1023 & o) << 10) + (1023 & t.charCodeAt(++i)), n[r++] = o >> 18 | 240, n[r++] = o >> 12 & 63 | 128, n[r++] = o >> 6 & 63 | 128, n[r++] = 63 & o | 128) : (n[r++] = o >> 12 | 224, n[r++] = o >> 6 & 63 | 128, n[r++] = 63 & o | 128) } else for (i = 0; i < t.length; i++)n[i] = 0 | t[i]; return n }, e.toHex = function (t) { for (var e = "", n = 0; n < t.length; n++)e += a(t[n].toString(16)); return e }, e.htonl = o, e.toHex32 = function (t, e) { for (var n = "", r = 0; r < t.length; r++) { var i = t[r]; "little" === e && (i = o(i)), n += l(i.toString(16)) } return n }, e.zero2 = a, e.zero8 = l, e.join32 = function (t, e, n, i) { var s = n - e; r(s % 4 == 0); for (var o = new Array(s / 4), a = 0, l = e; a < o.length; a++, l += 4)o[a] = ("big" === i ? t[l] << 24 | t[l + 1] << 16 | t[l + 2] << 8 | t[l + 3] : t[l + 3] << 24 | t[l + 2] << 16 | t[l + 1] << 8 | t[l]) >>> 0; return o }, e.split32 = function (t, e) { for (var n = new Array(4 * t.length), r = 0, i = 0; r < t.length; r++, i += 4) { var s = t[r]; "big" === e ? (n[i] = s >>> 24, n[i + 1] = s >>> 16 & 255, n[i + 2] = s >>> 8 & 255, n[i + 3] = 255 & s) : (n[i + 3] = s >>> 24, n[i + 2] = s >>> 16 & 255, n[i + 1] = s >>> 8 & 255, n[i] = 255 & s) } return n }, e.rotr32 = function (t, e) { return t >>> e | t << 32 - e }, e.rotl32 = function (t, e) { return t << e | t >>> 32 - e }, e.sum32 = function (t, e) { return t + e >>> 0 }, e.sum32_3 = function (t, e, n) { return t + e + n >>> 0 }, e.sum32_4 = function (t, e, n, r) { return t + e + n + r >>> 0 }, e.sum32_5 = function (t, e, n, r, i) { return t + e + n + r + i >>> 0 }, e.sum64 = function (t, e, n, r) { var i = r + t[e + 1] >>> 0; t[e] = (i < r ? 1 : 0) + n + t[e] >>> 0, t[e + 1] = i }, e.sum64_hi = function (t, e, n, r) { return (e + r >>> 0 < e ? 1 : 0) + t + n >>> 0 }, e.sum64_lo = function (t, e, n, r) { return e + r >>> 0 }, e.sum64_4_hi = function (t, e, n, r, i, s, o, a) { var l = 0, c = e; return l += (c = c + r >>> 0) < e ? 1 : 0, l += (c = c + s >>> 0) < s ? 1 : 0, t + n + i + o + (l += (c = c + a >>> 0) < a ? 1 : 0) >>> 0 }, e.sum64_4_lo = function (t, e, n, r, i, s, o, a) { return e + r + s + a >>> 0 }, e.sum64_5_hi = function (t, e, n, r, i, s, o, a, l, c) { var u = 0, h = e; return u += (h = h + r >>> 0) < e ? 1 : 0, u += (h = h + s >>> 0) < s ? 1 : 0, u += (h = h + a >>> 0) < a ? 1 : 0, t + n + i + o + l + (u += (h = h + c >>> 0) < c ? 1 : 0) >>> 0 }, e.sum64_5_lo = function (t, e, n, r, i, s, o, a, l, c) { return e + r + s + a + c >>> 0 }, e.rotr64_hi = function (t, e, n) { return (e << 32 - n | t >>> n) >>> 0 }, e.rotr64_lo = function (t, e, n) { return (t << 32 - n | e >>> n) >>> 0 }, e.shr64_hi = function (t, e, n) { return t >>> n }, e.shr64_lo = function (t, e, n) { return (t << 32 - n | e >>> n) >>> 0 } }, 5517: (t, e, n) => { var r = n(3313), i = n(5617), s = "undefined" == typeof window ? n(1525) : window, o = s.document, a = s.Text; function l() { var t = []; function e() { var e = [].slice.call(arguments), n = null; function s(e) { var l, d; if (null == e); else if ("string" == typeof e) n ? n.appendChild(l = o.createTextNode(e)) : (d = r(e, /([\.#]?[^\s#.]+)/), /^\.|#/.test(d[1]) && (n = o.createElement("div")), u(d, function (t) { var e = t.substring(1, t.length); t && (n ? "." === t[0] ? i(n).add(e) : "#" === t[0] && n.setAttribute("id", e) : n = o.createElement(t)) })); else if ("number" == typeof e || "boolean" == typeof e || e instanceof Date || e instanceof RegExp) n.appendChild(l = o.createTextNode(e.toString())); else if (h(e)) u(e, s); else if (c(e)) n.appendChild(l = e); else if (e instanceof a) n.appendChild(l = e); else if ("object" == typeof e) for (var p in e) if ("function" == typeof e[p]) /^on\w+/.test(p) ? function (e, r) { n.addEventListener ? (n.addEventListener(e.substring(2), r[e], !1), t.push(function () { n.removeEventListener(e.substring(2), r[e], !1) })) : (n.attachEvent(e, r[e]), t.push(function () { n.detachEvent(e, r[e]) })) }(p, e) : (n[p] = e[p](), t.push(e[p](function (t) { n[p] = t }))); else if ("style" === p) if ("string" == typeof e[p]) n.style.cssText = e[p]; else for (var f in e[p]) !function (r, i) { if ("function" == typeof i) n.style.setProperty(r, i()), t.push(i(function (t) { n.style.setProperty(r, t) })); else var s = e[p][r].match(/(.*)\W+!important\W*$/); s ? n.style.setProperty(r, s[1], "important") : n.style.setProperty(r, e[p][r]) }(f, e[p][f]); else if ("attrs" === p) for (var m in e[p]) n.setAttribute(m, e[p][m]); else "data-" === p.substr(0, 5) ? n.setAttribute(p, e[p]) : n[p] = e[p]; else "function" == typeof e && (m = e(), n.appendChild(l = c(m) ? m : o.createTextNode(m)), t.push(e(function (t) { c(t) && l.parentElement ? (l.parentElement.replaceChild(t, l), l = t) : l.textContent = t }))); return l } for (; e.length;)s(e.shift()); return n } return e.cleanup = function () { for (var e = 0; e < t.length; e++)t[e](); t.length = 0 }, e } function c(t) { return t && t.nodeName && t.nodeType } function u(t, e) { if (t.forEach) return t.forEach(e); for (var n = 0; n < t.length; n++)e(t[n], n) } function h(t) { return "[object Array]" == Object.prototype.toString.call(t) } (t.exports = l()).context = l }, 7736: t => { var e = [].indexOf; t.exports = function (t, n) { if (e) return t.indexOf(n); for (var r = 0; r < t.length; ++r)if (t[r] === n) return r; return -1 } }, 9879: t => { t.exports = "function" == typeof Object.create ? function (t, e) { e && (t.super_ = e, t.prototype = Object.create(e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } })) } : function (t, e) { if (e) { t.super_ = e; var n = function () { }; n.prototype = e.prototype, t.prototype = new n, t.prototype.constructor = t } } }, 1299: (t, e, n) => { "use strict"; var r = n(9708); function i(t) { return !0 === r(t) && "[object Object]" === Object.prototype.toString.call(t) } t.exports = function (t) { var e, n; return !1 !== i(t) && "function" == typeof (e = t.constructor) && !1 !== i(n = e.prototype) && !1 !== n.hasOwnProperty("isPrototypeOf") } }, 9708: t => { "use strict"; t.exports = function (t) { return null != t && "object" == typeof t && !1 === Array.isArray(t) } }, 7109: t => { !function () { "use strict"; var e = "object" == typeof window ? window : {}; !e.JS_SHA3_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node && (e = global); for (var n = !e.JS_SHA3_NO_COMMON_JS && t.exports, r = "0123456789abcdef".split(""), i = [0, 8, 16, 24], s = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], o = [224, 256, 384, 512], a = ["hex", "buffer", "arrayBuffer", "array"], l = function (t, e, n) { return function (r) { return new b(t, e, t).update(r)[n]() } }, c = function (t, e, n) { return function (r, i) { return new b(t, e, i).update(r)[n]() } }, u = function (t, e) { var n = l(t, e, "hex"); n.create = function () { return new b(t, e, t) }, n.update = function (t) { return n.create().update(t) }; for (var r = 0; r < a.length; ++r) { var i = a[r]; n[i] = l(t, e, i) } return n }, h = [{ name: "keccak", padding: [1, 256, 65536, 16777216], bits: o, createMethod: u }, { name: "sha3", padding: [6, 1536, 393216, 100663296], bits: o, createMethod: u }, { name: "shake", padding: [31, 7936, 2031616, 520093696], bits: [128, 256], createMethod: function (t, e) { var n = c(t, e, "hex"); n.create = function (n) { return new b(t, e, n) }, n.update = function (t, e) { return n.create(e).update(t) }; for (var r = 0; r < a.length; ++r) { var i = a[r]; n[i] = c(t, e, i) } return n } }], d = {}, p = [], f = 0; f < h.length; ++f)for (var m = h[f], g = m.bits, v = 0; v < g.length; ++v) { var y = m.name + "_" + g[v]; p.push(y), d[y] = m.createMethod(g[v], m.padding) } function b(t, e, n) { this.blocks = [], this.s = [], this.padding = e, this.outputBits = n, this.reset = !0, this.block = 0, this.start = 0, this.blockCount = 1600 - (t << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = n >> 5, this.extraBytes = (31 & n) >> 3; for (var r = 0; r < 50; ++r)this.s[r] = 0 } b.prototype.update = function (t) { var e = "string" != typeof t; e && t.constructor === ArrayBuffer && (t = new Uint8Array(t)); for (var n, r, s = t.length, o = this.blocks, a = this.byteCount, l = this.blockCount, c = 0, u = this.s; c < s;) { if (this.reset) for (this.reset = !1, o[0] = this.block, n = 1; n < l + 1; ++n)o[n] = 0; if (e) for (n = this.start; c < s && n < a; ++c)o[n >> 2] |= t[c] << i[3 & n++]; else for (n = this.start; c < s && n < a; ++c)(r = t.charCodeAt(c)) < 128 ? o[n >> 2] |= r << i[3 & n++] : r < 2048 ? (o[n >> 2] |= (192 | r >> 6) << i[3 & n++], o[n >> 2] |= (128 | 63 & r) << i[3 & n++]) : r < 55296 || r >= 57344 ? (o[n >> 2] |= (224 | r >> 12) << i[3 & n++], o[n >> 2] |= (128 | r >> 6 & 63) << i[3 & n++], o[n >> 2] |= (128 | 63 & r) << i[3 & n++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & t.charCodeAt(++c)), o[n >> 2] |= (240 | r >> 18) << i[3 & n++], o[n >> 2] |= (128 | r >> 12 & 63) << i[3 & n++], o[n >> 2] |= (128 | r >> 6 & 63) << i[3 & n++], o[n >> 2] |= (128 | 63 & r) << i[3 & n++]); if (this.lastByteIndex = n, n >= a) { for (this.start = n - a, this.block = o[l], n = 0; n < l; ++n)u[n] ^= o[n]; _(u), this.reset = !0 } else this.start = n } return this }, b.prototype.finalize = function () { var t = this.blocks, e = this.lastByteIndex, n = this.blockCount, r = this.s; if (t[e >> 2] |= this.padding[3 & e], this.lastByteIndex === this.byteCount) for (t[0] = t[n], e = 1; e < n + 1; ++e)t[e] = 0; for (t[n - 1] |= 2147483648, e = 0; e < n; ++e)r[e] ^= t[e]; _(r) }, b.prototype.toString = b.prototype.hex = function () { this.finalize(); for (var t, e = this.blockCount, n = this.s, i = this.outputBlocks, s = this.extraBytes, o = 0, a = 0, l = ""; a < i;) { for (o = 0; o < e && a < i; ++o, ++a)l += r[(t = n[o]) >> 4 & 15] + r[15 & t] + r[t >> 12 & 15] + r[t >> 8 & 15] + r[t >> 20 & 15] + r[t >> 16 & 15] + r[t >> 28 & 15] + r[t >> 24 & 15]; a % e == 0 && (_(n), o = 0) } return s && (t = n[o], s > 0 && (l += r[t >> 4 & 15] + r[15 & t]), s > 1 && (l += r[t >> 12 & 15] + r[t >> 8 & 15]), s > 2 && (l += r[t >> 20 & 15] + r[t >> 16 & 15])), l }, b.prototype.buffer = b.prototype.arrayBuffer = function () { this.finalize(); var t, e = this.blockCount, n = this.s, r = this.outputBlocks, i = this.extraBytes, s = 0, o = 0, a = this.outputBits >> 3; t = i ? new ArrayBuffer(r + 1 << 2) : new ArrayBuffer(a); for (var l = new Uint32Array(t); o < r;) { for (s = 0; s < e && o < r; ++s, ++o)l[o] = n[s]; o % e == 0 && _(n) } return i && (l[s] = n[s], t = t.slice(0, a)), t }, b.prototype.digest = b.prototype.array = function () { this.finalize(); for (var t, e, n = this.blockCount, r = this.s, i = this.outputBlocks, s = this.extraBytes, o = 0, a = 0, l = []; a < i;) { for (o = 0; o < n && a < i; ++o, ++a)l[t = a << 2] = 255 & (e = r[o]), l[t + 1] = e >> 8 & 255, l[t + 2] = e >> 16 & 255, l[t + 3] = e >> 24 & 255; a % n == 0 && _(r) } return s && (t = a << 2, e = r[o], s > 0 && (l[t] = 255 & e), s > 1 && (l[t + 1] = e >> 8 & 255), s > 2 && (l[t + 2] = e >> 16 & 255)), l }; var _ = function (t) { var e, n, r, i, o, a, l, c, u, h, d, p, f, m, g, v, y, b, _, w, S, x, T, E, M, A, C, P, R, L, k, D, I, O, F, N, B, H, U, G, V, z, j, J, X, W, q, Z, K, Y, Q, $, tt, et, nt, rt, it, st, ot, at, lt, ct, ut; for (r = 0; r < 48; r += 2)i = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40], o = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41], c = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44], u = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45], h = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46], d = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47], n = (f = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49]) ^ ((l = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43]) << 1 | (a = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42]) >>> 31), t[0] ^= e = (p = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48]) ^ (a << 1 | l >>> 31), t[1] ^= n, t[10] ^= e, t[11] ^= n, t[20] ^= e, t[21] ^= n, t[30] ^= e, t[31] ^= n, t[40] ^= e, t[41] ^= n, n = o ^ (u << 1 | c >>> 31), t[2] ^= e = i ^ (c << 1 | u >>> 31), t[3] ^= n, t[12] ^= e, t[13] ^= n, t[22] ^= e, t[23] ^= n, t[32] ^= e, t[33] ^= n, t[42] ^= e, t[43] ^= n, n = l ^ (d << 1 | h >>> 31), t[4] ^= e = a ^ (h << 1 | d >>> 31), t[5] ^= n, t[14] ^= e, t[15] ^= n, t[24] ^= e, t[25] ^= n, t[34] ^= e, t[35] ^= n, t[44] ^= e, t[45] ^= n, n = u ^ (f << 1 | p >>> 31), t[6] ^= e = c ^ (p << 1 | f >>> 31), t[7] ^= n, t[16] ^= e, t[17] ^= n, t[26] ^= e, t[27] ^= n, t[36] ^= e, t[37] ^= n, t[46] ^= e, t[47] ^= n, n = d ^ (o << 1 | i >>> 31), t[8] ^= e = h ^ (i << 1 | o >>> 31), t[9] ^= n, t[18] ^= e, t[19] ^= n, t[28] ^= e, t[29] ^= n, t[38] ^= e, t[39] ^= n, t[48] ^= e, t[49] ^= n, g = t[1], W = t[11] << 4 | t[10] >>> 28, q = t[10] << 4 | t[11] >>> 28, P = t[20] << 3 | t[21] >>> 29, R = t[21] << 3 | t[20] >>> 29, at = t[31] << 9 | t[30] >>> 23, lt = t[30] << 9 | t[31] >>> 23, z = t[40] << 18 | t[41] >>> 14, j = t[41] << 18 | t[40] >>> 14, O = t[2] << 1 | t[3] >>> 31, F = t[3] << 1 | t[2] >>> 31, y = t[12] << 12 | t[13] >>> 20, Z = t[22] << 10 | t[23] >>> 22, K = t[23] << 10 | t[22] >>> 22, L = t[33] << 13 | t[32] >>> 19, k = t[32] << 13 | t[33] >>> 19, ct = t[42] << 2 | t[43] >>> 30, ut = t[43] << 2 | t[42] >>> 30, et = t[5] << 30 | t[4] >>> 2, nt = t[4] << 30 | t[5] >>> 2, N = t[14] << 6 | t[15] >>> 26, B = t[15] << 6 | t[14] >>> 26, _ = t[24] << 11 | t[25] >>> 21, Y = t[34] << 15 | t[35] >>> 17, Q = t[35] << 15 | t[34] >>> 17, D = t[45] << 29 | t[44] >>> 3, I = t[44] << 29 | t[45] >>> 3, E = t[6] << 28 | t[7] >>> 4, M = t[7] << 28 | t[6] >>> 4, rt = t[17] << 23 | t[16] >>> 9, it = t[16] << 23 | t[17] >>> 9, H = t[26] << 25 | t[27] >>> 7, U = t[27] << 25 | t[26] >>> 7, w = t[36] << 21 | t[37] >>> 11, S = t[37] << 21 | t[36] >>> 11, $ = t[47] << 24 | t[46] >>> 8, tt = t[46] << 24 | t[47] >>> 8, J = t[8] << 27 | t[9] >>> 5, X = t[9] << 27 | t[8] >>> 5, A = t[18] << 20 | t[19] >>> 12, C = t[19] << 20 | t[18] >>> 12, st = t[29] << 7 | t[28] >>> 25, ot = t[28] << 7 | t[29] >>> 25, G = t[38] << 8 | t[39] >>> 24, V = t[39] << 8 | t[38] >>> 24, x = t[48] << 14 | t[49] >>> 18, T = t[49] << 14 | t[48] >>> 18, t[0] = (m = t[0]) ^ ~(v = t[13] << 12 | t[12] >>> 20) & (b = t[25] << 11 | t[24] >>> 21), t[1] = g ^ ~y & _, t[10] = E ^ ~A & P, t[11] = M ^ ~C & R, t[20] = O ^ ~N & H, t[21] = F ^ ~B & U, t[30] = J ^ ~W & Z, t[31] = X ^ ~q & K, t[40] = et ^ ~rt & st, t[41] = nt ^ ~it & ot, t[2] = v ^ ~b & w, t[3] = y ^ ~_ & S, t[12] = A ^ ~P & L, t[13] = C ^ ~R & k, t[22] = N ^ ~H & G, t[23] = B ^ ~U & V, t[32] = W ^ ~Z & Y, t[33] = q ^ ~K & Q, t[42] = rt ^ ~st & at, t[43] = it ^ ~ot & lt, t[4] = b ^ ~w & x, t[5] = _ ^ ~S & T, t[14] = P ^ ~L & D, t[15] = R ^ ~k & I, t[24] = H ^ ~G & z, t[25] = U ^ ~V & j, t[34] = Z ^ ~Y & $, t[35] = K ^ ~Q & tt, t[44] = st ^ ~at & ct, t[45] = ot ^ ~lt & ut, t[6] = w ^ ~x & m, t[7] = S ^ ~T & g, t[16] = L ^ ~D & E, t[17] = k ^ ~I & M, t[26] = G ^ ~z & O, t[27] = V ^ ~j & F, t[36] = Y ^ ~$ & J, t[37] = Q ^ ~tt & X, t[46] = at ^ ~ct & et, t[47] = lt ^ ~ut & nt, t[8] = x ^ ~m & v, t[9] = T ^ ~g & y, t[18] = D ^ ~E & A, t[19] = I ^ ~M & C, t[28] = z ^ ~O & N, t[29] = j ^ ~F & B, t[38] = $ ^ ~J & W, t[39] = tt ^ ~X & q, t[48] = ct ^ ~et & rt, t[49] = ut ^ ~nt & it, t[0] ^= s[r], t[1] ^= s[r + 1] }; if (n) t.exports = d; else for (f = 0; f < p.length; ++f)e[p[f]] = d[p[f]] }() }, 7726: (t, e) => { "use strict"; var n = "undefined" != typeof Reflect ? Reflect.construct : void 0, r = Object.defineProperty, i = Error.captureStackTrace; function s(t) { void 0 !== t && r(this, "message", { configurable: !0, value: t, writable: !0 }); var e = this.constructor.name; void 0 !== e && e !== this.name && r(this, "name", { configurable: !0, value: e, writable: !0 }), i(this, this.constructor) } void 0 === i && (i = function (t) { var e = new Error; r(t, "stack", { configurable: !0, get: function () { var t = e.stack; return r(this, "stack", { configurable: !0, value: t, writable: !0 }), t }, set: function (e) { r(t, "stack", { configurable: !0, value: e, writable: !0 }) } }) }), s.prototype = Object.create(Error.prototype, { constructor: { configurable: !0, value: s, writable: !0 } }); var o = function () { function t(t, e) { return r(t, "name", { configurable: !0, value: e }) } try { var e = function () { }; if (t(e, "foo"), "foo" === e.name) return t } catch (n) { } }(); (t.exports = function (t, e) { if (null == e || e === Error) e = s; else if ("function" != typeof e) throw new TypeError("super_ should be a function"); var r; if ("string" == typeof t) r = t, t = void 0 !== n ? function () { return n(e, arguments, this.constructor) } : function () { e.apply(this, arguments) }, void 0 !== o && (o(t, r), r = void 0); else if ("function" != typeof t) throw new TypeError("constructor should be either a string or a function"); t.super_ = t.super = e; var i = { constructor: { configurable: !0, value: t, writable: !0 } }; return void 0 !== r && (i.name = { configurable: !0, value: r, writable: !0 }), t.prototype = Object.create(e.prototype, i), t }).BaseError = s }, 6055: t => { function e(t, e) { if (!t) throw new Error(e || "Assertion failed") } t.exports = e, e.equal = function (t, e, n) { if (t != e) throw new Error(n || "Assertion failed: " + t + " != " + e) } }, 8180: t => { t.exports = function () { var t = []; return { subscribe: function (e) { return t.push(e), function () { var n = t.indexOf(e); n > -1 && t.splice(n, 1) } }, publish: function () { for (var e = 0; e < t.length; e++)t[e].apply(null, arguments) } } } }, 8228: t => { "use strict"; var e = Object.getOwnPropertySymbols, n = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable; function i(t) { if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(t) } t.exports = function () { try { if (!Object.assign) return !1; var t = new String("abc"); if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1; for (var e = {}, n = 0; n < 10; n++)e["_" + String.fromCharCode(n)] = n; if ("0123456789" !== Object.getOwnPropertyNames(e).map(function (t) { return e[t] }).join("")) return !1; var r = {}; return "abcdefghijklmnopqrst".split("").forEach(function (t) { r[t] = t }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r)).join("") } catch (i) { return !1 } }() ? Object.assign : function (t, s) { for (var o, a, l = i(t), c = 1; c < arguments.length; c++) { for (var u in o = Object(arguments[c])) n.call(o, u) && (l[u] = o[u]); if (e) { a = e(o); for (var h = 0; h < a.length; h++)r.call(o, a[h]) && (l[a[h]] = o[a[h]]) } } return l } }, 7999: t => { var e = function (t) { return t.replace(/^\s+|\s+$/g, "") }; t.exports = function (t) { if (!t) return {}; for (var n = {}, r = e(t).split("\n"), i = 0; i < r.length; i++) { var s = r[i], o = s.indexOf(":"), a = e(s.slice(0, o)).toLowerCase(), l = e(s.slice(o + 1)); void 0 === n[a] ? n[a] = l : "[object Array]" === Object.prototype.toString.call(n[a]) ? n[a].push(l) : n[a] = [n[a], l] } return n } }, 6959: (t, e) => { "use strict"; var n = Object.prototype.hasOwnProperty; function r(t) { try { return decodeURIComponent(t.replace(/\+/g, " ")) } catch (e) { return null } } function i(t) { try { return encodeURIComponent(t) } catch (e) { return null } } e.stringify = function (t, e) { e = e || ""; var r, s, o = []; for (s in "string" != typeof e && (e = "?"), t) if (n.call(t, s)) { if ((r = t[s]) || null != r && !isNaN(r) || (r = ""), s = i(s), r = i(r), null === s || null === r) continue; o.push(s + "=" + r) } return o.length ? e + o.join("&") : "" }, e.parse = function (t) { for (var e, n = /([^=?#&]+)=?([^&]*)/g, i = {}; e = n.exec(t);) { var s = r(e[1]), o = r(e[2]); null === s || null === o || s in i || (i[s] = o) } return i } }, 465: t => { "use strict"; t.exports = function (t, e) { if (e = e.split(":")[0], !(t = +t)) return !1; switch (e) { case "http": case "ws": return 80 !== t; case "https": case "wss": return 443 !== t; case "ftp": return 21 !== t; case "gopher": return 70 !== t; case "file": return !1 }return 0 !== t } }, 3576: (t, e, n) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var r = n(5730), i = n(7104), s = n(6232), o = n(3915), a = n(8273), l = function () { function t(t) { this._isScalar = !1, t && (this._subscribe = t) } return t.prototype.lift = function (e) { var n = new t; return n.source = this, n.operator = e, n }, t.prototype.subscribe = function (t, e, n) { var r = this.operator, s = i.toSubscriber(t, e, n); if (s.add(r ? r.call(s, this.source) : this.source || a.config.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), a.config.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown)) throw s.syncErrorValue; return s }, t.prototype._trySubscribe = function (t) { try { return this._subscribe(t) } catch (e) { a.config.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), r.canReportError(t) ? t.error(e) : console.warn(e) } }, t.prototype.forEach = function (t, e) { var n = this; return new (e = c(e))(function (e, r) { var i; i = n.subscribe(function (e) { try { t(e) } catch (n) { r(n), i && i.unsubscribe() } }, r, e) }) }, t.prototype._subscribe = function (t) { var e = this.source; return e && e.subscribe(t) }, t.prototype[s.observable] = function () { return this }, t.prototype.pipe = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return 0 === t.length ? this : o.pipeFromArray(t)(this) }, t.prototype.toPromise = function (t) { var e = this; return new (t = c(t))(function (t, n) { var r; e.subscribe(function (t) { return r = t }, function (t) { return n(t) }, function () { return t(r) }) }) }, t.create = function (e) { return new t(e) }, t }(); function c(t) { if (t || (t = a.config.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } e.Observable = l }, 6011: (t, e, n) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var r = n(8273), i = n(2434); e.empty = { closed: !0, next: function (t) { }, error: function (t) { if (r.config.useDeprecatedSynchronousErrorHandling) throw t; i.hostReportError(t) }, complete: function () { } } }, 7241: function (t, e, n) { "use strict"; var r, i = this && this.__extends || (r = function (t, e) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }, function (t, e) { function n() { this.constructor = t } r(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) }); Object.defineProperty(e, "__esModule", { value: !0 }); var s = n(7382), o = n(6011), a = n(3984), l = n(1476), c = n(8273), u = n(2434), h = function (t) { function e(n, r, i) { var s = t.call(this) || this; switch (s.syncErrorValue = null, s.syncErrorThrown = !1, s.syncErrorThrowable = !1, s.isStopped = !1, arguments.length) { case 0: s.destination = o.empty; break; case 1: if (!n) { s.destination = o.empty; break } if ("object" == typeof n) { n instanceof e ? (s.syncErrorThrowable = n.syncErrorThrowable, s.destination = n, n.add(s)) : (s.syncErrorThrowable = !0, s.destination = new d(s, n)); break } default: s.syncErrorThrowable = !0, s.destination = new d(s, n, r, i) }return s } return i(e, t), e.prototype[l.rxSubscriber] = function () { return this }, e.create = function (t, n, r) { var i = new e(t, n, r); return i.syncErrorThrowable = !1, i }, e.prototype.next = function (t) { this.isStopped || this._next(t) }, e.prototype.error = function (t) { this.isStopped || (this.isStopped = !0, this._error(t)) }, e.prototype.complete = function () { this.isStopped || (this.isStopped = !0, this._complete()) }, e.prototype.unsubscribe = function () { this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this)) }, e.prototype._next = function (t) { this.destination.next(t) }, e.prototype._error = function (t) { this.destination.error(t), this.unsubscribe() }, e.prototype._complete = function () { this.destination.complete(), this.unsubscribe() }, e.prototype._unsubscribeAndRecycle = function () { var t = this._parentOrParents; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this }, e }(a.Subscription); e.Subscriber = h; var d = function (t) { function e(e, n, r, i) { var a, l = t.call(this) || this; l._parentSubscriber = e; var c = l; return s.isFunction(n) ? a = n : n && (a = n.next, r = n.error, i = n.complete, n !== o.empty && (c = Object.create(n), s.isFunction(c.unsubscribe) && l.add(c.unsubscribe.bind(c)), c.unsubscribe = l.unsubscribe.bind(l))), l._context = c, l._next = a, l._error = r, l._complete = i, l } return i(e, t), e.prototype.next = function (t) { if (!this.isStopped && this._next) { var e = this._parentSubscriber; c.config.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } }, e.prototype.error = function (t) { if (!this.isStopped) { var e = this._parentSubscriber, n = c.config.useDeprecatedSynchronousErrorHandling; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : u.hostReportError(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; u.hostReportError(t) } } }, e.prototype.complete = function () { var t = this; if (!this.isStopped) { var e = this._parentSubscriber; if (this._complete) { var n = function () { return t._complete.call(t._context) }; c.config.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? (this.__tryOrSetError(e, n), this.unsubscribe()) : (this.__tryOrUnsub(n), this.unsubscribe()) } else this.unsubscribe() } }, e.prototype.__tryOrUnsub = function (t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), c.config.useDeprecatedSynchronousErrorHandling) throw n; u.hostReportError(n) } }, e.prototype.__tryOrSetError = function (t, e, n) { if (!c.config.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (r) { return c.config.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = r, t.syncErrorThrown = !0, !0) : (u.hostReportError(r), !0) } return !1 }, e.prototype._unsubscribe = function () { var t = this._parentSubscriber; this._context = null, this._parentSubscriber = null, t.unsubscribe() }, e }(h); e.SafeSubscriber = d }, 3984: (t, e, n) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var r = n(993), i = n(4720), s = n(7382), o = n(8574), a = function () { function t(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._ctorUnsubscribe = !0, this._unsubscribe = t) } var e; return t.prototype.unsubscribe = function () { var e; if (!this.closed) { var n = this, a = n._parentOrParents, c = n._ctorUnsubscribe, u = n._unsubscribe, h = n._subscriptions; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, a instanceof t) a.remove(this); else if (null !== a) for (var d = 0; d < a.length; ++d)a[d].remove(this); if (s.isFunction(u)) { c && (this._unsubscribe = void 0); try { u.call(this) } catch (m) { e = m instanceof o.UnsubscriptionError ? l(m.errors) : [m] } } if (r.isArray(h)) { d = -1; for (var p = h.length; ++d < p;) { var f = h[d]; if (i.isObject(f)) try { f.unsubscribe() } catch (m) { e = e || [], m instanceof o.UnsubscriptionError ? e = e.concat(l(m.errors)) : e.push(m) } } } if (e) throw new o.UnsubscriptionError(e) } }, t.prototype.add = function (e) { var n = e; if (!e) return t.EMPTY; switch (typeof e) { case "function": n = new t(e); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof t)) { var r = n; (n = new t)._subscriptions = [r] } break; default: throw new Error("unrecognized teardown " + e + " added to Subscription.") }var i = n._parentOrParents; if (null === i) n._parentOrParents = this; else if (i instanceof t) { if (i === this) return n; n._parentOrParents = [i, this] } else { if (-1 !== i.indexOf(this)) return n; i.push(this) } var s = this._subscriptions; return null === s ? this._subscriptions = [n] : s.push(n), n }, t.prototype.remove = function (t) { var e = this._subscriptions; if (e) { var n = e.indexOf(t); -1 !== n && e.splice(n, 1) } }, t.EMPTY = ((e = new t).closed = !0, e), t }(); function l(t) { return t.reduce(function (t, e) { return t.concat(e instanceof o.UnsubscriptionError ? e.errors : e) }, []) } e.Subscription = a }, 8273: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n = !1; e.config = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { var e = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + e.stack) } else n && console.log("RxJS: Back to a better error behavior. Thank you. <3"); n = t }, get useDeprecatedSynchronousErrorHandling() { return n } } }, 9941: (t, e, n) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var r = n(3576); e.EMPTY = new r.Observable(function (t) { return t.complete() }), e.empty = function (t) { return t ? function (t) { return new r.Observable(function (e) { return t.schedule(function () { return e.complete() }) }) }(t) : e.EMPTY } }, 500: function (t, e, n) { "use strict"; var r, i = this && this.__extends || (r = function (t, e) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }, function (t, e) { function n() { this.constructor = t } r(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) }); Object.defineProperty(e, "__esModule", { value: !0 }); var s = n(7241); e.defaultIfEmpty = function (t) { return void 0 === t && (t = null), function (e) { return e.lift(new o(t)) } }; var o = function () { function t(t) { this.defaultValue = t } return t.prototype.call = function (t, e) { return e.subscribe(new a(t, this.defaultValue)) }, t }(), a = function (t) { function e(e, n) { var r = t.call(this, e) || this; return r.defaultValue = n, r.isEmpty = !0, r } return i(e, t), e.prototype._next = function (t) { this.isEmpty = !1, this.destination.next(t) }, e.prototype._complete = function () { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() }, e }(s.Subscriber) }, 6179: function (t, e, n) { "use strict"; var r, i = this && this.__extends || (r = function (t, e) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }, function (t, e) { function n() { this.constructor = t } r(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) }); Object.defineProperty(e, "__esModule", { value: !0 }); var s = n(7241); e.filter = function (t, e) { return function (n) { return n.lift(new o(t, e)) } }; var o = function () { function t(t, e) { this.predicate = t, this.thisArg = e } return t.prototype.call = function (t, e) { return e.subscribe(new a(t, this.predicate, this.thisArg)) }, t }(), a = function (t) { function e(e, n, r) { var i = t.call(this, e) || this; return i.predicate = n, i.thisArg = r, i.count = 0, i } return i(e, t), e.prototype._next = function (t) { var e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) }, e }(s.Subscriber) }, 1156: function (t, e, n) { "use strict"; var r, i = this && this.__extends || (r = function (t, e) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }, function (t, e) { function n() { this.constructor = t } r(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) }); Object.defineProperty(e, "__esModule", { value: !0 }); var s = n(7241); e.map = function (t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new o(t, e)) } }; var o = function () { function t(t, e) { this.project = t, this.thisArg = e } return t.prototype.call = function (t, e) { return e.subscribe(new a(t, this.project, this.thisArg)) }, t }(); e.MapOperator = o; var a = function (t) { function e(e, n, r) { var i = t.call(this, e) || this; return i.project = n, i.count = 0, i.thisArg = r || i, i } return i(e, t), e.prototype._next = function (t) { var e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) }, e }(s.Subscriber) }, 4589: (t, e, n) => { "use strict"; var r = n(4952), i = n(1589), s = n(500), o = n(3915); e.reduce = function (t, e) { return arguments.length >= 2 ? function (n) { return o.pipe(r.scan(t, e), i.takeLast(1), s.defaultIfEmpty(e))(n) } : function (e) { return o.pipe(r.scan(function (e, n, r) { return t(e, n, r + 1) }), i.takeLast(1))(e) } } }, 4952: function (t, e, n) { "use strict"; var r, i = this && this.__extends || (r = function (t, e) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }, function (t, e) { function n() { this.constructor = t } r(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) }); Object.defineProperty(e, "__esModule", { value: !0 }); var s = n(7241); e.scan = function (t, e) { var n = !1; return arguments.length >= 2 && (n = !0), function (r) { return r.lift(new o(t, e, n)) } }; var o = function () { function t(t, e, n) { void 0 === n && (n = !1), this.accumulator = t, this.seed = e, this.hasSeed = n } return t.prototype.call = function (t, e) { return e.subscribe(new a(t, this.accumulator, this.seed, this.hasSeed)) }, t }(), a = function (t) { function e(e, n, r, i) { var s = t.call(this, e) || this; return s.accumulator = n, s._seed = r, s.hasSeed = i, s.index = 0, s } return i(e, t), Object.defineProperty(e.prototype, "seed", { get: function () { return this._seed }, set: function (t) { this.hasSeed = !0, this._seed = t }, enumerable: !0, configurable: !0 }), e.prototype._next = function (t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) }, e.prototype._tryNext = function (t) { var e, n = this.index++; try { e = this.accumulator(this.seed, t, n) } catch (r) { this.destination.error(r) } this.seed = e, this.destination.next(e) }, e }(s.Subscriber) }, 1589: function (t, e, n) { "use strict"; var r, i = this && this.__extends || (r = function (t, e) { return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]) })(t, e) }, function (t, e) { function n() { this.constructor = t } r(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n) }); Object.defineProperty(e, "__esModule", { value: !0 }); var s = n(7241), o = n(2974), a = n(9941); e.takeLast = function (t) { return function (e) { return 0 === t ? a.empty() : e.lift(new l(t)) } }; var l = function () { function t(t) { if (this.total = t, this.total < 0) throw new o.ArgumentOutOfRangeError } return t.prototype.call = function (t, e) { return e.subscribe(new c(t, this.total)) }, t }(), c = function (t) { function e(e, n) { var r = t.call(this, e) || this; return r.total = n, r.ring = new Array, r.count = 0, r } return i(e, t), e.prototype._next = function (t) { var e = this.ring, n = this.total, r = this.count++; e.length < n ? e.push(t) : e[r % n] = t }, e.prototype._complete = function () { var t = this.destination, e = this.count; if (e > 0) for (var n = this.count >= this.total ? this.total : this.count, r = this.ring, i = 0; i < n; i++) { var s = e++ % n; t.next(r[s]) } t.complete() }, e }(s.Subscriber) }, 6232: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.observable = "function" == typeof Symbol && Symbol.observable || "@@observable" }, 1476: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.rxSubscriber = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random(), e.$$rxSubscriber = e.rxSubscriber }, 2974: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n = function () { function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t }(); e.ArgumentOutOfRangeError = n }, 8574: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var n = function () { function t(t) { return Error.call(this), this.message = t ? t.length + " errors occurred during unsubscription:\n" + t.map(function (t, e) { return e + 1 + ") " + t.toString() }).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t }(); e.UnsubscriptionError = n }, 5730: (t, e, n) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var r = n(7241); e.canReportError = function (t) { for (; t;) { var e = t.destination; if (t.closed || t.isStopped) return !1; t = e && e instanceof r.Subscriber ? e : null } return !0 } }, 2434: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.hostReportError = function (t) { setTimeout(function () { throw t }, 0) } }, 2516: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.identity = function (t) { return t } }, 993: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.isArray = Array.isArray || function (t) { return t && "number" == typeof t.length } }, 7382: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.isFunction = function (t) { return "function" == typeof t } }, 4720: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.isObject = function (t) { return null !== t && "object" == typeof t } }, 3915: (t, e, n) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var r = n(2516); function i(t) { return 0 === t.length ? r.identity : 1 === t.length ? t[0] : function (e) { return t.reduce(function (t, e) { return e(t) }, e) } } e.pipe = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return i(t) }, e.pipeFromArray = i }, 7104: (t, e, n) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var r = n(7241), i = n(1476), s = n(6011); e.toSubscriber = function (t, e, n) { if (t) { if (t instanceof r.Subscriber) return t; if (t[i.rxSubscriber]) return t[i.rxSubscriber]() } return t || e || n ? new r.Subscriber(t, e, n) : new r.Subscriber(s.empty) } }, 7385: (t, e, n) => { "use strict"; var r = n(1637); t.exports = function (t, e, n) { if (t === e) return !0; var i = r.parse(t, !1, !0), s = r.parse(e, !1, !0), o = { proto: i.protocol === s.protocol, hostname: i.hostname === s.hostname, port: (0 | i.port || ("https" === i.protocol ? 443 : 80)) === (0 | s.port || ("https" === s.protocol ? 443 : 80)) }; return o.proto && o.hostname && (o.port || n) } }, 1637: t => { "use strict"; var e = /^(?:(?:(?:([^:\/#\?]+:)?(?:(?:\/\/)((?:((?:[^:@\/#\?]+)(?:\:(?:[^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((?:\/?(?:[^\/\?#]+\/+)*)(?:[^\?#]*)))?(\?[^#]+)?)(#.*)?/; t.exports = { regex: e, parse: function (t) { var n = e.exec(t); return n ? { protocol: (n[1] || "").toLowerCase() || void 0, hostname: (n[5] || "").toLowerCase() || void 0, port: n[6] || void 0 } : {} } } }, 1719: function (t) { "use strict"; !function (e) { const n = 2147483647; function r(t) { const e = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]); let n = 1779033703, r = 3144134277, i = 1013904242, s = 2773480762, o = 1359893119, a = 2600822924, l = 528734635, c = 1541459225; const u = new Uint32Array(64); function h(t) { let h = 0, d = t.length; for (; d >= 64;) { let p, f, m, g, v, y = n, b = r, _ = i, w = s, S = o, x = a, T = l, E = c; for (f = 0; f < 16; f++)m = h + 4 * f, u[f] = (255 & t[m]) << 24 | (255 & t[m + 1]) << 16 | (255 & t[m + 2]) << 8 | 255 & t[m + 3]; for (f = 16; f < 64; f++)p = u[f - 2], g = (p >>> 17 | p << 15) ^ (p >>> 19 | p << 13) ^ p >>> 10, p = u[f - 15], v = (p >>> 7 | p << 25) ^ (p >>> 18 | p << 14) ^ p >>> 3, u[f] = (g + u[f - 7] | 0) + (v + u[f - 16] | 0) | 0; for (f = 0; f < 64; f++)g = (((S >>> 6 | S << 26) ^ (S >>> 11 | S << 21) ^ (S >>> 25 | S << 7)) + (S & x ^ ~S & T) | 0) + (E + (e[f] + u[f] | 0) | 0) | 0, v = ((y >>> 2 | y << 30) ^ (y >>> 13 | y << 19) ^ (y >>> 22 | y << 10)) + (y & b ^ y & _ ^ b & _) | 0, E = T, T = x, x = S, S = w + g | 0, w = _, _ = b, b = y, y = g + v | 0; n = n + y | 0, r = r + b | 0, i = i + _ | 0, s = s + w | 0, o = o + S | 0, a = a + x | 0, l = l + T | 0, c = c + E | 0, h += 64, d -= 64 } } h(t); let d, p = t.length % 64, f = t.length / 536870912 | 0, m = t.length << 3, g = p < 56 ? 56 : 120, v = t.slice(t.length - p, t.length); for (v.push(128), d = p + 1; d < g; d++)v.push(0); return v.push(f >>> 24 & 255), v.push(f >>> 16 & 255), v.push(f >>> 8 & 255), v.push(f >>> 0 & 255), v.push(m >>> 24 & 255), v.push(m >>> 16 & 255), v.push(m >>> 8 & 255), v.push(m >>> 0 & 255), h(v), [n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, n >>> 0 & 255, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, r >>> 0 & 255, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, i >>> 0 & 255, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, s >>> 0 & 255, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, o >>> 0 & 255, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, a >>> 0 & 255, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, l >>> 0 & 255, c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, c >>> 0 & 255] } function i(t, e, n) { t = t.length <= 64 ? t : r(t); const i = 64 + e.length + 4, s = new Array(i), o = new Array(64); let a, l = []; for (a = 0; a < 64; a++)s[a] = 54; for (a = 0; a < t.length; a++)s[a] ^= t[a]; for (a = 0; a < e.length; a++)s[64 + a] = e[a]; for (a = i - 4; a < i; a++)s[a] = 0; for (a = 0; a < 64; a++)o[a] = 92; for (a = 0; a < t.length; a++)o[a] ^= t[a]; function c() { for (let t = i - 1; t >= i - 4; t--) { if (s[t]++, s[t] <= 255) return; s[t] = 0 } } for (; n >= 32;)c(), l = l.concat(r(o.concat(r(s)))), n -= 32; return n > 0 && (c(), l = l.concat(r(o.concat(r(s))).slice(0, n))), l } function s(t, e, n, r, i) { let s; for (c(t, 16 * (2 * n - 1), i, 0, 16), s = 0; s < 2 * n; s++)l(t, 16 * s, i, 16), a(i, r), c(i, 0, t, e + 16 * s, 16); for (s = 0; s < n; s++)c(t, e + 2 * s * 16, t, 16 * s, 16); for (s = 0; s < n; s++)c(t, e + 16 * (2 * s + 1), t, 16 * (s + n), 16) } function o(t, e) { return t << e | t >>> 32 - e } function a(t, e) { c(t, 0, e, 0, 16); for (let n = 8; n > 0; n -= 2)e[4] ^= o(e[0] + e[12], 7), e[8] ^= o(e[4] + e[0], 9), e[12] ^= o(e[8] + e[4], 13), e[0] ^= o(e[12] + e[8], 18), e[9] ^= o(e[5] + e[1], 7), e[13] ^= o(e[9] + e[5], 9), e[1] ^= o(e[13] + e[9], 13), e[5] ^= o(e[1] + e[13], 18), e[14] ^= o(e[10] + e[6], 7), e[2] ^= o(e[14] + e[10], 9), e[6] ^= o(e[2] + e[14], 13), e[10] ^= o(e[6] + e[2], 18), e[3] ^= o(e[15] + e[11], 7), e[7] ^= o(e[3] + e[15], 9), e[11] ^= o(e[7] + e[3], 13), e[15] ^= o(e[11] + e[7], 18), e[1] ^= o(e[0] + e[3], 7), e[2] ^= o(e[1] + e[0], 9), e[3] ^= o(e[2] + e[1], 13), e[0] ^= o(e[3] + e[2], 18), e[6] ^= o(e[5] + e[4], 7), e[7] ^= o(e[6] + e[5], 9), e[4] ^= o(e[7] + e[6], 13), e[5] ^= o(e[4] + e[7], 18), e[11] ^= o(e[10] + e[9], 7), e[8] ^= o(e[11] + e[10], 9), e[9] ^= o(e[8] + e[11], 13), e[10] ^= o(e[9] + e[8], 18), e[12] ^= o(e[15] + e[14], 7), e[13] ^= o(e[12] + e[15], 9), e[14] ^= o(e[13] + e[12], 13), e[15] ^= o(e[14] + e[13], 18); for (let n = 0; n < 16; ++n)t[n] += e[n] } function l(t, e, n, r) { for (let i = 0; i < r; i++)n[i] ^= t[e + i] } function c(t, e, n, r, i) { for (; i--;)n[r++] = t[e++] } function u(t) { if (!t || "number" != typeof t.length) return !1; for (let e = 0; e < t.length; e++) { const n = t[e]; if ("number" != typeof n || n % 1 || n < 0 || n >= 256) return !1 } return !0 } function h(t, e) { if ("number" != typeof t || t % 1) throw new Error("invalid " + e); return t } function d(t, e, r, o, a, d, p) { if (r = h(r, "N"), o = h(o, "r"), a = h(a, "p"), d = h(d, "dkLen"), 0 === r || 0 != (r & r - 1)) throw new Error("N must be power of 2"); if (r > n / 128 / o) throw new Error("N too large"); if (o > n / 128 / a) throw new Error("r too large"); if (!u(t)) throw new Error("password must be an array or buffer"); if (t = Array.prototype.slice.call(t), !u(e)) throw new Error("salt must be an array or buffer"); e = Array.prototype.slice.call(e); let f = i(t, e, 128 * a * o); const m = new Uint32Array(32 * a * o); for (let n = 0; n < m.length; n++) { const t = 4 * n; m[n] = (255 & f[t + 3]) << 24 | (255 & f[t + 2]) << 16 | (255 & f[t + 1]) << 8 | (255 & f[t + 0]) << 0 } const g = new Uint32Array(64 * o), v = new Uint32Array(32 * o * r), y = 32 * o, b = new Uint32Array(16), _ = new Uint32Array(16), w = a * r * 2; let S, x, T = 0, E = null, M = !1, A = 0, C = 0; const P = p ? parseInt(1e3 / o) : 4294967295, R = "undefined" != typeof setImmediate ? setImmediate : setTimeout, L = function () { if (M) return p(new Error("cancelled"), T / w); let e; switch (A) { case 0: x = 32 * C * o, c(m, x, g, 0, y), A = 1, S = 0; case 1: e = r - S, e > P && (e = P); for (let t = 0; t < e; t++)c(g, 0, v, (S + t) * y, y), s(g, y, o, b, _); if (S += e, T += e, p) { const t = parseInt(1e3 * T / w); if (t !== E) { if (M = p(null, T / w), M) break; E = t } } if (S < r) break; S = 0, A = 2; case 2: e = r - S, e > P && (e = P); for (let t = 0; t < e; t++)l(v, (g[16 * (2 * o - 1)] & r - 1) * y, g, y), s(g, y, o, b, _); if (S += e, T += e, p) { const t = parseInt(1e3 * T / w); if (t !== E) { if (M = p(null, T / w), M) break; E = t } } if (S < r) break; if (c(g, 0, m, x, y), C++, C < a) { A = 0; break } f = []; for (let t = 0; t < m.length; t++)f.push(m[t] >> 0 & 255), f.push(m[t] >> 8 & 255), f.push(m[t] >> 16 & 255), f.push(m[t] >> 24 & 255); const n = i(t, f, d); return p && p(null, 1, n), n }p && R(L) }; if (!p) for (; ;) { const t = L(); if (null != t) return t } L() } t.exports = { scrypt: function (t, e, n, r, i, s, o) { return new Promise(function (a, l) { let c = 0; o && o(0), d(t, e, n, r, i, s, function (t, e, n) { if (t) l(t); else if (n) o && 1 !== c && o(1), a(new Uint8Array(n)); else if (o && e !== c) return c = e, o(e) }) }) }, syncScrypt: function (t, e, n, r, i, s) { return new Uint8Array(d(t, e, n, r, i, s)) } } }() }, 2135: (t, e, n) => { "use strict"; var r = n(465), i = n(6959), s = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/, o = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i, a = new RegExp("^[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+"); function l(t) { return (t || "").toString().replace(a, "") } var c = [["#", "hash"], ["?", "query"], function (t) { return t.replace("\\", "/") }, ["/", "pathname"], ["@", "auth", 1], [NaN, "host", void 0, 1, 1], [/:(\d+)$/, "port", void 0, 1], [NaN, "hostname", void 0, 1, 1]], u = { hash: 1, query: 1 }; function h(t) { var e; e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; var n, r = {}, i = typeof (t = t || e.location || {}); if ("blob:" === t.protocol) r = new p(unescape(t.pathname), {}); else if ("string" === i) for (n in r = new p(t, {}), u) delete r[n]; else if ("object" === i) { for (n in t) n in u || (r[n] = t[n]); void 0 === r.slashes && (r.slashes = s.test(t.href)) } return r } function d(t) { t = l(t); var e = o.exec(t); return { protocol: e[1] ? e[1].toLowerCase() : "", slashes: !!(e[2] && e[2].length >= 2), rest: e[2] && 1 === e[2].length ? "/" + e[3] : e[3] } } function p(t, e, n) { if (t = l(t), !(this instanceof p)) return new p(t, e, n); var s, o, a, u, f, m, g = c.slice(), v = typeof e, y = this, b = 0; for ("object" !== v && "string" !== v && (n = e, e = null), n && "function" != typeof n && (n = i.parse), e = h(e), s = !(o = d(t || "")).protocol && !o.slashes, y.slashes = o.slashes || s && e.slashes, y.protocol = o.protocol || e.protocol || "", t = o.rest, o.slashes || (g[3] = [/(.*)/, "pathname"]); b < g.length; b++)"function" != typeof (u = g[b]) ? (m = u[1], (a = u[0]) != a ? y[m] = t : "string" == typeof a ? ~(f = t.indexOf(a)) && ("number" == typeof u[2] ? (y[m] = t.slice(0, f), t = t.slice(f + u[2])) : (y[m] = t.slice(f), t = t.slice(0, f))) : (f = a.exec(t)) && (y[m] = f[1], t = t.slice(0, f.index)), y[m] = y[m] || s && u[3] && e[m] || "", u[4] && (y[m] = y[m].toLowerCase())) : t = u(t); n && (y.query = n(y.query)), s && e.slashes && "/" !== y.pathname.charAt(0) && ("" !== y.pathname || "" !== e.pathname) && (y.pathname = function (t, e) { if ("" === t) return e; for (var n = (e || "/").split("/").slice(0, -1).concat(t.split("/")), r = n.length, i = n[r - 1], s = !1, o = 0; r--;)"." === n[r] ? n.splice(r, 1) : ".." === n[r] ? (n.splice(r, 1), o++) : o && (0 === r && (s = !0), n.splice(r, 1), o--); return s && n.unshift(""), "." !== i && ".." !== i || n.push(""), n.join("/") }(y.pathname, e.pathname)), "/" !== y.pathname.charAt(0) && y.hostname && (y.pathname = "/" + y.pathname), r(y.port, y.protocol) || (y.host = y.hostname, y.port = ""), y.username = y.password = "", y.auth && (u = y.auth.split(":"), y.username = u[0] || "", y.password = u[1] || ""), y.origin = y.protocol && y.host && "file:" !== y.protocol ? y.protocol + "//" + y.host : "null", y.href = y.toString() } p.prototype = { set: function (t, e, n) { var s = this; switch (t) { case "query": "string" == typeof e && e.length && (e = (n || i.parse)(e)), s[t] = e; break; case "port": s[t] = e, r(e, s.protocol) ? e && (s.host = s.hostname + ":" + e) : (s.host = s.hostname, s[t] = ""); break; case "hostname": s[t] = e, s.port && (e += ":" + s.port), s.host = e; break; case "host": s[t] = e, /:\d+$/.test(e) ? (e = e.split(":"), s.port = e.pop(), s.hostname = e.join(":")) : (s.hostname = e, s.port = ""); break; case "protocol": s.protocol = e.toLowerCase(), s.slashes = !n; break; case "pathname": case "hash": if (e) { var o = "pathname" === t ? "/" : "#"; s[t] = e.charAt(0) !== o ? o + e : e } else s[t] = e; break; default: s[t] = e }for (var a = 0; a < c.length; a++) { var l = c[a]; l[4] && (s[l[1]] = s[l[1]].toLowerCase()) } return s.origin = s.protocol && s.host && "file:" !== s.protocol ? s.protocol + "//" + s.host : "null", s.href = s.toString(), s }, toString: function (t) { t && "function" == typeof t || (t = i.stringify); var e, n = this, r = n.protocol; r && ":" !== r.charAt(r.length - 1) && (r += ":"); var s = r + (n.slashes ? "//" : ""); return n.username && (s += n.username, n.password && (s += ":" + n.password), s += "@"), s += n.host + n.pathname, (e = "object" == typeof n.query ? t(n.query) : n.query) && (s += "?" !== e.charAt(0) ? "?" + e : e), n.hash && (s += n.hash), s } }, p.extractProtocol = d, p.location = h, p.trimLeft = l, p.qs = i, t.exports = p }, 4075: (t, e, n) => { "use strict"; var r = {}; function i(t) { return "function" == typeof t } n.r(r), n.d(r, { AsyncCompress: () => HB, AsyncDecompress: () => eH, AsyncDeflate: () => LB, AsyncGunzip: () => zB, AsyncGzip: () => HB, AsyncInflate: () => OB, AsyncUnzipInflate: () => CH, AsyncUnzlib: () => YB, AsyncZipDeflate: () => SH, AsyncZlib: () => WB, Compress: () => BB, DecodeUTF8: () => cH, Decompress: () => tH, Deflate: () => RB, EncodeUTF8: () => uH, Gunzip: () => VB, Gzip: () => BB, Inflate: () => IB, Unzip: () => PH, UnzipInflate: () => AH, UnzipPassThrough: () => MH, Unzlib: () => KB, Zip: () => xH, ZipDeflate: () => wH, ZipPassThrough: () => _H, Zlib: () => XB, compress: () => UB, compressSync: () => GB, decompress: () => nH, decompressSync: () => rH, deflate: () => kB, deflateSync: () => DB, gunzip: () => jB, gunzipSync: () => JB, gzip: () => UB, gzipSync: () => GB, inflate: () => FB, inflateSync: () => NB, strFromU8: () => dH, strToU8: () => hH, unzip: () => RH, unzipSync: () => LH, unzlib: () => QB, unzlibSync: () => $B, zip: () => TH, zipSync: () => EH, zlib: () => qB, zlibSync: () => ZB }); let s = !1; const o = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3"); s = t }, get useDeprecatedSynchronousErrorHandling() { return s } }; function a(t) { setTimeout(() => { throw t }, 0) } const l = { closed: !0, next(t) { }, error(t) { if (o.useDeprecatedSynchronousErrorHandling) throw t; a(t) }, complete() { } }, c = Array.isArray || (t => t && "number" == typeof t.length); function u(t) { return null !== t && "object" == typeof t } const h = (() => { function t(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t })(); class d { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._ctorUnsubscribe = !0, this._unsubscribe = t) } unsubscribe() { let t; if (this.closed) return; let { _parentOrParents: e, _ctorUnsubscribe: n, _unsubscribe: r, _subscriptions: s } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, e instanceof d) e.remove(this); else if (null !== e) for (let i = 0; i < e.length; ++i)e[i].remove(this); if (i(r)) { n && (this._unsubscribe = void 0); try { r.call(this) } catch (o) { t = o instanceof h ? p(o.errors) : [o] } } if (c(s)) { let e = -1, n = s.length; for (; ++e < n;) { const n = s[e]; if (u(n)) try { n.unsubscribe() } catch (o) { t = t || [], o instanceof h ? t = t.concat(p(o.errors)) : t.push(o) } } } if (t) throw new h(t) } add(t) { let e = t; if (!t) return d.EMPTY; switch (typeof t) { case "function": e = new d(t); case "object": if (e === this || e.closed || "function" != typeof e.unsubscribe) return e; if (this.closed) return e.unsubscribe(), e; if (!(e instanceof d)) { const t = e; e = new d, e._subscriptions = [t] } break; default: throw new Error("unrecognized teardown " + t + " added to Subscription.") }let { _parentOrParents: n } = e; if (null === n) e._parentOrParents = this; else if (n instanceof d) { if (n === this) return e; e._parentOrParents = [n, this] } else { if (-1 !== n.indexOf(this)) return e; n.push(this) } const r = this._subscriptions; return null === r ? this._subscriptions = [e] : r.push(e), e } remove(t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } } } function p(t) { return t.reduce((t, e) => t.concat(e instanceof h ? e.errors : e), []) } d.EMPTY = function (t) { return t.closed = !0, t }(new d); const f = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random(); class m extends d { constructor(t, e, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = l; break; case 1: if (!t) { this.destination = l; break } if ("object" == typeof t) { t instanceof m ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new g(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new g(this, t, e, n) } } [f]() { return this } static create(t, e, n) { const r = new m(t, e, n); return r.syncErrorThrowable = !1, r } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class g extends m { constructor(t, e, n, r) { let s; super(), this._parentSubscriber = t; let o = this; i(e) ? s = e : e && (s = e.next, n = e.error, r = e.complete, e !== l && (o = Object.create(e), i(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = s, this._error = n, this._complete = r } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; o.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: n } = o; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : a(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; a(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); o.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), o.useDeprecatedSynchronousErrorHandling) throw n; a(n) } } __tryOrSetError(t, e, n) { if (!o.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (r) { return o.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = r, t.syncErrorThrown = !0, !0) : (a(r), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const v = "function" == typeof Symbol && Symbol.observable || "@@observable"; function y(t) { return t } function b(...t) { return _(t) } function _(t) { return 0 === t.length ? y : 1 === t.length ? t[0] : function (e) { return t.reduce((t, e) => e(t), e) } } let w = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } subscribe(t, e, n) { const { operator: r } = this, i = function (t, e, n) { if (t) { if (t instanceof m) return t; if (t[f]) return t[f]() } return t || e || n ? new m(t, e, n) : new m(l) }(t, e, n); if (i.add(r ? r.call(i, this.source) : this.source || o.useDeprecatedSynchronousErrorHandling && !i.syncErrorThrowable ? this._subscribe(i) : this._trySubscribe(i)), o.useDeprecatedSynchronousErrorHandling && i.syncErrorThrowable && (i.syncErrorThrowable = !1, i.syncErrorThrown)) throw i.syncErrorValue; return i } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { o.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: n, isStopped: r } = t; if (e || r) return !1; t = n && n instanceof m ? n : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = S(e))((e, n) => { let r; r = this.subscribe(e => { try { t(e) } catch (i) { n(i), r && r.unsubscribe() } }, n, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [v]() { return this } pipe(...t) { return 0 === t.length ? this : _(t)(this) } toPromise(t) { return new (t = S(t))((t, e) => { let n; this.subscribe(t => n = t, t => e(t), () => t(n)) }) } } return t.create = e => new t(e), t })(); function S(t) { if (t || (t = o.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } const x = (() => { function t() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return t.prototype = Object.create(Error.prototype), t })(); class T extends d { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const n = e.indexOf(this.subscriber); -1 !== n && e.splice(n, 1) } } class E extends m { constructor(t) { super(t), this.destination = t } } let M = (() => { class t extends w { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [f]() { return new E(this) } lift(t) { const e = new A(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new x; if (!this.isStopped) { const { observers: e } = this, n = e.length, r = e.slice(); for (let i = 0; i < n; i++)r[i].next(t) } } error(t) { if (this.closed) throw new x; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, n = e.length, r = e.slice(); for (let i = 0; i < n; i++)r[i].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new x; this.isStopped = !0; const { observers: t } = this, e = t.length, n = t.slice(); for (let r = 0; r < e; r++)n[r].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new x; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new x; return this.hasError ? (t.error(this.thrownError), d.EMPTY) : this.isStopped ? (t.complete(), d.EMPTY) : (this.observers.push(t), new T(this, t)) } asObservable() { const t = new w; return t.source = this, t } } return t.create = (t, e) => new A(t, e), t })(); class A extends M { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : d.EMPTY } } function C(t) { return t && "function" == typeof t.schedule } function P(t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new R(t, e)) } } class R { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new L(t, this.project, this.thisArg)) } } class L extends m { constructor(t, e, n) { super(t), this.project = e, this.count = 0, this.thisArg = n || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } const k = t => e => { for (let n = 0, r = t.length; n < r && !e.closed; n++)e.next(t[n]); e.complete() }, D = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator", I = t => t && "number" == typeof t.length && "function" != typeof t; function O(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } const F = t => { if (t && "function" == typeof t[v]) return n = t, t => { const e = n[v](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) }; if (I(t)) return k(t); if (O(t)) return (t => e => (t.then(t => { e.closed || (e.next(t), e.complete()) }, t => e.error(t)).then(null, a), e))(t); if (t && "function" == typeof t[D]) return e = t, t => { const n = e[D](); for (; ;) { let e; try { e = n.next() } catch (r) { return t.error(r), t } if (e.done) { t.complete(); break } if (t.next(e.value), t.closed) break } return "function" == typeof n.return && t.add(() => { n.return && n.return() }), t }; { const e = u(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`) } var e, n }; function N(t, e) { return new w(n => { const r = new d; let i = 0; return r.add(e.schedule(function () { i !== t.length ? (n.next(t[i++]), n.closed || r.add(this.schedule())) : n.complete() })), r }) } function B(t, e) { return e ? function (t, e) { if (null != t) { if (function (t) { return t && "function" == typeof t[v] }(t)) return function (t, e) { return new w(n => { const r = new d; return r.add(e.schedule(() => { const i = t[v](); r.add(i.subscribe({ next(t) { r.add(e.schedule(() => n.next(t))) }, error(t) { r.add(e.schedule(() => n.error(t))) }, complete() { r.add(e.schedule(() => n.complete())) } })) })), r }) }(t, e); if (O(t)) return function (t, e) { return new w(n => { const r = new d; return r.add(e.schedule(() => t.then(t => { r.add(e.schedule(() => { n.next(t), r.add(e.schedule(() => n.complete())) })) }, t => { r.add(e.schedule(() => n.error(t))) }))), r }) }(t, e); if (I(t)) return N(t, e); if (function (t) { return t && "function" == typeof t[D] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new w(n => { const r = new d; let i; return r.add(() => { i && "function" == typeof i.return && i.return() }), r.add(e.schedule(() => { i = t[D](), r.add(e.schedule(function () { if (n.closed) return; let t, e; try { const n = i.next(); t = n.value, e = n.done } catch (r) { return void n.error(r) } e ? n.complete() : (n.next(t), this.schedule()) })) })), r }) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") }(t, e) : t instanceof w ? t : new w(F(t)) } class H extends m { constructor(t) { super(), this.parent = t } _next(t) { this.parent.notifyNext(t) } _error(t) { this.parent.notifyError(t), this.unsubscribe() } _complete() { this.parent.notifyComplete(), this.unsubscribe() } } class U extends m { notifyNext(t) { this.destination.next(t) } notifyError(t) { this.destination.error(t) } notifyComplete() { this.destination.complete() } } function G(t, e) { if (e.closed) return; if (t instanceof w) return t.subscribe(e); let n; try { n = F(t)(e) } catch (r) { e.error(r) } return n } function V(t, e, n = Number.POSITIVE_INFINITY) { return "function" == typeof e ? r => r.pipe(V((n, r) => B(t(n, r)).pipe(P((t, i) => e(n, t, r, i))), n)) : ("number" == typeof e && (n = e), e => e.lift(new z(t, n))) } class z { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new j(t, this.project, this.concurrent)) } } class j extends U { constructor(t, e, n = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this.active++, this._innerSub(e) } _innerSub(t) { const e = new H(this), n = this.destination; n.add(e); const r = G(t, e); r !== e && n.add(r) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t) { this.destination.next(t) } notifyComplete() { const t = this.buffer; this.active--, t.length > 0 ? this._next(t.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function J(t = Number.POSITIVE_INFINITY) { return V(y, t) } function X(t, e) { return e ? N(t, e) : new w(k(t)) } function W(...t) { let e = Number.POSITIVE_INFINITY, n = null, r = t[t.length - 1]; return C(r) ? (n = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof r && (e = t.pop()), null === n && 1 === t.length && t[0] instanceof w ? t[0] : J(e)(X(t, n)) } function q() { return function (t) { return t.lift(new Z(t)) } } class Z { constructor(t) { this.connectable = t } call(t, e) { const { connectable: n } = this; n._refCount++; const r = new K(t, n), i = e.subscribe(r); return r.closed || (r.connection = n.connect()), i } } class K extends m { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: n } = this, r = t._connection; this.connection = null, !r || n && r !== n || r.unsubscribe() } } class Y extends w { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new d, t.add(this.source.subscribe(new $(this.getSubject(), this))), t.closed && (this._connection = null, t = d.EMPTY)), t } refCount() { return q()(this) } } const Q = (() => { const t = Y.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: t._subscribe }, _isComplete: { value: t._isComplete, writable: !0 }, getSubject: { value: t.getSubject }, connect: { value: t.connect }, refCount: { value: t.refCount } } })(); class $ extends E { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } function tt() { return new M } function et() { return t => { return q()((e = tt, function (t) { let n; n = "function" == typeof e ? e : function () { return e }; const r = Object.create(t, Q); return r.source = t, r.subjectFactory = n, r })(t)); var e } } function nt(t) { for (let e in t) if (t[e] === nt) return e; throw Error("Could not find renamed property on target object.") } function rt(t, e) { for (const n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]) } function it(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(it).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function st(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const ot = nt({ __forward_ref__: nt }); function at(t) { return t.__forward_ref__ = at, t.toString = function () { return it(this()) }, t } function lt(t) { return ct(t) ? t() : t } function ct(t) { return "function" == typeof t && t.hasOwnProperty(ot) && t.__forward_ref__ === at } class ut extends Error { constructor(t, e) { super(function (t, e) { return `${t ? `NG0${t}: ` : ""}${e}` }(t, e)), this.code = t } } function ht(t) { return "string" == typeof t ? t : null == t ? "" : String(t) } function dt(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : ht(t) } function pt(t, e) { const n = e ? ` in ${e}` : ""; throw new ut("201", `No provider for ${dt(t)} found${n}`) } function ft(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function mt(t) { return { providers: t.providers || [], imports: t.imports || [] } } function gt(t) { return vt(t, bt) || vt(t, wt) } function vt(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function yt(t) { return t && (t.hasOwnProperty(_t) || t.hasOwnProperty(St)) ? t[_t] : null } const bt = nt({ "\u0275prov": nt }), _t = nt({ "\u0275inj": nt }), wt = nt({ ngInjectableDef: nt }), St = nt({ ngInjectorDef: nt }); var xt = (() => ((xt = xt || {})[xt.Default = 0] = "Default", xt[xt.Host = 1] = "Host", xt[xt.Self = 2] = "Self", xt[xt.SkipSelf = 4] = "SkipSelf", xt[xt.Optional = 8] = "Optional", xt))(); let Tt; function Et(t) { const e = Tt; return Tt = t, e } function Mt(t, e, n) { const r = gt(t); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & xt.Optional ? null : void 0 !== e ? e : void pt(it(t), "Injector") } function At(t) { return { toString: t }.toString() } var Ct = (() => ((Ct = Ct || {})[Ct.OnPush = 0] = "OnPush", Ct[Ct.Default = 1] = "Default", Ct))(), Pt = (() => ((Pt = Pt || {})[Pt.Emulated = 0] = "Emulated", Pt[Pt.None = 2] = "None", Pt[Pt.ShadowDom = 3] = "ShadowDom", Pt))(); const Rt = "undefined" != typeof globalThis && globalThis, Lt = "undefined" != typeof window && window, kt = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, Dt = "undefined" != typeof global && global, It = Rt || Dt || Lt || kt, Ot = {}, Ft = [], Nt = nt({ "\u0275cmp": nt }), Bt = nt({ "\u0275dir": nt }), Ht = nt({ "\u0275pipe": nt }), Ut = nt({ "\u0275mod": nt }), Gt = nt({ "\u0275loc": nt }), Vt = nt({ "\u0275fac": nt }), zt = nt({ __NG_ELEMENT_ID__: nt }); let jt = 0; function Jt(t) { return At(() => { const e = {}, n = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === Ct.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || Ft, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || Pt.Emulated, id: "c", styles: t.styles || Ft, _: null, setInput: null, schemas: t.schemas || null, tView: null }, r = t.directives, i = t.features, s = t.pipes; return n.id += jt++, n.inputs = Kt(t.inputs, e), n.outputs = Kt(t.outputs), i && i.forEach(t => t(n)), n.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(Xt) : null, n.pipeDefs = s ? () => ("function" == typeof s ? s() : s).map(Wt) : null, n }) } function Xt(t) { return $t(t) || function (t) { return t[Bt] || null }(t) } function Wt(t) { return function (t) { return t[Ht] || null }(t) } const qt = {}; function Zt(t) { return At(() => { const e = { type: t.type, bootstrap: t.bootstrap || Ft, declarations: t.declarations || Ft, imports: t.imports || Ft, exports: t.exports || Ft, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && (qt[t.id] = t.type), e }) } function Kt(t, e) { if (null == t) return Ot; const n = {}; for (const r in t) if (t.hasOwnProperty(r)) { let i = t[r], s = i; Array.isArray(i) && (s = i[1], i = i[0]), n[i] = r, e && (e[i] = s) } return n } const Yt = Jt; function Qt(t) { return { type: t.type, name: t.name, factory: null, pure: !1 !== t.pure, onDestroy: t.type.prototype.ngOnDestroy || null } } function $t(t) { return t[Nt] || null } function te(t, e) { const n = t[Ut] || null; if (!n && !0 === e) throw new Error(`Type ${it(t)} does not have '\u0275mod' property.`); return n } const ee = 20, ne = 10; function re(t) { return Array.isArray(t) && "object" == typeof t[1] } function ie(t) { return Array.isArray(t) && !0 === t[1] } function se(t) { return 0 != (8 & t.flags) } function oe(t) { return 2 == (2 & t.flags) } function ae(t) { return 1 == (1 & t.flags) } function le(t) { return null !== t.template } function ce(t, e) { return t.hasOwnProperty(Vt) ? t[Vt] : null } class ue { constructor(t, e, n) { this.previousValue = t, this.currentValue = e, this.firstChange = n } isFirstChange() { return this.firstChange } } function he() { return de } function de(t) { return t.type.prototype.ngOnChanges && (t.setInput = fe), pe } function pe() { const t = me(this), e = null == t ? void 0 : t.current; if (e) { const n = t.previous; if (n === Ot) t.previous = e; else for (let t in e) n[t] = e[t]; t.current = null, this.ngOnChanges(e) } } function fe(t, e, n, r) { const i = me(t) || function (t, e) { return t.__ngSimpleChanges__ = e }(t, { previous: Ot, current: null }), s = i.current || (i.current = {}), o = i.previous, a = this.declaredInputs[n], l = o[a]; s[a] = new ue(l && l.currentValue, e, o === Ot), t[r] = e } function me(t) { return t.__ngSimpleChanges__ || null } let ge; function ve() { return void 0 !== ge ? ge : "undefined" != typeof document ? document : void 0 } function ye(t) { return !!t.listen } he.ngInherit = !0; const be = { createRenderer: (t, e) => ve() }; function _e(t) { for (; Array.isArray(t);)t = t[0]; return t } function we(t, e) { return _e(e[t]) } function Se(t, e) { return _e(e[t.index]) } function xe(t, e) { return t.data[e] } function Te(t, e) { return t[e] } function Ee(t, e) { const n = e[t]; return re(n) ? n : n[0] } function Me(t) { return 4 == (4 & t[2]) } function Ae(t) { return 128 == (128 & t[2]) } function Ce(t, e) { return null == e ? null : t[e] } function Pe(t) { t[18] = 0 } function Re(t, e) { t[5] += e; let n = t, r = t[3]; for (; null !== r && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)r[5] += e, n = r, r = r[3] } const Le = { lFrame: nn(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function ke() { return Le.bindingsEnabled } function De() { return Le.lFrame.lView } function Ie() { return Le.lFrame.tView } function Oe(t) { return Le.lFrame.contextLView = t, t[8] } function Fe() { let t = Ne(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function Ne() { return Le.lFrame.currentTNode } function Be(t, e) { const n = Le.lFrame; n.currentTNode = t, n.isParent = e } function He() { return Le.lFrame.isParent } function Ue() { Le.lFrame.isParent = !1 } function Ge() { return Le.isInCheckNoChangesMode } function Ve(t) { Le.isInCheckNoChangesMode = t } function ze() { const t = Le.lFrame; let e = t.bindingRootIndex; return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e } function je() { return Le.lFrame.bindingIndex } function Je() { return Le.lFrame.bindingIndex++ } function Xe(t) { const e = Le.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n } function We(t, e) { const n = Le.lFrame; n.bindingIndex = n.bindingRootIndex = t, qe(e) } function qe(t) { Le.lFrame.currentDirectiveIndex = t } function Ze(t) { const e = Le.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] } function Ke() { return Le.lFrame.currentQueryIndex } function Ye(t) { Le.lFrame.currentQueryIndex = t } function Qe(t) { const e = t[1]; return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null } function $e(t, e, n) { if (n & xt.SkipSelf) { let r = e, i = t; for (; r = r.parent, !(null !== r || n & xt.Host || (r = Qe(i), null === r) || (i = i[15], 10 & r.type));); if (null === r) return !1; e = r, t = i } const r = Le.lFrame = en(); return r.currentTNode = e, r.lView = t, !0 } function tn(t) { const e = en(), n = t[1]; Le.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1 } function en() { const t = Le.lFrame, e = null === t ? null : t.child; return null === e ? nn(t) : e } function nn(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = e), e } function rn() { const t = Le.lFrame; return Le.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const sn = rn; function on() { const t = rn(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function an() { return Le.lFrame.selectedIndex } function ln(t) { Le.lFrame.selectedIndex = t } function cn() { const t = Le.lFrame; return xe(t.tView, t.selectedIndex) } function un(t, e) { for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) { const e = t.data[n].type.prototype, { ngAfterContentInit: r, ngAfterContentChecked: i, ngAfterViewInit: s, ngAfterViewChecked: o, ngOnDestroy: a } = e; r && (t.contentHooks || (t.contentHooks = [])).push(-n, r), i && ((t.contentHooks || (t.contentHooks = [])).push(n, i), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, i)), s && (t.viewHooks || (t.viewHooks = [])).push(-n, s), o && ((t.viewHooks || (t.viewHooks = [])).push(n, o), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, o)), null != a && (t.destroyHooks || (t.destroyHooks = [])).push(n, a) } } function hn(t, e, n) { fn(t, e, 3, n) } function dn(t, e, n, r) { (3 & t[2]) === n && fn(t, e, n, r) } function pn(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function fn(t, e, n, r) { const i = null != r ? r : -1, s = e.length - 1; let o = 0; for (let a = void 0 !== r ? 65535 & t[18] : 0; a < s; a++)if ("number" == typeof e[a + 1]) { if (o = e[a], null != r && o >= r) break } else e[a] < 0 && (t[18] += 65536), (o < i || -1 == i) && (mn(t, n, e, a), t[18] = (4294901760 & t[18]) + a + 2), a++ } function mn(t, e, n, r) { const i = n[r] < 0, s = n[r + 1], o = t[i ? -n[r] : n[r]]; if (i) { if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) { t[2] += 2048; try { s.call(o) } finally { } } } else try { s.call(o) } finally { } } const gn = -1; class vn { constructor(t, e, n) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = n } } function yn(t, e, n) { const r = ye(t); let i = 0; for (; i < n.length;) { const s = n[i]; if ("number" == typeof s) { if (0 !== s) break; i++; const o = n[i++], a = n[i++], l = n[i++]; r ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l) } else { const o = s, a = n[++i]; _n(o) ? r && t.setProperty(e, o, a) : r ? t.setAttribute(e, o, a) : e.setAttribute(o, a), i++ } } return i } function bn(t) { return 3 === t || 4 === t || 6 === t } function _n(t) { return 64 === t.charCodeAt(0) } function wn(t, e) { if (null === e || 0 === e.length); else if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let r = 0; r < e.length; r++) { const i = e[r]; "number" == typeof i ? n = i : 0 === n || Sn(t, n, i, null, -1 === n || 2 === n ? e[++r] : null) } } return t } function Sn(t, e, n, r, i) { let s = 0, o = t.length; if (-1 === e) o = -1; else for (; s < t.length;) { const n = t[s++]; if ("number" == typeof n) { if (n === e) { o = -1; break } if (n > e) { o = s - 1; break } } } for (; s < t.length;) { const e = t[s]; if ("number" == typeof e) break; if (e === n) { if (null === r) return void (null !== i && (t[s + 1] = i)); if (r === t[s + 1]) return void (t[s + 2] = i) } s++, null !== r && s++, null !== i && s++ } -1 !== o && (t.splice(o, 0, e), s = o + 1), t.splice(s++, 0, n), null !== r && t.splice(s++, 0, r), null !== i && t.splice(s++, 0, i) } function xn(t) { return t !== gn } function Tn(t) { return 32767 & t } function En(t, e) { let n = t >> 16, r = e; for (; n > 0;)r = r[15], n--; return r } let Mn = !0; function An(t) { const e = Mn; return Mn = t, e } let Cn = 0; function Pn(t, e) { const n = Ln(t, e); if (-1 !== n) return n; const r = e[1]; r.firstCreatePass && (t.injectorIndex = e.length, Rn(r.data, t), Rn(e, null), Rn(r.blueprint, null)); const i = kn(t, e), s = t.injectorIndex; if (xn(i)) { const t = Tn(i), n = En(i, e), r = n[1].data; for (let i = 0; i < 8; i++)e[s + i] = n[t + i] | r[t + i] } return e[s + 8] = i, s } function Rn(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Ln(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function kn(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = 0, r = null, i = e; for (; null !== i;) { const t = i[1], e = t.type; if (r = 2 === e ? t.declTNode : 1 === e ? i[6] : null, null === r) return gn; if (n++, i = i[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return gn } function Dn(t, e, n) { !function (t, e, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(zt) && (r = n[zt]), null == r && (r = n[zt] = Cn++); const i = 255 & r; e.data[t + (i >> 5)] |= 1 << i }(t, e, n) } function In(t, e, n) { if (n & xt.Optional) return t; pt(e, "NodeInjector") } function On(t, e, n, r) { if (n & xt.Optional && void 0 === r && (r = null), 0 == (n & (xt.Self | xt.Host))) { const i = t[9], s = Et(void 0); try { return i ? i.get(e, r, n & xt.Optional) : Mt(e, r, n & xt.Optional) } finally { Et(s) } } return In(r, e, n) } function Fn(t, e, n, r = xt.Default, i) { if (null !== t) { const s = function (t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(zt) ? t[zt] : void 0; return "number" == typeof e ? e >= 0 ? 255 & e : Bn : e }(n); if ("function" == typeof s) { if (!$e(e, t, r)) return r & xt.Host ? In(i, n, r) : On(e, n, r, i); try { const t = s(r); if (null != t || r & xt.Optional) return t; pt(n) } finally { sn() } } else if ("number" == typeof s) { let i = null, o = Ln(t, e), a = gn, l = r & xt.Host ? e[16][6] : null; for ((-1 === o || r & xt.SkipSelf) && (a = -1 === o ? kn(t, e) : e[o + 8], a !== gn && zn(r, !1) ? (i = e[1], o = Tn(a), e = En(a, e)) : o = -1); -1 !== o;) { const t = e[1]; if (Vn(s, o, t.data)) { const t = Hn(o, e, n, i, r, l); if (t !== Nn) return t } a = e[o + 8], a !== gn && zn(r, e[1].data[o + 8] === l) && Vn(s, o, e) ? (i = t, o = Tn(a), e = En(a, e)) : o = -1 } } } return On(e, n, r, i) } const Nn = {}; function Bn() { return new jn(Fe(), De()) } function Hn(t, e, n, r, i, s) { const o = e[1], a = o.data[t + 8], l = Un(a, o, n, null == r ? oe(a) && Mn : r != o && 0 != (3 & a.type), i & xt.Host && s === a); return null !== l ? Gn(e, o, l, a) : Nn } function Un(t, e, n, r, i) { const s = t.providerIndexes, o = e.data, a = 1048575 & s, l = t.directiveStart, c = s >> 20, u = i ? a + c : t.directiveEnd; for (let h = r ? a : a + c; h < u; h++) { const t = o[h]; if (h < l && n === t || h >= l && t.type === n) return h } if (i) { const t = o[l]; if (t && le(t) && t.type === n) return l } return null } function Gn(t, e, n, r) { let i = t[n]; const s = e.data; if (i instanceof vn) { const o = i; o.resolving && function (t, e) { throw new ut("200", `Circular dependency in DI detected for ${t}`) }(dt(s[n])); const a = An(o.canSeeViewProviders); o.resolving = !0; const l = o.injectImpl ? Et(o.injectImpl) : null; $e(t, r, xt.Default); try { i = t[n] = o.factory(void 0, s, t, r), e.firstCreatePass && n >= r.directiveStart && function (t, e, n) { const { ngOnChanges: r, ngOnInit: i, ngDoCheck: s } = e.type.prototype; if (r) { const r = de(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, r), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, r) } i && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, i), s && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, s)) }(n, s[n], e) } finally { null !== l && Et(l), An(a), o.resolving = !1, sn() } } return i } function Vn(t, e, n) { return !!(n[e + (t >> 5)] & 1 << t) } function zn(t, e) { return !(t & xt.Self || t & xt.Host && e) } class jn { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return Fn(this._tNode, this._lView, t, void 0, e) } } function Jn(t) { return At(() => { const e = t.prototype.constructor, n = e[Vt] || Xn(e), r = Object.prototype; let i = Object.getPrototypeOf(t.prototype).constructor; for (; i && i !== r;) { const t = i[Vt] || Xn(i); if (t && t !== n) return t; i = Object.getPrototypeOf(i) } return t => new t }) } function Xn(t) { return ct(t) ? () => { const e = Xn(lt(t)); return e && e() } : ce(t) } function Wn(t) { return function (t, e) { if ("class" === e) return t.classes; if ("style" === e) return t.styles; const n = t.attrs; if (n) { const t = n.length; let r = 0; for (; r < t;) { const i = n[r]; if (bn(i)) break; if (0 === i) r += 2; else if ("number" == typeof i) for (r++; r < t && "string" == typeof n[r];)r++; else { if (i === e) return n[r + 1]; r += 2 } } } return null }(Fe(), t) } const qn = "__parameters__"; function Zn(t, e, n) { return At(() => { const r = function (t) { return function (...e) { if (t) { const n = t(...e); for (const t in n) this[t] = n[t] } } }(e); function i(...t) { if (this instanceof i) return r.apply(this, t), this; const e = new i(...t); return n.annotation = e, n; function n(t, n, r) { const i = t.hasOwnProperty(qn) ? t[qn] : Object.defineProperty(t, qn, { value: [] })[qn]; for (; i.length <= r;)i.push(null); return (i[r] = i[r] || []).push(e), t } } return n && (i.prototype = Object.create(n.prototype)), i.prototype.ngMetadataName = t, i.annotationCls = i, i }) } class Kn { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = ft({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } const Yn = new Kn("AnalyzeForEntryComponents"), Qn = Function; function $n(t, e) { void 0 === e && (e = t); for (let n = 0; n < t.length; n++) { let r = t[n]; Array.isArray(r) ? (e === t && (e = t.slice(0, n)), $n(r, e)) : e !== t && e.push(r) } return e } function tr(t, e) { t.forEach(t => Array.isArray(t) ? tr(t, e) : e(t)) } function er(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function nr(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function rr(t, e) { const n = []; for (let r = 0; r < t; r++)n.push(e); return n } function ir(t, e, n) { let r = or(t, e); return r >= 0 ? t[1 | r] = n : (r = ~r, function (t, e, n, r) { let i = t.length; if (i == e) t.push(n, r); else if (1 === i) t.push(r, t[0]), t[0] = n; else { for (i--, t.push(t[i - 1], t[i]); i > e;)t[i] = t[i - 2], i--; t[e] = n, t[e + 1] = r } }(t, r, e, n)), r } function sr(t, e) { const n = or(t, e); if (n >= 0) return t[1 | n] } function or(t, e) { return function (t, e, n) { let r = 0, i = t.length >> 1; for (; i !== r;) { const n = r + (i - r >> 1), s = t[n << 1]; if (e === s) return n << 1; s > e ? i = n : r = n + 1 } return ~(i << 1) }(t, e) } const ar = {}, lr = /\n/gm, cr = "__source", ur = nt({ provide: String, useValue: nt }); let hr; function dr(t) { const e = hr; return hr = t, e } function pr(t, e = xt.Default) { if (void 0 === hr) throw new Error("inject() must be called from an injection context"); return null === hr ? Mt(t, void 0, e) : hr.get(t, e & xt.Optional ? null : void 0, e) } function fr(t, e = xt.Default) { return (Tt || pr)(lt(t), e) } const mr = fr; function gr(t) { const e = []; for (let n = 0; n < t.length; n++) { const r = lt(t[n]); if (Array.isArray(r)) { if (0 === r.length) throw new Error("Arguments array must have arguments."); let t, n = xt.Default; for (let e = 0; e < r.length; e++) { const i = r[e], s = i.__NG_DI_FLAG__; "number" == typeof s ? -1 === s ? t = i.token : n |= s : t = i } e.push(fr(t, n)) } else e.push(fr(r)) } return e } function vr(t, e) { return t.__NG_DI_FLAG__ = e, t.prototype.__NG_DI_FLAG__ = e, t } const yr = vr(Zn("Inject", t => ({ token: t })), -1), br = vr(Zn("Optional"), 8), _r = vr(Zn("SkipSelf"), 4); let wr, Sr; function xr(t) { var e; return (null === (e = function () { if (void 0 === wr && (wr = null, It.trustedTypes)) try { wr = It.trustedTypes.createPolicy("angular", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch (e) { } return wr }()) || void 0 === e ? void 0 : e.createHTML(t)) || t } function Tr(t) { var e; return (null === (e = function () { if (void 0 === Sr && (Sr = null, It.trustedTypes)) try { Sr = It.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch (e) { } return Sr }()) || void 0 === e ? void 0 : e.createHTML(t)) || t } class Er { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } class Mr extends Er { getTypeName() { return "HTML" } } class Ar extends Er { getTypeName() { return "Style" } } class Cr extends Er { getTypeName() { return "Script" } } class Pr extends Er { getTypeName() { return "URL" } } class Rr extends Er { getTypeName() { return "ResourceURL" } } function Lr(t) { return t instanceof Er ? t.changingThisBreaksApplicationSecurity : t } function kr(t, e) { const n = Dr(t); if (null != n && n !== e) { if ("ResourceURL" === n && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === e } function Dr(t) { return t instanceof Er && t.getTypeName() || null } class Ir { constructor(t) { this.inertDocumentHelper = t } getInertBodyElement(t) { t = "<body><remove></remove>" + t; try { const e = (new window.DOMParser).parseFromString(xr(t), "text/html").body; return null === e ? this.inertDocumentHelper.getInertBodyElement(t) : (e.removeChild(e.firstChild), e) } catch (wN) { return null } } } class Or { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const t = this.inertDocument.createElement("html"); this.inertDocument.appendChild(t); const e = this.inertDocument.createElement("body"); t.appendChild(e) } } getInertBodyElement(t) { const e = this.inertDocument.createElement("template"); if ("content" in e) return e.innerHTML = xr(t), e; const n = this.inertDocument.createElement("body"); return n.innerHTML = xr(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(n), n } stripCustomNsAttrs(t) { const e = t.attributes; for (let r = e.length - 1; 0 < r; r--) { const n = e.item(r).name; "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || t.removeAttribute(n) } let n = t.firstChild; for (; n;)n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling } } const Fr = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, Nr = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function Br(t) { return (t = String(t)).match(Fr) || t.match(Nr) ? t : "unsafe:" + t } function Hr(t) { const e = {}; for (const n of t.split(",")) e[n] = !0; return e } function Ur(...t) { const e = {}; for (const n of t) for (const t in n) n.hasOwnProperty(t) && (e[t] = !0); return e } const Gr = Hr("area,br,col,hr,img,wbr"), Vr = Hr("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), zr = Hr("rp,rt"), jr = Ur(zr, Vr), Jr = Ur(Gr, Ur(Vr, Hr("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Ur(zr, Hr("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), jr), Xr = Hr("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), Wr = Hr("srcset"), qr = Ur(Xr, Wr, Hr("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Hr("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), Zr = Hr("script,style,template"); class Kr { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, n = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? n = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, n && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let t = this.checkClobberedElement(e, e.nextSibling); if (t) { e = t; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!Jr.hasOwnProperty(e)) return this.sanitizedSomething = !0, !Zr.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const n = t.attributes; for (let i = 0; i < n.length; i++) { const t = n.item(i), e = t.name, s = e.toLowerCase(); if (!qr.hasOwnProperty(s)) { this.sanitizedSomething = !0; continue } let o = t.value; Xr[s] && (o = Br(o)), Wr[s] && (r = o, o = (r = String(r)).split(",").map(t => Br(t.trim())).join(", ")), this.buf.push(" ", e, '="', $r(o), '"') } var r; return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); Jr.hasOwnProperty(e) && !Gr.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push($r(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return e } } const Yr = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Qr = /([^\#-~ |!])/g; function $r(t) { return t.replace(/&/g, "&amp;").replace(Yr, function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" }).replace(Qr, function (t) { return "&#" + t.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let ti; function ei(t, e) { let n = null; try { ti = ti || function (t) { const e = new Or(t); return function () { try { return !!(new window.DOMParser).parseFromString(xr(""), "text/html") } catch (wN) { return !1 } }() ? new Ir(e) : e }(t); let r = e ? String(e) : ""; n = ti.getInertBodyElement(r); let i = 5, s = r; do { if (0 === i) throw new Error("Failed to sanitize html because the input is unstable"); i--, r = s, s = n.innerHTML, n = ti.getInertBodyElement(r) } while (r !== s); return xr((new Kr).sanitizeChildren(ni(n) || n)) } finally { if (n) { const t = ni(n) || n; for (; t.firstChild;)t.removeChild(t.firstChild) } } } function ni(t) { return "content" in t && function (t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } var ri = (() => ((ri = ri || {})[ri.NONE = 0] = "NONE", ri[ri.HTML = 1] = "HTML", ri[ri.STYLE = 2] = "STYLE", ri[ri.SCRIPT = 3] = "SCRIPT", ri[ri.URL = 4] = "URL", ri[ri.RESOURCE_URL = 5] = "RESOURCE_URL", ri))(); function ii(t) { const e = oi(); return e ? Tr(e.sanitize(ri.HTML, t) || "") : kr(t, "HTML") ? Tr(Lr(t)) : ei(ve(), ht(t)) } function si(t) { const e = oi(); return e ? e.sanitize(ri.URL, t) || "" : kr(t, "URL") ? Lr(t) : Br(ht(t)) } function oi() { const t = De(); return t && t[12] } function ai(t, e) { t.__ngContext__ = e } function li(t) { const e = function (t) { return t.__ngContext__ || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function ci(t) { return t.ngDebugContext } function ui(t) { return t.ngOriginalError } function hi(t, ...e) { t.error(...e) } class di { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), n = this._findContext(t), r = function (t) { return t.ngErrorLogger || hi }(t); r(this._console, "ERROR", t), e && r(this._console, "ORIGINAL ERROR", e), n && r(this._console, "ERROR CONTEXT", n) } _findContext(t) { return t ? ci(t) ? ci(t) : this._findContext(ui(t)) : null } _findOriginalError(t) { let e = ui(t); for (; e && ui(e);)e = ui(e); return e } } const pi = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(It))(); function fi(t) { return t instanceof Function ? t() : t } var mi = (() => ((mi = mi || {})[mi.Important = 1] = "Important", mi[mi.DashCase = 2] = "DashCase", mi))(); function gi(t, e) { return (void 0)(t, e) } function vi(t) { const e = t[3]; return ie(e) ? e[3] : e } function yi(t) { return _i(t[13]) } function bi(t) { return _i(t[4]) } function _i(t) { for (; null !== t && !ie(t);)t = t[4]; return t } function wi(t, e, n, r, i) { if (null != r) { let s, o = !1; ie(r) ? s = r : re(r) && (o = !0, r = r[0]); const a = _e(r); 0 === t && null !== n ? null == i ? Pi(e, n, a) : Ci(e, n, a, i || null, !0) : 1 === t && null !== n ? Ci(e, n, a, i || null, !0) : 2 === t ? function (t, e, n) { const r = Li(t, e); r && function (t, e, n, r) { ye(t) ? t.removeChild(e, n, r) : e.removeChild(n) }(t, r, e, n) }(e, a, o) : 3 === t && e.destroyNode(a), null != s && function (t, e, n, r, i) { const s = n[7]; s !== _e(n) && wi(e, t, r, s, i); for (let o = ne; o < n.length; o++) { const i = n[o]; Hi(i[1], i, t, e, r, s) } }(e, t, s, n, i) } } function Si(t, e, n) { return ye(t) ? t.createElement(e, n) : null === n ? t.createElement(e) : t.createElementNS(n, e) } function xi(t, e) { const n = t[9], r = n.indexOf(e), i = e[3]; 1024 & e[2] && (e[2] &= -1025, Re(i, -1)), n.splice(r, 1) } function Ti(t, e) { if (t.length <= ne) return; const n = ne + e, r = t[n]; if (r) { const s = r[17]; null !== s && s !== t && xi(s, r), e > 0 && (t[n - 1][4] = r[4]); const o = nr(t, ne + e); Hi(r[1], i = r, i[11], 2, null, null), i[0] = null, i[6] = null; const a = o[19]; null !== a && a.detachView(o[1]), r[3] = null, r[4] = null, r[2] &= -129 } var i; return r } function Ei(t, e) { if (!(256 & e[2])) { const n = e[11]; ye(n) && n.destroyNode && Hi(t, e, n, 3, null, null), function (t) { let e = t[13]; if (!e) return Mi(t[1], t); for (; e;) { let n = null; if (re(e)) n = e[13]; else { const t = e[10]; t && (n = t) } if (!n) { for (; e && !e[4] && e !== t;)re(e) && Mi(e[1], e), e = e[3]; null === e && (e = t), re(e) && Mi(e[1], e), n = e && e[4] } e = n } }(e) } } function Mi(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function (t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const t = e[n[r]]; if (!(t instanceof vn)) { const e = n[r + 1]; if (Array.isArray(e)) for (let n = 0; n < e.length; n += 2) { const r = t[e[n]], i = e[n + 1]; try { i.call(r) } finally { } } else try { e.call(t) } finally { } } } }(t, e), function (t, e) { const n = t.cleanup, r = e[7]; let i = -1; if (null !== n) for (let s = 0; s < n.length - 1; s += 2)if ("string" == typeof n[s]) { const t = n[s + 1], o = "function" == typeof t ? t(e) : _e(e[t]), a = r[i = n[s + 2]], l = n[s + 3]; "boolean" == typeof l ? o.removeEventListener(n[s], a, l) : l >= 0 ? r[i = l]() : r[i = -l].unsubscribe(), s += 2 } else { const t = r[i = n[s + 1]]; n[s].call(t) } if (null !== r) { for (let t = i + 1; t < r.length; t++)(0, r[t])(); e[7] = null } }(t, e), 1 === e[1].type && ye(e[11]) && e[11].destroy(); const n = e[17]; if (null !== n && ie(e[3])) { n !== e[3] && xi(n, e); const r = e[19]; null !== r && r.detachView(t) } } } function Ai(t, e, n) { return function (t, e, n) { let r = e; for (; null !== r && 40 & r.type;)r = (e = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const e = t.data[r.directiveStart].encapsulation; if (e === Pt.None || e === Pt.Emulated) return null } return Se(r, n) }(t, e.parent, n) } function Ci(t, e, n, r, i) { ye(t) ? t.insertBefore(e, n, r, i) : e.insertBefore(n, r, i) } function Pi(t, e, n) { ye(t) ? t.appendChild(e, n) : e.appendChild(n) } function Ri(t, e, n, r, i) { null !== r ? Ci(t, e, n, r, i) : Pi(t, e, n) } function Li(t, e) { return ye(t) ? t.parentNode(e) : e.parentNode } function ki(t, e, n) { return Di(t, e, n) } let Di = function (t, e, n) { return 40 & t.type ? Se(t, n) : null }; function Ii(t, e, n, r) { const i = Ai(t, r, e), s = e[11], o = ki(r.parent || e[6], r, e); if (null != i) if (Array.isArray(n)) for (let a = 0; a < n.length; a++)Ri(s, i, n[a], o, !1); else Ri(s, i, n, o, !1) } function Oi(t, e) { if (null !== e) { const n = e.type; if (3 & n) return Se(e, t); if (4 & n) return Ni(-1, t[e.index]); if (8 & n) { const n = e.child; if (null !== n) return Oi(t, n); { const n = t[e.index]; return ie(n) ? Ni(-1, n) : _e(n) } } if (32 & n) return gi(e, t)() || _e(t[e.index]); { const n = Fi(t, e); return null !== n ? Array.isArray(n) ? n[0] : Oi(vi(t[16]), n) : Oi(t, e.next) } } return null } function Fi(t, e) { return null !== e ? t[16][6].projection[e.projection] : null } function Ni(t, e) { const n = ne + t + 1; if (n < e.length) { const t = e[n], r = t[1].firstChild; if (null !== r) return Oi(t, r) } return e[7] } function Bi(t, e, n, r, i, s, o) { for (; null != n;) { const a = r[n.index], l = n.type; if (o && 0 === e && (a && ai(_e(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & l) Bi(t, e, n.child, r, i, s, !1), wi(e, t, i, a, s); else if (32 & l) { const o = gi(n, r); let l; for (; l = o();)wi(e, t, i, l, s); wi(e, t, i, a, s) } else 16 & l ? Ui(t, e, r, n, i, s) : wi(e, t, i, a, s); n = o ? n.projectionNext : n.next } } function Hi(t, e, n, r, i, s) { Bi(n, r, t.firstChild, e, i, s, !1) } function Ui(t, e, n, r, i, s) { const o = n[16], a = o[6].projection[r.projection]; if (Array.isArray(a)) for (let l = 0; l < a.length; l++)wi(e, t, i, a[l], s); else Bi(t, e, a, o[3], i, s, !0) } function Gi(t, e, n) { ye(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function Vi(t, e, n) { ye(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } function zi(t, e, n) { let r = t.length; for (; ;) { const i = t.indexOf(e, n); if (-1 === i) return i; if (0 === i || t.charCodeAt(i - 1) <= 32) { const n = e.length; if (i + n === r || t.charCodeAt(i + n) <= 32) return i } n = i + 1 } } const ji = "ng-template"; function Ji(t, e, n) { let r = 0; for (; r < t.length;) { let i = t[r++]; if (n && "class" === i) { if (i = t[r], -1 !== zi(i.toLowerCase(), e, 0)) return !0 } else if (1 === i) { for (; r < t.length && "string" == typeof (i = t[r++]);)if (i.toLowerCase() === e) return !0; return !1 } } return !1 } function Xi(t) { return 4 === t.type && t.value !== ji } function Wi(t, e, n) { return e === (4 !== t.type || n ? t.value : ji) } function qi(t, e, n) { let r = 4; const i = t.attrs || [], s = function (t) { for (let e = 0; e < t.length; e++)if (bn(t[e])) return e; return t.length }(i); let o = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!o) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !Wi(t, l, n) || "" === l && 1 === e.length) { if (Zi(r)) return !1; o = !0 } } else { const c = 8 & r ? l : e[++a]; if (8 & r && null !== t.attrs) { if (!Ji(t.attrs, c, n)) { if (Zi(r)) return !1; o = !0 } continue } const u = Ki(8 & r ? "class" : l, i, Xi(t), n); if (-1 === u) { if (Zi(r)) return !1; o = !0; continue } if ("" !== c) { let t; t = u > s ? "" : i[u + 1].toLowerCase(); const e = 8 & r ? t : null; if (e && -1 !== zi(e, c, 0) || 2 & r && c !== t) { if (Zi(r)) return !1; o = !0 } } } } else { if (!o && !Zi(r) && !Zi(l)) return !1; if (o && Zi(l)) continue; o = !1, r = l | 1 & r } } return Zi(r) || o } function Zi(t) { return 0 == (1 & t) } function Ki(t, e, n, r) { if (null === e) return -1; let i = 0; if (r || !n) { let n = !1; for (; i < e.length;) { const r = e[i]; if (r === t) return i; if (3 === r || 6 === r) n = !0; else { if (1 === r || 2 === r) { let t = e[++i]; for (; "string" == typeof t;)t = e[++i]; continue } if (4 === r) break; if (0 === r) { i += 4; continue } } i += n ? 1 : 2 } return -1 } return function (t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const r = t[n]; if ("number" == typeof r) return -1; if (r === e) return n; n++ } return -1 }(e, t) } function Yi(t, e, n = !1) { for (let r = 0; r < e.length; r++)if (qi(t, e[r], n)) return !0; return !1 } function Qi(t, e) { t: for (let n = 0; n < e.length; n++) { const r = e[n]; if (t.length === r.length) { for (let e = 0; e < t.length; e++)if (t[e] !== r[e]) continue t; return !0 } } return !1 } function $i(t, e) { return t ? ":not(" + e.trim() + ")" : e } function ts(t) { let e = t[0], n = 1, r = 2, i = "", s = !1; for (; n < t.length;) { let o = t[n]; if ("string" == typeof o) if (2 & r) { const e = t[++n]; i += "[" + o + (e.length > 0 ? '="' + e + '"' : "") + "]" } else 8 & r ? i += "." + o : 4 & r && (i += " " + o); else "" === i || Zi(o) || (e += $i(s, i), i = ""), r = o, s = s || !Zi(r); n++ } return "" !== i && (e += $i(s, i)), e } const es = {}; function ns(t) { rs(Ie(), De(), an() + t, Ge()) } function rs(t, e, n, r) { if (!r) if (3 == (3 & e[2])) { const r = t.preOrderCheckHooks; null !== r && hn(e, r, n) } else { const r = t.preOrderHooks; null !== r && dn(e, r, 0, n) } ln(n) } function is(t, e) { return t << 17 | e << 2 } function ss(t) { return t >> 17 & 32767 } function os(t) { return 2 | t } function as(t) { return (131068 & t) >> 2 } function ls(t, e) { return -131069 & t | e << 2 } function cs(t) { return 1 | t } function us(t, e) { const n = t.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const i = n[r], s = n[r + 1]; if (-1 !== s) { const n = t.data[s]; Ye(i), n.contentQueries(2, e[s], s) } } } function hs(t, e, n, r, i, s, o, a, l, c) { const u = e.blueprint.slice(); return u[0] = i, u[2] = 140 | r, Pe(u), u[3] = u[15] = t, u[8] = n, u[10] = o || t && t[10], u[11] = a || t && t[11], u[12] = l || t && t[12] || null, u[9] = c || t && t[9] || null, u[6] = s, u[16] = 2 == e.type ? t[16] : u, u } function ds(t, e, n, r, i) { let s = t.data[e]; if (null === s) s = function (t, e, n, r, i) { const s = Ne(), o = He(), a = t.data[e] = function (t, e, n, r, i, s) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: i, attrs: s, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? s : s && s.parent, n, e, r, i); return null === t.firstChild && (t.firstChild = a), null !== s && (o ? null == s.child && null !== a.parent && (s.child = a) : null === s.next && (s.next = a)), a }(t, e, n, r, i), Le.lFrame.inI18n && (s.flags |= 64); else if (64 & s.type) { s.type = n, s.value = r, s.attrs = i; const t = function () { const t = Le.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent }(); s.injectorIndex = null === t ? -1 : t.injectorIndex } return Be(s, !0), s } function ps(t, e, n, r) { if (0 === n) return -1; const i = e.length; for (let s = 0; s < n; s++)e.push(r), t.blueprint.push(r), t.data.push(null); return i } function fs(t, e, n) { tn(e); try { const r = t.viewQuery; null !== r && js(1, r, n); const i = t.template; null !== i && vs(t, e, i, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && us(t, e), t.staticViewQueries && js(2, t.viewQuery, n); const s = t.components; null !== s && function (t, e) { for (let n = 0; n < e.length; n++)Hs(t, e[n]) }(e, s) } catch (r) { throw t.firstCreatePass && (t.incompleteFirstPass = !0), r } finally { e[2] &= -5, on() } } function ms(t, e, n, r) { const i = e[2]; if (256 == (256 & i)) return; tn(e); const s = Ge(); try { Pe(e), Le.lFrame.bindingIndex = t.bindingStartIndex, null !== n && vs(t, e, n, 2, r); const o = 3 == (3 & i); if (!s) if (o) { const n = t.preOrderCheckHooks; null !== n && hn(e, n, null) } else { const n = t.preOrderHooks; null !== n && dn(e, n, 0, null), pn(e, 0) } if (function (t) { for (let e = yi(t); null !== e; e = bi(e)) { if (!e[2]) continue; const t = e[9]; for (let e = 0; e < t.length; e++) { const n = t[e], r = n[3]; 0 == (1024 & n[2]) && Re(r, 1), n[2] |= 1024 } } }(e), function (t) { for (let e = yi(t); null !== e; e = bi(e))for (let t = ne; t < e.length; t++) { const n = e[t], r = n[1]; Ae(n) && ms(r, n, r.template, n[8]) } }(e), null !== t.contentQueries && us(t, e), !s) if (o) { const n = t.contentCheckHooks; null !== n && hn(e, n) } else { const n = t.contentHooks; null !== n && dn(e, n, 1), pn(e, 1) } !function (t, e) { const n = t.hostBindingOpCodes; if (null !== n) try { for (let t = 0; t < n.length; t++) { const r = n[t]; if (r < 0) ln(~r); else { const i = r, s = n[++t], o = n[++t]; We(s, i), o(2, e[i]) } } } finally { ln(-1) } }(t, e); const a = t.components; null !== a && function (t, e) { for (let n = 0; n < e.length; n++)Ns(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && js(2, l, r), !s) if (o) { const n = t.viewCheckHooks; null !== n && hn(e, n) } else { const n = t.viewHooks; null !== n && dn(e, n, 2), pn(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), s || (e[2] &= -73), 1024 & e[2] && (e[2] &= -1025, Re(e[3], -1)) } finally { on() } } function gs(t, e, n, r) { const i = e[10], s = !Ge(), o = Me(e); try { s && !o && i.begin && i.begin(), o && fs(t, e, r), ms(t, e, n, r) } finally { s && !o && i.end && i.end() } } function vs(t, e, n, r, i) { const s = an(), o = 2 & r; try { ln(-1), o && e.length > ee && rs(t, e, ee, Ge()), n(r, i) } finally { ln(s) } } function ys(t, e, n) { if (se(e)) { const r = e.directiveEnd; for (let i = e.directiveStart; i < r; i++) { const e = t.data[i]; e.contentQueries && e.contentQueries(1, n[i], i) } } } function bs(t, e, n) { ke() && (function (t, e, n, r) { const i = n.directiveStart, s = n.directiveEnd; t.firstCreatePass || Pn(n, e), ai(r, e); const o = n.initialInputs; for (let a = i; a < s; a++) { const r = t.data[a], s = le(r); s && Ds(e, n, r); const l = Gn(e, t, a, n); ai(l, e), null !== o && Is(0, a - i, l, r, 0, o), s && (Ee(n.index, e)[8] = l) } }(t, e, n, Se(n, e)), 128 == (128 & n.flags) && function (t, e, n) { const r = n.directiveStart, i = n.directiveEnd, s = n.index, o = Le.lFrame.currentDirectiveIndex; try { ln(s); for (let n = r; n < i; n++) { const r = t.data[n], i = e[n]; qe(n), null === r.hostBindings && 0 === r.hostVars && null === r.hostAttrs || Cs(r, i) } } finally { ln(-1), qe(o) } }(t, e, n)) } function _s(t, e, n = Se) { const r = e.localNames; if (null !== r) { let i = e.index + 1; for (let s = 0; s < r.length; s += 2) { const o = r[s + 1], a = -1 === o ? n(e, t) : t[o]; t[i++] = a } } } function ws(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = Ss(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function Ss(t, e, n, r, i, s, o, a, l, c) { const u = ee + r, h = u + i, d = function (t, e) { const n = []; for (let r = 0; r < e; r++)n.push(r < t ? null : es); return n }(u, h), p = "function" == typeof c ? c() : c; return d[1] = { type: t, blueprint: d, template: n, queries: null, viewQuery: a, declTNode: e, data: d.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: h, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof s ? s() : s, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: p, incompleteFirstPass: !1 } } function xs(t, e, n, r) { const i = Xs(e); null === n ? i.push(r) : (i.push(n), t.firstCreatePass && Ws(t).push(r, i.length - 1)) } function Ts(t, e, n) { for (let r in t) if (t.hasOwnProperty(r)) { const i = t[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(e, i) : n[r] = [e, i] } return n } function Es(t, e, n, r, i, s, o, a) { const l = Se(e, n); let c, u = e.inputs; !a && null != u && (c = u[r]) ? (Ks(t, n, c, r, i), oe(e) && function (t, e) { const n = Ee(e, t); 16 & n[2] || (n[2] |= 64) }(n, e.index)) : 3 & e.type && (r = function (t) { return "class" === t ? "className" : "for" === t ? "htmlFor" : "formaction" === t ? "formAction" : "innerHtml" === t ? "innerHTML" : "readonly" === t ? "readOnly" : "tabindex" === t ? "tabIndex" : t }(r), i = null != o ? o(i, e.value || "", r) : i, ye(s) ? s.setProperty(l, r, i) : _n(r) || (l.setProperty ? l.setProperty(r, i) : l[r] = i)) } function Ms(t, e, n, r) { let i = !1; if (ke()) { const s = function (t, e, n) { const r = t.directiveRegistry; let i = null; if (r) for (let s = 0; s < r.length; s++) { const o = r[s]; Yi(n, o.selectors, !1) && (i || (i = []), Dn(Pn(n, e), t, o.type), le(o) ? (Ps(t, n), i.unshift(o)) : i.push(o)) } return i }(t, e, n), o = null === r ? null : { "": -1 }; if (null !== s) { i = !0, Ls(n, t.data.length, s.length); for (let t = 0; t < s.length; t++) { const e = s[t]; e.providersResolver && e.providersResolver(e) } let r = !1, a = !1, l = ps(t, e, s.length, null); for (let i = 0; i < s.length; i++) { const c = s[i]; n.mergedAttrs = wn(n.mergedAttrs, c.hostAttrs), ks(t, n, e, l, c), Rs(l, c, o), null !== c.contentQueries && (n.flags |= 8), null === c.hostBindings && null === c.hostAttrs && 0 === c.hostVars || (n.flags |= 128); const u = c.type.prototype; !r && (u.ngOnChanges || u.ngOnInit || u.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index), r = !0), a || !u.ngOnChanges && !u.ngDoCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index), a = !0), l++ } !function (t, e) { const n = e.directiveEnd, r = t.data, i = e.attrs, s = []; let o = null, a = null; for (let l = e.directiveStart; l < n; l++) { const t = r[l], n = t.inputs, c = null === i || Xi(e) ? null : Os(n, i); s.push(c), o = Ts(n, l, o), a = Ts(t.outputs, l, a) } null !== o && (o.hasOwnProperty("class") && (e.flags |= 16), o.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = s, e.inputs = o, e.outputs = a }(t, n) } o && function (t, e, n) { if (e) { const r = t.localNames = []; for (let t = 0; t < e.length; t += 2) { const i = n[e[t + 1]]; if (null == i) throw new ut("301", `Export of name '${e[t + 1]}' not found!`); r.push(e[t], i) } } }(n, r, o) } return n.mergedAttrs = wn(n.mergedAttrs, n.attrs), i } function As(t, e, n, r, i, s) { const o = s.hostBindings; if (o) { let n = t.hostBindingOpCodes; null === n && (n = t.hostBindingOpCodes = []); const s = ~e.index; (function (t) { let e = t.length; for (; e > 0;) { const n = t[--e]; if ("number" == typeof n && n < 0) return n } return 0 })(n) != s && n.push(s), n.push(r, i, o) } } function Cs(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function Ps(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function Rs(t, e, n) { if (n) { if (e.exportAs) for (let r = 0; r < e.exportAs.length; r++)n[e.exportAs[r]] = t; le(e) && (n[""] = t) } } function Ls(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function ks(t, e, n, r, i) { t.data[r] = i; const s = i.factory || (i.factory = ce(i.type)), o = new vn(s, le(i), null); t.blueprint[r] = o, n[r] = o, As(t, e, 0, r, ps(t, n, i.hostVars, es), i) } function Ds(t, e, n) { const r = Se(e, t), i = ws(n), s = t[10], o = Us(t, hs(t, i, null, n.onPush ? 64 : 16, r, e, s, s.createRenderer(r, n), null, null)); t[e.index] = o } function Is(t, e, n, r, i, s) { const o = s[e]; if (null !== o) { const t = r.setInput; for (let e = 0; e < o.length;) { const i = o[e++], s = o[e++], a = o[e++]; null !== t ? r.setInput(n, a, i, s) : n[s] = a } } } function Os(t, e) { let n = null, r = 0; for (; r < e.length;) { const i = e[r]; if (0 !== i) if (5 !== i) { if ("number" == typeof i) break; t.hasOwnProperty(i) && (null === n && (n = []), n.push(i, t[i], e[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function Fs(t, e, n, r) { return new Array(t, !0, !1, e, null, 0, r, n, null, null) } function Ns(t, e) { const n = Ee(e, t); if (Ae(n)) { const t = n[1]; 80 & n[2] ? ms(t, n, t.template, n[8]) : n[5] > 0 && Bs(n) } } function Bs(t) { for (let n = yi(t); null !== n; n = bi(n))for (let t = ne; t < n.length; t++) { const e = n[t]; if (1024 & e[2]) { const t = e[1]; ms(t, e, t.template, e[8]) } else e[5] > 0 && Bs(e) } const e = t[1].components; if (null !== e) for (let n = 0; n < e.length; n++) { const r = Ee(e[n], t); Ae(r) && r[5] > 0 && Bs(r) } } function Hs(t, e) { const n = Ee(e, t), r = n[1]; !function (t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) }(r, n), fs(r, n, n[8]) } function Us(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function Gs(t) { for (; t;) { t[2] |= 64; const e = vi(t); if (0 != (512 & t[2]) && !e) return t; t = e } return null } function Vs(t, e, n) { const r = e[10]; r.begin && r.begin(); try { ms(t, e, t.template, n) } catch (i) { throw Zs(e, i), i } finally { r.end && r.end() } } function zs(t) { !function (t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], r = li(n), i = r[1]; gs(i, r, i.template, n) } }(t[8]) } function js(t, e, n) { Ye(0), e(t, n) } const Js = (() => Promise.resolve(null))(); function Xs(t) { return t[7] || (t[7] = []) } function Ws(t) { return t.cleanup || (t.cleanup = []) } function qs(t, e, n) { return (null === t || le(t)) && (n = function (t) { for (; Array.isArray(t);) { if ("object" == typeof t[1]) return t; t = t[0] } return null }(n[e.index])), n[11] } function Zs(t, e) { const n = t[9], r = n ? n.get(di, null) : null; r && r.handleError(e) } function Ks(t, e, n, r, i) { for (let s = 0; s < n.length;) { const o = n[s++], a = n[s++], l = e[o], c = t.data[o]; null !== c.setInput ? c.setInput(l, i, r, a) : l[a] = i } } function Ys(t, e, n) { const r = we(e, t); !function (t, e, n) { ye(t) ? t.setValue(e, n) : e.textContent = n }(t[11], r, n) } function Qs(t, e, n) { let r = n ? t.styles : null, i = n ? t.classes : null, s = 0; if (null !== e) for (let o = 0; o < e.length; o++) { const t = e[o]; "number" == typeof t ? s = t : 1 == s ? i = st(i, t) : 2 == s && (r = st(r, t + ": " + e[++o] + ";")) } n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = i : t.classesWithoutHost = i } const $s = new Kn("INJECTOR", -1); class to { get(t, e = ar) { if (e === ar) { const e = new Error(`NullInjectorError: No provider for ${it(t)}!`); throw e.name = "NullInjectorError", e } return e } } const eo = new Kn("Set Injector scope."), no = {}, ro = {}; let io; function so() { return void 0 === io && (io = new to), io } function oo(t, e = null, n = null, r) { return new ao(t, n, e || so(), r) } class ao { constructor(t, e, n, r = null) { this.parent = n, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const i = []; e && tr(e, n => this.processProvider(n, t, e)), tr([t], t => this.processInjectorType(t, [], i)), this.records.set($s, uo(void 0, this)); const s = this.records.get(eo); this.scope = null != s ? s.value : null, this.source = r || ("object" == typeof t ? null : it(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = ar, n = xt.Default) { this.assertNotDestroyed(); const r = dr(this); try { if (!(n & xt.SkipSelf)) { let e = this.records.get(t); if (void 0 === e) { const n = ("function" == typeof (i = t) || "object" == typeof i && i instanceof Kn) && gt(t); e = n && this.injectableDefInScope(n) ? uo(lo(t), no) : null, this.records.set(t, e) } if (null != e) return this.hydrate(t, e) } return (n & xt.Self ? so() : this.parent).get(t, e = n & xt.Optional && e === ar ? null : e) } catch (s) { if ("NullInjectorError" === s.name) { if ((s.ngTempTokenPath = s.ngTempTokenPath || []).unshift(it(t)), r) throw s; return function (t, e, n, r) { const i = t.ngTempTokenPath; throw e[cr] && i.unshift(e[cr]), t.message = function (t, e, n, r = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let i = it(e); if (Array.isArray(e)) i = e.map(it).join(" -> "); else if ("object" == typeof e) { let t = []; for (let n in e) if (e.hasOwnProperty(n)) { let r = e[n]; t.push(n + ":" + ("string" == typeof r ? JSON.stringify(r) : it(r))) } i = `{${t.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${i}]: ${t.replace(lr, "\n  ")}` }("\n" + t.message, i, n, r), t.ngTokenPath = i, t.ngTempTokenPath = null, t }(s, t, "R3InjectorError", this.source) } throw s } finally { dr(r) } var i } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((e, n) => t.push(it(n))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, n) { if (!(t = lt(t))) return !1; let r = yt(t); const i = null == r && t.ngModule || void 0, s = void 0 === i ? t : i, o = -1 !== n.indexOf(s); if (void 0 !== i && (r = yt(i)), null == r) return !1; if (null != r.imports && !o) { let t; n.push(s); try { tr(r.imports, r => { this.processInjectorType(r, e, n) && (void 0 === t && (t = []), t.push(r)) }) } finally { } if (void 0 !== t) for (let e = 0; e < t.length; e++) { const { ngModule: n, providers: r } = t[e]; tr(r, t => this.processProvider(t, n, r || Ft)) } } this.injectorDefTypes.add(s); const a = ce(s) || (() => new s); this.records.set(s, uo(a, no)); const l = r.providers; if (null != l && !o) { const e = t; tr(l, t => this.processProvider(t, e, l)) } return void 0 !== i && void 0 !== t.providers } processProvider(t, e, n) { let r = po(t = lt(t)) ? t : lt(t && t.provide); const i = function (t, e, n) { return ho(t) ? uo(void 0, t.useValue) : uo(co(t), no) }(t); if (po(t) || !0 !== t.multi) this.records.get(r); else { let e = this.records.get(r); e || (e = uo(void 0, no, !0), e.factory = () => gr(e.multi), this.records.set(r, e)), r = t, e.multi.push(t) } this.records.set(r, i) } hydrate(t, e) { var n; return e.value === no && (e.value = ro, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (n = e.value) && "object" == typeof n && "function" == typeof n.ngOnDestroy && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const e = lt(t.providedIn); return "string" == typeof e ? "any" === e || e === this.scope : this.injectorDefTypes.has(e) } } function lo(t) { const e = gt(t), n = null !== e ? e.factory : ce(t); if (null !== n) return n; if (t instanceof Kn) throw new Error(`Token ${it(t)} is missing a \u0275prov definition.`); if (t instanceof Function) return function (t) { const e = t.length; if (e > 0) { const n = rr(e, "?"); throw new Error(`Can't resolve all parameters for ${it(t)}: (${n.join(", ")}).`) } const n = function (t) { const e = t && (t[bt] || t[wt]); if (e) { const n = function (t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new Error("unreachable") } function co(t, e, n) { let r; if (po(t)) { const e = lt(t); return ce(e) || lo(e) } if (ho(t)) r = () => lt(t.useValue); else if ((i = t) && i.useFactory) r = () => t.useFactory(...gr(t.deps || [])); else if (function (t) { return !(!t || !t.useExisting) }(t)) r = () => fr(lt(t.useExisting)); else { const e = lt(t && (t.useClass || t.provide)); if (!function (t) { return !!t.deps }(t)) return ce(e) || lo(e); r = () => new e(...gr(t.deps)) } var i; return r } function uo(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function ho(t) { return null !== t && "object" == typeof t && ur in t } function po(t) { return "function" == typeof t } const fo = function (t, e, n) { return function (t, e = null, n = null, r) { const i = oo(t, e, n, r); return i._resolveInjectorDefTypes(), i }({ name: n }, e, t, n) }; class mo { static create(t, e) { return Array.isArray(t) ? fo(t, e, "") : fo(t.providers, t.parent, t.name || "") } } function go(t, e) { un(li(t)[1], Fe()) } function vo(t) { let e = Object.getPrototypeOf(t.type.prototype).constructor, n = !0; const r = [t]; for (; e;) { let i; if (le(t)) i = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new Error("Directives cannot inherit Components"); i = e.\u0275dir } if (i) { if (n) { r.push(i); const e = t; e.inputs = yo(t.inputs), e.declaredInputs = yo(t.declaredInputs), e.outputs = yo(t.outputs); const n = i.hostBindings; n && wo(t, n); const s = i.viewQuery, o = i.contentQueries; if (s && bo(t, s), o && _o(t, o), rt(t.inputs, i.inputs), rt(t.declaredInputs, i.declaredInputs), rt(t.outputs, i.outputs), le(i) && i.data.animation) { const e = t.data; e.animation = (e.animation || []).concat(i.data.animation) } } const e = i.features; if (e) for (let r = 0; r < e.length; r++) { const i = e[r]; i && i.ngInherit && i(t), i === vo && (n = !1) } } e = Object.getPrototypeOf(e) } !function (t) { let e = 0, n = null; for (let r = t.length - 1; r >= 0; r--) { const i = t[r]; i.hostVars = e += i.hostVars, i.hostAttrs = wn(i.hostAttrs, n = wn(n, i.hostAttrs)) } }(r) } function yo(t) { return t === Ot ? {} : t === Ft ? [] : t } function bo(t, e) { const n = t.viewQuery; t.viewQuery = n ? (t, r) => { e(t, r), n(t, r) } : e } function _o(t, e) { const n = t.contentQueries; t.contentQueries = n ? (t, r, i) => { e(t, r, i), n(t, r, i) } : e } function wo(t, e) { const n = t.hostBindings; t.hostBindings = n ? (t, r) => { e(t, r), n(t, r) } : e } mo.THROW_IF_NOT_FOUND = ar, mo.NULL = new to, mo.\u0275prov = ft({ token: mo, providedIn: "any", factory: () => fr($s) }), mo.__NG_ELEMENT_ID__ = -1; let So = null; function xo() { if (!So) { const t = It.Symbol; if (t && t.iterator) So = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const n = t[e]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (So = n) } } } return So } class To { constructor(t) { this.wrapped = t } static wrap(t) { return new To(t) } static unwrap(t) { return To.isWrapped(t) ? t.wrapped : t } static isWrapped(t) { return t instanceof To } } function Eo(t) { return !!Mo(t) && (Array.isArray(t) || !(t instanceof Map) && xo() in t) } function Mo(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function Ao(t, e, n) { return t[e] = n } function Co(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function Po(t, e, n, r) { const i = Co(t, e, n); return Co(t, e + 1, r) || i } function Ro(t, e, n, r) { const i = De(); return Co(i, Je(), e) && (Ie(), function (t, e, n, r, i, s) { const o = Se(t, e); !function (t, e, n, r, i, s, o) { if (null == s) ye(t) ? t.removeAttribute(e, i, n) : e.removeAttribute(i); else { const a = null == o ? ht(s) : o(s, r || "", i); ye(t) ? t.setAttribute(e, i, a, n) : n ? e.setAttributeNS(n, i, a) : e.setAttribute(i, a) } }(e[11], o, s, t.value, n, r, i) }(cn(), i, t, e, n, r)), Ro } function Lo(t, e, n, r, i, s, o, a) { const l = De(), c = Ie(), u = t + ee, h = c.firstCreatePass ? function (t, e, n, r, i, s, o, a, l) { const c = e.consts, u = ds(e, t, 4, o || null, Ce(c, a)); Ms(e, n, u, Ce(c, l)), un(e, u); const h = u.tViews = Ss(2, u, r, i, s, e.directiveRegistry, e.pipeRegistry, null, e.schemas, c); return null !== e.queries && (e.queries.template(e, u), h.queries = e.queries.embeddedTView(u)), u }(u, c, l, e, n, r, i, s, o) : c.data[u]; Be(h, !1); const d = l[11].createComment(""); Ii(c, l, d, h), ai(d, l), Us(l, l[u] = Fs(d, l, d, h)), ae(h) && bs(c, l, h), null != o && _s(l, h, a) } function ko(t) { return Te(Le.lFrame.contextLView, ee + t) } function Do(t, e = xt.Default) { const n = De(); return null === n ? fr(t, e) : Fn(Fe(), n, lt(t), e) } function Io(t, e, n) { const r = De(); return Co(r, Je(), e) && Es(Ie(), cn(), r, t, e, r[11], n, !1), Io } function Oo(t, e, n, r, i) { const s = i ? "class" : "style"; Ks(t, n, e.inputs[s], s, r) } function Fo(t, e, n, r) { const i = De(), s = Ie(), o = ee + t, a = i[11], l = i[o] = Si(a, e, Le.lFrame.currentNamespace), c = s.firstCreatePass ? function (t, e, n, r, i, s, o) { const a = e.consts, l = ds(e, t, 2, i, Ce(a, s)); return Ms(e, n, l, Ce(a, o)), null !== l.attrs && Qs(l, l.attrs, !1), null !== l.mergedAttrs && Qs(l, l.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, l), l }(o, s, i, 0, e, n, r) : s.data[o]; Be(c, !0); const u = c.mergedAttrs; null !== u && yn(a, l, u); const h = c.classes; null !== h && Vi(a, l, h); const d = c.styles; null !== d && Gi(a, l, d), 64 != (64 & c.flags) && Ii(s, i, l, c), 0 === Le.lFrame.elementDepthCount && ai(l, i), Le.lFrame.elementDepthCount++, ae(c) && (bs(s, i, c), ys(s, c, i)), null !== r && _s(i, c) } function No() { let t = Fe(); He() ? Ue() : (t = t.parent, Be(t, !1)); const e = t; Le.lFrame.elementDepthCount--; const n = Ie(); n.firstCreatePass && (un(n, t), se(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function (t) { return 0 != (16 & t.flags) }(e) && Oo(n, e, De(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function (t) { return 0 != (32 & t.flags) }(e) && Oo(n, e, De(), e.stylesWithoutHost, !1) } function Bo(t, e, n, r) { Fo(t, e, n, r), No() } function Ho(t, e, n) { const r = De(), i = Ie(), s = t + ee, o = i.firstCreatePass ? function (t, e, n, r, i) { const s = e.consts, o = Ce(s, r), a = ds(e, t, 8, "ng-container", o); return null !== o && Qs(a, o, !0), Ms(e, n, a, Ce(s, i)), null !== e.queries && e.queries.elementStart(e, a), a }(s, i, r, e, n) : i.data[s]; Be(o, !0); const a = r[s] = r[11].createComment(""); Ii(i, r, a, o), ai(a, r), ae(o) && (bs(i, r, o), ys(i, o, r)), null != n && _s(r, o) } function Uo() { let t = Fe(); const e = Ie(); He() ? Ue() : (t = t.parent, Be(t, !1)), e.firstCreatePass && (un(e, t), se(t) && e.queries.elementEnd(t)) } function Go() { return De() } function Vo(t) { return !!t && "function" == typeof t.then } function zo(t) { return !!t && "function" == typeof t.subscribe } const jo = zo; function Jo(t, e, n, r) { const i = De(), s = Ie(), o = Fe(); return Wo(s, i, i[11], o, t, e, !!n, r), Jo } function Xo(t, e) { const n = Fe(), r = De(), i = Ie(); return Wo(i, r, qs(Ze(i.data), n, r), n, t, e, !1), Xo } function Wo(t, e, n, r, i, s, o, a) { const l = ae(r), c = t.firstCreatePass && Ws(t), u = Xs(e); let h = !0; if (3 & r.type || a) { const d = Se(r, e), p = a ? a(d) : d, f = u.length, m = a ? t => a(_e(t[r.index])) : r.index; if (ye(n)) { let o = null; if (!a && l && (o = function (t, e, n, r) { const i = t.cleanup; if (null != i) for (let s = 0; s < i.length - 1; s += 2) { const t = i[s]; if (t === n && i[s + 1] === r) { const t = e[7], n = i[s + 2]; return t.length > n ? t[n] : null } "string" == typeof t && (s += 2) } return null }(t, e, i, r.index)), null !== o) (o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = s, o.__ngLastListenerFn__ = s, h = !1; else { s = Zo(r, e, 0, s, !1); const t = n.listen(p, i, s); u.push(s, t), c && c.push(i, m, f, f + 1) } } else s = Zo(r, e, 0, s, !0), p.addEventListener(i, s, o), u.push(s), c && c.push(i, m, f, o) } else s = Zo(r, e, 0, s, !1); const d = r.outputs; let p; if (h && null !== d && (p = d[i])) { const t = p.length; if (t) for (let n = 0; n < t; n += 2) { const t = e[p[n]][p[n + 1]].subscribe(s), o = u.length; u.push(s, t), c && c.push(i, r.index, o, -(o + 1)) } } } function qo(t, e, n, r) { try { return !1 !== n(r) } catch (i) { return Zs(t, i), !1 } } function Zo(t, e, n, r, i) { return function n(s) { if (s === Function) return r; const o = 2 & t.flags ? Ee(t.index, e) : e; 0 == (32 & e[2]) && Gs(o); let a = qo(e, 0, r, s), l = n.__ngNextListenerFn__; for (; l;)a = qo(e, 0, l, s) && a, l = l.__ngNextListenerFn__; return i && !1 === a && (s.preventDefault(), s.returnValue = !1), a } } function Ko(t = 1) { return function (t) { return (Le.lFrame.contextLView = function (t, e) { for (; t > 0;)e = e[15], t--; return e }(t, Le.lFrame.contextLView))[8] }(t) } function Yo(t, e) { let n = null; const r = function (t) { const e = t.attrs; if (null != e) { const t = e.indexOf(5); if (0 == (1 & t)) return e[t + 1] } return null }(t); for (let i = 0; i < e.length; i++) { const s = e[i]; if ("*" !== s) { if (null === r ? Yi(t, s, !0) : Qi(r, s)) return i } else n = i } return n } function Qo(t) { const e = De()[16][6]; if (!e.projection) { const n = e.projection = rr(t ? t.length : 1, null), r = n.slice(); let i = e.child; for (; null !== i;) { const e = t ? Yo(i, t) : 0; null !== e && (r[e] ? r[e].projectionNext = i : n[e] = i, r[e] = i), i = i.next } } } function $o(t, e = 0, n) { const r = De(), i = Ie(), s = ds(i, ee + t, 16, null, n || null); null === s.projection && (s.projection = e), Ue(), 64 != (64 & s.flags) && function (t, e, n) { Ui(e[11], 0, e, n, Ai(t, n, e), ki(n.parent || e[6], n, e)) }(i, r, s) } function ta(t, e, n, r, i) { const s = t[n + 1], o = null === e; let a = r ? ss(s) : as(s), l = !1; for (; 0 !== a && (!1 === l || o);) { const n = t[a + 1]; ea(t[a], e) && (l = !0, t[a + 1] = r ? cs(n) : os(n)), a = r ? ss(n) : as(n) } l && (t[n + 1] = r ? os(s) : cs(s)) } function ea(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && or(t, e) >= 0 } const na = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function ra(t) { return t.substring(na.key, na.keyEnd) } function ia(t, e) { const n = na.textEnd; return n === e ? -1 : (e = na.keyEnd = function (t, e, n) { for (; e < n && t.charCodeAt(e) > 32;)e++; return e }(t, na.key = e, n), sa(t, e, n)) } function sa(t, e, n) { for (; e < n && t.charCodeAt(e) <= 32;)e++; return e } function oa(t, e, n) { return ca(t, e, n, !1), oa } function aa(t, e) { return ca(t, e, null, !0), aa } function la(t, e) { for (let n = function (t) { return function (t) { na.key = 0, na.keyEnd = 0, na.value = 0, na.valueEnd = 0, na.textEnd = t.length }(t), ia(t, sa(t, 0, na.textEnd)) }(e); n >= 0; n = ia(e, n))ir(t, ra(e), !0) } function ca(t, e, n, r) { const i = De(), s = Ie(), o = Xe(2); s.firstUpdatePass && ha(s, t, o, r), e !== es && Co(i, o, e) && fa(s, s.data[an()], i, i[11], t, i[o + 1] = function (t, e) { return null == t || ("string" == typeof e ? t += e : "object" == typeof t && (t = it(Lr(t)))), t }(e, n), r, o) } function ua(t, e) { return e >= t.expandoStartIndex } function ha(t, e, n, r) { const i = t.data; if (null === i[n + 1]) { const s = i[an()], o = ua(t, n); va(s, r) && null === e && !o && (e = !1), e = function (t, e, n, r) { const i = Ze(t); let s = r ? e.residualClasses : e.residualStyles; if (null === i) 0 === (r ? e.classBindings : e.styleBindings) && (n = pa(n = da(null, t, e, n, r), e.attrs, r), s = null); else { const o = e.directiveStylingLast; if (-1 === o || t[o] !== i) if (n = da(i, t, e, n, r), null === s) { let n = function (t, e, n) { const r = n ? e.classBindings : e.styleBindings; if (0 !== as(r)) return t[ss(r)] }(t, e, r); void 0 !== n && Array.isArray(n) && (n = da(null, t, e, n[1], r), n = pa(n, e.attrs, r), function (t, e, n, r) { t[ss(n ? e.classBindings : e.styleBindings)] = r }(t, e, r, n)) } else s = function (t, e, n) { let r; const i = e.directiveEnd; for (let s = 1 + e.directiveStylingLast; s < i; s++)r = pa(r, t[s].hostAttrs, n); return pa(r, e.attrs, n) }(t, e, r) } return void 0 !== s && (r ? e.residualClasses = s : e.residualStyles = s), n }(i, s, e, r), function (t, e, n, r, i, s) { let o = s ? e.classBindings : e.styleBindings, a = ss(o), l = as(o); t[r] = n; let c, u = !1; if (Array.isArray(n)) { const t = n; c = t[1], (null === c || or(t, c) > 0) && (u = !0) } else c = n; if (i) if (0 !== l) { const e = ss(t[a + 1]); t[r + 1] = is(e, a), 0 !== e && (t[e + 1] = ls(t[e + 1], r)), t[a + 1] = 131071 & t[a + 1] | r << 17 } else t[r + 1] = is(a, 0), 0 !== a && (t[a + 1] = ls(t[a + 1], r)), a = r; else t[r + 1] = is(l, 0), 0 === a ? a = r : t[l + 1] = ls(t[l + 1], r), l = r; u && (t[r + 1] = os(t[r + 1])), ta(t, c, r, !0), ta(t, c, r, !1), function (t, e, n, r, i) { const s = i ? t.residualClasses : t.residualStyles; null != s && "string" == typeof e && or(s, e) >= 0 && (n[r + 1] = cs(n[r + 1])) }(e, c, t, r, s), o = is(a, l), s ? e.classBindings = o : e.styleBindings = o }(i, s, e, n, o, r) } } function da(t, e, n, r, i) { let s = null; const o = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < o && (s = e[a], r = pa(r, s.hostAttrs, i), s !== t);)a++; return null !== t && (n.directiveStylingLast = a), r } function pa(t, e, n) { const r = n ? 1 : 2; let i = -1; if (null !== e) for (let s = 0; s < e.length; s++) { const o = e[s]; "number" == typeof o ? i = o : i === r && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), ir(t, o, !!n || e[++s])) } return void 0 === t ? null : t } function fa(t, e, n, r, i, s, o, a) { if (!(3 & e.type)) return; const l = t.data, c = l[a + 1]; ga(1 == (1 & c) ? ma(l, e, n, i, as(c), o) : void 0) || (ga(s) || 2 == (2 & c) && (s = ma(l, null, n, i, a, o)), function (t, e, n, r, i) { const s = ye(t); if (e) i ? s ? t.addClass(n, r) : n.classList.add(r) : s ? t.removeClass(n, r) : n.classList.remove(r); else { let e = -1 === r.indexOf("-") ? void 0 : mi.DashCase; if (null == i) s ? t.removeStyle(n, r, e) : n.style.removeProperty(r); else { const o = "string" == typeof i && i.endsWith("!important"); o && (i = i.slice(0, -10), e |= mi.Important), s ? t.setStyle(n, r, i, e) : n.style.setProperty(r, i, o ? "important" : "") } } }(r, o, we(an(), n), i, s)) } function ma(t, e, n, r, i, s) { const o = null === e; let a; for (; i > 0;) { const e = t[i], s = Array.isArray(e), l = s ? e[1] : e, c = null === l; let u = n[i + 1]; u === es && (u = c ? Ft : void 0); let h = c ? sr(u, r) : l === r ? u : void 0; if (s && !ga(h) && (h = sr(e, r)), ga(h) && (a = h, o)) return a; const d = t[i + 1]; i = o ? ss(d) : as(d) } if (null !== e) { let t = s ? e.residualClasses : e.residualStyles; null != t && (a = sr(t, r)) } return a } function ga(t) { return void 0 !== t } function va(t, e) { return 0 != (t.flags & (e ? 16 : 32)) } function ya(t, e = "") { const n = De(), r = Ie(), i = t + ee, s = r.firstCreatePass ? ds(r, i, 1, e, null) : r.data[i], o = n[i] = function (t, e) { return ye(t) ? t.createText(e) : t.createTextNode(e) }(n[11], e); Ii(r, n, o, s), Be(s, !1) } function ba(t) { return _a("", t, ""), ba } function _a(t, e, n) { const r = De(), i = function (t, e, n, r) { return Co(t, Je(), n) ? e + ht(n) + r : es }(r, t, e, n); return i !== es && Ys(r, an(), i), _a } function wa(t, e, n, r, i) { const s = De(), o = function (t, e, n, r, i, s) { const o = Po(t, je(), n, i); return Xe(2), o ? e + ht(n) + r + ht(i) + s : es }(s, t, e, n, r, i); return o !== es && Ys(s, an(), o), wa } function Sa(t, e, n) { const r = De(); return Co(r, Je(), e) && Es(Ie(), cn(), r, t, e, r[11], n, !0), Sa } function xa(t, e, n) { const r = De(); if (Co(r, Je(), e)) { const i = Ie(), s = cn(); Es(i, s, r, t, e, qs(Ze(i.data), s, r), n, !0) } return xa } const Ta = void 0; var Ea = ["en", [["a", "p"], ["AM", "PM"], Ta], [["AM", "PM"], Ta, Ta], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], Ta, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], Ta, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", Ta, "{1} 'at' {0}", Ta], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (t) { let e = Math.floor(Math.abs(t)), n = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === n ? 1 : 5 }]; let Ma = {}; function Aa(t) { const e = function (t) { return t.toLowerCase().replace(/_/g, "-") }(t); let n = Ca(e); if (n) return n; const r = e.split("-")[0]; if (n = Ca(r), n) return n; if ("en" === r) return Ea; throw new Error(`Missing locale data for the locale "${t}".`) } function Ca(t) { return t in Ma || (Ma[t] = It.ng && It.ng.common && It.ng.common.locales && It.ng.common.locales[t]), Ma[t] } var Pa = (() => ((Pa = Pa || {})[Pa.LocaleId = 0] = "LocaleId", Pa[Pa.DayPeriodsFormat = 1] = "DayPeriodsFormat", Pa[Pa.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", Pa[Pa.DaysFormat = 3] = "DaysFormat", Pa[Pa.DaysStandalone = 4] = "DaysStandalone", Pa[Pa.MonthsFormat = 5] = "MonthsFormat", Pa[Pa.MonthsStandalone = 6] = "MonthsStandalone", Pa[Pa.Eras = 7] = "Eras", Pa[Pa.FirstDayOfWeek = 8] = "FirstDayOfWeek", Pa[Pa.WeekendRange = 9] = "WeekendRange", Pa[Pa.DateFormat = 10] = "DateFormat", Pa[Pa.TimeFormat = 11] = "TimeFormat", Pa[Pa.DateTimeFormat = 12] = "DateTimeFormat", Pa[Pa.NumberSymbols = 13] = "NumberSymbols", Pa[Pa.NumberFormats = 14] = "NumberFormats", Pa[Pa.CurrencyCode = 15] = "CurrencyCode", Pa[Pa.CurrencySymbol = 16] = "CurrencySymbol", Pa[Pa.CurrencyName = 17] = "CurrencyName", Pa[Pa.Currencies = 18] = "Currencies", Pa[Pa.Directionality = 19] = "Directionality", Pa[Pa.PluralCase = 20] = "PluralCase", Pa[Pa.ExtraData = 21] = "ExtraData", Pa))(); const Ra = "en-US"; let La = Ra; function ka(t) { var e, n; n = "Expected localeId to be defined", null == (e = t) && function (t, e, n, r) { throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`) }(n, e), "string" == typeof t && (La = t.toLowerCase().replace(/_/g, "-")) } function Da(t, e, n, r, i) { if (t = lt(t), Array.isArray(t)) for (let s = 0; s < t.length; s++)Da(t[s], e, n, r, i); else { const s = Ie(), o = De(); let a = po(t) ? t : lt(t.provide), l = co(t); const c = Fe(), u = 1048575 & c.providerIndexes, h = c.directiveStart, d = c.providerIndexes >> 20; if (po(t) || !t.multi) { const r = new vn(l, i, Do), p = Fa(a, e, i ? u : u + d, h); -1 === p ? (Dn(Pn(c, o), s, a), Ia(s, t, e.length), e.push(a), c.directiveStart++, c.directiveEnd++, i && (c.providerIndexes += 1048576), n.push(r), o.push(r)) : (n[p] = r, o[p] = r) } else { const p = Fa(a, e, u + d, h), f = Fa(a, e, u, u + d), m = p >= 0 && n[p], g = f >= 0 && n[f]; if (i && !g || !i && !m) { Dn(Pn(c, o), s, a); const u = function (t, e, n, r, i) { const s = new vn(t, n, Do); return s.multi = [], s.index = e, s.componentProviders = 0, Oa(s, i, r && !n), s }(i ? Ba : Na, n.length, i, r, l); !i && g && (n[f].providerFactory = u), Ia(s, t, e.length, 0), e.push(a), c.directiveStart++, c.directiveEnd++, i && (c.providerIndexes += 1048576), n.push(u), o.push(u) } else Ia(s, t, p > -1 ? p : f, Oa(n[i ? f : p], l, !i && r)); !i && r && g && n[f].componentProviders++ } } } function Ia(t, e, n, r) { const i = po(e); if (i || e.useClass) { const s = (e.useClass || e).prototype.ngOnDestroy; if (s) { const o = t.destroyHooks || (t.destroyHooks = []); if (!i && e.multi) { const t = o.indexOf(n); -1 === t ? o.push(n, [r, s]) : o[t + 1].push(r, s) } else o.push(n, s) } } } function Oa(t, e, n) { return n && t.componentProviders++, t.multi.push(e) - 1 } function Fa(t, e, n, r) { for (let i = n; i < r; i++)if (e[i] === t) return i; return -1 } function Na(t, e, n, r) { return Ha(this.multi, []) } function Ba(t, e, n, r) { const i = this.multi; let s; if (this.providerFactory) { const t = this.providerFactory.componentProviders, e = Gn(n, n[1], this.providerFactory.index, r); s = e.slice(0, t), Ha(i, s); for (let n = t; n < e.length; n++)s.push(e[n]) } else s = [], Ha(i, s); return s } function Ha(t, e) { for (let n = 0; n < t.length; n++)e.push((0, t[n])()); return e } function Ua(t, e = []) { return n => { n.providersResolver = (n, r) => function (t, e, n) { const r = Ie(); if (r.firstCreatePass) { const i = le(t); Da(n, r.data, r.blueprint, i, !0), Da(e, r.data, r.blueprint, i, !1) } }(n, r ? r(t) : t, e) } } class Ga { } class Va { resolveComponentFactory(t) { throw function (t) { const e = Error(`No component factory found for ${it(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(t) } } class za { } function ja(...t) { } function Ja(t, e) { return new Wa(Se(t, e)) } za.NULL = new Va; const Xa = function () { return Ja(Fe(), De()) }; let Wa = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = Xa, t })(); function qa(t) { return t instanceof Wa ? t.nativeElement : t } class Za { } let Ka = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Ya(), t })(); const Ya = function () { const t = De(), e = Ee(Fe().index, t); return function (t) { return t[11] }(re(e) ? e : t) }; let Qa = (() => { class t { } return t.\u0275prov = ft({ token: t, providedIn: "root", factory: () => null }), t })(); class $a { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const tl = new $a("12.1.1"); class el { constructor() { } supports(t) { return Eo(t) } create(t) { return new rl(t) } } const nl = (t, e) => e; class rl { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || nl } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, n = this._removalsHead, r = 0, i = null; for (; e || n;) { const s = !n || e && e.currentIndex < al(n, r, i) ? e : n, o = al(s, r, i), a = s.currentIndex; if (s === n) r--, n = n._nextRemoved; else if (e = e._next, null == s.previousIndex) r++; else { i || (i = []); const t = o - r, e = a - r; if (t != e) { for (let n = 0; n < t; n++) { const r = n < i.length ? i[n] : i[n] = 0, s = r + n; e <= s && s < t && (i[n] = r + 1) } i[s.previousIndex] = e - t } } o !== a && t(s, o, a) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !Eo(t)) throw new Error(`Error trying to diff '${it(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, n, r, i = this._itHead, s = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)n = t[e], r = this._trackByFn(e, n), null !== i && Object.is(i.trackById, r) ? (s && (i = this._verifyReinsertion(i, n, r, e)), Object.is(i.item, n) || this._addIdentityChange(i, n)) : (i = this._mismatch(i, n, r, e), s = !0), i = i._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[xo()](); let r; for (; !(r = n.next()).done;)e(r.value) } }(t, t => { r = this._trackByFn(e, t), null !== i && Object.is(i.trackById, r) ? (s && (i = this._verifyReinsertion(i, t, r, e)), Object.is(i.item, t) || this._addIdentityChange(i, t)) : (i = this._mismatch(i, t, r, e), s = !0), i = i._next, e++ }), this.length = e; return this._truncate(i), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, n, r) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, i, r)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(n, r)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, i, r)) : t = this._addAfter(new il(e, n), i, r), t } _verifyReinsertion(t, e, n, r) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== i ? t = this._reinsertAfter(i, t._prev, r) : t.currentIndex != r && (t.currentIndex = r, this._addToMoves(t, r)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const r = t._prevRemoved, i = t._nextRemoved; return null === r ? this._removalsHead = i : r._nextRemoved = i, null === i ? this._removalsTail = r : i._prevRemoved = r, this._insertAfter(t, e, n), this._addToMoves(t, n), t } _moveAfter(t, e, n) { return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t } _addAfter(t, e, n) { return this._insertAfter(t, e, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, n) { const r = null === e ? this._itHead : e._next; return t._next = r, t._prev = e, null === r ? this._itTail = t : r._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new ol), this._linkedRecords.put(t), t.currentIndex = n, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, n = t._next; return null === e ? this._itHead = n : e._next = n, null === n ? this._itTail = e : n._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new ol), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class il { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class sl { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === e || e <= n.currentIndex) && Object.is(n.trackById, t)) return n; return null } remove(t) { const e = t._prevDup, n = t._nextDup; return null === e ? this._head = n : e._nextDup = n, null === n ? this._tail = e : n._prevDup = e, null === this._head } } class ol { constructor() { this.map = new Map } put(t) { const e = t.trackById; let n = this.map.get(e); n || (n = new sl, this.map.set(e, n)), n.add(t) } get(t, e) { const n = this.map.get(t); return n ? n.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function al(t, e, n) { const r = t.previousIndex; if (null === r) return r; let i = 0; return n && r < n.length && (i = n[r]), r + e + i } class ll { constructor() { } supports(t) { return t instanceof Map || Mo(t) } create() { return new cl } } class cl { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || Mo(t))) throw new Error(`Error trying to diff '${it(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, n) => { if (e && e.key === n) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const r = this._getOrCreateRecordForKey(n, t); e = this._insertBeforeOrAppend(e, r) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const n = t._prev; return e._next = t, e._prev = n, t._prev = e, n && (n._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const n = this._records.get(t); this._maybeAddToChanges(n, e); const r = n._prev, i = n._next; return r && (r._next = i), i && (i._prev = r), n._next = null, n._prev = null, n } const n = new ul(t); return this._records.set(t, n), n.currentValue = e, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(n => e(t[n], n)) } } class ul { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function hl() { return new dl([new el]) } let dl = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (null != n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => t.create(e, n || hl()), deps: [[t, new _r, new br]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${n = t, n.name || typeof n}'`); var n } } return t.\u0275prov = ft({ token: t, providedIn: "root", factory: hl }), t })(); function pl() { return new fl([new ll]) } let fl = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => t.create(e, n || pl()), deps: [[t, new _r, new br]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.\u0275prov = ft({ token: t, providedIn: "root", factory: pl }), t })(); function ml(t, e, n, r, i = !1) { for (; null !== n;) { const s = e[n.index]; if (null !== s && r.push(_e(s)), ie(s)) for (let t = ne; t < s.length; t++) { const e = s[t], n = e[1].firstChild; null !== n && ml(e[1], e, n, r) } const o = n.type; if (8 & o) ml(t, e, n.child, r); else if (32 & o) { const t = gi(n, e); let i; for (; i = t();)r.push(i) } else if (16 & o) { const t = Fi(e, n); if (Array.isArray(t)) r.push(...t); else { const n = vi(e[16]); ml(n[1], n, t, r, !0) } } n = i ? n.projectionNext : n.next } return r } class gl { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, e = t[1]; return ml(e, t, e.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (ie(t)) { const e = t[8], n = e ? e.indexOf(this) : -1; n > -1 && (Ti(t, n), nr(e, n)) } this._attachedToViewContainer = !1 } Ei(this._lView[1], this._lView) } onDestroy(t) { xs(this._lView[1], this._lView, null, t) } markForCheck() { Gs(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { Vs(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (t, e, n) { Ve(!0); try { Vs(t, e, n) } finally { Ve(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._attachedToViewContainer = !0 } detachFromAppRef() { var t; this._appRef = null, Hi(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class vl extends gl { constructor(t) { super(t), this._view = t } detectChanges() { zs(this._view) } checkNoChanges() { !function (t) { Ve(!0); try { zs(t) } finally { Ve(!1) } }(this._view) } get context() { return null } } const yl = function (t) { return function (t, e, n) { if (oe(t) && !n) { const n = Ee(t.index, e); return new gl(n, n) } return 47 & t.type ? new gl(e[16], e) : null }(Fe(), De(), 16 == (16 & t)) }; let bl = (() => { class t { } return t.__NG_ELEMENT_ID__ = yl, t })(); const _l = [new ll], wl = new dl([new el]), Sl = new fl(_l), xl = function () { return Al(Fe(), De()) }; let Tl = (() => { class t { } return t.__NG_ELEMENT_ID__ = xl, t })(); const El = Tl, Ml = class extends El { constructor(t, e, n) { super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = n } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, n = hs(this._declarationLView, e, t, 16, null, e.declTNode, null, null, null, null); n[17] = this._declarationLView[this._declarationTContainer.index]; const r = this._declarationLView[19]; return null !== r && (n[19] = r.createEmbeddedView(e)), fs(e, n, t), new gl(n) } }; function Al(t, e) { return 4 & t.type ? new Ml(e, t, Ja(t, e)) : null } class Cl { } class Pl { } const Rl = function () { return Fl(Fe(), De()) }; let Ll = (() => { class t { } return t.__NG_ELEMENT_ID__ = Rl, t })(); const kl = Ll, Dl = class extends kl { constructor(t, e, n) { super(), this._lContainer = t, this._hostTNode = e, this._hostLView = n } get element() { return Ja(this._hostTNode, this._hostLView) } get injector() { return new jn(this._hostTNode, this._hostLView) } get parentInjector() { const t = kn(this._hostTNode, this._hostLView); if (xn(t)) { const e = En(t, this._hostLView), n = Tn(t); return new jn(e[1].data[n + 8], e) } return new jn(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const e = Il(this._lContainer); return null !== e && e[t] || null } get length() { return this._lContainer.length - ne } createEmbeddedView(t, e, n) { const r = t.createEmbeddedView(e || {}); return this.insert(r, n), r } createComponent(t, e, n, r, i) { const s = n || this.parentInjector; if (!i && null == t.ngModule && s) { const t = s.get(Cl, null); t && (i = t) } const o = t.create(s, r, void 0, i); return this.insert(o.hostView, e), o } insert(t, e) { const n = t._lView, r = n[1]; if (ie(n[3])) { const e = this.indexOf(t); if (-1 !== e) this.detach(e); else { const e = n[3], r = new Dl(e, e[6], e[3]); r.detach(r.indexOf(t)) } } const i = this._adjustIndex(e), s = this._lContainer; !function (t, e, n, r) { const i = ne + r, s = n.length; r > 0 && (n[i - 1][4] = e), r < s - ne ? (e[4] = n[i], er(n, ne + r, e)) : (n.push(e), e[4] = null), e[3] = n; const o = e[17]; null !== o && n !== o && function (t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(o, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 128 }(r, n, s, i); const o = Ni(i, s), a = n[11], l = Li(a, s[7]); return null !== l && function (t, e, n, r, i, s) { r[0] = i, r[6] = e, Hi(t, r, n, 1, i, s) }(r, s[6], a, n, l, o), t.attachToViewContainerRef(), er(Ol(s), i, t), t } move(t, e) { return this.insert(t, e) } indexOf(t) { const e = Il(this._lContainer); return null !== e ? e.indexOf(t) : -1 } remove(t) { const e = this._adjustIndex(t, -1), n = Ti(this._lContainer, e); n && (nr(Ol(this._lContainer), e), Ei(n[1], n)) } detach(t) { const e = this._adjustIndex(t, -1), n = Ti(this._lContainer, e); return n && null != nr(Ol(this._lContainer), e) ? new gl(n) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } }; function Il(t) { return t[8] } function Ol(t) { return t[8] || (t[8] = []) } function Fl(t, e) { let n; const r = e[t.index]; if (ie(r)) n = r; else { let i; if (8 & t.type) i = _e(r); else { const n = e[11]; i = n.createComment(""); const r = Se(t, e); Ci(n, Li(n, r), i, function (t, e) { return ye(t) ? t.nextSibling(e) : e.nextSibling }(n, r), !1) } e[t.index] = n = Fs(r, e, i, t), Us(e, n) } return new Dl(n, t, e) } const Nl = {}; class Bl extends za { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = $t(t); return new Gl(e, this.ngModule) } } function Hl(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } const Ul = new Kn("SCHEDULER_TOKEN", { providedIn: "root", factory: () => pi }); class Gl extends Ga { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(ts).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return Hl(this.componentDef.inputs) } get outputs() { return Hl(this.componentDef.outputs) } create(t, e, n, r) { const i = (r = r || this.ngModule) ? function (t, e) { return { get: (n, r, i) => { const s = t.get(n, Nl, i); return s !== Nl || r === Nl ? s : e.get(n, r, i) } } }(t, r.injector) : t, s = i.get(Za, be), o = i.get(Qa, null), a = s.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", c = n ? function (t, e, n) { if (ye(t)) return t.selectRootElement(e, n === Pt.ShadowDom); let r = "string" == typeof e ? t.querySelector(e) : e; return r.textContent = "", r }(a, n, this.componentDef.encapsulation) : Si(s.createRenderer(null, this.componentDef), l, function (t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(l)), u = this.componentDef.onPush ? 576 : 528, h = { components: [], scheduler: pi, clean: Js, playerHandler: null, flags: 0 }, d = Ss(0, null, null, 1, 0, null, null, null, null, null), p = hs(null, d, h, u, null, null, s, a, o, i); let f, m; tn(p); try { const t = function (t, e, n, r, i, s) { const o = n[1]; n[20] = t; const a = ds(o, 20, 2, "#host", null), l = a.mergedAttrs = e.hostAttrs; null !== l && (Qs(a, l, !0), null !== t && (yn(i, t, l), null !== a.classes && Vi(i, t, a.classes), null !== a.styles && Gi(i, t, a.styles))); const c = r.createRenderer(t, e), u = hs(n, ws(e), null, e.onPush ? 64 : 16, n[20], a, r, c, null, null); return o.firstCreatePass && (Dn(Pn(a, n), o, e.type), Ps(o, a), Ls(a, n.length, 1)), Us(n, u), n[20] = u }(c, this.componentDef, p, s, a); if (c) if (n) yn(a, c, ["ng-version", tl.full]); else { const { attrs: t, classes: e } = function (t) { const e = [], n = []; let r = 1, i = 2; for (; r < t.length;) { let s = t[r]; if ("string" == typeof s) 2 === i ? "" !== s && e.push(s, t[++r]) : 8 === i && n.push(s); else { if (!Zi(i)) break; i = s } r++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); t && yn(a, c, t), e && e.length > 0 && Vi(a, c, e.join(" ")) } if (m = xe(d, ee), void 0 !== e) { const t = m.projection = []; for (let n = 0; n < this.ngContentSelectors.length; n++) { const r = e[n]; t.push(null != r ? Array.from(r) : null) } } f = function (t, e, n, r, i) { const s = n[1], o = function (t, e, n) { const r = Fe(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), ks(t, r, e, ps(t, e, 1, null), n)); const i = Gn(e, t, r.directiveStart, r); ai(i, e); const s = Se(r, e); return s && ai(s, e), i }(s, n, e); if (r.components.push(o), t[8] = o, i && i.forEach(t => t(o, e)), e.contentQueries) { const t = Fe(); e.contentQueries(1, o, t.directiveStart) } const a = Fe(); return !s.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (ln(a.index), As(n[1], a, 0, a.directiveStart, a.directiveEnd, e), Cs(e, o)), o }(t, this.componentDef, p, h, [go]), fs(d, p, null) } finally { on() } return new Vl(this.componentType, f, Ja(m, p), p, m) } } class Vl extends class { }{ constructor(t, e, n, r, i) { super(), this.location = n, this._rootLView = r, this._tNode = i, this.instance = e, this.hostView = this.changeDetectorRef = new vl(r), this.componentType = t } get injector() { return new jn(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } const zl = new Map; class jl extends Cl { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new Bl(this); const n = te(t), r = t[Gt] || null; r && ka(r), this._bootstrapComponents = fi(n.bootstrap), this._r3Injector = oo(t, e, [{ provide: Cl, useValue: this }, { provide: za, useValue: this.componentFactoryResolver }], it(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = mo.THROW_IF_NOT_FOUND, n = xt.Default) { return t === mo || t === Cl || t === $s ? this : this._r3Injector.get(t, e, n) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Jl extends Pl { constructor(t) { super(), this.moduleType = t, null !== te(t) && function (t) { const e = new Set; !function t(n) { const r = te(n, !0), i = r.id; null !== i && (function (t, e, n) { if (e && e !== n) throw new Error(`Duplicate module registered for ${t} - ${it(e)} vs ${it(e.name)}`) }(i, zl.get(i), n), zl.set(i, n)); const s = fi(r.imports); for (const o of s) e.has(o) || (e.add(o), t(o)) }(t) }(t) } create(t) { return new jl(this.moduleType, t) } } function Xl(t, e) { const n = t[e]; return n === es ? void 0 : n } function Wl(t, e, n, r, i, s) { const o = e + n; return Co(t, o, i) ? Ao(t, o + 1, s ? r.call(s, i) : r(i)) : Xl(t, o + 1) } function ql(t, e, n, r, i, s, o) { const a = e + n; return Po(t, a, i, s) ? Ao(t, a + 2, o ? r.call(o, i, s) : r(i, s)) : Xl(t, a + 2) } function Zl(t, e) { const n = Ie(); let r; const i = t + ee; n.firstCreatePass ? (r = function (t, e) { if (e) for (let n = e.length - 1; n >= 0; n--) { const r = e[n]; if (t === r.name) return r } throw new ut("302", `The pipe '${t}' could not be found!`) }(e, n.pipeRegistry), n.data[i] = r, r.onDestroy && (n.destroyHooks || (n.destroyHooks = [])).push(i, r.onDestroy)) : r = n.data[i]; const s = r.factory || (r.factory = ce(r.type)), o = Et(Do); try { const t = An(!1), e = s(); return An(t), function (t, e, n, r) { n >= t.data.length && (t.data[n] = null, t.blueprint[n] = null), e[n] = r }(n, De(), i, e), e } finally { Et(o) } } function Kl(t, e, n) { const r = t + ee, i = De(), s = Te(i, r); return $l(i, Ql(i, r) ? Wl(i, ze(), e, s.transform, n, s) : s.transform(n)) } function Yl(t, e, n, r) { const i = t + ee, s = De(), o = Te(s, i); return $l(s, Ql(s, i) ? ql(s, ze(), e, o.transform, n, r, o) : o.transform(n, r)) } function Ql(t, e) { return t[1].data[e].pure } function $l(t, e) { return To.isWrapped(e) && (e = To.unwrap(e), t[je()] = es), e } function tc(t) { return e => { setTimeout(t, void 0, e) } } const ec = class extends M { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, n) { var r, i, s; let o = t, a = e || (() => null), l = n; if (t && "object" == typeof t) { const e = t; o = null === (r = e.next) || void 0 === r ? void 0 : r.bind(e), a = null === (i = e.error) || void 0 === i ? void 0 : i.bind(e), l = null === (s = e.complete) || void 0 === s ? void 0 : s.bind(e) } this.__isAsync && (a = tc(a), o && (o = tc(o)), l && (l = tc(l))); const c = super.subscribe({ next: o, error: a, complete: l }); return t instanceof d && t.add(c), c } }; function nc() { return this._results[xo()]() } class rc { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = xo(), n = rc.prototype; n[e] || (n[e] = nc) } get changes() { return this._changes || (this._changes = new ec) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, e) { const n = this; n.dirty = !1; const r = $n(t); (this._changesDetected = !function (t, e, n) { if (t.length !== e.length) return !1; for (let r = 0; r < t.length; r++) { let i = t[r], s = e[r]; if (n && (i = n(i), s = n(s)), s !== i) return !1 } return !0 }(n._results, r, e)) && (n._results = r, n.length = r.length, n.last = r[this.length - 1], n.first = r[0]) } notifyOnChanges() { !this._changes || !this._changesDetected && this._emitDistinctChangesOnly || this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } Symbol; class ic { constructor(t) { this.queryList = t, this.matches = null } clone() { return new ic(this.queryList) } setDirty() { this.queryList.setDirty() } } class sc { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const n = null !== t.contentQueries ? t.contentQueries[0] : e.length, r = []; for (let t = 0; t < n; t++) { const n = e.getByIndex(t); r.push(this.queries[n.indexInDeclarationView].clone()) } return new sc(r) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== bc(t, e).matches && this.queries[e].setDirty() } } class oc { constructor(t, e, n = null) { this.predicate = t, this.flags = e, this.read = n } } class ac { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let n = 0; n < this.length; n++) { const r = null !== e ? e.length : 0, i = this.getByIndex(n).embeddedTView(t, r); i && (i.indexInDeclarationView = n, null !== e ? e.push(i) : e = [i]) } return null !== e ? new ac(e) : null } template(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class lc { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new lc(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let n = t.parent; for (; null !== n && 8 & n.type && n.index !== e;)n = n.parent; return e === (null !== n ? n.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const n = this.metadata.predicate; if (Array.isArray(n)) for (let r = 0; r < n.length; r++) { const i = n[r]; this.matchTNodeWithReadOption(t, e, cc(e, i)), this.matchTNodeWithReadOption(t, e, Un(e, t, i, !1, !1)) } else n === Tl ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, Un(e, t, n, !1, !1)) } matchTNodeWithReadOption(t, e, n) { if (null !== n) { const r = this.metadata.read; if (null !== r) if (r === Wa || r === Ll || r === Tl && 4 & e.type) this.addMatch(e.index, -2); else { const n = Un(e, t, r, !1, !1); null !== n && this.addMatch(e.index, n) } else this.addMatch(e.index, n) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function cc(t, e) { const n = t.localNames; if (null !== n) for (let r = 0; r < n.length; r += 2)if (n[r] === e) return n[r + 1]; return null } function uc(t, e, n, r) { return -1 === n ? function (t, e) { return 11 & t.type ? Ja(t, e) : 4 & t.type ? Al(t, e) : null }(e, t) : -2 === n ? function (t, e, n) { return n === Wa ? Ja(e, t) : n === Tl ? Al(e, t) : n === Ll ? Fl(e, t) : void 0 }(t, e, r) : Gn(t, t[1], n, e) } function hc(t, e, n, r) { const i = e[19].queries[r]; if (null === i.matches) { const r = t.data, s = n.matches, o = []; for (let t = 0; t < s.length; t += 2) { const i = s[t]; o.push(i < 0 ? null : uc(e, r[i], s[t + 1], n.metadata.read)) } i.matches = o } return i.matches } function dc(t, e, n, r) { const i = t.queries.getByIndex(n), s = i.matches; if (null !== s) { const o = hc(t, e, i, n); for (let t = 0; t < s.length; t += 2) { const n = s[t]; if (n > 0) r.push(o[t / 2]); else { const i = s[t + 1], o = e[-n]; for (let t = ne; t < o.length; t++) { const e = o[t]; e[17] === e[3] && dc(e[1], e, i, r) } if (null !== o[9]) { const t = o[9]; for (let e = 0; e < t.length; e++) { const n = t[e]; dc(n[1], n, i, r) } } } } } return r } function pc(t) { const e = De(), n = Ie(), r = Ke(); Ye(r + 1); const i = bc(n, r); if (t.dirty && Me(e) === (2 == (2 & i.metadata.flags))) { if (null === i.matches) t.reset([]); else { const s = i.crossesNgTemplate ? dc(n, e, r, []) : hc(n, e, i, r); t.reset(s, qa), t.notifyOnChanges() } return !0 } return !1 } function fc(t, e, n) { const r = Ie(); r.firstCreatePass && (yc(r, new oc(t, e, n), -1), 2 == (2 & e) && (r.staticViewQueries = !0)), vc(r, De(), e) } function mc(t, e, n, r) { const i = Ie(); if (i.firstCreatePass) { const s = Fe(); yc(i, new oc(e, n, r), s.index), function (t, e) { const n = t.contentQueries || (t.contentQueries = []); e !== (n.length ? n[n.length - 1] : -1) && n.push(t.queries.length - 1, e) }(i, t), 2 == (2 & n) && (i.staticContentQueries = !0) } vc(i, De(), n) } function gc() { return t = De(), e = Ke(), t[19].queries[e].queryList; var t, e } function vc(t, e, n) { const r = new rc(4 == (4 & n)); xs(t, e, r, r.destroy), null === e[19] && (e[19] = new sc), e[19].queries.push(new ic(r)) } function yc(t, e, n) { null === t.queries && (t.queries = new ac), t.queries.track(new lc(e, n)) } function bc(t, e) { return t.queries.getByIndex(e) } function _c(t, e) { return Al(t, e) } const wc = new Kn("Application Initializer"); let Sc = (() => { class t { constructor(t) { this.appInits = t, this.resolve = ja, this.reject = ja, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const e = this.appInits[n](); if (Vo(e)) t.push(e); else if (jo(e)) { const n = new Promise((t, n) => { e.subscribe({ complete: t, error: n }) }); t.push(n) } } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } return t.\u0275fac = function (e) { return new (e || t)(fr(wc, 8)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const xc = new Kn("AppId"), Tc = { provide: xc, useFactory: function () { return `${Ec()}${Ec()}${Ec()}` }, deps: [] }; function Ec() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const Mc = new Kn("Platform Initializer"), Ac = new Kn("Platform ID"), Cc = new Kn("appBootstrapListener"); let Pc = (() => { class t { log(t) { console.log(t) } warn(t) { console.warn(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const Rc = new Kn("LocaleId"), Lc = new Kn("DefaultCurrencyCode"); class kc { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const Dc = function (t) { return new Jl(t) }, Ic = Dc, Oc = function (t) { return Promise.resolve(Dc(t)) }, Fc = function (t) { const e = Dc(t), n = fi(te(t).declarations).reduce((t, e) => { const n = $t(e); return n && t.push(new Gl(n)), t }, []); return new kc(e, n) }, Nc = Fc, Bc = function (t) { return Promise.resolve(Fc(t)) }; let Hc = (() => { class t { constructor() { this.compileModuleSync = Ic, this.compileModuleAsync = Oc, this.compileModuleAndAllComponentsSync = Nc, this.compileModuleAndAllComponentsAsync = Bc } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const Uc = (() => Promise.resolve(0))(); function Gc(t) { "undefined" == typeof Zone ? Uc.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Vc { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: n = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new ec(!1), this.onMicrotaskEmpty = new ec(!1), this.onStable = new ec(!1), this.onError = new ec(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const r = this; r._nesting = 0, r._outer = r._inner = Zone.current, Zone.TaskTrackingZoneSpec && (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)), r.shouldCoalesceEventChangeDetection = !n && e, r.shouldCoalesceRunChangeDetection = n, r.lastRequestAnimationFrameId = -1, r.nativeRequestAnimationFrame = function () { let t = It.requestAnimationFrame, e = It.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const r = e[Zone.__symbol__("OriginalDelegate")]; r && (e = r) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function (t) { const e = () => { !function (t) { t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(It, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, Jc(t), t.isCheckStableRunning = !0, jc(t), t.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), Jc(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, i, s, o, a) => { try { return Xc(t), n.invokeTask(i, s, o, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === s.type || t.shouldCoalesceRunChangeDetection) && e(), Wc(t) } }, onInvoke: (n, r, i, s, o, a, l) => { try { return Xc(t), n.invoke(i, s, o, a, l) } finally { t.shouldCoalesceRunChangeDetection && e(), Wc(t) } }, onHasTask: (e, n, r, i) => { e.hasTask(r, i), n === r && ("microTask" == i.change ? (t._hasPendingMicrotasks = i.microTask, Jc(t), jc(t)) : "macroTask" == i.change && (t.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (e, n, r, i) => (e.handleError(r, i), t.runOutsideAngular(() => t.onError.emit(i)), !1) }) }(r) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Vc.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Vc.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, n) { return this._inner.run(t, e, n) } runTask(t, e, n, r) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + r, t, zc, ja, ja); try { return i.runTask(s, e, n) } finally { i.cancelTask(s) } } runGuarded(t, e, n) { return this._inner.runGuarded(t, e, n) } runOutsideAngular(t) { return this._outer.run(t) } } const zc = {}; function jc(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function Jc(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function Xc(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function Wc(t) { t._nesting--, jc(t) } class qc { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new ec, this.onMicrotaskEmpty = new ec, this.onStable = new ec, this.onError = new ec } run(t, e, n) { return t.apply(e, n) } runGuarded(t, e, n) { return t.apply(e, n) } runOutsideAngular(t) { return t() } runTask(t, e, n, r) { return t.apply(e, n) } } let Zc = (() => { class t { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Vc.assertNotInAngularZone(), Gc(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Gc(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, n) { let r = -1; e && e > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== r), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: r, updateCb: n }) } whenStable(t, e, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(t, e, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, n) { return [] } } return t.\u0275fac = function (e) { return new (e || t)(fr(Vc)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), Kc = (() => { class t { constructor() { this._applications = new Map, $c.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return $c.findTestabilityInTree(this, t, e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); class Yc { addToWindow(t) { } findTestabilityInTree(t, e, n) { return null } } let Qc, $c = new Yc, tu = !0, eu = !1; function nu() { return eu = !0, tu } const ru = new Kn("AllowMultipleToken"); class iu { constructor(t, e) { this.name = t, this.token = e } } function su(t, e, n = []) { const r = `Platform: ${e}`, i = new Kn(r); return (e = []) => { let s = ou(); if (!s || s.injector.get(ru, !1)) if (t) t(n.concat(e).concat({ provide: i, useValue: !0 })); else { const t = n.concat(e).concat({ provide: i, useValue: !0 }, { provide: eo, useValue: "platform" }); !function (t) { if (Qc && !Qc.destroyed && !Qc.injector.get(ru, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); Qc = t.get(au); const e = t.get(Mc, null); e && e.forEach(t => t()) }(mo.create({ providers: t, name: r })) } return function (t) { const e = ou(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(i) } } function ou() { return Qc && !Qc.destroyed ? Qc : null } let au = (() => { class t { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const n = function (t, e) { let n; return n = "noop" === t ? new qc : ("zone.js" === t ? void 0 : t) || new Vc({ enableLongStackTrace: nu(), shouldCoalesceEventChangeDetection: !!(null == e ? void 0 : e.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == e ? void 0 : e.ngZoneRunCoalescing) }), n }(e ? e.ngZone : void 0, { ngZoneEventCoalescing: e && e.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: e && e.ngZoneRunCoalescing || !1 }), r = [{ provide: Vc, useValue: n }]; return n.run(() => { const e = mo.create({ providers: r, parent: this.injector, name: t.moduleType.name }), i = t.create(e), s = i.injector.get(di, null); if (!s) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return n.runOutsideAngular(() => { const t = n.onError.subscribe({ next: t => { s.handleError(t) } }); i.onDestroy(() => { uu(this._modules, i), t.unsubscribe() }) }), function (t, e, n) { try { const r = n(); return Vo(r) ? r.catch(n => { throw e.runOutsideAngular(() => t.handleError(n)), n }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } }(s, n, () => { const t = i.injector.get(Sc); return t.runInitializers(), t.donePromise.then(() => (ka(i.injector.get(Rc, Ra) || Ra), this._moduleDoBootstrap(i), i)) }) }) } bootstrapModule(t, e = []) { const n = lu({}, e); return function (t, e, n) { const r = new Jl(n); return Promise.resolve(r) }(0, 0, t).then(t => this.bootstrapModuleFactory(t, n)) } _moduleDoBootstrap(t) { const e = t.injector.get(cu); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${it(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (e) { return new (e || t)(fr(mo)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); function lu(t, e) { return Array.isArray(e) ? e.reduce(lu, t) : Object.assign(Object.assign({}, t), e) } let cu = (() => { class t { constructor(t, e, n, r, i) { this._zone = t, this._injector = e, this._exceptionHandler = n, this._componentFactoryResolver = r, this._initStatus = i, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const s = new w(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), o = new w(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { Vc.assertNotInAngularZone(), Gc(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { Vc.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), n.unsubscribe() } }); this.isStable = W(s, o.pipe(et())) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = t instanceof Ga ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(n.componentType); const r = n.isBoundToModule ? void 0 : this._injector.get(Cl), i = n.create(mo.NULL, [], e || n.selector, r), s = i.location.nativeElement, o = i.injector.get(Zc, null), a = o && i.injector.get(Kc); return o && a && a.registerApplication(s, o), i.onDestroy(() => { this.detachView(i.hostView), uu(this.components, i), a && a.unregisterApplication(s) }), this._loadComponent(i), i } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let t of this._views) t.detectChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; uu(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(Cc, []).concat(this._bootstrapListeners).forEach(e => e(t)) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return t.\u0275fac = function (e) { return new (e || t)(fr(Vc), fr(mo), fr(di), fr(za), fr(Sc)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); function uu(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class hu { } class du { } const pu = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let fu = (() => { class t { constructor(t, e) { this._compiler = t, this._config = e || pu } load(t) { return this.loadAndCompile(t) } loadAndCompile(t) { let [e, r] = t.split("#"); return void 0 === r && (r = "default"), n(8255)(e).then(t => t[r]).then(t => mu(t, e, r)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, r] = t.split("#"), i = "NgFactory"; return void 0 === r && (r = "default", i = ""), n(8255)(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[r + i]).then(t => mu(t, e, r)) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Hc), fr(du, 8)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); function mu(t, e, n) { if (!t) throw new Error(`Cannot find '${n}' in '${e}'`); return t } const gu = su(null, "core", [{ provide: Ac, useValue: "unknown" }, { provide: au, deps: [mo] }, { provide: Kc, deps: [] }, { provide: Pc, deps: [] }]), vu = [{ provide: cu, useClass: cu, deps: [Vc, mo, di, za, Sc] }, { provide: Ul, deps: [Vc], useFactory: function (t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } }, { provide: Sc, useClass: Sc, deps: [[new br, wc]] }, { provide: Hc, useClass: Hc, deps: [] }, Tc, { provide: dl, useFactory: function () { return wl }, deps: [] }, { provide: fl, useFactory: function () { return Sl }, deps: [] }, { provide: Rc, useFactory: function (t) { return ka(t = t || "undefined" != typeof $localize && $localize.locale || Ra), t }, deps: [[new yr(Rc), new br, new _r]] }, { provide: Lc, useValue: "USD" }]; let yu = (() => { class t { constructor(t) { } } return t.\u0275fac = function (e) { return new (e || t)(fr(cu)) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: vu }), t })(), bu = null; function _u() { return bu } const wu = new Kn("DocumentToken"); let Su = (() => { class t { historyGo(t) { throw new Error("Not implemented") } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ factory: xu, token: t, providedIn: "platform" }), t })(); function xu() { return fr(Eu) } const Tu = new Kn("Location Initialized"); let Eu = (() => { class t extends Su { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return _u().getBaseHref(this._doc) } onPopState(t) { const e = _u().getGlobalEventTarget(this._doc, "window"); return e.addEventListener("popstate", t, !1), () => e.removeEventListener("popstate", t) } onHashChange(t) { const e = _u().getGlobalEventTarget(this._doc, "window"); return e.addEventListener("hashchange", t, !1), () => e.removeEventListener("hashchange", t) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, n) { Mu() ? this._history.pushState(t, e, n) : this.location.hash = n } replaceState(t, e, n) { Mu() ? this._history.replaceState(t, e, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } historyGo(t = 0) { this._history.go(t) } getState() { return this._history.state } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu)) }, t.\u0275prov = ft({ factory: Au, token: t, providedIn: "platform" }), t })(); function Mu() { return !!window.history.pushState } function Au() { return new Eu(fr(wu)) } function Cu(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } function Pu(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } function Ru(t) { return t && "?" !== t[0] ? "?" + t : t } let Lu = (() => { class t { historyGo(t) { throw new Error("Not implemented") } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ factory: ku, token: t, providedIn: "root" }), t })(); function ku(t) { const e = fr(wu).location; return new Iu(fr(Su), e && e.origin || "") } const Du = new Kn("appBaseHref"); let Iu = (() => { class t extends Lu { constructor(t, e) { if (super(), this._platformLocation = t, this._removeListenerFns = [], null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return Cu(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + Ru(this._platformLocation.search), n = this._platformLocation.hash; return n && t ? `${e}${n}` : e } pushState(t, e, n, r) { const i = this.prepareExternalUrl(n + Ru(r)); this._platformLocation.pushState(t, e, i) } replaceState(t, e, n, r) { const i = this.prepareExternalUrl(n + Ru(r)); this._platformLocation.replaceState(t, e, i) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(t = 0) { var e, n; null === (n = (e = this._platformLocation).historyGo) || void 0 === n || n.call(e, t) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Su), fr(Du, 8)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), Ou = (() => { class t extends Lu { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", this._removeListenerFns = [], null != e && (this._baseHref = e) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = Cu(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, n, r) { let i = this.prepareExternalUrl(n + Ru(r)); 0 == i.length && (i = this._platformLocation.pathname), this._platformLocation.pushState(t, e, i) } replaceState(t, e, n, r) { let i = this.prepareExternalUrl(n + Ru(r)); 0 == i.length && (i = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, i) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(t = 0) { var e, n; null === (n = (e = this._platformLocation).historyGo) || void 0 === n || n.call(e, t) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Su), fr(Du, 8)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), Fu = (() => { class t { constructor(t, e) { this._subject = new ec, this._urlChangeListeners = [], this._platformStrategy = t; const n = this._platformStrategy.getBaseHref(); this._platformLocation = e, this._baseHref = Pu(Bu(n)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + Ru(e)) } normalize(e) { return t.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, Bu(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", n = null) { this._platformStrategy.pushState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Ru(e)), n) } replaceState(t, e = "", n = null) { this._platformStrategy.replaceState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + Ru(e)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(t = 0) { var e, n; null === (n = (e = this._platformStrategy).historyGo) || void 0 === n || n.call(e, t) } onUrlChange(t) { this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) })) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(n => n(t, e)) } subscribe(t, e, n) { return this._subject.subscribe({ next: t, error: e, complete: n }) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Lu), fr(Su)) }, t.normalizeQueryParams = Ru, t.joinWithSlash = Cu, t.stripTrailingSlash = Pu, t.\u0275prov = ft({ factory: Nu, token: t, providedIn: "root" }), t })(); function Nu() { return new Fu(fr(Lu), fr(Su)) } function Bu(t) { return t.replace(/\/index.html$/, "") } var Hu = (() => ((Hu = Hu || {})[Hu.Decimal = 0] = "Decimal", Hu[Hu.Percent = 1] = "Percent", Hu[Hu.Currency = 2] = "Currency", Hu[Hu.Scientific = 3] = "Scientific", Hu))(), Uu = (() => ((Uu = Uu || {})[Uu.Zero = 0] = "Zero", Uu[Uu.One = 1] = "One", Uu[Uu.Two = 2] = "Two", Uu[Uu.Few = 3] = "Few", Uu[Uu.Many = 4] = "Many", Uu[Uu.Other = 5] = "Other", Uu))(), Gu = (() => ((Gu = Gu || {})[Gu.Decimal = 0] = "Decimal", Gu[Gu.Group = 1] = "Group", Gu[Gu.List = 2] = "List", Gu[Gu.PercentSign = 3] = "PercentSign", Gu[Gu.PlusSign = 4] = "PlusSign", Gu[Gu.MinusSign = 5] = "MinusSign", Gu[Gu.Exponential = 6] = "Exponential", Gu[Gu.SuperscriptingExponent = 7] = "SuperscriptingExponent", Gu[Gu.PerMille = 8] = "PerMille", Gu[Gu[1 / 0] = 9] = "Infinity", Gu[Gu.NaN = 10] = "NaN", Gu[Gu.TimeSeparator = 11] = "TimeSeparator", Gu[Gu.CurrencyDecimal = 12] = "CurrencyDecimal", Gu[Gu.CurrencyGroup = 13] = "CurrencyGroup", Gu))(); function Vu(t, e) { const n = Aa(t), r = n[Pa.NumberSymbols][e]; if (void 0 === r) { if (e === Gu.CurrencyDecimal) return n[Pa.NumberSymbols][Gu.Decimal]; if (e === Gu.CurrencyGroup) return n[Pa.NumberSymbols][Gu.Group] } return r } const zu = /^(\d+)?\.((\d+)(-(\d+))?)?$/, ju = ".", Ju = "0"; function Xu(t) { const e = parseInt(t); if (isNaN(e)) throw new Error("Invalid integer literal when parsing " + t); return e } class Wu { } let qu = (() => { class t extends Wu { constructor(t) { super(), this.locale = t } getPluralCategory(t, e) { switch (function (t) { return Aa(t)[Pa.PluralCase] }(e || this.locale)(t)) { case Uu.Zero: return "zero"; case Uu.One: return "one"; case Uu.Two: return "two"; case Uu.Few: return "few"; case Uu.Many: return "many"; default: return "other" } } } return t.\u0275fac = function (e) { return new (e || t)(fr(Rc)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); function Zu(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const t = n.indexOf("="), [r, i] = -1 == t ? [n, ""] : [n.slice(0, t), n.slice(t + 1)]; if (r.trim() === e) return decodeURIComponent(i) } return null } let Ku = (() => { class t { constructor(t, e, n, r) { this._iterableDiffers = t, this._keyValueDiffers = e, this._ngEl = n, this._renderer = r, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(t) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof t ? t.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(t) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof t ? t.split(/\s+/) : t, this._rawClass && (Eo(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const t = this._iterableDiffer.diff(this._rawClass); t && this._applyIterableChanges(t) } else if (this._keyValueDiffer) { const t = this._keyValueDiffer.diff(this._rawClass); t && this._applyKeyValueChanges(t) } } _applyKeyValueChanges(t) { t.forEachAddedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachChangedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachRemovedItem(t => { t.previousValue && this._toggleClass(t.key, !1) }) } _applyIterableChanges(t) { t.forEachAddedItem(t => { if ("string" != typeof t.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${it(t.item)}`); this._toggleClass(t.item, !0) }), t.forEachRemovedItem(t => this._toggleClass(t.item, !1)) } _applyClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !0)) : Object.keys(t).forEach(e => this._toggleClass(e, !!t[e]))) } _removeClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !1)) : Object.keys(t).forEach(t => this._toggleClass(t, !1))) } _toggleClass(t, e) { (t = t.trim()) && t.split(/\s+/g).forEach(t => { e ? this._renderer.addClass(this._ngEl.nativeElement, t) : this._renderer.removeClass(this._ngEl.nativeElement, t) }) } } return t.\u0275fac = function (e) { return new (e || t)(Do(dl), Do(fl), Do(Wa), Do(Ka)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), t })(); class Yu { constructor(t, e, n, r) { this.$implicit = t, this.ngForOf = e, this.index = n, this.count = r } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Qu = (() => { class t { constructor(t, e, n) { this._viewContainer = t, this._template = e, this._differs = n, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const e = this._ngForOf; if (!this._differ && e) try { this._differ = this._differs.find(e).create(this.ngForTrackBy) } catch (wN) { throw new Error(`Cannot find a differ supporting object '${e}' of type '${t = e, t.name || typeof t}'. NgFor only supports binding to Iterables such as Arrays.`) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const e = []; t.forEachOperation((t, n, r) => { if (null == t.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new Yu(null, this._ngForOf, -1, -1), null === r ? void 0 : r), i = new $u(t, n); e.push(i) } else if (null == r) this._viewContainer.remove(null === n ? void 0 : n); else if (null !== n) { const i = this._viewContainer.get(n); this._viewContainer.move(i, r); const s = new $u(t, i); e.push(s) } }); for (let n = 0; n < e.length; n++)this._perViewChange(e[n].view, e[n].record); for (let n = 0, r = this._viewContainer.length; n < r; n++) { const t = this._viewContainer.get(n); t.context.index = n, t.context.count = r, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ll), Do(Tl), Do(dl)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })(); class $u { constructor(t, e) { this.record = t, this.view = e } } let th = (() => { class t { constructor(t, e) { this._viewContainer = t, this._context = new eh, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { nh("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { nh("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ll), Do(Tl)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class eh { constructor() { this.$implicit = null, this.ngIf = null } } function nh(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${it(e)}'.`) } class rh { constructor(t, e) { this._viewContainerRef = t, this._templateRef = e, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(t) { t && !this._created ? this.create() : !t && this._created && this.destroy() } } let ih = (() => { class t { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(t) { this._ngSwitch = t, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(t) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(t) } _matchCase(t) { const e = t == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || e, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), e } _updateDefaultCases(t) { if (this._defaultViews && t !== this._defaultUsed) { this._defaultUsed = t; for (let e = 0; e < this._defaultViews.length; e++)this._defaultViews[e].enforceState(t) } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" } }), t })(), sh = (() => { class t { constructor(t, e, n) { this.ngSwitch = n, n._addCase(), this._view = new rh(t, e) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ll), Do(Tl), Do(ih, 9)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" } }), t })(); function oh(t, e) { return Error(`InvalidPipeArgument: '${e}' for pipe '${it(t)}'`) } class ah { createSubscription(t, e) { return t.subscribe({ next: e, error: t => { throw t } }) } dispose(t) { t.unsubscribe() } onDestroy(t) { t.unsubscribe() } } class lh { createSubscription(t, e) { return t.then(e, t => { throw t }) } dispose(t) { } onDestroy(t) { } } const ch = new lh, uh = new ah; let hh = (() => { class t { constructor(t) { this._ref = t, this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null } ngOnDestroy() { this._subscription && this._dispose() } transform(t) { return this._obj ? t !== this._obj ? (this._dispose(), this.transform(t)) : this._latestValue : (t && this._subscribe(t), this._latestValue) } _subscribe(t) { this._obj = t, this._strategy = this._selectStrategy(t), this._subscription = this._strategy.createSubscription(t, e => this._updateLatestValue(t, e)) } _selectStrategy(e) { if (Vo(e)) return ch; if (zo(e)) return uh; throw oh(t, e) } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(t, e) { t === this._obj && (this._latestValue = e, this._ref.markForCheck()) } } return t.\u0275fac = function (e) { return new (e || t)(Do(bl, 16)) }, t.\u0275pipe = Qt({ name: "async", type: t, pure: !1 }), t })(); const dh = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D])\S*/g; let ph = (() => { class t { transform(e) { if (null == e) return null; if ("string" != typeof e) throw oh(t, e); return e.replace(dh, t => t[0].toUpperCase() + t.substr(1).toLowerCase()) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275pipe = Qt({ name: "titlecase", type: t, pure: !0 }), t })(), fh = (() => { class t { constructor(t) { this._locale = t } transform(e, n, r) { if (!function (t) { return !(null == t || "" === t || t != t) }(e)) return null; r = r || this._locale; try { return function (t, e, n) { return function (t, e, n, r, i, s, o = !1) { let a = "", l = !1; if (isFinite(t)) { let c = function (t) { let e, n, r, i, s, o = Math.abs(t) + "", a = 0; for ((n = o.indexOf(ju)) > -1 && (o = o.replace(ju, "")), (r = o.search(/e/i)) > 0 ? (n < 0 && (n = r), n += +o.slice(r + 1), o = o.substring(0, r)) : n < 0 && (n = o.length), r = 0; o.charAt(r) === Ju; r++); if (r === (s = o.length)) e = [0], n = 1; else { for (s--; o.charAt(s) === Ju;)s--; for (n -= r, e = [], i = 0; r <= s; r++, i++)e[i] = Number(o.charAt(r)) } return n > 22 && (e = e.splice(0, 21), a = n - 1, n = 1), { digits: e, exponent: a, integerLen: n } }(t); o && (c = function (t) { if (0 === t.digits[0]) return t; const e = t.digits.length - t.integerLen; return t.exponent ? t.exponent += 2 : (0 === e ? t.digits.push(0, 0) : 1 === e && t.digits.push(0), t.integerLen += 2), t }(c)); let u = e.minInt, h = e.minFrac, d = e.maxFrac; if (s) { const t = s.match(zu); if (null === t) throw new Error(`${s} is not a valid digit info`); const e = t[1], n = t[3], r = t[5]; null != e && (u = Xu(e)), null != n && (h = Xu(n)), null != r ? d = Xu(r) : null != n && h > d && (d = h) } !function (t, e, n) { if (e > n) throw new Error(`The minimum number of digits after fraction (${e}) is higher than the maximum (${n}).`); let r = t.digits, i = r.length - t.integerLen; const s = Math.min(Math.max(e, i), n); let o = s + t.integerLen, a = r[o]; if (o > 0) { r.splice(Math.max(t.integerLen, o)); for (let t = o; t < r.length; t++)r[t] = 0 } else { i = Math.max(0, i), t.integerLen = 1, r.length = Math.max(1, o = s + 1), r[0] = 0; for (let t = 1; t < o; t++)r[t] = 0 } if (a >= 5) if (o - 1 < 0) { for (let e = 0; e > o; e--)r.unshift(0), t.integerLen++; r.unshift(1), t.integerLen++ } else r[o - 1]++; for (; i < Math.max(0, s); i++)r.push(0); let l = 0 !== s; const c = e + t.integerLen, u = r.reduceRight(function (t, e, n, r) { return r[n] = (e += t) < 10 ? e : e - 10, l && (0 === r[n] && n >= c ? r.pop() : l = !1), e >= 10 ? 1 : 0 }, 0); u && (r.unshift(u), t.integerLen++) }(c, h, d); let p = c.digits, f = c.integerLen; const m = c.exponent; let g = []; for (l = p.every(t => !t); f < u; f++)p.unshift(0); for (; f < 0; f++)p.unshift(0); f > 0 ? g = p.splice(f, p.length) : (g = p, p = [0]); const v = []; for (p.length >= e.lgSize && v.unshift(p.splice(-e.lgSize, p.length).join("")); p.length > e.gSize;)v.unshift(p.splice(-e.gSize, p.length).join("")); p.length && v.unshift(p.join("")), a = v.join(Vu(n, r)), g.length && (a += Vu(n, i) + g.join("")), m && (a += Vu(n, Gu.Exponential) + "+" + m) } else a = Vu(n, Gu.Infinity); return a = t < 0 && !l ? e.negPre + a + e.negSuf : e.posPre + a + e.posSuf, a }(t, function (t, e = "-") { const n = { minInt: 1, minFrac: 0, maxFrac: 0, posPre: "", posSuf: "", negPre: "", negSuf: "", gSize: 0, lgSize: 0 }, r = t.split(";"), i = r[0], s = r[1], o = -1 !== i.indexOf(ju) ? i.split(ju) : [i.substring(0, i.lastIndexOf(Ju) + 1), i.substring(i.lastIndexOf(Ju) + 1)], a = o[0], l = o[1] || ""; n.posPre = a.substr(0, a.indexOf("#")); for (let u = 0; u < l.length; u++) { const t = l.charAt(u); t === Ju ? n.minFrac = n.maxFrac = u + 1 : "#" === t ? n.maxFrac = u + 1 : n.posSuf += t } const c = a.split(","); if (n.gSize = c[1] ? c[1].length : 0, n.lgSize = c[2] || c[1] ? (c[2] || c[1]).length : 0, s) { const t = i.length - n.posPre.length - n.posSuf.length, e = s.indexOf("#"); n.negPre = s.substr(0, e).replace(/'/g, ""), n.negSuf = s.substr(e + t).replace(/'/g, "") } else n.negPre = e + n.posPre, n.negSuf = n.posSuf; return n }(function (t, e) { return Aa(t)[Pa.NumberFormats][e] }(e, Hu.Decimal), Vu(e, Gu.MinusSign)), e, Gu.Group, Gu.Decimal, n) }(function (t) { if ("string" == typeof t && !isNaN(Number(t) - parseFloat(t))) return Number(t); if ("number" != typeof t) throw new Error(`${t} is not a number`); return t }(e), r, n) } catch (i) { throw oh(t, i.message) } } } return t.\u0275fac = function (e) { return new (e || t)(Do(Rc, 16)) }, t.\u0275pipe = Qt({ name: "number", type: t, pure: !0 }), t })(), mh = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [{ provide: Wu, useClass: qu }] }), t })(); function gh(t) { return "browser" === t } function vh(t) { return "server" === t } let yh = (() => { class t { } return t.\u0275prov = ft({ token: t, providedIn: "root", factory: () => new bh(fr(wu), window) }), t })(); class bh { constructor(t, e) { this.document = t, this.window = e, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const e = function (t, e) { const n = t.getElementById(e) || t.getElementsByName(e)[0]; if (n) return n; if ("function" == typeof t.createTreeWalker && t.body && (t.body.createShadowRoot || t.body.attachShadow)) { const n = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT); let r = n.currentNode; for (; r;) { const t = r.shadowRoot; if (t) { const n = t.getElementById(e) || t.querySelector(`[name="${e}"]`); if (n) return n } r = n.nextNode() } } return null }(this.document, t); e && (this.scrollToElement(e), this.attemptFocus(e)) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), n = e.left + this.window.pageXOffset, r = e.top + this.window.pageYOffset, i = this.offset(); this.window.scrollTo(n - i[0], r - i[1]) } attemptFocus(t) { return t.focus(), this.document.activeElement === t } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = _h(this.window.history) || _h(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (wN) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (wN) { return !1 } } } function _h(t) { return Object.getOwnPropertyDescriptor(t, "scrollRestoration") } class wh { } class Sh extends class extends class { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { var t; t = new Sh, bu || (bu = t) } onAndCancel(t, e, n) { return t.addEventListener(e, n, !1), () => { t.removeEventListener(e, n, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getBaseHref(t) { const e = (Th = Th || document.querySelector("base"), Th ? Th.getAttribute("href") : null); return null == e ? null : function (t) { xh = xh || document.createElement("a"), xh.setAttribute("href", t); const e = xh.pathname; return "/" === e.charAt(0) ? e : `/${e}` }(e) } resetBaseElement() { Th = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return Zu(document.cookie, t) } } let xh, Th = null; const Eh = new Kn("TRANSITION_ID"), Mh = [{ provide: wc, useFactory: function (t, e, n) { return () => { n.get(Sc).donePromise.then(() => { const n = _u(); Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => n.remove(t)) }) } }, deps: [Eh, wu, mo], multi: !0 }]; class Ah { static init() { var t; t = new Ah, $c = t } addToWindow(t) { It.getAngularTestability = (e, n = !0) => { const r = t.findTestabilityInTree(e, n); if (null == r) throw new Error("Could not find testability for element."); return r }, It.getAllAngularTestabilities = () => t.getAllTestabilities(), It.getAllAngularRootElements = () => t.getAllRootElements(), It.frameworkStabilizers || (It.frameworkStabilizers = []), It.frameworkStabilizers.push(t => { const e = It.getAllAngularTestabilities(); let n = e.length, r = !1; const i = function (e) { r = r || e, n--, 0 == n && t(r) }; e.forEach(function (t) { t.whenStable(i) }) }) } findTestabilityInTree(t, e, n) { if (null == e) return null; const r = t.getTestability(e); return null != r ? r : n ? _u().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } let Ch = (() => { class t { build() { return new XMLHttpRequest } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const Ph = new Kn("EventManagerPlugins"); let Rh = (() => { class t { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, n) { return this._findPluginFor(e).addEventListener(t, e, n) } addGlobalEventListener(t, e, n) { return this._findPluginFor(e).addGlobalEventListener(t, e, n) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const n = this._plugins; for (let r = 0; r < n.length; r++) { const e = n[r]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error(`No event manager plugin found for event ${t}`) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Ph), fr(Vc)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); class Lh { constructor(t) { this._doc = t } addGlobalEventListener(t, e, n) { const r = _u().getGlobalEventTarget(this._doc, t); if (!r) throw new Error(`Unsupported event target ${r} for event ${e}`); return this.addEventListener(r, e, n) } } let kh = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), Dh = (() => { class t extends kh { constructor(t) { super(), this._doc = t, this._hostNodes = new Map, this._hostNodes.set(t.head, []) } _addStylesToHost(t, e, n) { t.forEach(t => { const r = this._doc.createElement("style"); r.textContent = t, n.push(e.appendChild(r)) }) } addHost(t) { const e = []; this._addStylesToHost(this._stylesSet, t, e), this._hostNodes.set(t, e) } removeHost(t) { const e = this._hostNodes.get(t); e && e.forEach(Ih), this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach((e, n) => { this._addStylesToHost(t, n, e) }) } ngOnDestroy() { this._hostNodes.forEach(t => t.forEach(Ih)) } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); function Ih(t) { _u().remove(t) } const Oh = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, Fh = /%COMP%/g; function Nh(t, e, n) { for (let r = 0; r < e.length; r++) { let i = e[r]; Array.isArray(i) ? Nh(t, i, n) : (i = i.replace(Fh, t), n.push(i)) } return n } function Bh(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let Hh = (() => { class t { constructor(t, e, n) { this.eventManager = t, this.sharedStylesHost = e, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new Uh(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case Pt.Emulated: { let n = this.rendererByCompId.get(e.id); return n || (n = new Gh(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, n)), n.applyToHost(t), n } case 1: case Pt.ShadowDom: return new Vh(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = Nh(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (e) { return new (e || t)(fr(Rh), fr(Dh), fr(xc)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); class Uh { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(Oh[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, n) { t && t.insertBefore(e, n) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let n = "string" == typeof t ? document.querySelector(t) : t; if (!n) throw new Error(`The selector "${t}" did not match any elements`); return e || (n.textContent = ""), n } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, n, r) { if (r) { e = r + ":" + e; const i = Oh[r]; i ? t.setAttributeNS(i, e, n) : t.setAttribute(e, n) } else t.setAttribute(e, n) } removeAttribute(t, e, n) { if (n) { const r = Oh[n]; r ? t.removeAttributeNS(r, e) : t.removeAttribute(`${n}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, n, r) { r & (mi.DashCase | mi.Important) ? t.style.setProperty(e, n, r & mi.Important ? "important" : "") : t.style[e] = n } removeStyle(t, e, n) { n & mi.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, n) { t[e] = n } setValue(t, e) { t.nodeValue = e } listen(t, e, n) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, Bh(n)) : this.eventManager.addEventListener(t, e, Bh(n)) } } class Gh extends Uh { constructor(t, e, n, r) { super(t), this.component = n; const i = Nh(r + "-" + n.id, n.styles, []); e.addStyles(i), this.contentAttr = "_ngcontent-%COMP%".replace(Fh, r + "-" + n.id), this.hostAttr = "_nghost-%COMP%".replace(Fh, r + "-" + n.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const n = super.createElement(t, e); return super.setAttribute(n, this.contentAttr, ""), n } } class Vh extends Uh { constructor(t, e, n, r) { super(t), this.sharedStylesHost = e, this.hostEl = n, this.shadowRoot = n.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const i = Nh(r.id, r.styles, []); for (let s = 0; s < i.length; s++) { const t = document.createElement("style"); t.textContent = i[s], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, n) { return super.insertBefore(this.nodeOrShadowRoot(t), e, n) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let zh = (() => { class t extends Lh { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, e, n) { return t.addEventListener(e, n, !1), () => this.removeEventListener(t, e, n) } removeEventListener(t, e, n) { return t.removeEventListener(e, n) } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const jh = ["alt", "control", "meta", "shift"], Jh = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Xh = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, Wh = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let qh = (() => { class t extends Lh { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, n, r) { const i = t.parseEventName(n), s = t.eventCallback(i.fullKey, r, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => _u().onAndCancel(e, i.domEventName, s)) } static parseEventName(e) { const n = e.toLowerCase().split("."), r = n.shift(); if (0 === n.length || "keydown" !== r && "keyup" !== r) return null; const i = t._normalizeKey(n.pop()); let s = ""; if (jh.forEach(t => { const e = n.indexOf(t); e > -1 && (n.splice(e, 1), s += t + ".") }), s += i, 0 != n.length || 0 === i.length) return null; const o = {}; return o.domEventName = r, o.fullKey = s, o } static getEventFullKey(t) { let e = "", n = function (t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && Xh.hasOwnProperty(e) && (e = Xh[e])) } return Jh[e] || e }(t); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), jh.forEach(r => { r != n && (0, Wh[r])(t) && (e += r + ".") }), e += n, e } static eventCallback(e, n, r) { return i => { t.getEventFullKey(i) === e && r.runGuarded(() => n(i)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), Zh = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ factory: function () { return fr(Yh) }, token: t, providedIn: "root" }), t })(); function Kh(t) { return new Yh(t.get(wu)) } let Yh = (() => { class t extends Zh { constructor(t) { super(), this._doc = t } sanitize(t, e) { if (null == e) return null; switch (t) { case ri.NONE: return e; case ri.HTML: return kr(e, "HTML") ? Lr(e) : ei(this._doc, String(e)).toString(); case ri.STYLE: return kr(e, "Style") ? Lr(e) : e; case ri.SCRIPT: if (kr(e, "Script")) return Lr(e); throw new Error("unsafe value used in a script context"); case ri.URL: return Dr(e), kr(e, "URL") ? Lr(e) : Br(String(e)); case ri.RESOURCE_URL: if (kr(e, "ResourceURL")) return Lr(e); throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`) } } bypassSecurityTrustHtml(t) { return new Mr(t) } bypassSecurityTrustStyle(t) { return new Ar(t) } bypassSecurityTrustScript(t) { return new Cr(t) } bypassSecurityTrustUrl(t) { return new Pr(t) } bypassSecurityTrustResourceUrl(t) { return new Rr(t) } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu)) }, t.\u0275prov = ft({ factory: function () { return Kh(fr($s)) }, token: t, providedIn: "root" }), t })(); const Qh = su(gu, "browser", [{ provide: Ac, useValue: "browser" }, { provide: Mc, useValue: function () { Sh.makeCurrent(), Ah.init() }, multi: !0 }, { provide: wu, useFactory: function () { return function (t) { ge = t }(document), document }, deps: [] }]), $h = [[], { provide: eo, useValue: "root" }, { provide: di, useFactory: function () { return new di }, deps: [] }, { provide: Ph, useClass: zh, multi: !0, deps: [wu, Vc, Ac] }, { provide: Ph, useClass: qh, multi: !0, deps: [wu] }, [], { provide: Hh, useClass: Hh, deps: [Rh, Dh, xc] }, { provide: Za, useExisting: Hh }, { provide: kh, useExisting: Dh }, { provide: Dh, useClass: Dh, deps: [wu] }, { provide: Zc, useClass: Zc, deps: [Vc] }, { provide: Rh, useClass: Rh, deps: [Ph, Vc] }, { provide: wh, useClass: Ch, deps: [] }, []]; let td = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: xc, useValue: e.appId }, { provide: Eh, useExisting: xc }, Mh] } } } return t.\u0275fac = function (e) { return new (e || t)(fr(t, 12)) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: $h, imports: [mh, yu] }), t })(); "undefined" != typeof window && window; let ed = (() => { class t { constructor() { this.store = {}, this.onSerializeCallbacks = {} } static init(e) { const n = new t; return n.store = e, n } get(t, e) { return void 0 !== this.store[t] ? this.store[t] : e } set(t, e) { this.store[t] = e } remove(t) { delete this.store[t] } hasKey(t) { return this.store.hasOwnProperty(t) } onSerialize(t, e) { this.onSerializeCallbacks[t] = e } toJson() { for (const e in this.onSerializeCallbacks) if (this.onSerializeCallbacks.hasOwnProperty(e)) try { this.store[e] = this.onSerializeCallbacks[e]() } catch (t) { console.warn("Exception in onSerialize callback: ", t) } return JSON.stringify(this.store) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); function nd(t, e) { const n = t.getElementById(e + "-state"); let r = {}; if (n && n.textContent) try { r = JSON.parse(function (t) { const e = { "&a;": "&", "&q;": '"', "&s;": "'", "&l;": "<", "&g;": ">" }; return t.replace(/&[^;]+;/g, t => e[t]) }(n.textContent)) } catch (i) { console.warn("Exception while restoring TransferState for app " + e, i) } return ed.init(r) } let rd = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [{ provide: ed, useFactory: nd, deps: [wu, xc] }] }), t })(); function id(...t) { let e = t[t.length - 1]; return C(e) ? (t.pop(), N(t, e)) : X(t) } function sd(t, e) { return V(t, e, 1) } function od(t, e) { return function (n) { return n.lift(new ad(t, e)) } } class ad { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new ld(t, this.predicate, this.thisArg)) } } class ld extends m { constructor(t, e, n) { super(t), this.predicate = e, this.thisArg = n, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) } } class cd { } class ud { } class hd { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const n = t.slice(0, e), r = n.toLowerCase(), i = t.slice(e + 1).trim(); this.maybeSetNormalizedName(n, r), this.headers.has(r) ? this.headers.get(r).push(i) : this.headers.set(r, [i]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let n = t[e]; const r = e.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(r, n), this.maybeSetNormalizedName(e, r)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof hd ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new hd; return e.lazyInit = this.lazyInit && this.lazyInit instanceof hd ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let n = t.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(t.name, e); const r = ("a" === t.op ? this.headers.get(e) : void 0) || []; r.push(...n), this.headers.set(e, r); break; case "d": const i = t.value; if (i) { let t = this.headers.get(e); if (!t) return; t = t.filter(t => -1 === i.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class dd { encodeKey(t) { return pd(t) } encodeValue(t) { return pd(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function pd(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } function fd(t) { return `${t}` } class md { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new dd, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (t, e) { const n = new Map; return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(t => { const r = t.indexOf("="), [i, s] = -1 == r ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, r)), e.decodeValue(t.slice(r + 1))], o = n.get(i) || []; o.push(s), n.set(i, o) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const n = t.fromObject[e]; this.map.set(e, Array.isArray(n) ? n : [n]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } appendAll(t) { const e = []; return Object.keys(t).forEach(n => { const r = t[n]; Array.isArray(r) ? r.forEach(t => { e.push({ param: n, value: t, op: "a" }) }) : e.push({ param: n, value: r, op: "a" }) }), this.clone(e) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new md({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(fd(t.value)), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const n = e.indexOf(fd(t.value)); -1 !== n && e.splice(n, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class gd { constructor() { this.map = new Map } set(t, e) { return this.map.set(t, e), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } keys() { return this.map.keys() } } function vd(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function yd(t) { return "undefined" != typeof Blob && t instanceof Blob } function bd(t) { return "undefined" != typeof FormData && t instanceof FormData } class _d { constructor(t, e, n, r) { let i; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || r ? (this.body = void 0 !== n ? n : null, i = r) : i = n, i && (this.reportProgress = !!i.reportProgress, this.withCredentials = !!i.withCredentials, i.responseType && (this.responseType = i.responseType), i.headers && (this.headers = i.headers), i.context && (this.context = i.context), i.params && (this.params = i.params)), this.headers || (this.headers = new hd), this.context || (this.context = new gd), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e; else { const n = e.indexOf("?"); this.urlWithParams = e + (-1 === n ? "?" : n < e.length - 1 ? "&" : "") + t } } else this.params = new md, this.urlWithParams = e } serializeBody() { return null === this.body ? null : vd(this.body) || yd(this.body) || bd(this.body) || "undefined" != typeof URLSearchParams && this.body instanceof URLSearchParams || "string" == typeof this.body ? this.body : this.body instanceof md ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || bd(this.body) ? null : yd(this.body) ? this.body.type || null : vd(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof md ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { var e; const n = t.method || this.method, r = t.url || this.url, i = t.responseType || this.responseType, s = void 0 !== t.body ? t.body : this.body, o = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let l = t.headers || this.headers, c = t.params || this.params; const u = null !== (e = t.context) && void 0 !== e ? e : this.context; return void 0 !== t.setHeaders && (l = Object.keys(t.setHeaders).reduce((e, n) => e.set(n, t.setHeaders[n]), l)), t.setParams && (c = Object.keys(t.setParams).reduce((e, n) => e.set(n, t.setParams[n]), c)), new _d(n, r, s, { params: c, headers: l, context: u, reportProgress: a, responseType: i, withCredentials: o }) } } var wd = (() => ((wd = wd || {})[wd.Sent = 0] = "Sent", wd[wd.UploadProgress = 1] = "UploadProgress", wd[wd.ResponseHeader = 2] = "ResponseHeader", wd[wd.DownloadProgress = 3] = "DownloadProgress", wd[wd.Response = 4] = "Response", wd[wd.User = 5] = "User", wd))(); class Sd { constructor(t, e = 200, n = "OK") { this.headers = t.headers || new hd, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || n, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class xd extends Sd { constructor(t = {}) { super(t), this.type = wd.ResponseHeader } clone(t = {}) { return new xd({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Td extends Sd { constructor(t = {}) { super(t), this.type = wd.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new Td({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Ed extends Sd { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function Md(t, e) { return { body: e, headers: t.headers, context: t.context, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let Ad = (() => { class t { constructor(t) { this.handler = t } request(t, e, n = {}) { let r; if (t instanceof _d) r = t; else { let i, s; i = n.headers instanceof hd ? n.headers : new hd(n.headers), n.params && (s = n.params instanceof md ? n.params : new md({ fromObject: n.params })), r = new _d(t, e, void 0 !== n.body ? n.body : null, { headers: i, context: n.context, params: s, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const i = id(r).pipe(sd(t => this.handler.handle(t))); if (t instanceof _d || "events" === n.observe) return i; const s = i.pipe(od(t => t instanceof Td)); switch (n.observe || "body") { case "body": switch (r.responseType) { case "arraybuffer": return s.pipe(P(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body })); case "blob": return s.pipe(P(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body })); case "text": return s.pipe(P(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body })); case "json": default: return s.pipe(P(t => t.body)) }case "response": return s; default: throw new Error(`Unreachable: unhandled observe type ${n.observe}}`) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new md).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, n = {}) { return this.request("PATCH", t, Md(n, e)) } post(t, e, n = {}) { return this.request("POST", t, Md(n, e)) } put(t, e, n = {}) { return this.request("PUT", t, Md(n, e)) } } return t.\u0275fac = function (e) { return new (e || t)(fr(cd)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); class Cd { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const Pd = new Kn("HTTP_INTERCEPTORS"); let Rd = (() => { class t { intercept(t, e) { return e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const Ld = /^\)\]\}',?\n/; let kd = (() => { class t { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new w(e => { const n = this.xhrFactory.build(); if (n.open(t.method, t.urlWithParams), t.withCredentials && (n.withCredentials = !0), t.headers.forEach((t, e) => n.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader(); null !== e && n.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase(); n.responseType = "json" !== e ? e : "text" } const r = t.serializeBody(); let i = null; const s = () => { if (null !== i) return i; const e = 1223 === n.status ? 204 : n.status, r = n.statusText || "OK", s = new hd(n.getAllResponseHeaders()), o = function (t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(n) || t.url; return i = new xd({ headers: s, status: e, statusText: r, url: o }), i }, o = () => { let { headers: r, status: i, statusText: o, url: a } = s(), l = null; 204 !== i && (l = void 0 === n.response ? n.responseText : n.response), 0 === i && (i = l ? 200 : 0); let c = i >= 200 && i < 300; if ("json" === t.responseType && "string" == typeof l) { const t = l; l = l.replace(Ld, ""); try { l = "" !== l ? JSON.parse(l) : null } catch (u) { l = t, c && (c = !1, l = { error: u, text: l }) } } c ? (e.next(new Td({ body: l, headers: r, status: i, statusText: o, url: a || void 0 })), e.complete()) : e.error(new Ed({ error: l, headers: r, status: i, statusText: o, url: a || void 0 })) }, a = t => { const { url: r } = s(), i = new Ed({ error: t, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: r || void 0 }); e.error(i) }; let l = !1; const c = r => { l || (e.next(s()), l = !0); let i = { type: wd.DownloadProgress, loaded: r.loaded }; r.lengthComputable && (i.total = r.total), "text" === t.responseType && n.responseText && (i.partialText = n.responseText), e.next(i) }, u = t => { let n = { type: wd.UploadProgress, loaded: t.loaded }; t.lengthComputable && (n.total = t.total), e.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", a), n.addEventListener("timeout", a), n.addEventListener("abort", a), t.reportProgress && (n.addEventListener("progress", c), null !== r && n.upload && n.upload.addEventListener("progress", u)), n.send(r), e.next({ type: wd.Sent }), () => { n.removeEventListener("error", a), n.removeEventListener("abort", a), n.removeEventListener("load", o), n.removeEventListener("timeout", a), t.reportProgress && (n.removeEventListener("progress", c), null !== r && n.upload && n.upload.removeEventListener("progress", u)), n.readyState !== n.DONE && n.abort() } }) } } return t.\u0275fac = function (e) { return new (e || t)(fr(wh)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const Dd = new Kn("XSRF_COOKIE_NAME"), Id = new Kn("XSRF_HEADER_NAME"); class Od { } let Fd = (() => { class t { constructor(t, e, n) { this.doc = t, this.platform = e, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = Zu(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu), fr(Ac), fr(Dd)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), Nd = (() => { class t { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const n = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || n.startsWith("http://") || n.startsWith("https://")) return e.handle(t); const r = this.tokenService.getToken(); return null === r || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, r) })), e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Od), fr(Id)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), Bd = (() => { class t { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(Pd, []); this.chain = t.reduceRight((t, e) => new Cd(t, e), this.backend) } return this.chain.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(fr(ud), fr(mo)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), Hd = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: Nd, useClass: Rd }] } } static withOptions(e = {}) { return { ngModule: t, providers: [e.cookieName ? { provide: Dd, useValue: e.cookieName } : [], e.headerName ? { provide: Id, useValue: e.headerName } : []] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [Nd, { provide: Pd, useExisting: Nd, multi: !0 }, { provide: Od, useClass: Fd }, { provide: Dd, useValue: "XSRF-TOKEN" }, { provide: Id, useValue: "X-XSRF-TOKEN" }] }), t })(), Ud = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [Ad, { provide: cd, useClass: Bd }, kd, { provide: ud, useExisting: kd }], imports: [[Hd.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), t })(); class Gd extends d { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class Vd extends Gd { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const n = this.id, r = this.scheduler; return null != n && (this.id = this.recycleAsyncId(r, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(r, this.id, e), this } requestAsyncId(t, e, n = 0) { return setInterval(t.flush.bind(t, this), n) } recycleAsyncId(t, e, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let n, r = !1; try { this.work(t) } catch (i) { r = !0, n = !!i && i || new Error(i) } if (r) return this.unsubscribe(), n } _unsubscribe() { const t = this.id, e = this.scheduler, n = e.actions, r = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== r && n.splice(r, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } let zd = (() => { class t { constructor(e, n = t.now) { this.SchedulerAction = e, this.now = n } schedule(t, e = 0, n) { return new this.SchedulerAction(this, t).schedule(n, e) } } return t.now = () => Date.now(), t })(); class jd extends zd { constructor(t, e = zd.now) { super(t, () => jd.delegate && jd.delegate !== this ? jd.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, n) { return jd.delegate && jd.delegate !== this ? jd.delegate.schedule(t, e, n) : super.schedule(t, e, n) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, n) { for (; t = e.shift();)t.unsubscribe(); throw n } } } const Jd = new class extends jd { }(class extends Vd { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } schedule(t, e = 0) { return e > 0 ? super.schedule(t, e) : (this.delay = e, this.state = t, this.scheduler.flush(this), this) } execute(t, e) { return e > 0 || this.closed ? super.execute(t, e) : this._execute(t, e) } requestAsyncId(t, e, n = 0) { return null !== n && n > 0 || null === n && this.delay > 0 ? super.requestAsyncId(t, e, n) : t.flush(this) } }), Xd = new w(t => t.complete()); function Wd(t) { return t ? function (t) { return new w(e => t.schedule(() => e.complete())) }(t) : Xd } function qd(t, e) { return new w(e ? n => e.schedule(Zd, 0, { error: t, subscriber: n }) : e => e.error(t)) } function Zd({ error: t, subscriber: e }) { e.error(t) } class Kd { constructor(t, e, n) { this.kind = t, this.value = e, this.error = n, this.hasValue = "N" === t } observe(t) { switch (this.kind) { case "N": return t.next && t.next(this.value); case "E": return t.error && t.error(this.error); case "C": return t.complete && t.complete() } } do(t, e, n) { switch (this.kind) { case "N": return t && t(this.value); case "E": return e && e(this.error); case "C": return n && n() } } accept(t, e, n) { return t && "function" == typeof t.next ? this.observe(t) : this.do(t, e, n) } toObservable() { switch (this.kind) { case "N": return id(this.value); case "E": return qd(this.error); case "C": return Wd() }throw new Error("unexpected notification kind value") } static createNext(t) { return void 0 !== t ? new Kd("N", t) : Kd.undefinedValueNotification } static createError(t) { return new Kd("E", void 0, t) } static createComplete() { return Kd.completeNotification } } Kd.completeNotification = new Kd("C"), Kd.undefinedValueNotification = new Kd("N", void 0); class Yd extends m { constructor(t, e, n = 0) { super(t), this.scheduler = e, this.delay = n } static dispatch(t) { const { notification: e, destination: n } = t; e.observe(n), this.unsubscribe() } scheduleMessage(t) { this.destination.add(this.scheduler.schedule(Yd.dispatch, this.delay, new Qd(t, this.destination))) } _next(t) { this.scheduleMessage(Kd.createNext(t)) } _error(t) { this.scheduleMessage(Kd.createError(t)), this.unsubscribe() } _complete() { this.scheduleMessage(Kd.createComplete()), this.unsubscribe() } } class Qd { constructor(t, e) { this.notification = t, this.destination = e } } class $d extends M { constructor(t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, n) { super(), this.scheduler = n, this._events = [], this._infiniteTimeWindow = !1, this._bufferSize = t < 1 ? 1 : t, this._windowTime = e < 1 ? 1 : e, e === Number.POSITIVE_INFINITY ? (this._infiniteTimeWindow = !0, this.next = this.nextInfiniteTimeWindow) : this.next = this.nextTimeWindow } nextInfiniteTimeWindow(t) { if (!this.isStopped) { const e = this._events; e.push(t), e.length > this._bufferSize && e.shift() } super.next(t) } nextTimeWindow(t) { this.isStopped || (this._events.push(new tp(this._getNow(), t)), this._trimBufferThenGetEvents()), super.next(t) } _subscribe(t) { const e = this._infiniteTimeWindow, n = e ? this._events : this._trimBufferThenGetEvents(), r = this.scheduler, i = n.length; let s; if (this.closed) throw new x; if (this.isStopped || this.hasError ? s = d.EMPTY : (this.observers.push(t), s = new T(this, t)), r && t.add(t = new Yd(t, r)), e) for (let o = 0; o < i && !t.closed; o++)t.next(n[o]); else for (let o = 0; o < i && !t.closed; o++)t.next(n[o].value); return this.hasError ? t.error(this.thrownError) : this.isStopped && t.complete(), s } _getNow() { return (this.scheduler || Jd).now() } _trimBufferThenGetEvents() { const t = this._getNow(), e = this._bufferSize, n = this._windowTime, r = this._events, i = r.length; let s = 0; for (; s < i && !(t - r[s].time < n);)s++; return i > e && (s = Math.max(s, i - e)), s > 0 && r.splice(0, s), r } } class tp { constructor(t, e) { this.time = t, this.value = e } } function ep(t, e) { return "function" == typeof e ? n => n.pipe(ep((n, r) => B(t(n, r)).pipe(P((t, i) => e(n, t, r, i))))) : e => e.lift(new np(t)) } class np { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new rp(t, this.project)) } } class rp extends U { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this._innerSub(e) } _innerSub(t) { const e = this.innerSubscription; e && e.unsubscribe(); const n = new H(this), r = this.destination; r.add(n), this.innerSubscription = G(t, n), this.innerSubscription !== n && r.add(this.innerSubscription) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = void 0 } notifyComplete() { this.innerSubscription = void 0, this.isStopped && super._complete() } notifyNext(t) { this.destination.next(t) } } const ip = { schedule(t, e) { const n = setTimeout(t, e); return () => clearTimeout(n) }, scheduleBeforeRender(t) { if ("undefined" == typeof window) return ip.schedule(t, 0); if (void 0 === window.requestAnimationFrame) return ip.schedule(t, 16); const e = window.requestAnimationFrame(t); return () => window.cancelAnimationFrame(e) } }; let sp; function op(t, e, n) { let r = n; return function (t) { return !!t && t.nodeType === Node.ELEMENT_NODE }(t) && e.some((e, n) => !("*" === e || !function (t, e) { if (!sp) { const t = Element.prototype; sp = t.matches || t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector } return t.nodeType === Node.ELEMENT_NODE && sp.call(t, e) }(t, e) || (r = n, 0))), r } class ap { constructor(t, e) { this.componentFactory = e.get(za).resolveComponentFactory(t) } create(t) { return new lp(this.componentFactory, t) } } class lp { constructor(t, e) { this.componentFactory = t, this.injector = e, this.eventEmitters = new $d(1), this.events = this.eventEmitters.pipe(ep(t => W(...t))), this.componentRef = null, this.viewChangeDetectorRef = null, this.inputChanges = null, this.hasInputChanges = !1, this.implementsOnChanges = !1, this.scheduledChangeDetectionFn = null, this.scheduledDestroyFn = null, this.initialInputValues = new Map, this.unchangedInputs = new Set(this.componentFactory.inputs.map(({ propName: t }) => t)), this.ngZone = this.injector.get(Vc), this.elementZone = "undefined" == typeof Zone ? null : this.ngZone.run(() => Zone.current) } connect(t) { this.runInZone(() => { if (null !== this.scheduledDestroyFn) return this.scheduledDestroyFn(), void (this.scheduledDestroyFn = null); null === this.componentRef && this.initializeComponent(t) }) } disconnect() { this.runInZone(() => { null !== this.componentRef && null === this.scheduledDestroyFn && (this.scheduledDestroyFn = ip.schedule(() => { null !== this.componentRef && (this.componentRef.destroy(), this.componentRef = null, this.viewChangeDetectorRef = null) }, 10)) }) } getInputValue(t) { return this.runInZone(() => null === this.componentRef ? this.initialInputValues.get(t) : this.componentRef.instance[t]) } setInputValue(t, e) { this.runInZone(() => { var n, r; null !== this.componentRef ? ((n = e) !== (r = this.getInputValue(t)) && (n == n || r == r) || void 0 === e && this.unchangedInputs.has(t)) && (this.recordInputChange(t, e), this.unchangedInputs.delete(t), this.hasInputChanges = !0, this.componentRef.instance[t] = e, this.scheduleDetectChanges()) : this.initialInputValues.set(t, e) }) } initializeComponent(t) { const e = mo.create({ providers: [], parent: this.injector }), n = function (t, e) { const n = t.childNodes, r = e.map(() => []); let i = -1; e.some((t, e) => "*" === t && (i = e, !0)); for (let s = 0, o = n.length; s < o; ++s) { const t = n[s], o = op(t, e, i); -1 !== o && r[o].push(t) } return r }(t, this.componentFactory.ngContentSelectors); this.componentRef = this.componentFactory.create(e, n, t), this.viewChangeDetectorRef = this.componentRef.injector.get(bl), this.implementsOnChanges = "function" == typeof this.componentRef.instance.ngOnChanges, this.initializeInputs(), this.initializeOutputs(this.componentRef), this.detectChanges(), this.injector.get(cu).attachView(this.componentRef.hostView) } initializeInputs() { this.componentFactory.inputs.forEach(({ propName: t }) => { this.initialInputValues.has(t) && this.setInputValue(t, this.initialInputValues.get(t)) }), this.initialInputValues.clear() } initializeOutputs(t) { const e = this.componentFactory.outputs.map(({ propName: e, templateName: n }) => t.instance[e].pipe(P(t => ({ name: n, value: t })))); this.eventEmitters.next(e) } callNgOnChanges(t) { if (!this.implementsOnChanges || null === this.inputChanges) return; const e = this.inputChanges; this.inputChanges = null, t.instance.ngOnChanges(e) } markViewForCheck(t) { this.hasInputChanges && (this.hasInputChanges = !1, t.markForCheck()) } scheduleDetectChanges() { this.scheduledChangeDetectionFn || (this.scheduledChangeDetectionFn = ip.scheduleBeforeRender(() => { this.scheduledChangeDetectionFn = null, this.detectChanges() })) } recordInputChange(t, e) { if (!this.implementsOnChanges) return; null === this.inputChanges && (this.inputChanges = {}); const n = this.inputChanges[t]; if (n) return void (n.currentValue = e); const r = this.unchangedInputs.has(t), i = r ? void 0 : this.getInputValue(t); this.inputChanges[t] = new ue(i, e, r) } detectChanges() { null !== this.componentRef && (this.callNgOnChanges(this.componentRef), this.markViewForCheck(this.viewChangeDetectorRef), this.componentRef.changeDetectorRef.detectChanges()) } runInZone(t) { return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(t) : t() } } class cp extends HTMLElement { constructor() { super(...arguments), this.ngElementEventsSubscription = null } } function up(t, e) { const n = function (t, e) { return e.get(za).resolveComponentFactory(t).inputs }(t, e.injector), r = e.strategyFactory || new ap(t, e.injector), i = function (t) { const e = {}; return t.forEach(({ propName: t, templateName: n }) => { var r; e[(r = n, r.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`))] = t }), e }(n); class s extends cp { constructor(t) { super(), this.injector = t } get ngElementStrategy() { if (!this._ngElementStrategy) { const t = this._ngElementStrategy = r.create(this.injector || e.injector); n.forEach(({ propName: e }) => { if (!this.hasOwnProperty(e)) return; const n = this[e]; delete this[e], t.setInputValue(e, n) }) } return this._ngElementStrategy } attributeChangedCallback(t, e, n, r) { this.ngElementStrategy.setInputValue(i[t], n) } connectedCallback() { let t = !1; this.ngElementStrategy.events && (this.subscribeToEvents(), t = !0), this.ngElementStrategy.connect(this), t || this.subscribeToEvents() } disconnectedCallback() { this._ngElementStrategy && this._ngElementStrategy.disconnect(), this.ngElementEventsSubscription && (this.ngElementEventsSubscription.unsubscribe(), this.ngElementEventsSubscription = null) } subscribeToEvents() { this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(t => { const e = function (t, e, n) { if ("function" != typeof CustomEvent) { const r = t.createEvent("CustomEvent"); return r.initCustomEvent(e, !1, !1, n), r } return new CustomEvent(e, { bubbles: !1, cancelable: !1, detail: n }) }(this.ownerDocument, t.name, t.value); this.dispatchEvent(e) }) } } return s.observedAttributes = Object.keys(i), n.forEach(({ propName: t }) => { Object.defineProperty(s.prototype, t, { get() { return this.ngElementStrategy.getInputValue(t) }, set(e) { this.ngElementStrategy.setInputValue(t, e) }, configurable: !0, enumerable: !0 }) }), s } class hp { } const dp = "*"; function pp(t, e) { return { type: 7, name: t, definitions: e, options: {} } } function fp(t, e = null) { return { type: 4, styles: e, timings: t } } function mp(t, e = null) { return { type: 2, steps: t, options: e } } function gp(t) { return { type: 6, styles: t, offset: null } } function vp(t, e, n) { return { type: 0, name: t, styles: e, options: n } } function yp(t, e, n = null) { return { type: 1, expr: t, animation: e, options: n } } function bp(t) { Promise.resolve(null).then(t) } class _p { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { bp(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(t) { this._position = this.totalTime ? t * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class wp { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, n = 0, r = 0; const i = this.players.length; 0 == i ? bp(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => { ++e == i && this._onFinish() }), t.onDestroy(() => { ++n == i && this._onDestroy() }), t.onStart(() => { ++r == i && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(t => { const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1; t.setPosition(n) }) } getPosition() { const t = this.players.reduce((t, e) => null === t || e.totalTime > t.totalTime ? e : t, null); return null != t ? t.getPosition() : 0 } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } function Sp() { return "undefined" != typeof window && void 0 !== window.document } function xp() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function Tp(t) { switch (t.length) { case 0: return new _p; case 1: return t[0]; default: return new wp(t) } } function Ep(t, e, n, r, i = {}, s = {}) { const o = [], a = []; let l = -1, c = null; if (r.forEach(t => { const n = t.offset, r = n == l, u = r && c || {}; Object.keys(t).forEach(n => { let r = n, a = t[n]; if ("offset" !== n) switch (r = e.normalizePropertyName(r, o), a) { case "!": a = i[n]; break; case dp: a = s[n]; break; default: a = e.normalizeStyleValue(n, r, a, o) }u[r] = a }), r || a.push(u), c = u, l = n }), o.length) { const t = "\n - "; throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`) } return a } function Mp(t, e, n, r) { switch (e) { case "start": t.onStart(() => r(n && Ap(n, "start", t))); break; case "done": t.onDone(() => r(n && Ap(n, "done", t))); break; case "destroy": t.onDestroy(() => r(n && Ap(n, "destroy", t))) } } function Ap(t, e, n) { const r = n.totalTime, i = Cp(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == r ? t.totalTime : r, !!n.disabled), s = t._data; return null != s && (i._data = s), i } function Cp(t, e, n, r, i = "", s = 0, o) { return { element: t, triggerName: e, fromState: n, toState: r, phaseName: i, totalTime: s, disabled: !!o } } function Pp(t, e, n) { let r; return t instanceof Map ? (r = t.get(e), r || t.set(e, r = n)) : (r = t[e], r || (r = t[e] = n)), r } function Rp(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let Lp = (t, e) => !1, kp = (t, e) => !1, Dp = (t, e, n) => []; const Ip = xp(); (Ip || "undefined" != typeof Element) && (Lp = Sp() ? (t, e) => { for (; e && e !== document.documentElement;) { if (e === t) return !0; e = e.parentNode || e.host } return !1 } : (t, e) => t.contains(e), kp = (() => { if (Ip || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype, e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, n) => e.apply(t, [n]) : kp } })(), Dp = (t, e, n) => { let r = []; if (n) { const n = t.querySelectorAll(e); for (let t = 0; t < n.length; t++)r.push(n[t]) } else { const n = t.querySelector(e); n && r.push(n) } return r }); let Op = null, Fp = !1; function Np(t) { Op || (Op = ("undefined" != typeof document ? document.body : null) || {}, Fp = !!Op.style && "WebkitAppearance" in Op.style); let e = !0; return Op.style && !function (t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in Op.style, !e && Fp) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in Op.style), e } const Bp = kp, Hp = Lp, Up = Dp; function Gp(t) { const e = {}; return Object.keys(t).forEach(n => { const r = n.replace(/([a-z])([A-Z])/g, "$1-$2"); e[r] = t[n] }), e } let Vp = (() => { class t { validateStyleProperty(t) { return Np(t) } matchesElement(t, e) { return Bp(t, e) } containsElement(t, e) { return Hp(t, e) } query(t, e, n) { return Up(t, e, n) } computeStyle(t, e, n) { return n || "" } animate(t, e, n, r, i, s = [], o) { return new _p(n, r) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); class zp { } zp.NOOP = new Vp; const jp = "ng-enter", Jp = "ng-leave", Xp = "ng-trigger", Wp = ".ng-trigger", qp = "ng-animating", Zp = ".ng-animating"; function Kp(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : Yp(parseFloat(e[1]), e[2]) } function Yp(t, e) { switch (e) { case "s": return 1e3 * t; default: return t } } function Qp(t, e, n) { return t.hasOwnProperty("duration") ? t : function (t, e, n) { let r, i = 0, s = ""; if ("string" == typeof t) { const n = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === n) return e.push(`The provided timing value "${t}" is invalid.`), { duration: 0, delay: 0, easing: "" }; r = Yp(parseFloat(n[1]), n[2]); const o = n[3]; null != o && (i = Yp(parseFloat(o), n[4])); const a = n[5]; a && (s = a) } else r = t; if (!n) { let n = !1, s = e.length; r < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), n = !0), i < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), n = !0), n && e.splice(s, 0, `The provided timing value "${t}" is invalid.`) } return { duration: r, delay: i, easing: s } }(t, e, n) } function $p(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function tf(t, e, n = {}) { if (e) for (let r in t) n[r] = t[r]; else $p(t, n); return n } function ef(t, e, n) { return n ? e + ":" + n + ";" : "" } function nf(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const r = t.style.item(n); e += ef(0, r, t.style.getPropertyValue(r)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += ef(0, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[n])); t.setAttribute("style", e) } function rf(t, e, n) { t.style && (Object.keys(e).forEach(r => { const i = df(r); n && !n.hasOwnProperty(r) && (n[r] = t.style[i]), t.style[i] = e[r] }), xp() && nf(t)) } function sf(t, e) { t.style && (Object.keys(e).forEach(e => { const n = df(e); t.style[n] = "" }), xp() && nf(t)) } function of(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : mp(t) : t } const af = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function lf(t) { let e = []; if ("string" == typeof t) { let n; for (; n = af.exec(t);)e.push(n[1]); af.lastIndex = 0 } return e } function cf(t, e, n) { const r = t.toString(), i = r.replace(af, (t, r) => { let i = e[r]; return e.hasOwnProperty(r) || (n.push(`Please provide a value for the animation param ${r}`), i = ""), i.toString() }); return i == r ? t : i } function uf(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const hf = /-+([a-z0-9])/g; function df(t) { return t.replace(hf, (...t) => t[1].toUpperCase()) } function pf(t, e) { return 0 === t || 0 === e } function ff(t, e, n) { const r = Object.keys(n); if (r.length && e.length) { let s = e[0], o = []; if (r.forEach(t => { s.hasOwnProperty(t) || o.push(t), s[t] = n[t] }), o.length) for (var i = 1; i < e.length; i++) { let n = e[i]; o.forEach(function (e) { n[e] = gf(t, e) }) } } return e } function mf(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw new Error(`Unable to resolve animation metadata node #${e.type}`) } } function gf(t, e) { return window.getComputedStyle(t)[e] } const vf = "*"; function yf(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function (t, e, n) { if (":" == t[0]) { const r = function (t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, e) => parseFloat(e) > parseFloat(t); case ":decrement": return (t, e) => parseFloat(e) < parseFloat(t); default: return e.push(`The transition alias value "${t}" is not supported`), "* => *" } }(t, n); if ("function" == typeof r) return void e.push(r); t = r } const r = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == r || r.length < 4) return n.push(`The provided transition expression "${t}" is not supported`), e; const i = r[1], s = r[2], o = r[3]; e.push(wf(i, o)), "<" != s[0] || i == vf && o == vf || e.push(wf(o, i)) }(t, n, e)) : n.push(t), n } const bf = new Set(["true", "1"]), _f = new Set(["false", "0"]); function wf(t, e) { const n = bf.has(t) || _f.has(t), r = bf.has(e) || _f.has(e); return (i, s) => { let o = t == vf || t == i, a = e == vf || e == s; return !o && n && "boolean" == typeof i && (o = i ? bf.has(t) : _f.has(t)), !a && r && "boolean" == typeof s && (a = s ? bf.has(e) : _f.has(e)), o && a } } const Sf = new RegExp("s*:selfs*,?", "g"); function xf(t, e, n) { return new Tf(t).build(e, n) } class Tf { constructor(t) { this._driver = t } build(t, e) { const n = new Ef(e); return this._resetContextStyleTimingState(n), mf(this, of(t), n) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let n = e.queryCount = 0, r = e.depCount = 0; const i = [], s = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const n = t, r = n.name; r.toString().split(/\s*,\s*/).forEach(t => { n.name = t, i.push(this.visitState(n, e)) }), n.name = r } else if (1 == t.type) { const i = this.visitTransition(t, e); n += i.queryCount, r += i.depCount, s.push(i) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: i, transitions: s, queryCount: n, depCount: r, options: null } } visitState(t, e) { const n = this.visitStyle(t.styles, e), r = t.options && t.options.params || null; if (n.containsDynamicStyles) { const i = new Set, s = r || {}; if (n.styles.forEach(t => { if (Mf(t)) { const e = t; Object.keys(e).forEach(t => { lf(e[t]).forEach(t => { s.hasOwnProperty(t) || i.add(t) }) }) } }), i.size) { const n = uf(i.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`) } } return { type: 0, name: t.name, style: n, options: r ? { params: r } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const n = mf(this, of(t.animation), e); return { type: 1, matchers: yf(t.expr, e.errors), animation: n, queryCount: e.queryCount, depCount: e.depCount, options: Af(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => mf(this, t, e)), options: Af(t.options) } } visitGroup(t, e) { const n = e.currentTime; let r = 0; const i = t.steps.map(t => { e.currentTime = n; const i = mf(this, t, e); return r = Math.max(r, e.currentTime), i }); return e.currentTime = r, { type: 3, steps: i, options: Af(t.options) } } visitAnimate(t, e) { const n = function (t, e) { let n = null; if (t.hasOwnProperty("duration")) n = t; else if ("number" == typeof t) return Cf(Qp(t, e).duration, 0, ""); const r = t; if (r.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = Cf(0, 0, ""); return t.dynamic = !0, t.strValue = r, t } return n = n || Qp(r, e), Cf(n.duration, n.delay, n.easing) }(t.timings, e.errors); let r; e.currentAnimateTimings = n; let i = t.styles ? t.styles : gp({}); if (5 == i.type) r = this.visitKeyframes(i, e); else { let i = t.styles, s = !1; if (!i) { s = !0; const t = {}; n.easing && (t.easing = n.easing), i = gp(t) } e.currentTime += n.duration + n.delay; const o = this.visitStyle(i, e); o.isEmptyStep = s, r = o } return e.currentAnimateTimings = null, { type: 4, timings: n, style: r, options: null } } visitStyle(t, e) { const n = this._makeStyleAst(t, e); return this._validateStyleAst(n, e), n } _makeStyleAst(t, e) { const n = []; Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? t == dp ? n.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : n.push(t) }) : n.push(t.styles); let r = !1, i = null; return n.forEach(t => { if (Mf(t)) { const e = t, n = e.easing; if (n && (i = n, delete e.easing), !r) for (let t in e) if (e[t].toString().indexOf("{{") >= 0) { r = !0; break } } }), { type: 6, styles: n, easing: i, offset: t.offset, containsDynamicStyles: r, options: null } } _validateStyleAst(t, e) { const n = e.currentAnimateTimings; let r = e.currentTime, i = e.currentTime; n && i > 0 && (i -= n.duration + n.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(n => { if (!this._driver.validateStyleProperty(n)) return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`); const s = e.collectedStyles[e.currentQuerySelector], o = s[n]; let a = !0; o && (i != r && i >= o.startTime && r <= o.endTime && (e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${i}ms" and "${r}ms"`), a = !1), i = o.startTime), a && (s[n] = { startTime: i, endTime: r }), e.options && function (t, e, n) { const r = e.params || {}, i = lf(t); i.length && i.forEach(t => { r.hasOwnProperty(t) || n.push(`Unable to resolve the local animation param ${t} in the given list of values`) }) }(t[n], e.options, e.errors) }) }) } visitKeyframes(t, e) { const n = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), n; let r = 0; const i = []; let s = !1, o = !1, a = 0; const l = t.steps.map(t => { const n = this._makeStyleAst(t, e); let l = null != n.offset ? n.offset : function (t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (Mf(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } }); else if (Mf(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } return e }(n.styles), c = 0; return null != l && (r++, c = n.offset = l), o = o || c < 0 || c > 1, s = s || c < a, a = c, i.push(c), n }); o && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), s && e.errors.push("Please ensure that all keyframe offsets are in order"); const c = t.steps.length; let u = 0; r > 0 && r < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == r && (u = 1 / (c - 1)); const h = c - 1, d = e.currentTime, p = e.currentAnimateTimings, f = p.duration; return l.forEach((t, r) => { const s = u > 0 ? r == h ? 1 : u * r : i[r], o = s * f; e.currentTime = d + p.delay + o, p.duration = o, this._validateStyleAst(t, e), t.offset = s, n.styles.push(t) }), n } visitReference(t, e) { return { type: 8, animation: mf(this, of(t.animation), e), options: Af(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: Af(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: Af(t.options) } } visitQuery(t, e) { const n = e.currentQuerySelector, r = t.options || {}; e.queryCount++, e.currentQuery = t; const [i, s] = function (t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(Sf, "")), [t = t.replace(/@\*/g, Wp).replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, Zp), e] }(t.selector); e.currentQuerySelector = n.length ? n + " " + i : i, Pp(e.collectedStyles, e.currentQuerySelector, {}); const o = mf(this, of(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = n, { type: 11, selector: i, limit: r.limit || 0, optional: !!r.optional, includeSelf: s, animation: o, originalSelector: t.selector, options: Af(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const n = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : Qp(t.timings, e.errors, !0); return { type: 12, animation: mf(this, of(t.animation), e), timings: n, options: null } } } class Ef { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function Mf(t) { return !Array.isArray(t) && "object" == typeof t } function Af(t) { var e; return t ? (t = $p(t)).params && (t.params = (e = t.params) ? $p(e) : null) : t = {}, t } function Cf(t, e, n) { return { duration: t, delay: e, easing: n } } function Pf(t, e, n, r, i, s, o = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: r, duration: i, delay: s, totalTime: i + s, easing: o, subTimeline: a } } class Rf { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let n = this._map.get(t); n || this._map.set(t, n = []), n.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const Lf = new RegExp(":enter", "g"), kf = new RegExp(":leave", "g"); function Df(t, e, n, r, i, s = {}, o = {}, a, l, c = []) { return (new If).buildKeyframes(t, e, n, r, i, s, o, a, l, c) } class If { buildKeyframes(t, e, n, r, i, s, o, a, l, c = []) { l = l || new Rf; const u = new Ff(t, e, l, r, i, c, []); u.options = a, u.currentTimeline.setStyles([s], null, u.errors, a), mf(this, n, u); const h = u.timelines.filter(t => t.containsAnimation()); if (h.length && Object.keys(o).length) { const t = h[h.length - 1]; t.allowOnlyTimelineStyles() || t.setStyles([o], null, u.errors, a) } return h.length ? h.map(t => t.buildKeyframes()) : [Pf(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const n = e.subInstructions.consume(e.element); if (n) { const r = e.createSubContext(t.options), i = e.currentTimeline.currentTime, s = this._visitSubInstructions(n, r, r.options); i != s && e.transformIntoNewTimeline(s) } e.previousNode = t } visitAnimateRef(t, e) { const n = e.createSubContext(t.options); n.transformIntoNewTimeline(), this.visitReference(t.animation, n), e.transformIntoNewTimeline(n.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, n) { let r = e.currentTimeline.currentTime; const i = null != n.duration ? Kp(n.duration) : null, s = null != n.delay ? Kp(n.delay) : null; return 0 !== i && t.forEach(t => { const n = e.appendInstructionToTimeline(t, i, s); r = Math.max(r, n.duration + n.delay) }), r } visitReference(t, e) { e.updateOptions(t.options, !0), mf(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const n = e.subContextCount; let r = e; const i = t.options; if (i && (i.params || i.delay) && (r = e.createSubContext(i), r.transformIntoNewTimeline(), null != i.delay)) { 6 == r.previousNode.type && (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = Of); const t = Kp(i.delay); r.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => mf(this, t, r)), r.currentTimeline.applyStylesToKeyframe(), r.subContextCount > n && r.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const n = []; let r = e.currentTimeline.currentTime; const i = t.options && t.options.delay ? Kp(t.options.delay) : 0; t.steps.forEach(s => { const o = e.createSubContext(t.options); i && o.delayNextStep(i), mf(this, s, o), r = Math.max(r, o.currentTimeline.currentTime), n.push(o.currentTimeline) }), n.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(r), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const n = t.strValue; return Qp(e.params ? cf(n, e.params, e.errors) : n, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const n = e.currentAnimateTimings = this._visitTiming(t.timings, e), r = e.currentTimeline; n.delay && (e.incrementTime(n.delay), r.snapshotCurrentStyles()); const i = t.style; 5 == i.type ? this.visitKeyframes(i, e) : (e.incrementTime(n.duration), this.visitStyle(i, e), r.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const n = e.currentTimeline, r = e.currentAnimateTimings; !r && n.getCurrentStyleProperties().length && n.forwardFrame(); const i = r && r.easing || t.easing; t.isEmptyStep ? n.applyEmptyStep(i) : n.setStyles(t.styles, i, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const n = e.currentAnimateTimings, r = e.currentTimeline.duration, i = n.duration, s = e.createSubContext().currentTimeline; s.easing = n.easing, t.styles.forEach(t => { s.forwardTime((t.offset || 0) * i), s.setStyles(t.styles, t.easing, e.errors, e.options), s.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(s), e.transformIntoNewTimeline(r + i), e.previousNode = t } visitQuery(t, e) { const n = e.currentTimeline.currentTime, r = t.options || {}, i = r.delay ? Kp(r.delay) : 0; i && (6 === e.previousNode.type || 0 == n && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = Of); let s = n; const o = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!r.optional, e.errors); e.currentQueryTotal = o.length; let a = null; o.forEach((n, r) => { e.currentQueryIndex = r; const o = e.createSubContext(t.options, n); i && o.delayNextStep(i), n === e.element && (a = o.currentTimeline), mf(this, t.animation, o), o.currentTimeline.applyStylesToKeyframe(), s = Math.max(s, o.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(s), a && (e.currentTimeline.mergeTimelineCollectedStyles(a), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const n = e.parentContext, r = e.currentTimeline, i = t.timings, s = Math.abs(i.duration), o = s * (e.currentQueryTotal - 1); let a = s * e.currentQueryIndex; switch (i.duration < 0 ? "reverse" : i.easing) { case "reverse": a = o - a; break; case "full": a = n.currentStaggerTime }const l = e.currentTimeline; a && l.delayNextStep(a); const c = l.currentTime; mf(this, t.animation, e), e.previousNode = t, n.currentStaggerTime = r.currentTime - c + (r.startTime - n.currentTimeline.startTime) } } const Of = {}; class Ff { constructor(t, e, n, r, i, s, o, a) { this._driver = t, this.element = e, this.subInstructions = n, this._enterClassName = r, this._leaveClassName = i, this.errors = s, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = Of, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = a || new Nf(this._driver, e, 0), o.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const n = t; let r = this.options; null != n.duration && (r.duration = Kp(n.duration)), null != n.delay && (r.delay = Kp(n.delay)); const i = n.params; if (i) { let t = r.params; t || (t = this.options.params = {}), Object.keys(i).forEach(n => { e && t.hasOwnProperty(n) || (t[n] = cf(i[n], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const n = t.params = {}; Object.keys(e).forEach(t => { n[t] = e[t] }) } } return t } createSubContext(t = null, e, n) { const r = e || this.element, i = new Ff(this._driver, r, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(r, n || 0)); return i.previousNode = this.previousNode, i.currentAnimateTimings = this.currentAnimateTimings, i.options = this._copyOptions(), i.updateOptions(t), i.currentQueryIndex = this.currentQueryIndex, i.currentQueryTotal = this.currentQueryTotal, i.parentContext = this, this.subContextCount++, i } transformIntoNewTimeline(t) { return this.previousNode = Of, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, n) { const r = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != n ? n : 0) + t.delay, easing: "" }, i = new Bf(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, r, t.stretchStartingKeyframe); return this.timelines.push(i), r } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, n, r, i, s) { let o = []; if (r && o.push(this.element), t.length > 0) { t = (t = t.replace(Lf, "." + this._enterClassName)).replace(kf, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != n); 0 !== n && (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)), o.push(...e) } return i || 0 != o.length || s.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), o } } class Nf { constructor(t, e, n, r) { this._driver = t, this.element = e, this.startTime = n, this._elementTimelineStylesLookup = r, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new Nf(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || dp, this._currentKeyframe[t] = dp }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, n, r) { e && (this._previousKeyframe.easing = e); const i = r && r.params || {}, s = function (t, e) { const n = {}; let r; return t.forEach(t => { "*" === t ? (r = r || Object.keys(e), r.forEach(t => { n[t] = dp })) : tf(t, !1, n) }), n }(t, this._globalTimelineStyles); Object.keys(s).forEach(t => { const e = cf(s[t], i, n); this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : dp), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const n = this._styleSummary[e], r = t._styleSummary[e]; (!n || r.time > n.time) && this._updateStyle(e, r.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, n = 1 === this._keyframes.size && 0 === this.duration; let r = []; this._keyframes.forEach((i, s) => { const o = tf(i, !0); Object.keys(o).forEach(n => { const r = o[n]; "!" == r ? t.add(n) : r == dp && e.add(n) }), n || (o.offset = s / this.duration), r.push(o) }); const i = t.size ? uf(t.values()) : [], s = e.size ? uf(e.values()) : []; if (n) { const t = r[0], e = $p(t); t.offset = 0, e.offset = 1, r = [t, e] } return Pf(this.element, r, i, s, this.duration, this.startTime, this.easing, !1) } } class Bf extends Nf { constructor(t, e, n, r, i, s, o = !1) { super(t, e, s.delay), this.element = e, this.keyframes = n, this.preStyleProps = r, this.postStyleProps = i, this._stretchStartingKeyframe = o, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: n, easing: r } = this.timings; if (this._stretchStartingKeyframe && e) { const i = [], s = n + e, o = e / s, a = tf(t[0], !1); a.offset = 0, i.push(a); const l = tf(t[0], !1); l.offset = Hf(o), i.push(l); const c = t.length - 1; for (let r = 1; r <= c; r++) { let o = tf(t[r], !1); o.offset = Hf((e + o.offset * n) / s), i.push(o) } n = s, e = 0, r = "", t = i } return Pf(this.element, t, this.preStyleProps, this.postStyleProps, n, e, r, !0) } } function Hf(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class Uf { } class Gf extends Uf { normalizePropertyName(t, e) { return df(t) } normalizeStyleValue(t, e, n, r) { let i = ""; const s = n.toString().trim(); if (Vf[e] && 0 !== n && "0" !== n) if ("number" == typeof n) i = "px"; else { const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/); e && 0 == e[1].length && r.push(`Please provide a CSS unit value for ${t}:${n}`) } return s + i } } const Vf = (() => function (t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function zf(t, e, n, r, i, s, o, a, l, c, u, h, d) { return { type: 0, element: t, triggerName: e, isRemovalTransition: i, fromState: n, fromStyles: s, toState: r, toStyles: o, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: u, totalTime: h, errors: d } } const jf = {}; class Jf { constructor(t, e, n) { this._triggerName = t, this.ast = e, this._stateStyles = n } match(t, e, n, r) { return function (t, e, n, r, i) { return t.some(t => t(e, n, r, i)) }(this.ast.matchers, t, e, n, r) } buildStyles(t, e, n) { const r = this._stateStyles["*"], i = this._stateStyles[t], s = r ? r.buildStyles(e, n) : {}; return i ? i.buildStyles(e, n) : s } build(t, e, n, r, i, s, o, a, l, c) { const u = [], h = this.ast.options && this.ast.options.params || jf, d = this.buildStyles(n, o && o.params || jf, u), p = a && a.params || jf, f = this.buildStyles(r, p, u), m = new Set, g = new Map, v = new Map, y = "void" === r, b = { params: Object.assign(Object.assign({}, h), p) }, _ = c ? [] : Df(t, e, this.ast.animation, i, s, d, f, b, l, u); let w = 0; if (_.forEach(t => { w = Math.max(t.duration + t.delay, w) }), u.length) return zf(e, this._triggerName, n, r, y, d, f, [], [], g, v, w, u); _.forEach(t => { const n = t.element, r = Pp(g, n, {}); t.preStyleProps.forEach(t => r[t] = !0); const i = Pp(v, n, {}); t.postStyleProps.forEach(t => i[t] = !0), n !== e && m.add(n) }); const S = uf(m.values()); return zf(e, this._triggerName, n, r, y, d, f, _, S, g, v, w) } } class Xf { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const n = {}, r = $p(this.defaultParams); return Object.keys(t).forEach(e => { const n = t[e]; null != n && (r[e] = n) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const i = t; Object.keys(i).forEach(t => { let s = i[t]; s.length > 1 && (s = cf(s, r, e)), n[t] = s }) } }), n } } class Wf { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new Xf(t.style, t.options && t.options.params || {}) }), qf(this.states, "true", "1"), qf(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new Jf(t, e, this.states)) }), this.fallbackTransition = new Jf(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, n, r) { return this.transitionFactories.find(i => i.match(t, e, n, r)) || null } matchStyles(t, e, n) { return this.fallbackTransition.buildStyles(t, e, n) } } function qf(t, e, n) { t.hasOwnProperty(e) ? t.hasOwnProperty(n) || (t[n] = t[e]) : t.hasOwnProperty(n) && (t[e] = t[n]) } const Zf = new Rf; class Kf { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._normalizer = n, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const n = [], r = xf(this._driver, e, n); if (n.length) throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`); this._animations[t] = r } _buildPlayer(t, e, n) { const r = t.element, i = Ep(0, this._normalizer, 0, t.keyframes, e, n); return this._driver.animate(r, i, t.duration, t.delay, t.easing, [], !0) } create(t, e, n = {}) { const r = [], i = this._animations[t]; let s; const o = new Map; if (i ? (s = Df(this._driver, e, i, jp, Jp, {}, {}, n, Zf, r), s.forEach(t => { const e = Pp(o, t.element, {}); t.postStyleProps.forEach(t => e[t] = null) })) : (r.push("The requested animation doesn't exist or has already been destroyed"), s = []), r.length) throw new Error(`Unable to create the animation due to the following errors: ${r.join("\n")}`); o.forEach((t, e) => { Object.keys(t).forEach(n => { t[n] = this._driver.computeStyle(e, n, dp) }) }); const a = Tp(s.map(t => { const e = o.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = a, a.onDestroy(() => this.destroy(t)), this.players.push(a), a } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const n = this.players.indexOf(e); n >= 0 && this.players.splice(n, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, n, r) { const i = Cp(e, "", "", ""); return Mp(this._getPlayer(t), n, i, r), () => { } } command(t, e, n, r) { if ("register" == n) return void this.register(t, r[0]); if ("create" == n) return void this.create(t, e, r[0] || {}); const i = this._getPlayer(t); switch (n) { case "play": i.play(); break; case "pause": i.pause(); break; case "reset": i.reset(); break; case "restart": i.restart(); break; case "finish": i.finish(); break; case "init": i.init(); break; case "setPosition": i.setPosition(parseFloat(r[0])); break; case "destroy": this.destroy(t) } } } const Yf = "ng-animate-queued", Qf = "ng-animate-disabled", $f = ".ng-animate-disabled", tm = [], em = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, nm = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class rm { constructor(t, e = "") { this.namespaceId = e; const n = t && t.hasOwnProperty("value"); if (this.value = null != (r = n ? t.value : t) ? r : null, n) { const e = $p(t); delete e.value, this.options = e } else this.options = {}; var r; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params; Object.keys(e).forEach(n => { null == t[n] && (t[n] = e[n]) }) } } } const im = "void", sm = new rm(im); class om { constructor(t, e, n) { this.id = t, this.hostElement = e, this._engine = n, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, pm(e, this._hostClassName) } listen(t, e, n, r) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`); if (null == n || 0 == n.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (i = n) && "done" != i) throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`); var i; const s = Pp(this._elementListeners, t, []), o = { name: e, phase: n, callback: r }; s.push(o); const a = Pp(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (pm(t, Xp), pm(t, "ng-trigger-" + e), a[e] = sm), () => { this._engine.afterFlush(() => { const t = s.indexOf(o); t >= 0 && s.splice(t, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, n, r = !0) { const i = this._getTrigger(e), s = new lm(this.id, e, t); let o = this._engine.statesByElement.get(t); o || (pm(t, Xp), pm(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, o = {})); let a = o[e]; const l = new rm(n, this.id); if (!(n && n.hasOwnProperty("value")) && a && l.absorbOptions(a.options), o[e] = l, a || (a = sm), l.value !== im && a.value === l.value) { if (!function (t, e) { const n = Object.keys(t), r = Object.keys(e); if (n.length != r.length) return !1; for (let i = 0; i < n.length; i++) { const r = n[i]; if (!e.hasOwnProperty(r) || t[r] !== e[r]) return !1 } return !0 }(a.params, l.params)) { const e = [], n = i.matchStyles(a.value, a.params, e), r = i.matchStyles(l.value, l.params, e); e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { sf(t, n), rf(t, r) }) } return } const c = Pp(this._engine.playersByElement, t, []); c.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let u = i.matchTransition(a.value, l.value, t, l.params), h = !1; if (!u) { if (!r) return; u = i.fallbackTransition, h = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: u, fromState: a, toState: l, player: s, isFallbackTransition: h }), h || (pm(t, Yf), s.onStart(() => { fm(t, Yf) })), s.onDone(() => { let e = this.players.indexOf(s); e >= 0 && this.players.splice(e, 1); const n = this._engine.playersByElement.get(t); if (n) { let t = n.indexOf(s); t >= 0 && n.splice(t, 1) } }), this.players.push(s), c.push(s), s } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, n) => { delete e[t] }), this._elementListeners.forEach((e, n) => { this._elementListeners.set(n, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const n = this._engine.driver.query(t, Wp, !0); n.forEach(t => { if (t.__ng_removed) return; const n = this._engine.fetchNamespacesByElement(t); n.size ? n.forEach(n => n.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }), this._engine.afterFlushAnimationsDone(() => n.forEach(t => this.clearElementCache(t))) } triggerLeaveAnimation(t, e, n, r) { const i = this._engine.statesByElement.get(t); if (i) { const s = []; if (Object.keys(i).forEach(e => { if (this._triggers[e]) { const n = this.trigger(t, e, im, r); n && s.push(n) } }), s.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), n && Tp(s).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t), n = this._engine.statesByElement.get(t); if (e && n) { const r = new Set; e.forEach(e => { const i = e.name; if (r.has(i)) return; r.add(i); const s = this._triggers[i].fallbackTransition, o = n[i] || sm, a = new rm(im), l = new lm(this.id, i, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: i, transition: s, fromState: o, toState: a, player: l, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const n = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let r = !1; if (n.totalAnimations) { const e = n.players.length ? n.playersByQueriedElement.get(t) : []; if (e && e.length) r = !0; else { let e = t; for (; e = e.parentNode;)if (n.statesByElement.get(e)) { r = !0; break } } } if (this.prepareLeaveAnimationListeners(t), r) n.markElementAsRemoved(this.id, t, !1, e); else { const r = t.__ng_removed; r && r !== em || (n.afterFlush(() => this.clearElementCache(t)), n.destroyInnerAnimations(t), n._onRemovalComplete(t, e)) } } insertNode(t, e) { pm(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(n => { const r = n.player; if (r.destroyed) return; const i = n.element, s = this._elementListeners.get(i); s && s.forEach(e => { if (e.name == n.triggerName) { const r = Cp(i, n.triggerName, n.fromState.value, n.toState.value); r._data = t, Mp(n.player, e.phase, r, e.callback) } }), r.markedForDestroy ? this._engine.afterFlush(() => { r.destroy() }) : e.push(n) }), this._queue = [], e.sort((t, e) => { const n = t.transition.ast.depCount, r = e.transition.ast.depCount; return 0 == n || 0 == r ? n - r : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class am { constructor(t, e, n) { this.bodyNode = t, this.driver = e, this._normalizer = n, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const n = new om(t, e, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(n, e) : (this.newHostElements.set(e, n), this.collectEnterElement(e)), this._namespaceLookup[t] = n } _balanceNamespaceList(t, e) { const n = this._namespaceList.length - 1; if (n >= 0) { let r = !1; for (let i = n; i >= 0; i--)if (this.driver.containsElement(this._namespaceList[i].hostElement, e)) { this._namespaceList.splice(i + 1, 0, t), r = !0; break } r || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let n = this._namespaceLookup[t]; return n || (n = this.createNamespace(t, e)), n } registerTrigger(t, e, n) { let r = this._namespaceLookup[t]; r && r.register(e, n) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const n = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(n.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(n); e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => n.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, n = this.statesByElement.get(t); if (n) { const t = Object.keys(n); for (let r = 0; r < t.length; r++) { const i = n[t[r]].namespaceId; if (i) { const t = this._fetchNamespace(i); t && e.add(t) } } } return e } trigger(t, e, n, r) { if (cm(e)) { const i = this._fetchNamespace(t); if (i) return i.trigger(e, n, r), !0 } return !1 } insertNode(t, e, n, r) { if (!cm(e)) return; const i = e.__ng_removed; if (i && i.setForRemoval) { i.setForRemoval = !1, i.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e); t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const r = this._fetchNamespace(t); r && r.insertNode(e, n) } r && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), pm(t, Qf)) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), fm(t, Qf)) } removeNode(t, e, n, r) { if (cm(e)) { const i = t ? this._fetchNamespace(t) : null; if (i ? i.removeNode(e, r) : this.markElementAsRemoved(t, e, !1, r), n) { const n = this.namespacesByHostElement.get(e); n && n.id !== t && n.removeNode(e, r) } } else this._onRemovalComplete(e, r) } markElementAsRemoved(t, e, n, r) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: r, hasAnimation: n, removedBeforeQueried: !1 } } listen(t, e, n, r, i) { return cm(e) ? this._fetchNamespace(t).listen(e, n, r, i) : () => { } } _buildInstruction(t, e, n, r, i) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, n, r, t.fromState.options, t.toState.options, e, i) } destroyInnerAnimations(t) { let e = this.driver.query(t, Wp, !0); e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, Zp, !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return Tp(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = em, e.namespaceId) { this.destroyInnerAnimations(t); const n = this._fetchNamespace(e.namespaceId); n && n.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, $f) && this.markElementAsDisabled(t, !1), this.driver.query(t, $f, !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let n = 0; n < this.collectedEnterElements.length; n++)pm(this.collectedEnterElements[n], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const n = []; try { e = this._flushAnimations(n, t) } finally { for (let t = 0; t < n.length; t++)n[t]() } } else for (let n = 0; n < this.collectedLeaveElements.length; n++)this.processLeaveNode(this.collectedLeaveElements[n]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns; this._whenQuietFns = [], e.length ? Tp(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const n = new Rf, r = [], i = new Map, s = [], o = new Map, a = new Map, l = new Map, c = new Set; this.disabledNodes.forEach(t => { c.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let n = 0; n < e.length; n++)c.add(e[n]) }); const u = this.bodyNode, h = Array.from(this.statesByElement.keys()), d = dm(h, this.collectedEnterElements), p = new Map; let f = 0; d.forEach((t, e) => { const n = jp + f++; p.set(e, n), t.forEach(t => pm(t, n)) }); const m = [], g = new Set, v = new Set; for (let R = 0; R < this.collectedLeaveElements.length; R++) { const t = this.collectedLeaveElements[R], e = t.__ng_removed; e && e.setForRemoval && (m.push(t), g.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => g.add(t)) : v.add(t)) } const y = new Map, b = dm(h, Array.from(g)); b.forEach((t, e) => { const n = Jp + f++; y.set(e, n), t.forEach(t => pm(t, n)) }), t.push(() => { d.forEach((t, e) => { const n = p.get(e); t.forEach(t => fm(t, n)) }), b.forEach((t, e) => { const n = y.get(e); t.forEach(t => fm(t, n)) }), m.forEach(t => { this.processLeaveNode(t) }) }); const _ = [], w = []; for (let R = this._namespaceList.length - 1; R >= 0; R--)this._namespaceList[R].drainQueuedTransitions(e).forEach(t => { const e = t.player, i = t.element; if (_.push(e), this.collectedEnterElements.length) { const t = i.__ng_removed; if (t && t.setForMove) return void e.destroy() } const c = !u || !this.driver.containsElement(u, i), h = y.get(i), d = p.get(i), f = this._buildInstruction(t, n, d, h, c); if (f.errors && f.errors.length) w.push(f); else { if (c) return e.onStart(() => sf(i, f.fromStyles)), e.onDestroy(() => rf(i, f.toStyles)), void r.push(e); if (t.isFallbackTransition) return e.onStart(() => sf(i, f.fromStyles)), e.onDestroy(() => rf(i, f.toStyles)), void r.push(e); f.timelines.forEach(t => t.stretchStartingKeyframe = !0), n.append(i, f.timelines), s.push({ instruction: f, player: e, element: i }), f.queriedElements.forEach(t => Pp(o, t, []).push(e)), f.preStyleProps.forEach((t, e) => { const n = Object.keys(t); if (n.length) { let t = a.get(e); t || a.set(e, t = new Set), n.forEach(e => t.add(e)) } }), f.postStyleProps.forEach((t, e) => { const n = Object.keys(t); let r = l.get(e); r || l.set(e, r = new Set), n.forEach(t => r.add(t)) }) } }); if (w.length) { const t = []; w.forEach(e => { t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`)) }), _.forEach(t => t.destroy()), this.reportError(t) } const S = new Map, x = new Map; s.forEach(t => { const e = t.element; n.has(e) && (x.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, S)) }), r.forEach(t => { const e = t.element; this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { Pp(S, e, []).push(t), t.destroy() }) }); const T = m.filter(t => vm(t, a, l)), E = new Map; hm(E, this.driver, v, l, dp).forEach(t => { vm(t, a, l) && T.push(t) }); const M = new Map; d.forEach((t, e) => { hm(M, this.driver, new Set(t), a, "!") }), T.forEach(t => { const e = E.get(t), n = M.get(t); E.set(t, Object.assign(Object.assign({}, e), n)) }); const A = [], C = [], P = {}; s.forEach(t => { const { element: e, player: s, instruction: o } = t; if (n.has(e)) { if (c.has(e)) return s.onDestroy(() => rf(e, o.toStyles)), s.disabled = !0, s.overrideTotalTime(o.totalTime), void r.push(s); let t = P; if (x.size > 1) { let n = e; const r = []; for (; n = n.parentNode;) { const e = x.get(n); if (e) { t = e; break } r.push(n) } r.forEach(e => x.set(e, t)) } const n = this._buildAnimation(s.namespaceId, o, S, i, M, E); if (s.setRealPlayer(n), t === P) A.push(s); else { const e = this.playersByElement.get(t); e && e.length && (s.parentPlayer = Tp(e)), r.push(s) } } else sf(e, o.fromStyles), s.onDestroy(() => rf(e, o.toStyles)), C.push(s), c.has(e) && r.push(s) }), C.forEach(t => { const e = i.get(t.element); if (e && e.length) { const n = Tp(e); t.setRealPlayer(n) } }), r.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let R = 0; R < m.length; R++) { const t = m[R], e = t.__ng_removed; if (fm(t, Jp), e && e.hasAnimation) continue; let n = []; if (o.size) { let e = o.get(t); e && e.length && n.push(...e); let r = this.driver.query(t, Zp, !0); for (let t = 0; t < r.length; t++) { let e = o.get(r[t]); e && e.length && n.push(...e) } } const r = n.filter(t => !t.destroyed); r.length ? mm(this, t, r) : this.processLeaveNode(t) } return m.length = 0, A.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t); this.players.splice(e, 1) }), t.play() }), A } elementContainsData(t, e) { let n = !1; const r = e.__ng_removed; return r && r.setForRemoval && (n = !0), this.playersByElement.has(e) && (n = !0), this.playersByQueriedElement.has(e) && (n = !0), this.statesByElement.has(e) && (n = !0), this._fetchNamespace(t).elementContainsData(e) || n } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, n, r, i) { let s = []; if (e) { const e = this.playersByQueriedElement.get(t); e && (s = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !i || i == im; e.forEach(e => { e.queued || (t || e.triggerName == r) && s.push(e) }) } } return (n || r) && (s = s.filter(t => !(n && n != t.namespaceId || r && r != t.triggerName))), s } _beforeAnimationBuild(t, e, n) { const r = e.element, i = e.isRemovalTransition ? void 0 : t, s = e.isRemovalTransition ? void 0 : e.triggerName; for (const o of e.timelines) { const t = o.element, a = t !== r, l = Pp(n, t, []); this._getPreviousPlayers(t, a, i, s, e.toState).forEach(t => { const e = t.getRealPlayer(); e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t) }) } sf(r, e.fromStyles) } _buildAnimation(t, e, n, r, i, s) { const o = e.triggerName, a = e.element, l = [], c = new Set, u = new Set, h = e.timelines.map(e => { const h = e.element; c.add(h); const d = h.__ng_removed; if (d && d.removedBeforeQueried) return new _p(e.duration, e.delay); const p = h !== a, f = function (t) { const e = []; return gm(t, e), e }((n.get(h) || tm).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === h), m = i.get(h), g = s.get(h), v = Ep(0, this._normalizer, 0, e.keyframes, m, g), y = this._buildPlayer(e, v, f); if (e.subTimeline && r && u.add(h), p) { const e = new lm(t, o, h); e.setRealPlayer(y), l.push(e) } return y }); l.forEach(t => { Pp(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function (t, e, n) { let r; if (t instanceof Map) { if (r = t.get(e), r) { if (r.length) { const t = r.indexOf(n); r.splice(t, 1) } 0 == r.length && t.delete(e) } } else if (r = t[e], r) { if (r.length) { const t = r.indexOf(n); r.splice(t, 1) } 0 == r.length && delete t[e] } return r }(this.playersByQueriedElement, t.element, t)) }), c.forEach(t => pm(t, qp)); const d = Tp(h); return d.onDestroy(() => { c.forEach(t => fm(t, qp)), rf(a, e.toStyles) }), u.forEach(t => { Pp(r, t, []).push(d) }), d } _buildPlayer(t, e, n) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, n) : new _p(t.duration, t.delay) } } class lm { constructor(t, e, n) { this.namespaceId = t, this.triggerName = e, this.element = n, this._player = new _p, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(n => Mp(t, e, void 0, n)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { Pp(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function cm(t) { return t && 1 === t.nodeType } function um(t, e) { const n = t.style.display; return t.style.display = null != e ? e : "none", n } function hm(t, e, n, r, i) { const s = []; n.forEach(t => s.push(um(t))); const o = []; r.forEach((n, r) => { const s = {}; n.forEach(t => { const n = s[t] = e.computeStyle(r, t, i); n && 0 != n.length || (r.__ng_removed = nm, o.push(r)) }), t.set(r, s) }); let a = 0; return n.forEach(t => um(t, s[a++])), o } function dm(t, e) { const n = new Map; if (t.forEach(t => n.set(t, [])), 0 == e.length) return n; const r = new Set(e), i = new Map; function s(t) { if (!t) return 1; let e = i.get(t); if (e) return e; const o = t.parentNode; return e = n.has(o) ? o : r.has(o) ? 1 : s(o), i.set(t, e), e } return e.forEach(t => { const e = s(t); 1 !== e && n.get(e).push(t) }), n } function pm(t, e) { if (t.classList) t.classList.add(e); else { let n = t.$$classes; n || (n = t.$$classes = {}), n[e] = !0 } } function fm(t, e) { if (t.classList) t.classList.remove(e); else { let n = t.$$classes; n && delete n[e] } } function mm(t, e, n) { Tp(n).onDone(() => t.processLeaveNode(e)) } function gm(t, e) { for (let n = 0; n < t.length; n++) { const r = t[n]; r instanceof wp ? gm(r.players, e) : e.push(r) } } function vm(t, e, n) { const r = n.get(t); if (!r) return !1; let i = e.get(t); return i ? r.forEach(t => i.add(t)) : e.set(t, r), n.delete(t), !0 } class ym { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => { }, this._transitionEngine = new am(t, e, n), this._timelineEngine = new Kf(t, e, n), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, n, r, i) { const s = t + "-" + r; let o = this._triggerCache[s]; if (!o) { const t = [], e = xf(this._driver, i, t); if (t.length) throw new Error(`The animation trigger "${r}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`); o = function (t, e) { return new Wf(t, e) }(r, e), this._triggerCache[s] = o } this._transitionEngine.registerTrigger(e, r, o) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, n, r) { this._transitionEngine.insertNode(t, e, n, r) } onRemove(t, e, n, r) { this._transitionEngine.removeNode(t, e, r || !1, n) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, n, r) { if ("@" == n.charAt(0)) { const [t, i] = Rp(n); this._timelineEngine.command(t, e, i, r) } else this._transitionEngine.trigger(t, e, n, r) } listen(t, e, n, r, i) { if ("@" == n.charAt(0)) { const [t, r] = Rp(n); return this._timelineEngine.listen(t, e, r, i) } return this._transitionEngine.listen(t, e, n, r, i) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function bm(t, e) { let n = null, r = null; return Array.isArray(e) && e.length ? (n = wm(e[0]), e.length > 1 && (r = wm(e[e.length - 1]))) : e && (n = wm(e)), n || r ? new _m(t, n, r) : null } class _m { constructor(t, e, n) { this._element = t, this._startStyles = e, this._endStyles = n, this._state = 0; let r = _m.initialStylesByElement.get(t); r || _m.initialStylesByElement.set(t, r = {}), this._initialStyles = r } start() { this._state < 1 && (this._startStyles && rf(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (rf(this._element, this._initialStyles), this._endStyles && (rf(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (_m.initialStylesByElement.delete(this._element), this._startStyles && (sf(this._element, this._startStyles), this._endStyles = null), this._endStyles && (sf(this._element, this._endStyles), this._endStyles = null), rf(this._element, this._initialStyles), this._state = 3) } } function wm(t) { let e = null; const n = Object.keys(t); for (let r = 0; r < n.length; r++) { const i = n[r]; Sm(i) && (e = e || {}, e[i] = t[i]) } return e } function Sm(t) { return "display" === t || "position" === t } _m.initialStylesByElement = new WeakMap; const xm = "animation", Tm = "animationend"; class Em { constructor(t, e, n, r, i, s, o) { this._element = t, this._name = e, this._duration = n, this._delay = r, this._easing = i, this._fillMode = s, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() { !function (t, e) { const n = Lm(t, "").trim(); n.length && (function (t, e) { let n = 0; for (let r = 0; r < t.length; r++)"," === t.charAt(r) && n++ }(n), e = `${n}, ${e}`), Rm(t, "", e) }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), Pm(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { Mm(this._element, this._name, "paused") } resume() { Mm(this._element, this._name, "running") } setPosition(t) { const e = Am(this._element, this._name); this._position = t * this._duration, Rm(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), n = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && n >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), Pm(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (t, e) { const n = Lm(t, "").split(","), r = Cm(n, e); r >= 0 && (n.splice(r, 1), Rm(t, "", n.join(","))) }(this._element, this._name)) } } function Mm(t, e, n) { Rm(t, "PlayState", n, Am(t, e)) } function Am(t, e) { const n = Lm(t, ""); return n.indexOf(",") > 0 ? Cm(n.split(","), e) : Cm([n], e) } function Cm(t, e) { for (let n = 0; n < t.length; n++)if (t[n].indexOf(e) >= 0) return n; return -1 } function Pm(t, e, n) { n ? t.removeEventListener(Tm, e) : t.addEventListener(Tm, e) } function Rm(t, e, n, r) { const i = xm + e; if (null != r) { const e = t.style[i]; if (e.length) { const t = e.split(","); t[r] = n, n = t.join(",") } } t.style[i] = n } function Lm(t, e) { return t.style[xm + e] || "" } class km { constructor(t, e, n, r, i, s, o, a) { this.element = t, this.keyframes = e, this.animationName = n, this._duration = r, this._delay = i, this._finalStyles = o, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this.currentSnapshot = {}, this._state = 0, this.easing = s || "linear", this.totalTime = r + i, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._state = 0, this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new Em(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(n => { "offset" != n && (t[n] = e ? this._finalStyles[n] : gf(this.element, n)) }) } this.currentSnapshot = t } } class Dm extends _p { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = Gp(e) } init() { !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class Im { constructor() { this._count = 0 } validateStyleProperty(t) { return Np(t) } matchesElement(t, e) { return Bp(t, e) } containsElement(t, e) { return Hp(t, e) } query(t, e, n) { return Up(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, n) { n = n.map(t => Gp(t)); let r = `@keyframes ${e} {\n`, i = ""; n.forEach(t => { i = " "; const e = parseFloat(t.offset); r += `${i}${100 * e}% {\n`, i += " ", Object.keys(t).forEach(e => { const n = t[e]; switch (e) { case "offset": return; case "easing": return void (n && (r += `${i}animation-timing-function: ${n};\n`)); default: return void (r += `${i}${e}: ${n};\n`) } }), r += `${i}}\n` }), r += "}\n"; const s = document.createElement("style"); return s.textContent = r, s } animate(t, e, n, r, i, s = [], o) { const a = s.filter(t => t instanceof km), l = {}; pf(n, r) && a.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const c = function (t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(n => { "offset" != n && "easing" != n && (e[n] = t[n]) }) }), e }(e = ff(t, e, l)); if (0 == n) return new Dm(t, c); const u = "gen_css_kf_" + this._count++, h = this.buildKeyframeElement(t, u, e); (function (t) { var e; const n = null === (e = t.getRootNode) || void 0 === e ? void 0 : e.call(t); return "undefined" != typeof ShadowRoot && n instanceof ShadowRoot ? n : document.head })(t).appendChild(h); const d = bm(t, e), p = new km(t, e, u, n, r, i, c, d); return p.onDestroy(() => { var t; (t = h).parentNode.removeChild(t) }), p } } class Om { constructor(t, e, n, r) { this.element = t, this.keyframes = e, this.options = n, this._specialStyles = r, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, n) { return t.animate(e, n) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : gf(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class Fm { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(Nm().toString()), this._cssKeyframesDriver = new Im } validateStyleProperty(t) { return Np(t) } matchesElement(t, e) { return Bp(t, e) } containsElement(t, e) { return Hp(t, e) } query(t, e, n) { return Up(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, n, r, i, s = [], o) { if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, n, r, i, s); const a = { duration: n, delay: r, fill: 0 == r ? "both" : "forwards" }; i && (a.easing = i); const l = {}, c = s.filter(t => t instanceof Om); pf(n, r) && c.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const u = bm(t, e = ff(t, e = e.map(t => tf(t, !1)), l)); return new Om(t, e, a, u) } } function Nm() { return Sp() && Element.prototype.animate || {} } let Bm = (() => { class t extends hp { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: Pt.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString(); this._nextAnimationId++; const n = Array.isArray(t) ? mp(t) : t; return Gm(this._renderer, null, e, "register", [n]), new Hm(e, this._renderer) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Za), fr(wu)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); class Hm extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new Um(this._id, t, e || {}, this._renderer) } } class Um { constructor(t, e, n, r) { this.id = t, this.element = e, this._renderer = r, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", n) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return Gm(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(t) { this._command("setPosition", t) } getPosition() { var t, e; return null !== (e = null === (t = this._renderer.engine.players[+this.id]) || void 0 === t ? void 0 : t.getPosition()) && void 0 !== e ? e : 0 } } function Gm(t, e, n, r, i) { return t.setProperty(e, `@@${n}:${r}`, i) } const Vm = "@", zm = "@.disabled"; let jm = (() => { class t { constructor(t, e, n) { this.delegate = t, this.engine = e, this._zone = n, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const n = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(n); return t || (t = new Jm("", n, this.engine), this._rendererCache.set(n, t)), t } const r = e.id, i = e.id + "-" + this._currentId; this._currentId++, this.engine.register(i, t); const s = e => { Array.isArray(e) ? e.forEach(s) : this.engine.registerTrigger(r, i, t, e.name, e) }; return e.data.animation.forEach(s), new Xm(this, i, n, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, n) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(n)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, n] = t; e(n) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, n])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (e) { return new (e || t)(fr(Za), fr(ym), fr(Vc)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); class Jm { constructor(t, e, n) { this.namespaceId = t, this.delegate = e, this.engine = n, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, n, r = !0) { this.delegate.insertBefore(t, e, n), this.engine.onInsert(this.namespaceId, e, t, r) } removeChild(t, e, n) { this.engine.onRemove(this.namespaceId, e, this.delegate, n) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, n, r) { this.delegate.setAttribute(t, e, n, r) } removeAttribute(t, e, n) { this.delegate.removeAttribute(t, e, n) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, n, r) { this.delegate.setStyle(t, e, n, r) } removeStyle(t, e, n) { this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { e.charAt(0) == Vm && e == zm ? this.disableAnimations(t, !!n) : this.delegate.setProperty(t, e, n) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, n) { return this.delegate.listen(t, e, n) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class Xm extends Jm { constructor(t, e, n, r) { super(e, n, r), this.factory = t, this.namespaceId = e } setProperty(t, e, n) { e.charAt(0) == Vm ? "." == e.charAt(1) && e == zm ? this.disableAnimations(t, n = void 0 === n || !!n) : this.engine.process(this.namespaceId, t, e.substr(1), n) : this.delegate.setProperty(t, e, n) } listen(t, e, n) { if (e.charAt(0) == Vm) { const r = function (t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(t); let i = e.substr(1), s = ""; return i.charAt(0) != Vm && ([i, s] = function (t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(i)), this.engine.listen(this.namespaceId, r, i, s, t => { this.factory.scheduleListenerCallback(t._data || -1, n, t) }) } return this.delegate.listen(t, e, n) } } let Wm = (() => { class t extends ym { constructor(t, e, n) { super(t.body, e, n) } ngOnDestroy() { this.flush() } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu), fr(zp), fr(Uf)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const qm = new Kn("AnimationModuleType"), Zm = [{ provide: hp, useClass: Bm }, { provide: Uf, useFactory: function () { return new Gf } }, { provide: ym, useClass: Wm }, { provide: Za, useFactory: function (t, e, n) { return new jm(t, e, n) }, deps: [Hh, ym, Vc] }], Km = [{ provide: zp, useFactory: function () { return "function" == typeof Nm() ? new Fm : new Im } }, { provide: qm, useValue: "BrowserAnimations" }, ...Zm], Ym = [{ provide: zp, useClass: Vp }, { provide: qm, useValue: "NoopAnimations" }, ...Zm]; let Qm = (() => { class t { static withConfig(e) { return { ngModule: t, providers: e.disableAnimations ? Ym : Km } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: Km, imports: [td] }), t })(); class $m extends M { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new x; return this._value } next(t) { super.next(this._value = t) } } class tg extends m { notifyNext(t, e, n, r, i) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } class eg extends m { constructor(t, e, n) { super(), this.parent = t, this.outerValue = e, this.outerIndex = n, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } function ng(t, e, n, r, i = new eg(t, n, r)) { if (!i.closed) return e instanceof w ? e.subscribe(i) : F(e)(i) } const rg = {}; function ig(...t) { let e, n; return C(t[t.length - 1]) && (n = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && c(t[0]) && (t = t[0]), X(t, n).lift(new sg(e)) } class sg { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new og(t, this.resultSelector)) } } class og extends tg { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(rg), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let n = 0; n < e; n++)this.add(ng(this, t[n], void 0, n)) } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, n) { const r = this.values, i = this.toRespond ? r[n] === rg ? --this.toRespond : this.toRespond : 0; r[n] = e, 0 === i && (this.resultSelector ? this._tryResultSelector(r) : this.destination.next(r.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } const ag = (() => { function t() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return t.prototype = Object.create(Error.prototype), t })(); function lg(...t) { return J(1)(id(...t)) } function cg(t) { return new w(e => { let n; try { n = t() } catch (r) { return void e.error(r) } return (n ? B(n) : Wd()).subscribe(e) }) } const ug = (() => { function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t })(); function hg(t) { return e => 0 === t ? Wd() : e.lift(new dg(t)) } class dg { constructor(t) { if (this.total = t, this.total < 0) throw new ug } call(t, e) { return e.subscribe(new pg(t, this.total)) } } class pg extends m { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())) } } function fg(...t) { const e = t[t.length - 1]; return C(e) ? (t.pop(), n => lg(t, n, e)) : e => lg(t, e) } function mg(t, e) { let n = !1; return arguments.length >= 2 && (n = !0), function (r) { return r.lift(new gg(t, e, n)) } } class gg { constructor(t, e, n = !1) { this.accumulator = t, this.seed = e, this.hasSeed = n } call(t, e) { return e.subscribe(new vg(t, this.accumulator, this.seed, this.hasSeed)) } } class vg extends m { constructor(t, e, n, r) { super(t), this.accumulator = e, this._seed = n, this.hasSeed = r, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let n; try { n = this.accumulator(this.seed, t, e) } catch (r) { this.destination.error(r) } this.seed = n, this.destination.next(n) } } function yg(t) { return function (e) { const n = new bg(t), r = e.lift(n); return n.caught = r } } class bg { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new _g(t, this.selector, this.caught)) } } class _g extends U { constructor(t, e, n) { super(t), this.selector = e, this.caught = n } error(t) { if (!this.isStopped) { let n; try { n = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const r = new H(this); this.add(r); const i = G(n, r); i !== r && this.add(i) } } } function wg(t) { return function (e) { return 0 === t ? Wd() : e.lift(new Sg(t)) } } class Sg { constructor(t) { if (this.total = t, this.total < 0) throw new ug } call(t, e) { return e.subscribe(new xg(t, this.total)) } } class xg extends m { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, n = this.total, r = this.count++; e.length < n ? e.push(t) : e[r % n] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const n = this.count >= this.total ? this.total : this.count, r = this.ring; for (let i = 0; i < n; i++) { const i = e++ % n; t.next(r[i]) } } t.complete() } } function Tg(t = Ag) { return e => e.lift(new Eg(t)) } class Eg { constructor(t) { this.errorFactory = t } call(t, e) { return e.subscribe(new Mg(t, this.errorFactory)) } } class Mg extends m { constructor(t, e) { super(t), this.errorFactory = e, this.hasValue = !1 } _next(t) { this.hasValue = !0, this.destination.next(t) } _complete() { if (this.hasValue) return this.destination.complete(); { let e; try { e = this.errorFactory() } catch (t) { e = t } this.destination.error(e) } } } function Ag() { return new ag } function Cg(t = null) { return e => e.lift(new Pg(t)) } class Pg { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new Rg(t, this.defaultValue)) } } class Rg extends m { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } function Lg(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? od((e, n) => t(e, n, r)) : y, hg(1), n ? Cg(e) : Tg(() => new ag)) } function kg() { } function Dg(t, e, n) { return function (r) { return r.lift(new Ig(t, e, n)) } } class Ig { constructor(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n } call(t, e) { return e.subscribe(new Og(t, this.nextOrObserver, this.error, this.complete)) } } class Og extends m { constructor(t, e, n, r) { super(t), this._tapNext = kg, this._tapError = kg, this._tapComplete = kg, this._tapError = n || kg, this._tapComplete = r || kg, i(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || kg, this._tapError = e.error || kg, this._tapComplete = e.complete || kg) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } function Fg(t) { return e => e.lift(new Ng(t)) } class Ng { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new Bg(t, this.callback)) } } class Bg extends m { constructor(t, e) { super(t), this.add(new d(e)) } } class Hg { constructor(t, e) { this.id = t, this.url = e } } class Ug extends Hg { constructor(t, e, n = "imperative", r = null) { super(t, e), this.navigationTrigger = n, this.restoredState = r } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Gg extends Hg { constructor(t, e, n) { super(t, e), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Vg extends Hg { constructor(t, e, n) { super(t, e), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class zg extends Hg { constructor(t, e, n) { super(t, e), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class jg extends Hg { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Jg extends Hg { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Xg extends Hg { constructor(t, e, n, r, i) { super(t, e), this.urlAfterRedirects = n, this.state = r, this.shouldActivate = i } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class Wg extends Hg { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class qg extends Hg { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Zg { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Kg { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class Yg { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Qg { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class $g { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class tv { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ev { constructor(t, e, n) { this.routerEvent = t, this.position = e, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const nv = "primary"; class rv { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function iv(t) { return new rv(t) } function sv(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function ov(t, e, n) { const r = n.path.split("/"); if (r.length > t.length) return null; if ("full" === n.pathMatch && (e.hasChildren() || r.length < t.length)) return null; const i = {}; for (let s = 0; s < r.length; s++) { const e = r[s], n = t[s]; if (e.startsWith(":")) i[e.substring(1)] = n; else if (e !== n.path) return null } return { consumed: t.slice(0, r.length), posParams: i } } function av(t, e) { const n = t ? Object.keys(t) : void 0, r = e ? Object.keys(e) : void 0; if (!n || !r || n.length != r.length) return !1; let i; for (let s = 0; s < n.length; s++)if (i = n[s], !lv(t[i], e[i])) return !1; return !0 } function lv(t, e) { if (Array.isArray(t) && Array.isArray(e)) { if (t.length !== e.length) return !1; const n = [...t].sort(), r = [...e].sort(); return n.every((t, e) => r[e] === t) } return t === e } function cv(t) { return Array.prototype.concat.apply([], t) } function uv(t) { return t.length > 0 ? t[t.length - 1] : null } function hv(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function dv(t) { return jo(t) ? t : Vo(t) ? B(Promise.resolve(t)) : id(t) } const pv = { exact: function t(e, n, r) { if (!Sv(e.segments, n.segments)) return !1; if (!yv(e.segments, n.segments, r)) return !1; if (e.numberOfChildren !== n.numberOfChildren) return !1; for (const i in n.children) { if (!e.children[i]) return !1; if (!t(e.children[i], n.children[i], r)) return !1 } return !0 }, subset: gv }, fv = { exact: function (t, e) { return av(t, e) }, subset: function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => lv(t[n], e[n])) }, ignored: () => !0 }; function mv(t, e, n) { return pv[n.paths](t.root, e.root, n.matrixParams) && fv[n.queryParams](t.queryParams, e.queryParams) && !("exact" === n.fragment && t.fragment !== e.fragment) } function gv(t, e, n) { return vv(t, e, e.segments, n) } function vv(t, e, n, r) { if (t.segments.length > n.length) { const i = t.segments.slice(0, n.length); return !!Sv(i, n) && !e.hasChildren() && !!yv(i, n, r) } if (t.segments.length === n.length) { if (!Sv(t.segments, n)) return !1; if (!yv(t.segments, n, r)) return !1; for (const n in e.children) { if (!t.children[n]) return !1; if (!gv(t.children[n], e.children[n], r)) return !1 } return !0 } { const i = n.slice(0, t.segments.length), s = n.slice(t.segments.length); return !!Sv(t.segments, i) && !!yv(t.segments, i, r) && !!t.children.primary && vv(t.children.primary, e, s, r) } } function yv(t, e, n) { return e.every((e, r) => fv[n](t[r].parameters, e.parameters)) } class bv { constructor(t, e, n) { this.root = t, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = iv(this.queryParams)), this._queryParamMap } toString() { return Ev.serialize(this) } } class _v { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, hv(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Mv(this) } } class wv { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = iv(this.parameters)), this._parameterMap } toString() { return Dv(this) } } function Sv(t, e) { return t.length === e.length && t.every((t, n) => t.path === e[n].path) } class xv { } class Tv { parse(t) { const e = new Bv(t); return new bv(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { var e; return `/${Av(t.root, !0)}${function (t) { const e = Object.keys(t).map(e => { const n = t[e]; return Array.isArray(n) ? n.map(t => `${Pv(e)}=${Pv(t)}`).join("&") : `${Pv(e)}=${Pv(n)}` }).filter(t => !!t); return e.length ? `?${e.join("&")}` : "" }(t.queryParams)}${"string" == typeof t.fragment ? `#${e = t.fragment, encodeURI(e)}` : ""}` } } const Ev = new Tv; function Mv(t) { return t.segments.map(t => Dv(t)).join("/") } function Av(t, e) { if (!t.hasChildren()) return Mv(t); if (e) { const e = t.children.primary ? Av(t.children.primary, !1) : "", n = []; return hv(t.children, (t, e) => { e !== nv && n.push(`${e}:${Av(t, !1)}`) }), n.length > 0 ? `${e}(${n.join("//")})` : e } { const e = function (t, e) { let n = []; return hv(t.children, (t, r) => { r === nv && (n = n.concat(e(t, r))) }), hv(t.children, (t, r) => { r !== nv && (n = n.concat(e(t, r))) }), n }(t, (e, n) => n === nv ? [Av(t.children.primary, !1)] : [`${n}:${Av(e, !1)}`]); return 1 === Object.keys(t.children).length && null != t.children.primary ? `${Mv(t)}/${e[0]}` : `${Mv(t)}/(${e.join("//")})` } } function Cv(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Pv(t) { return Cv(t).replace(/%3B/gi, ";") } function Rv(t) { return Cv(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Lv(t) { return decodeURIComponent(t) } function kv(t) { return Lv(t.replace(/\+/g, "%20")) } function Dv(t) { return `${Rv(t.path)}${e = t.parameters, Object.keys(e).map(t => `;${Rv(t)}=${Rv(e[t])}`).join("")}`; var e } const Iv = /^[^\/()?;=#]+/; function Ov(t) { const e = t.match(Iv); return e ? e[0] : "" } const Fv = /^[^=?&#]+/, Nv = /^[^?&#]+/; class Bv { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new _v([], {}) : new _v([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (n.primary = new _v(t, e)), n } parseSegment() { const t = Ov(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new wv(Lv(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = Ov(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = Ov(this.remaining); t && (n = t, this.capture(n)) } t[Lv(e)] = Lv(n) } parseQueryParam(t) { const e = function (t) { const e = t.match(Fv); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(Nv); return e ? e[0] : "" }(this.remaining); t && (n = t, this.capture(n)) } const r = kv(e), i = kv(n); if (t.hasOwnProperty(r)) { let e = t[r]; Array.isArray(e) || (e = [e], t[r] = e), e.push(i) } else t[r] = i } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = Ov(this.remaining), r = this.remaining[n.length]; if ("/" !== r && ")" !== r && ";" !== r) throw new Error(`Cannot parse url '${this.url}'`); let i; n.indexOf(":") > -1 ? (i = n.substr(0, n.indexOf(":")), this.capture(i), this.capture(":")) : t && (i = nv); const s = this.parseChildren(); e[i] = 1 === Object.keys(s).length ? s.primary : new _v([], s), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class Hv { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = Uv(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = Uv(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = Gv(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return Gv(t, this._root).map(t => t.value) } } function Uv(t, e) { if (t === e.value) return e; for (const n of e.children) { const e = Uv(t, n); if (e) return e } return null } function Gv(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const r = Gv(t, n); if (r.length) return r.unshift(e), r } return [] } class Vv { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function zv(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class jv extends Hv { constructor(t, e) { super(t), this.snapshot = e, Kv(this, t) } toString() { return this.snapshot.toString() } } function Jv(t, e) { const n = function (t, e) { const n = new qv([], {}, {}, "", {}, nv, e, null, t.root, -1, {}); return new Zv("", new Vv(n, [])) }(t, e), r = new $m([new wv("", {})]), i = new $m({}), s = new $m({}), o = new $m({}), a = new $m(""), l = new Xv(r, i, o, a, s, nv, e, n.root); return l.snapshot = n.root, new jv(new Vv(l, []), n) } class Xv { constructor(t, e, n, r, i, s, o, a) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = i, this.outlet = s, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(P(t => iv(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(P(t => iv(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function Wv(t, e = "emptyOnly") { const n = t.pathFromRoot; let r = 0; if ("always" !== e) for (r = n.length - 1; r >= 1;) { const t = n[r], e = n[r - 1]; if (t.routeConfig && "" === t.routeConfig.path) r--; else { if (e.component) break; r-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class qv { constructor(t, e, n, r, i, s, o, a, l, c, u) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = i, this.outlet = s, this.component = o, this.routeConfig = a, this._urlSegment = l, this._lastPathIndex = c, this._resolve = u } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = iv(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = iv(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t => t.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class Zv extends Hv { constructor(t, e) { super(e), this.url = t, Kv(this, e) } toString() { return Yv(this._root) } } function Kv(t, e) { e.value._routerState = t, e.children.forEach(e => Kv(t, e)) } function Yv(t) { const e = t.children.length > 0 ? ` { ${t.children.map(Yv).join(", ")} } ` : ""; return `${t.value}${e}` } function Qv(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, av(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), av(e.params, n.params) || t.params.next(n.params), function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!av(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), av(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function $v(t, e) { var n, r; return av(t.params, e.params) && Sv(n = t.url, r = e.url) && n.every((t, e) => av(t.parameters, r[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || $v(t.parent, e.parent)) } function ty(t, e, n) { if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = e.value; const i = function (t, e, n) { return e.children.map(e => { for (const r of n.children) if (t.shouldReuseRoute(e.value, r.value.snapshot)) return ty(t, e, r); return ty(t, e) }) }(t, e, n); return new Vv(r, i) } { if (t.shouldAttach(e.value)) { const n = t.retrieve(e.value); if (null !== n) { const t = n.route; return ey(e, t), t } } const n = new Xv(new $m((r = e.value).url), new $m(r.params), new $m(r.queryParams), new $m(r.fragment), new $m(r.data), r.outlet, r.component, r), i = e.children.map(e => ty(t, e)); return new Vv(n, i) } var r } function ey(t, e) { if (t.value.routeConfig !== e.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (t.children.length !== e.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); e.value._futureSnapshot = t.value; for (let n = 0; n < t.children.length; ++n)ey(t.children[n], e.children[n]) } function ny(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function ry(t) { return "object" == typeof t && null != t && t.outlets } function iy(t, e, n, r, i) { let s = {}; return r && hv(r, (t, e) => { s[e] = Array.isArray(t) ? t.map(t => `${t}`) : `${t}` }), new bv(n.root === t ? e : sy(n.root, t, e), s, i) } function sy(t, e, n) { const r = {}; return hv(t.children, (t, i) => { r[i] = t === e ? n : sy(t, e, n) }), new _v(t.segments, r) } class oy { constructor(t, e, n) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = n, t && n.length > 0 && ny(n[0])) throw new Error("Root segment cannot have matrix parameters"); const r = n.find(ry); if (r && r !== uv(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class ay { constructor(t, e, n) { this.segmentGroup = t, this.processChildren = e, this.index = n } } function ly(t, e, n) { if (t || (t = new _v([], {})), 0 === t.segments.length && t.hasChildren()) return cy(t, e, n); const r = function (t, e, n) { let r = 0, i = e; const s = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; i < t.segments.length;) { if (r >= n.length) return s; const e = t.segments[i], o = n[r]; if (ry(o)) break; const a = `${o}`, l = r < n.length - 1 ? n[r + 1] : null; if (i > 0 && void 0 === a) break; if (a && l && "object" == typeof l && void 0 === l.outlets) { if (!py(a, l, e)) return s; r += 2 } else { if (!py(a, {}, e)) return s; r++ } i++ } return { match: !0, pathIndex: i, commandIndex: r } }(t, e, n), i = n.slice(r.commandIndex); if (r.match && r.pathIndex < t.segments.length) { const e = new _v(t.segments.slice(0, r.pathIndex), {}); return e.children.primary = new _v(t.segments.slice(r.pathIndex), t.children), cy(e, 0, i) } return r.match && 0 === i.length ? new _v(t.segments, {}) : r.match && !t.hasChildren() ? uy(t, e, n) : r.match ? cy(t, 0, i) : uy(t, e, n) } function cy(t, e, n) { if (0 === n.length) return new _v(t.segments, {}); { const r = function (t) { return ry(t[0]) ? t[0].outlets : { [nv]: t } }(n), i = {}; return hv(r, (n, r) => { "string" == typeof n && (n = [n]), null !== n && (i[r] = ly(t.children[r], e, n)) }), hv(t.children, (t, e) => { void 0 === r[e] && (i[e] = t) }), new _v(t.segments, i) } } function uy(t, e, n) { const r = t.segments.slice(0, e); let i = 0; for (; i < n.length;) { const s = n[i]; if (ry(s)) { const t = hy(s.outlets); return new _v(r, t) } if (0 === i && ny(n[0])) { r.push(new wv(t.segments[e].path, dy(n[0]))), i++; continue } const o = ry(s) ? s.outlets.primary : `${s}`, a = i < n.length - 1 ? n[i + 1] : null; o && a && ny(a) ? (r.push(new wv(o, dy(a))), i += 2) : (r.push(new wv(o, {})), i++) } return new _v(r, {}) } function hy(t) { const e = {}; return hv(t, (t, n) => { "string" == typeof t && (t = [t]), null !== t && (e[n] = uy(new _v([], {}), 0, t)) }), e } function dy(t) { const e = {}; return hv(t, (t, n) => e[n] = `${t}`), e } function py(t, e, n) { return t == n.path && av(e, n.parameters) } class fy { constructor(t, e, n, r) { this.routeReuseStrategy = t, this.futureState = e, this.currState = n, this.forwardEvent = r } activate(t) { const e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, t), Qv(this.futureState.root), this.activateChildRoutes(e, n, t) } deactivateChildRoutes(t, e, n) { const r = zv(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, r[e], n), delete r[e] }), hv(r, (t, e) => { this.deactivateRouteAndItsChildren(t, n) }) } deactivateRoutes(t, e, n) { const r = t.value, i = e ? e.value : null; if (r === i) if (r.component) { const i = n.getContext(r.outlet); i && this.deactivateChildRoutes(t, e, i.children) } else this.deactivateChildRoutes(t, e, n); else i && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const n = e.getContext(t.value.outlet); if (n && n.outlet) { const e = n.outlet.detach(), r = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: r }) } } deactivateRouteAndOutlet(t, e) { const n = e.getContext(t.value.outlet), r = n && t.value.component ? n.children : e, i = zv(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], r); n && n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated(), n.attachRef = null, n.resolver = null, n.route = null) } activateChildRoutes(t, e, n) { const r = zv(e); t.children.forEach(t => { this.activateRoutes(t, r[t.value.outlet], n), this.forwardEvent(new tv(t.value.snapshot)) }), t.children.length && this.forwardEvent(new Qg(t.value.snapshot)) } activateRoutes(t, e, n) { const r = t.value, i = e ? e.value : null; if (Qv(r), r === i) if (r.component) { const i = n.getOrCreateContext(r.outlet); this.activateChildRoutes(t, e, i.children) } else this.activateChildRoutes(t, e, n); else if (r.component) { const e = n.getOrCreateContext(r.outlet); if (this.routeReuseStrategy.shouldAttach(r.snapshot)) { const t = this.routeReuseStrategy.retrieve(r.snapshot); this.routeReuseStrategy.store(r.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), my(t.route) } else { const n = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(r.snapshot), i = n ? n.module.componentFactoryResolver : null; e.attachRef = null, e.route = r, e.resolver = i, e.outlet && e.outlet.activateWith(r, i), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, n) } } function my(t) { Qv(t.value), t.children.forEach(my) } class gy { constructor(t, e) { this.routes = t, this.module = e } } function vy(t) { return "function" == typeof t } function yy(t) { return t instanceof bv } const by = Symbol("INITIAL_VALUE"); function _y() { return ep(t => ig(t.map(t => t.pipe(hg(1), fg(by)))).pipe(mg((t, e) => { let n = !1; return e.reduce((t, r, i) => { if (t !== by) return t; if (r === by && (n = !0), !n) { if (!1 === r) return r; if (i === e.length - 1 || yy(r)) return r } return t }, t) }, by), od(t => t !== by), P(t => yy(t) ? t : !0 === t), hg(1))) } let wy = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = Jt({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && Bo(0, "router-outlet") }, directives: function () { return [bb] }, encapsulation: 2 }), t })(); function Sy(t, e = "") { for (let n = 0; n < t.length; n++) { const r = t[n]; xy(r, Ty(e, r)) } } function xy(t, e) { t.children && Sy(t.children, e) } function Ty(t, e) { return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Ey(t) { const e = t.children && t.children.map(Ey), n = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && n.outlet !== nv && (n.component = wy), n } function My(t) { return t.outlet || nv } function Ay(t, e) { const n = t.filter(t => My(t) === e); return n.push(...t.filter(t => My(t) !== e)), n } const Cy = { matched: !1, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; function Py(t, e, n) { var r; if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? Object.assign({}, Cy) : { matched: !0, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; const i = (e.matcher || ov)(n, t, e); if (!i) return Object.assign({}, Cy); const s = {}; hv(i.posParams, (t, e) => { s[e] = t.path }); const o = i.consumed.length > 0 ? Object.assign(Object.assign({}, s), i.consumed[i.consumed.length - 1].parameters) : s; return { matched: !0, consumedSegments: i.consumed, lastChild: i.consumed.length, parameters: o, positionalParamSegments: null !== (r = i.posParams) && void 0 !== r ? r : {} } } function Ry(t, e, n, r, i = "corrected") { if (n.length > 0 && function (t, e, n) { return n.some(n => Ly(t, e, n) && My(n) !== nv) }(t, n, r)) { const i = new _v(e, function (t, e, n, r) { const i = {}; i.primary = r, r._sourceSegment = t, r._segmentIndexShift = e.length; for (const s of n) if ("" === s.path && My(s) !== nv) { const n = new _v([], {}); n._sourceSegment = t, n._segmentIndexShift = e.length, i[My(s)] = n } return i }(t, e, r, new _v(n, t.children))); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: [] } } if (0 === n.length && function (t, e, n) { return n.some(n => Ly(t, e, n)) }(t, n, r)) { const s = new _v(t.segments, function (t, e, n, r, i, s) { const o = {}; for (const a of r) if (Ly(t, n, a) && !i[My(a)]) { const n = new _v([], {}); n._sourceSegment = t, n._segmentIndexShift = "legacy" === s ? t.segments.length : e.length, o[My(a)] = n } return Object.assign(Object.assign({}, i), o) }(t, e, n, r, t.children, i)); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: n } } const s = new _v(t.segments, t.children); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: n } } function Ly(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path } function ky(t, e, n, r) { return !!(My(t) === r || r !== nv && Ly(e, n, t)) && ("**" === t.path || Py(e, t, n).matched) } function Dy(t, e, n) { return 0 === e.length && !t.children[n] } class Iy { constructor(t) { this.segmentGroup = t || null } } class Oy { constructor(t) { this.urlTree = t } } function Fy(t) { return new w(e => e.error(new Iy(t))) } function Ny(t) { return new w(e => e.error(new Oy(t))) } function By(t) { return new w(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class Hy { constructor(t, e, n, r, i) { this.configLoader = e, this.urlSerializer = n, this.urlTree = r, this.config = i, this.allowRedirects = !0, this.ngModule = t.get(Cl) } apply() { const t = Ry(this.urlTree.root, [], [], this.config).segmentGroup, e = new _v(t.segments, t.children); return this.expandSegmentGroup(this.ngModule, this.config, e, nv).pipe(P(t => this.createUrlTree(Uy(t), this.urlTree.queryParams, this.urlTree.fragment))).pipe(yg(t => { if (t instanceof Oy) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof Iy) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, nv).pipe(P(e => this.createUrlTree(Uy(e), t.queryParams, t.fragment))).pipe(yg(t => { if (t instanceof Iy) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, n) { const r = t.segments.length > 0 ? new _v([], { [nv]: t }) : t; return new bv(r, e, n) } expandSegmentGroup(t, e, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(t, e, n).pipe(P(t => new _v([], t))) : this.expandSegment(t, n, e, n.segments, r, !0) } expandChildren(t, e, n) { const r = []; for (const i of Object.keys(n.children)) "primary" === i ? r.unshift(i) : r.push(i); return B(r).pipe(sd(r => { const i = n.children[r], s = Ay(e, r); return this.expandSegmentGroup(t, s, i, r).pipe(P(t => ({ segment: t, outlet: r }))) }), mg((t, e) => (t[e.outlet] = e.segment, t), {}), function (t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? od((e, n) => t(e, n, r)) : y, wg(1), n ? Cg(e) : Tg(() => new ag)) }()) } expandSegment(t, e, n, r, i, s) { return B(n).pipe(sd(o => this.expandSegmentAgainstRoute(t, e, n, o, r, i, s).pipe(yg(t => { if (t instanceof Iy) return id(null); throw t }))), Lg(t => !!t), yg((t, n) => { if (t instanceof ag || "EmptyError" === t.name) { if (Dy(e, r, i)) return id(new _v([], {})); throw new Iy(e) } throw t })) } expandSegmentAgainstRoute(t, e, n, r, i, s, o) { return ky(r, e, i, s) ? void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(t, e, r, i, s) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, r, i, s) : Fy(e) : Fy(e) } expandSegmentAgainstRouteUsingRedirect(t, e, n, r, i, s) { return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, i, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, r) { const i = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? Ny(i) : this.lineralizeSegments(n, i).pipe(V(n => { const i = new _v(n, {}); return this.expandSegment(t, i, e, n, r, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, i, s) { const { matched: o, consumedSegments: a, lastChild: l, positionalParamSegments: c } = Py(e, r, i); if (!o) return Fy(e); const u = this.applyRedirectCommands(a, r.redirectTo, c); return r.redirectTo.startsWith("/") ? Ny(u) : this.lineralizeSegments(r, u).pipe(V(r => this.expandSegment(t, e, n, r.concat(i.slice(l)), s, !1))) } matchSegmentAgainstRoute(t, e, n, r, i) { if ("**" === n.path) return n.loadChildren ? (n._loadedConfig ? id(n._loadedConfig) : this.configLoader.load(t.injector, n)).pipe(P(t => (n._loadedConfig = t, new _v(r, {})))) : id(new _v(r, {})); const { matched: s, consumedSegments: o, lastChild: a } = Py(e, n, r); if (!s) return Fy(e); const l = r.slice(a); return this.getChildConfig(t, n, r).pipe(V(t => { const r = t.module, s = t.routes, { segmentGroup: a, slicedSegments: c } = Ry(e, o, l, s), u = new _v(a.segments, a.children); if (0 === c.length && u.hasChildren()) return this.expandChildren(r, s, u).pipe(P(t => new _v(o, t))); if (0 === s.length && 0 === c.length) return id(new _v(o, {})); const h = My(n) === i; return this.expandSegment(r, u, s, c, h ? nv : i, !0).pipe(P(t => new _v(o.concat(t.segments), t.children))) })) } getChildConfig(t, e, n) { return e.children ? id(new gy(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? id(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, n).pipe(V(n => n ? this.configLoader.load(t.injector, e).pipe(P(t => (e._loadedConfig = t, t))) : function (t) { return new w(e => e.error(sv(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : id(new gy([], t)) } runCanLoadGuards(t, e, n) { const r = e.canLoad; return r && 0 !== r.length ? id(r.map(r => { const i = t.get(r); let s; if (function (t) { return t && vy(t.canLoad) }(i)) s = i.canLoad(e, n); else { if (!vy(i)) throw new Error("Invalid CanLoad guard"); s = i(e, n) } return dv(s) })).pipe(_y(), Dg(t => { if (!yy(t)) return; const e = sv(`Redirecting to "${this.urlSerializer.serialize(t)}"`); throw e.url = t, e }), P(t => !0 === t)) : id(!0) } lineralizeSegments(t, e) { let n = [], r = e.root; for (; ;) { if (n = n.concat(r.segments), 0 === r.numberOfChildren) return id(n); if (r.numberOfChildren > 1 || !r.children.primary) return By(t.redirectTo); r = r.children.primary } } applyRedirectCommands(t, e, n) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, n) } applyRedirectCreatreUrlTree(t, e, n, r) { const i = this.createSegmentGroup(t, e.root, n, r); return new bv(i, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const n = {}; return hv(t, (t, r) => { if ("string" == typeof t && t.startsWith(":")) { const i = t.substring(1); n[r] = e[i] } else n[r] = t }), n } createSegmentGroup(t, e, n, r) { const i = this.createSegments(t, e.segments, n, r); let s = {}; return hv(e.children, (e, i) => { s[i] = this.createSegmentGroup(t, e, n, r) }), new _v(i, s) } createSegments(t, e, n, r) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, r) : this.findOrReturn(e, n)) } findPosParam(t, e, n) { const r = n[e.path.substring(1)]; if (!r) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return r } findOrReturn(t, e) { let n = 0; for (const r of e) { if (r.path === t.path) return e.splice(n), r; n++ } return t } } function Uy(t) { const e = {}; for (const n of Object.keys(t.children)) { const r = Uy(t.children[n]); (r.segments.length > 0 || r.hasChildren()) && (e[n] = r) } return function (t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new _v(t.segments.concat(e.segments), e.children) } return t }(new _v(t.segments, e)) } class Gy { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Vy { constructor(t, e) { this.component = t, this.route = e } } function zy(t, e, n) { const r = t._root; return Jy(r, e ? e._root : null, n, [r.value]) } function jy(t, e, n) { const r = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (r ? r.module.injector : n).get(t) } function Jy(t, e, n, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const s = zv(e); return t.children.forEach(t => { !function (t, e, n, r, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const s = t.value, o = e ? e.value : null, a = n ? n.getContext(t.value.outlet) : null; if (o && s.routeConfig === o.routeConfig) { const l = function (t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !Sv(t.url, e.url); case "pathParamsOrQueryParamsChange": return !Sv(t.url, e.url) || !av(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !$v(t, e) || !av(t.queryParams, e.queryParams); case "paramsChange": default: return !$v(t, e) } }(o, s, s.routeConfig.runGuardsAndResolvers); l ? i.canActivateChecks.push(new Gy(r)) : (s.data = o.data, s._resolvedData = o._resolvedData), Jy(t, e, s.component ? a ? a.children : null : n, r, i), l && a && a.outlet && a.outlet.isActivated && i.canDeactivateChecks.push(new Vy(a.outlet.component, o)) } else o && Xy(e, a, i), i.canActivateChecks.push(new Gy(r)), Jy(t, null, s.component ? a ? a.children : null : n, r, i) }(t, s[t.value.outlet], n, r.concat([t.value]), i), delete s[t.value.outlet] }), hv(s, (t, e) => Xy(t, n.getContext(e), i)), i } function Xy(t, e, n) { const r = zv(t), i = t.value; hv(r, (t, r) => { Xy(t, i.component ? e ? e.children.getContext(r) : null : e, n) }), n.canDeactivateChecks.push(new Vy(i.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, i)) } class Wy { } function qy(t) { return new w(e => e.error(t)) } class Zy { constructor(t, e, n, r, i, s) { this.rootComponentType = t, this.config = e, this.urlTree = n, this.url = r, this.paramsInheritanceStrategy = i, this.relativeLinkResolution = s } recognize() { const t = Ry(this.urlTree.root, [], [], this.config.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, nv); if (null === e) return null; const n = new qv([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, nv, this.rootComponentType, null, this.urlTree.root, -1, {}), r = new Vv(n, e), i = new Zv(this.url, r); return this.inheritParamsAndData(i._root), i } inheritParamsAndData(t) { const e = t.value, n = Wv(e, this.paramsInheritanceStrategy); e.params = Object.freeze(n.params), e.data = Object.freeze(n.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, n) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, n) } processChildren(t, e) { const n = []; for (const i of Object.keys(e.children)) { const r = e.children[i], s = Ay(t, i), o = this.processSegmentGroup(s, r, i); if (null === o) return null; n.push(...o) } const r = Yy(n); return r.sort((t, e) => t.value.outlet === nv ? -1 : e.value.outlet === nv ? 1 : t.value.outlet.localeCompare(e.value.outlet)), r } processSegment(t, e, n, r) { for (const i of t) { const t = this.processSegmentAgainstRoute(i, e, n, r); if (null !== t) return t } return Dy(e, n, r) ? [] : null } processSegmentAgainstRoute(t, e, n, r) { if (t.redirectTo || !ky(t, e, n, r)) return null; let i, s = [], o = []; if ("**" === t.path) { const r = n.length > 0 ? uv(n).parameters : {}; i = new qv(n, r, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, tb(t), My(t), t.component, t, Qy(e), $y(e) + n.length, eb(t)) } else { const r = Py(e, t, n); if (!r.matched) return null; s = r.consumedSegments, o = n.slice(r.lastChild), i = new qv(s, r.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, tb(t), My(t), t.component, t, Qy(e), $y(e) + s.length, eb(t)) } const a = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: l, slicedSegments: c } = Ry(e, s, o, a.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution); if (0 === c.length && l.hasChildren()) { const t = this.processChildren(a, l); return null === t ? null : [new Vv(i, t)] } if (0 === a.length && 0 === c.length) return [new Vv(i, [])]; const u = My(t) === r, h = this.processSegment(a, l, c, u ? nv : r); return null === h ? null : [new Vv(i, h)] } } function Ky(t) { const e = t.value.routeConfig; return e && "" === e.path && void 0 === e.redirectTo } function Yy(t) { const e = [], n = new Set; for (const r of t) { if (!Ky(r)) { e.push(r); continue } const t = e.find(t => r.value.routeConfig === t.value.routeConfig); void 0 !== t ? (t.children.push(...r.children), n.add(t)) : e.push(r) } for (const r of n) { const t = Yy(r.children); e.push(new Vv(r.value, t)) } return e.filter(t => !n.has(t)) } function Qy(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function $y(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function tb(t) { return t.data || {} } function eb(t) { return t.resolve || {} } function nb(t) { return ep(e => { const n = t(e); return n ? B(n).pipe(P(() => e)) : id(e) }) } class rb extends class { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }{ } const ib = new Kn("ROUTES"); class sb { constructor(t, e, n, r) { this.loader = t, this.compiler = e, this.onLoadStartListener = n, this.onLoadEndListener = r } load(t, e) { if (e._loader$) return e._loader$; this.onLoadStartListener && this.onLoadStartListener(e); const n = this.loadModuleFactory(e.loadChildren).pipe(P(n => { this.onLoadEndListener && this.onLoadEndListener(e); const r = n.create(t); return new gy(cv(r.injector.get(ib, void 0, xt.Self | xt.Optional)).map(Ey), r) }), yg(t => { throw e._loader$ = void 0, t })); return e._loader$ = new Y(n, () => new M).pipe(q()), e._loader$ } loadModuleFactory(t) { return "string" == typeof t ? B(this.loader.load(t)) : dv(t()).pipe(V(t => t instanceof Pl ? id(t) : B(this.compiler.compileModuleAsync(t)))) } } class ob { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new ab, this.attachRef = null } } class ab { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const n = this.getOrCreateContext(t); n.outlet = e, this.contexts.set(t, n) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new ob, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } class lb { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function cb(t) { throw t } function ub(t, e, n) { return e.parse("/") } function hb(t, e) { return id(null) } const db = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, pb = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let fb = (() => { class t { constructor(t, e, n, r, i, s, o, a) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = n, this.location = r, this.config = a, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.lastLocationChangeInfo = null, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new M, this.errorHandler = cb, this.malformedUriErrorHandler = ub, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: hb, afterPreactivation: hb }, this.urlHandlingStrategy = new lb, this.routeReuseStrategy = new rb, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = i.get(Cl), this.console = i.get(Pc); const l = i.get(Vc); this.isNgZoneEnabled = l instanceof Vc && Vc.isInAngularZone(), this.resetConfig(a), this.currentUrlTree = new bv(new _v([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new sb(s, o, t => this.triggerEvent(new Zg(t)), t => this.triggerEvent(new Kg(t))), this.routerState = Jv(this.currentUrlTree, this.rootComponentType), this.transitions = new $m({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(od(t => 0 !== t.id), P(t => Object.assign(Object.assign({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), ep(t => { let n = !1, r = !1; return id(t).pipe(Dg(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), ep(t => { const n = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return id(t).pipe(ep(t => { const n = this.transitions.getValue(); return e.next(new Ug(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), n !== this.transitions.getValue() ? Xd : Promise.resolve(t) }), function (t, e, n, r) { return ep(i => function (t, e, n, r, i) { return new Hy(t, e, n, r, i).apply() }(t, e, n, i.extractedUrl, r).pipe(P(t => Object.assign(Object.assign({}, i), { urlAfterRedirects: t })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), Dg(t => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: t.urlAfterRedirects }) }), function (t, e, n, r, i) { return V(s => function (t, e, n, r, i = "emptyOnly", s = "legacy") { try { const o = new Zy(t, e, n, r, i, s).recognize(); return null === o ? qy(new Wy) : id(o) } catch (o) { return qy(o) } }(t, e, s.urlAfterRedirects, n(s.urlAfterRedirects), r, i).pipe(P(t => Object.assign(Object.assign({}, s), { targetSnapshot: t })))) }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), Dg(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, t), this.browserUrlTree = t.urlAfterRedirects); const n = new jg(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(n) })); if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: r, source: i, restoredState: s, extras: o } = t, a = new Ug(n, this.serializeUrl(r), i, s); e.next(a); const l = Jv(r, this.rootComponentType).snapshot; return id(Object.assign(Object.assign({}, t), { targetSnapshot: l, urlAfterRedirects: r, extras: Object.assign(Object.assign({}, o), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), Xd }), nb(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: i, extras: { skipLocationChange: s, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: i, skipLocationChange: !!s, replaceUrl: !!o }) }), Dg(t => { const e = new Jg(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), P(t => Object.assign(Object.assign({}, t), { guards: zy(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return V(n => { const { targetSnapshot: r, currentSnapshot: i, guards: { canActivateChecks: s, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === s.length ? id(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function (t, e, n, r) { return B(t).pipe(V(t => function (t, e, n, r, i) { const s = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return s && 0 !== s.length ? id(s.map(s => { const o = jy(s, e, i); let a; if (function (t) { return t && vy(t.canDeactivate) }(o)) a = dv(o.canDeactivate(t, e, n, r)); else { if (!vy(o)) throw new Error("Invalid CanDeactivate guard"); a = dv(o(t, e, n, r)) } return a.pipe(Lg()) })).pipe(_y()) : id(!0) }(t.component, t.route, n, e, r)), Lg(t => !0 !== t, !0)) }(o, r, i, t).pipe(V(n => n && "boolean" == typeof n ? function (t, e, n, r) { return B(e).pipe(sd(e => lg(function (t, e) { return null !== t && e && e(new Yg(t)), id(!0) }(e.route.parent, r), function (t, e) { return null !== t && e && e(new $g(t)), id(!0) }(e.route, r), function (t, e, n) { const r = e[e.length - 1], i = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => cg(() => id(e.guards.map(i => { const s = jy(i, e.node, n); let o; if (function (t) { return t && vy(t.canActivateChild) }(s)) o = dv(s.canActivateChild(r, t)); else { if (!vy(s)) throw new Error("Invalid CanActivateChild guard"); o = dv(s(r, t)) } return o.pipe(Lg()) })).pipe(_y()))); return id(i).pipe(_y()) }(t, e.path, n), function (t, e, n) { const r = e.routeConfig ? e.routeConfig.canActivate : null; return r && 0 !== r.length ? id(r.map(r => cg(() => { const i = jy(r, e, n); let s; if (function (t) { return t && vy(t.canActivate) }(i)) s = dv(i.canActivate(e, t)); else { if (!vy(i)) throw new Error("Invalid CanActivate guard"); s = dv(i(e, t)) } return s.pipe(Lg()) }))).pipe(_y()) : id(!0) }(t, e.route, n))), Lg(t => !0 !== t, !0)) }(r, s, t, e) : id(n)), P(t => Object.assign(Object.assign({}, n), { guardsResult: t }))) }) }(this.ngModule.injector, t => this.triggerEvent(t)), Dg(t => { if (yy(t.guardsResult)) { const e = sv(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } const e = new Xg(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), od(t => !!t.guardsResult || (this.cancelNavigationTransition(t, ""), !1)), nb(t => { if (t.guards.canActivateChecks.length) return id(t).pipe(Dg(t => { const e = new Wg(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), ep(t => { let e = !1; return id(t).pipe((n = this.paramsInheritanceStrategy, r = this.ngModule.injector, V(t => { const { targetSnapshot: e, guards: { canActivateChecks: i } } = t; if (!i.length) return id(t); let s = 0; return B(i).pipe(sd(t => function (t, e, n, r) { return function (t, e, n, r) { const i = Object.keys(t); if (0 === i.length) return id({}); const s = {}; return B(i).pipe(V(i => function (t, e, n, r) { const i = jy(t, e, r); return dv(i.resolve ? i.resolve(e, n) : i(e, n)) }(t[i], e, n, r).pipe(Dg(t => { s[i] = t }))), wg(1), V(() => Object.keys(s).length === i.length ? id(s) : Xd)) }(t._resolve, t, e, r).pipe(P(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), Wv(t, n).resolve), null))) }(t.route, e, n, r)), Dg(() => s++), wg(1), V(e => s === i.length ? id(t) : Xd)) })), Dg({ next: () => e = !0, complete: () => { e || this.cancelNavigationTransition(t, "At least one route resolver didn't emit any value.") } })); var n, r }), Dg(t => { const e = new qg(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })) }), nb(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: i, extras: { skipLocationChange: s, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: i, skipLocationChange: !!s, replaceUrl: !!o }) }), P(t => { const e = function (t, e, n) { const r = ty(t, e._root, n ? n._root : void 0); return new jv(r, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign(Object.assign({}, t), { targetRouterState: e }) }), Dg(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, t), this.browserUrlTree = t.urlAfterRedirects) }), (i = this.rootContexts, s = this.routeReuseStrategy, o = t => this.triggerEvent(t), P(t => (new fy(s, t.targetRouterState, t.currentRouterState, o).activate(i), t))), Dg({ next() { n = !0 }, complete() { n = !0 } }), Fg(() => { n || r || this.cancelNavigationTransition(t, `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`), this.currentNavigation = null }), yg(n => { if (r = !0, (i = n) && i.ngNavigationCancelingError) { const r = yy(n.url); r || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const i = new Vg(t.id, this.serializeUrl(t.extractedUrl), n.message); e.next(i), r ? setTimeout(() => { const e = this.urlHandlingStrategy.merge(n.url, this.rawUrlTree); this.scheduleNavigation(e, "imperative", null, { skipLocationChange: t.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: t.resolve, reject: t.reject, promise: t.promise }) }, 0) : t.resolve(!1) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const r = new zg(t.id, this.serializeUrl(t.extractedUrl), n); e.next(r); try { t.resolve(this.errorHandler(n)) } catch (s) { t.reject(s) } } var i; return Xd })); var i, s, o })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { const e = this.extractLocationChangeInfoFromEvent(t); this.shouldScheduleNavigation(this.lastLocationChangeInfo, e) && setTimeout(() => { const { source: t, state: n, urlTree: r } = e, i = { replaceUrl: !0 }; if (n) { const t = Object.assign({}, n); delete t.navigationId, delete t.\u0275routerPageId, 0 !== Object.keys(t).length && (i.state = t) } this.scheduleNavigation(r, t, n, i) }, 0), this.lastLocationChangeInfo = e })) } extractLocationChangeInfoFromEvent(t) { var e; return { source: "popstate" === t.type ? "popstate" : "hashchange", urlTree: this.parseUrl(t.url), state: (null === (e = t.state) || void 0 === e ? void 0 : e.navigationId) ? t.state : null, transitionId: this.getTransition().id } } shouldScheduleNavigation(t, e) { if (!t) return !0; const n = e.urlTree.toString() === t.urlTree.toString(); return !(e.transitionId === t.transitionId && n && ("hashchange" === e.source && "popstate" === t.source || "popstate" === e.source && "hashchange" === t.source)) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { Sy(t), this.config = t.map(Ey), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(t, e = {}) { const { relativeTo: n, queryParams: r, fragment: i, queryParamsHandling: s, preserveFragment: o } = e, a = n || this.routerState.root, l = o ? this.currentUrlTree.fragment : i; let c = null; switch (s) { case "merge": c = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), r); break; case "preserve": c = this.currentUrlTree.queryParams; break; default: c = r || null }return null !== c && (c = this.removeEmptyProps(c)), function (t, e, n, r, i) { if (0 === n.length) return iy(e.root, e.root, e, r, i); const s = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new oy(!0, 0, t); let e = 0, n = !1; const r = t.reduce((t, r, i) => { if ("object" == typeof r && null != r) { if (r.outlets) { const e = {}; return hv(r.outlets, (t, n) => { e[n] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (r.segmentPath) return [...t, r.segmentPath] } return "string" != typeof r ? [...t, r] : 0 === i ? (r.split("/").forEach((r, i) => { 0 == i && "." === r || (0 == i && "" === r ? n = !0 : ".." === r ? e++ : "" != r && t.push(r)) }), t) : [...t, r] }, []); return new oy(n, e, r) }(n); if (s.toRoot()) return iy(e.root, new _v([], {}), e, r, i); const o = function (t, e, n) { if (t.isAbsolute) return new ay(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const t = n.snapshot._urlSegment; return new ay(t, t === e.root, 0) } const r = ny(t.commands[0]) ? 0 : 1; return function (t, e, n) { let r = t, i = e, s = n; for (; s > i;) { if (s -= i, r = r.parent, !r) throw new Error("Invalid number of '../'"); i = r.segments.length } return new ay(r, !1, i - s) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, t.numberOfDoubleDots) }(s, e, t), a = o.processChildren ? cy(o.segmentGroup, o.index, s.commands) : ly(o.segmentGroup, o.index, s.commands); return iy(o.segmentGroup, a, e, r, i) }(a, this.currentUrlTree, t, c, null != l ? l : null) } navigateByUrl(t, e = { skipLocationChange: !1 }) { const n = yy(t) ? t : this.parseUrl(t), r = this.urlHandlingStrategy.merge(n, this.rawUrlTree); let i = null; return "computed" === this.canceledNavigationResolution && (0 === this.currentPageId || e.skipLocationChange || e.replaceUrl) && (i = this.location.getState()), this.scheduleNavigation(r, "imperative", i, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (n) { e = this.malformedUriErrorHandler(n, this.urlSerializer, t) } return e } isActive(t, e) { let n; if (n = !0 === e ? Object.assign({}, db) : !1 === e ? Object.assign({}, pb) : e, yy(t)) return mv(this.currentUrlTree, t, n); const r = this.parseUrl(t); return mv(this.currentUrlTree, r, n) } removeEmptyProps(t) { return Object.keys(t).reduce((e, n) => { const r = t[n]; return null != r && (e[n] = r), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.currentPageId = t.targetPageId, this.events.next(new Gg(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, n, r, i) { if (this.disposed) return Promise.resolve(!1); const s = this.getTransition(), o = "imperative" !== e && "imperative" === (null == s ? void 0 : s.source), a = (this.lastSuccessfulId === s.id || this.currentNavigation ? s.rawUrl : s.urlAfterRedirects).toString() === t.toString(); if (o && a) return Promise.resolve(!0); let l, c, u; i ? (l = i.resolve, c = i.reject, u = i.promise) : u = new Promise((t, e) => { l = t, c = e }); const h = ++this.navigationId; let d; return d = "computed" === this.canceledNavigationResolution ? n && n.\u0275routerPageId ? n.\u0275routerPageId : this.currentPageId + 1 : 0, this.setTransition({ id: h, targetPageId: d, source: e, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: r, resolve: l, reject: c, promise: u, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), u.catch(t => Promise.reject(t)) } setBrowserUrl(t, e) { const n = this.urlSerializer.serialize(t), r = Object.assign(Object.assign({}, e.extras.state), this.generateNgRouterState(e.id, e.targetPageId)); this.location.isCurrentPathEqualTo(n) || e.extras.replaceUrl ? this.location.replaceState(n, "", r) : this.location.go(n, "", r) } resetStateAndUrl(t, e, n) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(t, e) { "computed" === this.canceledNavigationResolution ? "popstate" !== t.source && "eager" !== this.urlUpdateStrategy || this.location.historyGo(this.currentPageId - t.targetPageId) : this.resetUrlToCurrentUrlTree(); const n = new Vg(t.id, this.serializeUrl(t.extractedUrl), e); this.triggerEvent(n), t.resolve(!1) } generateNgRouterState(t, e) { return "computed" === this.canceledNavigationResolution ? { navigationId: t, "\u0275routerPageId": e } : { navigationId: t } } } return t.\u0275fac = function (e) { return new (e || t)(fr(Qn), fr(xv), fr(ab), fr(Fu), fr(mo), fr(hu), fr(Hc), fr(void 0)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), mb = (() => { class t { constructor(t, e, n, r, i) { this.router = t, this.route = e, this.commands = [], this.onChanges = new M, null == n && r.setAttribute(i.nativeElement, "tabindex", "0") } ngOnChanges(t) { this.onChanges.next(this) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } onClick() { const t = { skipLocationChange: vb(this.skipLocationChange), replaceUrl: vb(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, t), !0 } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: vb(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(Do(fb), Do(Xv), Wn("tabindex"), Do(Ka), Do(Wa)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "routerLink", "", 5, "a", 5, "area"]], hostBindings: function (t, e) { 1 & t && Jo("click", function () { return e.onClick() }) }, inputs: { routerLink: "routerLink", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [he] }), t })(), gb = (() => { class t { constructor(t, e, n) { this.router = t, this.route = e, this.locationStrategy = n, this.commands = [], this.onChanges = new M, this.subscription = t.events.subscribe(t => { t instanceof Gg && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } ngOnChanges(t) { this.updateTargetUrlAndHref(), this.onChanges.next(this) } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, n, r, i) { if (0 !== t || e || n || r || i) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const s = { skipLocationChange: vb(this.skipLocationChange), replaceUrl: vb(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, s), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: vb(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(Do(fb), Do(Xv), Do(Lu)) }, t.\u0275dir = Yt({ type: t, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && Jo("click", function (t) { return e.onClick(t.button, t.ctrlKey, t.shiftKey, t.altKey, t.metaKey) }), 2 & t && (Sa("href", e.href, si), Ro("target", e.target)) }, inputs: { routerLink: "routerLink", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [he] }), t })(); function vb(t) { return "" === t || !!t } let yb = (() => { class t { constructor(t, e, n, r, i, s) { this.router = t, this.element = e, this.renderer = n, this.cdr = r, this.link = i, this.linkWithHref = s, this.classes = [], this.isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.routerEventsSubscription = t.events.subscribe(t => { t instanceof Gg && this.update() }) } ngAfterContentInit() { id(this.links.changes, this.linksWithHrefs.changes, id(null)).pipe(J()).subscribe(t => { this.update(), this.subscribeToEachLinkOnChanges() }) } subscribeToEachLinkOnChanges() { var t; null === (t = this.linkInputChangesSubscription) || void 0 === t || t.unsubscribe(); const e = [...this.links.toArray(), ...this.linksWithHrefs.toArray(), this.link, this.linkWithHref].filter(t => !!t).map(t => t.onChanges); this.linkInputChangesSubscription = B(e).pipe(J()).subscribe(t => { this.isActive !== this.isLinkActive(this.router)(t) && this.update() }) } set routerLinkActive(t) { const e = Array.isArray(t) ? t : t.split(" "); this.classes = e.filter(t => !!t) } ngOnChanges(t) { this.update() } ngOnDestroy() { var t; this.routerEventsSubscription.unsubscribe(), null === (t = this.linkInputChangesSubscription) || void 0 === t || t.unsubscribe() } update() { this.links && this.linksWithHrefs && this.router.navigated && Promise.resolve().then(() => { const t = this.hasActiveLinks(); this.isActive !== t && (this.isActive = t, this.cdr.markForCheck(), this.classes.forEach(e => { t ? this.renderer.addClass(this.element.nativeElement, e) : this.renderer.removeClass(this.element.nativeElement, e) })) }) } isLinkActive(t) { const e = "paths" in this.routerLinkActiveOptions ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1; return n => t.isActive(n.urlTree, e) } hasActiveLinks() { const t = this.isLinkActive(this.router); return this.link && t(this.link) || this.linkWithHref && t(this.linkWithHref) || this.links.some(t) || this.linksWithHrefs.some(t) } } return t.\u0275fac = function (e) { return new (e || t)(Do(fb), Do(Wa), Do(Ka), Do(bl), Do(mb, 8), Do(gb, 8)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "routerLinkActive", ""]], contentQueries: function (t, e, n) { if (1 & t && (mc(n, mb, 5), mc(n, gb, 5)), 2 & t) { let t; pc(t = gc()) && (e.links = t), pc(t = gc()) && (e.linksWithHrefs = t) } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", routerLinkActive: "routerLinkActive" }, exportAs: ["routerLinkActive"], features: [he] }), t })(), bb = (() => { class t { constructor(t, e, n, r, i) { this.parentContexts = t, this.location = e, this.resolver = n, this.changeDetector = i, this.activated = null, this._activatedRoute = null, this.activateEvents = new ec, this.deactivateEvents = new ec, this.name = r || nv, t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const n = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), r = this.parentContexts.getOrCreateContext(this.name).children, i = new _b(t, r, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, i), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (e) { return new (e || t)(Do(ab), Do(Ll), Do(za), Wn("name"), Do(bl)) }, t.\u0275dir = Yt({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), t })(); class _b { constructor(t, e, n) { this.route = t, this.childContexts = e, this.parent = n } get(t, e) { return t === Xv ? this.route : t === ab ? this.childContexts : this.parent.get(t, e) } } class wb { } class Sb { preload(t, e) { return id(null) } } let xb = (() => { class t { constructor(t, e, n, r, i) { this.router = t, this.injector = r, this.preloadingStrategy = i, this.loader = new sb(e, n, e => t.triggerEvent(new Zg(e)), e => t.triggerEvent(new Kg(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(od(t => t instanceof Gg), sd(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(Cl); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, e) { const n = []; for (const r of e) if (r.loadChildren && !r.canLoad && r._loadedConfig) { const t = r._loadedConfig; n.push(this.processRoutes(t.module, t.routes)) } else r.loadChildren && !r.canLoad ? n.push(this.preloadConfig(t, r)) : r.children && n.push(this.processRoutes(t, r.children)); return B(n).pipe(J(), P(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => (e._loadedConfig ? id(e._loadedConfig) : this.loader.load(t.injector, e)).pipe(V(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } return t.\u0275fac = function (e) { return new (e || t)(fr(fb), fr(hu), fr(Hc), fr(mo), fr(wb)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), Tb = (() => { class t { constructor(t, e, n = {}) { this.router = t, this.viewportScroller = e, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof Ug ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof Gg && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof ev && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new ev(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(fr(fb), fr(yh), fr(void 0)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const Eb = new Kn("ROUTER_CONFIGURATION"), Mb = new Kn("ROUTER_FORROOT_GUARD"), Ab = [Fu, { provide: xv, useClass: Tv }, { provide: fb, useFactory: function (t, e, n, r, i, s, o, a = {}, l, c) { const u = new fb(null, t, e, n, r, i, s, cv(o)); return l && (u.urlHandlingStrategy = l), c && (u.routeReuseStrategy = c), function (t, e) { t.errorHandler && (e.errorHandler = t.errorHandler), t.malformedUriErrorHandler && (e.malformedUriErrorHandler = t.malformedUriErrorHandler), t.onSameUrlNavigation && (e.onSameUrlNavigation = t.onSameUrlNavigation), t.paramsInheritanceStrategy && (e.paramsInheritanceStrategy = t.paramsInheritanceStrategy), t.relativeLinkResolution && (e.relativeLinkResolution = t.relativeLinkResolution), t.urlUpdateStrategy && (e.urlUpdateStrategy = t.urlUpdateStrategy) }(a, u), a.enableTracing && u.events.subscribe(t => { var e, n; null === (e = console.group) || void 0 === e || e.call(console, `Router Event: ${t.constructor.name}`), console.log(t.toString()), console.log(t), null === (n = console.groupEnd) || void 0 === n || n.call(console) }), u }, deps: [xv, ab, Fu, mo, hu, Hc, ib, Eb, [class { }, new br], [class { }, new br]] }, ab, { provide: Xv, useFactory: function (t) { return t.routerState.root }, deps: [fb] }, { provide: hu, useClass: fu }, xb, Sb, class { preload(t, e) { return e().pipe(yg(() => id(null))) } }, { provide: Eb, useValue: { enableTracing: !1 } }]; function Cb() { return new iu("Router", fb) } let Pb = (() => { class t { constructor(t, e) { } static forRoot(e, n) { return { ngModule: t, providers: [Ab, Db(e), { provide: Mb, useFactory: kb, deps: [[fb, new br, new _r]] }, { provide: Eb, useValue: n || {} }, { provide: Lu, useFactory: Lb, deps: [Su, [new yr(Du), new br], Eb] }, { provide: Tb, useFactory: Rb, deps: [fb, yh, Eb] }, { provide: wb, useExisting: n && n.preloadingStrategy ? n.preloadingStrategy : Sb }, { provide: iu, multi: !0, useFactory: Cb }, [Ib, { provide: wc, multi: !0, useFactory: Ob, deps: [Ib] }, { provide: Nb, useFactory: Fb, deps: [Ib] }, { provide: Cc, multi: !0, useExisting: Nb }]] } } static forChild(e) { return { ngModule: t, providers: [Db(e)] } } } return t.\u0275fac = function (e) { return new (e || t)(fr(Mb, 8), fr(fb, 8)) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({}), t })(); function Rb(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new Tb(t, e, n) } function Lb(t, e, n = {}) { return n.useHash ? new Ou(t, e) : new Iu(t, e) } function kb(t) { return "guarded" } function Db(t) { return [{ provide: Yn, multi: !0, useValue: t }, { provide: ib, multi: !0, useValue: t }] } let Ib = (() => { class t { constructor(t) { this.injector = t, this.initNavigation = !1, this.destroyed = !1, this.resultOfPreactivationDone = new M } appInitializer() { return this.injector.get(Tu, Promise.resolve(null)).then(() => { if (this.destroyed) return Promise.resolve(!0); let t = null; const e = new Promise(e => t = e), n = this.injector.get(fb), r = this.injector.get(Eb); return "disabled" === r.initialNavigation ? (n.setUpLocationChangeListener(), t(!0)) : "enabled" === r.initialNavigation || "enabledBlocking" === r.initialNavigation ? (n.hooks.afterPreactivation = () => this.initNavigation ? id(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), n.initialNavigation()) : t(!0), e }) } bootstrapListener(t) { const e = this.injector.get(Eb), n = this.injector.get(xb), r = this.injector.get(Tb), i = this.injector.get(fb), s = this.injector.get(cu); t === s.components[0] && ("enabledNonBlocking" !== e.initialNavigation && void 0 !== e.initialNavigation || i.initialNavigation(), n.setUpPreloading(), r.init(), i.resetRootComponentType(s.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } ngOnDestroy() { this.destroyed = !0 } } return t.\u0275fac = function (e) { return new (e || t)(fr(mo)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); function Ob(t) { return t.appInitializer.bind(t) } function Fb(t) { return t.bootstrapListener.bind(t) } const Nb = new Kn("Router Initializer"); function Bb(t) { return null != t && "false" != `${t}` } function Hb(t, e = 0) { return function (t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) }(t) ? Number(t) : e } function Ub(t) { return Array.isArray(t) ? t : [t] } function Gb(t) { return null == t ? "" : "string" == typeof t ? t : `${t}px` } function Vb(t) { return t instanceof Wa ? t.nativeElement : t } function zb(t, e, n, r) { return i(n) && (r = n, n = void 0), r ? zb(t, e, n).pipe(P(t => c(t) ? r(...t) : r(t))) : new w(r => { jb(t, e, function (t) { r.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }, r, n) }) } function jb(t, e, n, r, i) { let s; if (function (t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(t)) { const r = t; t.addEventListener(e, n, i), s = () => r.removeEventListener(e, n, i) } else if (function (t) { return t && "function" == typeof t.on && "function" == typeof t.off }(t)) { const r = t; t.on(e, n), s = () => r.off(e, n) } else if (function (t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(t)) { const r = t; t.addListener(e, n), s = () => r.removeListener(e, n) } else { if (!t || !t.length) throw new TypeError("Invalid event target"); for (let s = 0, o = t.length; s < o; s++)jb(t[s], e, n, r, i) } r.add(s) } new class extends jd { flush(t) { this.active = !0, this.scheduled = void 0; const { actions: e } = this; let n, r = -1, i = e.length; t = t || e.shift(); do { if (n = t.execute(t.state, t.delay)) break } while (++r < i && (t = e.shift())); if (this.active = !1, n) { for (; ++r < i && (t = e.shift());)t.unsubscribe(); throw n } } }(class extends Vd { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, n = 0) { return null !== n && n > 0 ? super.requestAsyncId(t, e, n) : (t.actions.push(this), t.scheduled || (t.scheduled = requestAnimationFrame(() => t.flush(null)))) } recycleAsyncId(t, e, n = 0) { if (null !== n && n > 0 || null === n && this.delay > 0) return super.recycleAsyncId(t, e, n); 0 === t.actions.length && (cancelAnimationFrame(e), t.scheduled = void 0) } }); let Jb = 1; const Xb = Promise.resolve(), Wb = {}; function qb(t) { return t in Wb && (delete Wb[t], !0) } const Zb = { setImmediate(t) { const e = Jb++; return Wb[e] = !0, Xb.then(() => qb(e) && t()), e }, clearImmediate(t) { qb(t) } }, Kb = new class extends jd { flush(t) { this.active = !0, this.scheduled = void 0; const { actions: e } = this; let n, r = -1, i = e.length; t = t || e.shift(); do { if (n = t.execute(t.state, t.delay)) break } while (++r < i && (t = e.shift())); if (this.active = !1, n) { for (; ++r < i && (t = e.shift());)t.unsubscribe(); throw n } } }(class extends Vd { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, n = 0) { return null !== n && n > 0 ? super.requestAsyncId(t, e, n) : (t.actions.push(this), t.scheduled || (t.scheduled = Zb.setImmediate(t.flush.bind(t, null)))) } recycleAsyncId(t, e, n = 0) { if (null !== n && n > 0 || null === n && this.delay > 0) return super.recycleAsyncId(t, e, n); 0 === t.actions.length && (Zb.clearImmediate(e), t.scheduled = void 0) } }); function Yb(t, e) { return n => n.lift(new Qb(t, e)) } class Qb { constructor(t, e) { this.compare = t, this.keySelector = e } call(t, e) { return e.subscribe(new $b(t, this.compare, this.keySelector)) } } class $b extends m { constructor(t, e, n) { super(t), this.keySelector = n, this.hasKey = !1, "function" == typeof e && (this.compare = e) } compare(t, e) { return t === e } _next(t) { let e; try { const { keySelector: n } = this; e = n ? n(t) : t } catch (r) { return this.destination.error(r) } let n = !1; if (this.hasKey) try { const { compare: t } = this; n = t(this.key, e) } catch (r) { return this.destination.error(r) } else this.hasKey = !0; n || (this.key = e, this.destination.next(t)) } } const t_ = new jd(Vd); class e_ { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new n_(t, this.durationSelector)) } } class n_ extends U { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { if (this.value = t, this.hasValue = !0, !this.throttled) { let n; try { const { durationSelector: e } = this; n = e(t) } catch (e) { return this.destination.error(e) } const r = G(n, new H(this)); !r || r.closed ? this.clearThrottle() : this.add(this.throttled = r) } } clearThrottle() { const { value: t, hasValue: e, throttled: n } = this; n && (this.remove(n), this.throttled = void 0, n.unsubscribe()), e && (this.value = void 0, this.hasValue = !1, this.destination.next(t)) } notifyNext() { this.clearThrottle() } notifyComplete() { this.clearThrottle() } } function r_(t) { return !c(t) && t - parseFloat(t) + 1 >= 0 } function i_(t = 0, e, n) { let r = -1; return r_(e) ? r = Number(e) < 1 ? 1 : Number(e) : C(e) && (n = e), C(n) || (n = t_), new w(e => { const i = r_(t) ? t : +t - n.now(); return n.schedule(s_, i, { index: 0, period: r, subscriber: e }) }) } function s_(t) { const { index: e, period: n, subscriber: r } = t; if (r.next(e), !r.closed) { if (-1 === n) return r.complete(); t.index = e + 1, this.schedule(t, n) } } function o_(t, e = t_) { return n = () => i_(t, e), function (t) { return t.lift(new e_(n)) }; var n } function a_(t) { return e => e.lift(new l_(t)) } class l_ { constructor(t) { this.notifier = t } call(t, e) { const n = new c_(t), r = G(this.notifier, new H(n)); return r && !n.seenValue ? (n.add(r), e.subscribe(n)) : n } } class c_ extends U { constructor(t) { super(t), this.seenValue = !1 } notifyNext() { this.seenValue = !0, this.complete() } notifyComplete() { } } function u_(t, e, n) { let r; return r = t && "object" == typeof t ? t : { bufferSize: t, windowTime: e, refCount: !1, scheduler: n }, t => t.lift(function ({ bufferSize: t = Number.POSITIVE_INFINITY, windowTime: e = Number.POSITIVE_INFINITY, refCount: n, scheduler: r }) { let i, s, o = 0, a = !1, l = !1; return function (c) { let u; o++, !i || a ? (a = !1, i = new $d(t, e, r), u = i.subscribe(this), s = c.subscribe({ next(t) { i.next(t) }, error(t) { a = !0, i.error(t) }, complete() { l = !0, s = void 0, i.complete() } }), l && (s = void 0)) : u = i.subscribe(this), this.add(() => { o--, u.unsubscribe(), u = void 0, s && !l && n && 0 === o && (s.unsubscribe(), s = void 0, i = void 0) }) } }(r)) } let h_; try { h_ = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (wN) { h_ = !1 } let d_, p_ = (() => { class t { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? gh(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !h_) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function (e) { return new (e || t)(fr(Ac)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(Ac)) }, token: t, providedIn: "root" }), t })(), f_ = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({}), t })(); const m_ = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function g_() { if (d_) return d_; if ("object" != typeof document || !document) return d_ = new Set(m_), d_; let t = document.createElement("input"); return d_ = new Set(m_.filter(e => (t.setAttribute("type", e), t.type === e))), d_ } let v_, y_, b_; function __(t) { return function () { if (null == v_ && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => v_ = !0 })) } finally { v_ = v_ || !1 } return v_ }() ? t : !!t.capture } function w_() { if (null == y_) { if ("object" != typeof document || !document || "function" != typeof Element || !Element) return y_ = !1, y_; if ("scrollBehavior" in document.documentElement.style) y_ = !0; else { const t = Element.prototype.scrollTo; y_ = !!t && !/\{\s*\[native code\]\s*\}/.test(t.toString()) } } return y_ } function S_() { let t = "undefined" != typeof document && document ? document.activeElement : null; for (; t && t.shadowRoot;) { const e = t.shadowRoot.activeElement; if (e === t) break; t = e } return t } const x_ = new Kn("cdk-dir-doc", { providedIn: "root", factory: function () { return mr(wu) } }); let T_ = (() => { class t { constructor(t) { if (this.value = "ltr", this.change = new ec, t) { const e = t.documentElement ? t.documentElement.dir : null, n = (t.body ? t.body.dir : null) || e; this.value = "ltr" === n || "rtl" === n ? n : "ltr" } } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function (e) { return new (e || t)(fr(x_, 8)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(x_, 8)) }, token: t, providedIn: "root" }), t })(), E_ = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({}), t })(), M_ = (() => { class t { constructor() { this._listeners = [] } notify(t, e) { for (let n of this._listeners) n(t, e) } listen(t) { return this._listeners.push(t), () => { this._listeners = this._listeners.filter(e => t !== e) } } ngOnDestroy() { this._listeners = [] } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), A_ = (() => { class t { constructor(t, e, n) { this._ngZone = t, this._platform = e, this._scrolled = new M, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = n } register(t) { this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t))) } deregister(t) { const e = this.scrollContainers.get(t); e && (e.unsubscribe(), this.scrollContainers.delete(t)) } scrolled(t = 20) { return this._platform.isBrowser ? new w(e => { this._globalSubscription || this._addGlobalListener(); const n = t > 0 ? this._scrolled.pipe(o_(t)).subscribe(e) : this._scrolled.subscribe(e); return this._scrolledCount++, () => { n.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : id() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((t, e) => this.deregister(e)), this._scrolled.complete() } ancestorScrolled(t, e) { const n = this.getAncestorScrollContainers(t); return this.scrolled(e).pipe(od(t => !t || n.indexOf(t) > -1)) } getAncestorScrollContainers(t) { const e = []; return this.scrollContainers.forEach((n, r) => { this._scrollableContainsElement(r, t) && e.push(r) }), e } _getWindow() { return this._document.defaultView || window } _scrollableContainsElement(t, e) { let n = Vb(e), r = t.getElementRef().nativeElement; do { if (n == r) return !0 } while (n = n.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => zb(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Vc), fr(p_), fr(wu, 8)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(Vc), fr(p_), fr(wu, 8)) }, token: t, providedIn: "root" }), t })(), C_ = (() => { class t { constructor(t, e, n) { this._platform = t, this._change = new M, this._changeListener = t => { this._change.next(t) }, this._document = n, e.runOutsideAngular(() => { if (t.isBrowser) { const t = this._getWindow(); t.addEventListener("resize", this._changeListener), t.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._updateViewportSize()) }) } ngOnDestroy() { if (this._platform.isBrowser) { const t = this._getWindow(); t.removeEventListener("resize", this._changeListener), t.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const t = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), t } getViewportRect() { const t = this.getViewportScrollPosition(), { width: e, height: n } = this.getViewportSize(); return { top: t.top, left: t.left, bottom: t.top + n, right: t.left + e, height: n, width: e } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const t = this._document, e = this._getWindow(), n = t.documentElement, r = n.getBoundingClientRect(); return { top: -r.top || t.body.scrollTop || e.scrollY || n.scrollTop || 0, left: -r.left || t.body.scrollLeft || e.scrollX || n.scrollLeft || 0 } } change(t = 20) { return t > 0 ? this._change.pipe(o_(t)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const t = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: t.innerWidth, height: t.innerHeight } : { width: 0, height: 0 } } } return t.\u0275fac = function (e) { return new (e || t)(fr(p_), fr(Vc), fr(wu, 8)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(p_), fr(Vc), fr(wu, 8)) }, token: t, providedIn: "root" }), t })(), P_ = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({}), t })(), R_ = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[E_, f_, P_], E_, P_] }), t })(); class L_ { attach(t) { return this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null != t && (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class k_ extends L_ { constructor(t, e, n, r) { super(), this.component = t, this.viewContainerRef = e, this.injector = n, this.componentFactoryResolver = r } } class D_ extends L_ { constructor(t, e, n) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = n } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class I_ extends L_ { constructor(t) { super(), this.element = t instanceof Wa ? t.nativeElement : t } } class O_ { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(t) { return t instanceof k_ ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof D_ ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof I_ ? (this._attachedPortal = t, this.attachDomPortal(t)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class F_ extends O_ { constructor(t, e, n, r, i) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = n, this._defaultInjector = r, this.attachDomPortal = t => { const e = t.element, n = this._document.createComment("dom-portal"); e.parentNode.insertBefore(n, e), this.outletElement.appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => { n.parentNode && n.parentNode.replaceChild(e, n) }) }, this._document = i } attachComponentPortal(t) { const e = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let n; return t.viewContainerRef ? (n = t.viewContainerRef.createComponent(e, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => n.destroy())) : (n = e.create(t.injector || this._defaultInjector), this._appRef.attachView(n.hostView), this.setDisposeFn(() => { this._appRef.detachView(n.hostView), n.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(n)), this._attachedPortal = t, n } attachTemplatePortal(t) { let e = t.viewContainerRef, n = e.createEmbeddedView(t.templateRef, t.context); return n.rootNodes.forEach(t => this.outletElement.appendChild(t)), n.detectChanges(), this.setDisposeFn(() => { let t = e.indexOf(n); -1 !== t && e.remove(t) }), this._attachedPortal = t, n } dispose() { super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement) } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } } let N_ = (() => { class t extends O_ { constructor(t, e, n) { super(), this._componentFactoryResolver = t, this._viewContainerRef = e, this._isInitialized = !1, this.attached = new ec, this.attachDomPortal = t => { const e = t.element, n = this._document.createComment("dom-portal"); t.setAttachedHost(this), e.parentNode.insertBefore(n, e), this._getRootNode().appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => { n.parentNode && n.parentNode.replaceChild(e, n) }) }, this._document = n } get portal() { return this._attachedPortal } set portal(t) { (!this.hasAttached() || t || this._isInitialized) && (this.hasAttached() && super.detach(), t && super.attach(t), this._attachedPortal = t) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(t) { t.setAttachedHost(this); const e = null != t.viewContainerRef ? t.viewContainerRef : this._viewContainerRef, n = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component), r = e.createComponent(n, e.length, t.injector || e.injector); return e !== this._viewContainerRef && this._getRootNode().appendChild(r.hostView.rootNodes[0]), super.setDisposeFn(() => r.destroy()), this._attachedPortal = t, this._attachedRef = r, this.attached.emit(r), r } attachTemplatePortal(t) { t.setAttachedHost(this); const e = this._viewContainerRef.createEmbeddedView(t.templateRef, t.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = t, this._attachedRef = e, this.attached.emit(e), e } _getRootNode() { const t = this._viewContainerRef.element.nativeElement; return t.nodeType === t.ELEMENT_NODE ? t : t.parentNode } } return t.\u0275fac = function (e) { return new (e || t)(Do(za), Do(Ll), Do(wu)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [vo] }), t })(), B_ = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({}), t })(); function H_(t, ...e) { return e.length ? e.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey } const U_ = w_(); class G_ { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const t = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = Gb(-this._previousScrollPosition.left), t.style.top = Gb(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement, e = t.style, n = this._document.body.style, r = e.scrollBehavior || "", i = n.scrollBehavior || ""; this._isEnabled = !1, e.left = this._previousHTMLStyles.left, e.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), U_ && (e.scrollBehavior = n.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), U_ && (e.scrollBehavior = r, n.scrollBehavior = i) } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const t = this._document.body, e = this._viewportRuler.getViewportSize(); return t.scrollHeight > e.height || t.scrollWidth > e.width } } class V_ { constructor(t, e, n, r) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = n, this._config = r, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const t = this._viewportRuler.getViewportScrollPosition().top; Math.abs(t - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class z_ { enable() { } disable() { } attach() { } } function j_(t, e) { return e.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right) } function J_(t, e) { return e.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right) } class X_ { constructor(t, e, n, r) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this._config = r, this._scrollSubscription = null } attach(t) { this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const t = this._overlayRef.overlayElement.getBoundingClientRect(), { width: e, height: n } = this._viewportRuler.getViewportSize(); j_(t, [{ width: e, height: n, bottom: n, right: e, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let W_ = (() => { class t { constructor(t, e, n, r) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this.noop = () => new z_, this.close = t => new V_(this._scrollDispatcher, this._ngZone, this._viewportRuler, t), this.block = () => new G_(this._viewportRuler, this._document), this.reposition = t => new X_(this._scrollDispatcher, this._viewportRuler, this._ngZone, t), this._document = r } } return t.\u0275fac = function (e) { return new (e || t)(fr(A_), fr(C_), fr(Vc), fr(wu)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(A_), fr(C_), fr(Vc), fr(wu)) }, token: t, providedIn: "root" }), t })(); class q_ { constructor(t) { if (this.scrollStrategy = new z_, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const n of e) void 0 !== t[n] && (this[n] = t[n]) } } } class Z_ { constructor(t, e, n, r, i) { this.offsetX = n, this.offsetY = r, this.panelClass = i, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY } } class K_ { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } } let Y_ = (() => { class t { constructor(t) { this._attachedOverlays = [], this._document = t } ngOnDestroy() { this.detach() } add(t) { this.remove(t), this._attachedOverlays.push(t) } remove(t) { const e = this._attachedOverlays.indexOf(t); e > -1 && this._attachedOverlays.splice(e, 1), 0 === this._attachedOverlays.length && this.detach() } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(wu)) }, token: t, providedIn: "root" }), t })(), Q_ = (() => { class t extends Y_ { constructor(t) { super(t), this._keydownListener = t => { const e = this._attachedOverlays; for (let n = e.length - 1; n > -1; n--)if (e[n]._keydownEvents.observers.length > 0) { e[n]._keydownEvents.next(t); break } } } add(t) { super.add(t), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0) } detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(wu)) }, token: t, providedIn: "root" }), t })(), $_ = (() => { class t extends Y_ { constructor(t, e) { super(t), this._platform = e, this._cursorStyleIsSet = !1, this._clickListener = t => { const e = t.composedPath ? t.composedPath()[0] : t.target, n = this._attachedOverlays.slice(); for (let r = n.length - 1; r > -1; r--) { const i = n[r]; if (!(i._outsidePointerEvents.observers.length < 1) && i.hasAttached()) { if (i.overlayElement.contains(e)) break; i._outsidePointerEvents.next(t) } } } } add(t) { if (super.add(t), !this._isAttached) { const t = this._document.body; t.addEventListener("click", this._clickListener, !0), t.addEventListener("auxclick", this._clickListener, !0), t.addEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = t.style.cursor, t.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0 } } detach() { if (this._isAttached) { const t = this._document.body; t.removeEventListener("click", this._clickListener, !0), t.removeEventListener("auxclick", this._clickListener, !0), t.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (t.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1 } } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu), fr(p_)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(wu), fr(p_)) }, token: t, providedIn: "root" }), t })(); const tw = "undefined" != typeof window ? window : {}, ew = void 0 !== tw.__karma__ && !!tw.__karma__ || void 0 !== tw.jasmine && !!tw.jasmine || void 0 !== tw.jest && !!tw.jest || void 0 !== tw.Mocha && !!tw.Mocha; let nw = (() => { class t { constructor(t, e) { this._platform = e, this._document = t } ngOnDestroy() { const t = this._containerElement; t && t.parentNode && t.parentNode.removeChild(t) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const t = "cdk-overlay-container"; if (this._platform.isBrowser || ew) { const e = this._document.querySelectorAll(`.${t}[platform="server"], .${t}[platform="test"]`); for (let t = 0; t < e.length; t++)e[t].parentNode.removeChild(e[t]) } const e = this._document.createElement("div"); e.classList.add(t), ew ? e.setAttribute("platform", "test") : this._platform.isBrowser || e.setAttribute("platform", "server"), this._document.body.appendChild(e), this._containerElement = e } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu), fr(p_)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(wu), fr(p_)) }, token: t, providedIn: "root" }), t })(); class rw { constructor(t, e, n, r, i, s, o, a, l) { this._portalOutlet = t, this._host = e, this._pane = n, this._config = r, this._ngZone = i, this._keyboardDispatcher = s, this._document = o, this._location = a, this._outsideClickDispatcher = l, this._backdropElement = null, this._backdropClick = new M, this._attachments = new M, this._detachments = new M, this._locationChanges = d.EMPTY, this._backdropClickHandler = t => this._backdropClick.next(t), this._keydownEvents = new M, this._outsidePointerEvents = new M, r.scrollStrategy && (this._scrollStrategy = r.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = r.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe(hg(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), t } dispose() { const t = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick } attachments() { return this._attachments } detachments() { return this._detachments } keydownEvents() { return this._keydownEvents } outsidePointerEvents() { return this._outsidePointerEvents } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign(Object.assign({}, this._config), t), this._updateElementSize() } setDirection(t) { this._config = Object.assign(Object.assign({}, this._config), { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style; t.width = Gb(this._config.width), t.height = Gb(this._config.height), t.minWidth = Gb(this._config.minWidth), t.minHeight = Gb(this._config.minHeight), t.maxWidth = Gb(this._config.maxWidth), t.maxHeight = Gb(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "" : "none" } _attachBackdrop() { const t = "cdk-overlay-backdrop-showing"; this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add(t) }) }) : this._backdropElement.classList.add(t) } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { let t, e = this._backdropElement; if (!e) return; let n = () => { e && (e.removeEventListener("click", this._backdropClickHandler), e.removeEventListener("transitionend", n), e.parentNode && e.parentNode.removeChild(e)), this._backdropElement == e && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(e, this._config.backdropClass, !1), clearTimeout(t) }; e.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { e.addEventListener("transitionend", n) }), e.style.pointerEvents = "none", t = this._ngZone.runOutsideAngular(() => setTimeout(n, 500)) } _toggleClasses(t, e, n) { const r = t.classList; Ub(e).forEach(t => { t && (n ? r.add(t) : r.remove(t)) }) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.pipe(a_(W(this._attachments, this._detachments))).subscribe(() => { this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe()) }) }) } _disposeScrollStrategy() { const t = this._scrollStrategy; t && (t.disable(), t.detach && t.detach()) } } const iw = "cdk-overlay-connected-position-bounding-box", sw = /([A-Za-z%]+)$/; class ow { constructor(t, e, n, r, i) { this._viewportRuler = e, this._document = n, this._platform = r, this._overlayContainer = i, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new M, this._resizeSubscription = d.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { this._validatePositions(), t.hostElement.classList.add(iw), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect, e = this._overlayRect, n = this._viewportRect, r = []; let i; for (let s of this._preferredPositions) { let o = this._getOriginPoint(t, s), a = this._getOverlayPoint(o, e, s), l = this._getOverlayFit(a, e, n, s); if (l.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(s, o); this._canFitWithFlexibleDimensions(l, a, n) ? r.push({ position: s, origin: o, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(o, s) }) : (!i || i.overlayFit.visibleArea < l.visibleArea) && (i = { overlayFit: l, overlayPoint: a, originPoint: o, position: s, overlayRect: e }) } if (r.length) { let t = null, e = -1; for (const n of r) { const r = n.boundingBoxRect.width * n.boundingBoxRect.height * (n.position.weight || 1); r > e && (e = r, t = n) } return this._isPushed = !1, void this._applyPosition(t.position, t.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(i.position, i.originPoint); this._applyPosition(i.position, i.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && aw(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(iw), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0], e = this._getOriginPoint(this._originRect, t); this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let n, r; if ("center" == e.originX) n = t.left + t.width / 2; else { const r = this._isRtl() ? t.right : t.left, i = this._isRtl() ? t.left : t.right; n = "start" == e.originX ? r : i } return r = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: n, y: r } } _getOverlayPoint(t, e, n) { let r, i; return r = "center" == n.overlayX ? -e.width / 2 : "start" === n.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, i = "center" == n.overlayY ? -e.height / 2 : "top" == n.overlayY ? 0 : -e.height, { x: t.x + r, y: t.y + i } } _getOverlayFit(t, e, n, r) { const i = cw(e); let { x: s, y: o } = t, a = this._getOffset(r, "x"), l = this._getOffset(r, "y"); a && (s += a), l && (o += l); let c = 0 - o, u = o + i.height - n.height, h = this._subtractOverflows(i.width, 0 - s, s + i.width - n.width), d = this._subtractOverflows(i.height, c, u), p = h * d; return { visibleArea: p, isCompletelyWithinViewport: i.width * i.height === p, fitsInViewportVertically: d === i.height, fitsInViewportHorizontally: h == i.width } } _canFitWithFlexibleDimensions(t, e, n) { if (this._hasFlexibleDimensions) { const r = n.bottom - e.y, i = n.right - e.x, s = lw(this._overlayRef.getConfig().minHeight), o = lw(this._overlayRef.getConfig().minWidth), a = t.fitsInViewportHorizontally || null != o && o <= i; return (t.fitsInViewportVertically || null != s && s <= r) && a } return !1 } _pushOverlayOnScreen(t, e, n) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const r = cw(e), i = this._viewportRect, s = Math.max(t.x + r.width - i.width, 0), o = Math.max(t.y + r.height - i.height, 0), a = Math.max(i.top - n.top - t.y, 0), l = Math.max(i.left - n.left - t.x, 0); let c = 0, u = 0; return c = r.width <= i.width ? l || -s : t.x < this._viewportMargin ? i.left - n.left - t.x : 0, u = r.height <= i.height ? a || -o : t.y < this._viewportMargin ? i.top - n.top - t.y : 0, this._previousPushAmount = { x: c, y: u }, { x: t.x + c, y: t.y + u } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const e = this._getScrollVisibility(), n = new K_(t, e); this._positionChanges.next(n) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let n, r = t.overlayY; n = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let i = 0; i < e.length; i++)e[i].style.transformOrigin = `${n} ${r}` } _calculateBoundingBoxRect(t, e) { const n = this._viewportRect, r = this._isRtl(); let i, s, o, a, l, c; if ("top" === e.overlayY) s = t.y, i = n.height - s + this._viewportMargin; else if ("bottom" === e.overlayY) o = n.height - t.y + 2 * this._viewportMargin, i = n.height - o + this._viewportMargin; else { const e = Math.min(n.bottom - t.y + n.top, t.y), r = this._lastBoundingBoxSize.height; i = 2 * e, s = t.y - e, i > r && !this._isInitialRender && !this._growAfterOpen && (s = t.y - r / 2) } if ("end" === e.overlayX && !r || "start" === e.overlayX && r) c = n.width - t.x + this._viewportMargin, a = t.x - this._viewportMargin; else if ("start" === e.overlayX && !r || "end" === e.overlayX && r) l = t.x, a = n.right - t.x; else { const e = Math.min(n.right - t.x + n.left, t.x), r = this._lastBoundingBoxSize.width; a = 2 * e, l = t.x - e, a > r && !this._isInitialRender && !this._growAfterOpen && (l = t.x - r / 2) } return { top: s, left: l, bottom: o, right: c, width: a, height: i } } _setBoundingBoxStyles(t, e) { const n = this._calculateBoundingBoxRect(t, e); this._isInitialRender || this._growAfterOpen || (n.height = Math.min(n.height, this._lastBoundingBoxSize.height), n.width = Math.min(n.width, this._lastBoundingBoxSize.width)); const r = {}; if (this._hasExactPosition()) r.top = r.left = "0", r.bottom = r.right = r.maxHeight = r.maxWidth = "", r.width = r.height = "100%"; else { const t = this._overlayRef.getConfig().maxHeight, i = this._overlayRef.getConfig().maxWidth; r.height = Gb(n.height), r.top = Gb(n.top), r.bottom = Gb(n.bottom), r.width = Gb(n.width), r.left = Gb(n.left), r.right = Gb(n.right), r.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", r.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", t && (r.maxHeight = Gb(t)), i && (r.maxWidth = Gb(i)) } this._lastBoundingBoxSize = n, aw(this._boundingBox.style, r) } _resetBoundingBoxStyles() { aw(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { aw(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const n = {}, r = this._hasExactPosition(), i = this._hasFlexibleDimensions, s = this._overlayRef.getConfig(); if (r) { const r = this._viewportRuler.getViewportScrollPosition(); aw(n, this._getExactOverlayY(e, t, r)), aw(n, this._getExactOverlayX(e, t, r)) } else n.position = "static"; let o = "", a = this._getOffset(e, "x"), l = this._getOffset(e, "y"); a && (o += `translateX(${a}px) `), l && (o += `translateY(${l}px)`), n.transform = o.trim(), s.maxHeight && (r ? n.maxHeight = Gb(s.maxHeight) : i && (n.maxHeight = "")), s.maxWidth && (r ? n.maxWidth = Gb(s.maxWidth) : i && (n.maxWidth = "")), aw(this._pane.style, n) } _getExactOverlayY(t, e, n) { let r = { top: "", bottom: "" }, i = this._getOverlayPoint(e, this._overlayRect, t); this._isPushed && (i = this._pushOverlayOnScreen(i, this._overlayRect, n)); let s = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return i.y -= s, "bottom" === t.overlayY ? r.bottom = this._document.documentElement.clientHeight - (i.y + this._overlayRect.height) + "px" : r.top = Gb(i.y), r } _getExactOverlayX(t, e, n) { let r, i = { left: "", right: "" }, s = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, n)), r = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === r ? i.right = this._document.documentElement.clientWidth - (s.x + this._overlayRect.width) + "px" : i.left = Gb(s.x), i } _getScrollVisibility() { const t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), n = this._scrollables.map(t => t.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: J_(t, n), isOriginOutsideView: j_(t, n), isOverlayClipped: J_(e, n), isOverlayOutsideView: j_(e, n) } } _subtractOverflows(t, ...e) { return e.reduce((t, e) => t - Math.max(e, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, n = this._viewportRuler.getViewportScrollPosition(); return { top: n.top + this._viewportMargin, left: n.left + this._viewportMargin, right: n.left + t - this._viewportMargin, bottom: n.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { } _addPanelClasses(t) { this._pane && Ub(t).forEach(t => { "" !== t && -1 === this._appliedPanelClasses.indexOf(t) && (this._appliedPanelClasses.push(t), this._pane.classList.add(t)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof Wa) return t.nativeElement.getBoundingClientRect(); if (t instanceof Element) return t.getBoundingClientRect(); const e = t.width || 0, n = t.height || 0; return { top: t.y, bottom: t.y + n, left: t.x, right: t.x + e, height: n, width: e } } } function aw(t, e) { for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } function lw(t) { if ("number" != typeof t && null != t) { const [e, n] = t.split(sw); return n && "px" !== n ? null : parseFloat(e) } return t || null } function cw(t) { return { top: Math.floor(t.top), right: Math.floor(t.right), bottom: Math.floor(t.bottom), left: Math.floor(t.left), width: Math.floor(t.width), height: Math.floor(t.height) } } class uw { constructor(t, e, n, r, i, s, o) { this._preferredPositions = [], this._positionStrategy = new ow(n, r, i, s, o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e), this.onPositionChange = this._positionStrategy.positionChanges } get positions() { return this._preferredPositions } attach(t) { this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null) } dispose() { this._positionStrategy.dispose() } detach() { this._positionStrategy.detach() } apply() { this._positionStrategy.apply() } recalculateLastPosition() { this._positionStrategy.reapplyLastPosition() } withScrollableContainers(t) { this._positionStrategy.withScrollableContainers(t) } withFallbackPosition(t, e, n, r) { const i = new Z_(t, e, n, r); return this._preferredPositions.push(i), this._positionStrategy.withPositions(this._preferredPositions), this } withDirection(t) { return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this } withOffsetX(t) { return this._positionStrategy.withDefaultOffsetX(t), this } withOffsetY(t) { return this._positionStrategy.withDefaultOffsetY(t), this } withLockedPosition(t) { return this._positionStrategy.withLockedPosition(t), this } withPositions(t) { return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this } setOrigin(t) { return this._positionStrategy.setOrigin(t), this } } const hw = "cdk-global-overlay-wrapper"; class dw { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig(); this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add(hw), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, n = this._overlayRef.getConfig(), { width: r, height: i, maxWidth: s, maxHeight: o } = n, a = !("100%" !== r && "100vw" !== r || s && "100%" !== s && "100vw" !== s), l = !("100%" !== i && "100vh" !== i || o && "100%" !== o && "100vh" !== o); t.position = this._cssPosition, t.marginLeft = a ? "0" : this._leftOffset, t.marginTop = l ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, a ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = l ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, n = e.style; e.classList.remove(hw), n.justifyContent = n.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } } let pw = (() => { class t { constructor(t, e, n, r) { this._viewportRuler = t, this._document = e, this._platform = n, this._overlayContainer = r } global() { return new dw } connectedTo(t, e, n) { return new uw(e, n, t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } flexibleConnectedTo(t) { return new ow(t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return t.\u0275fac = function (e) { return new (e || t)(fr(C_), fr(wu), fr(p_), fr(nw)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(C_), fr(wu), fr(p_), fr(nw)) }, token: t, providedIn: "root" }), t })(), fw = 0, mw = (() => { class t { constructor(t, e, n, r, i, s, o, a, l, c, u) { this.scrollStrategies = t, this._overlayContainer = e, this._componentFactoryResolver = n, this._positionBuilder = r, this._keyboardDispatcher = i, this._injector = s, this._ngZone = o, this._document = a, this._directionality = l, this._location = c, this._outsideClickDispatcher = u } create(t) { const e = this._createHostElement(), n = this._createPaneElement(e), r = this._createPortalOutlet(n), i = new q_(t); return i.direction = i.direction || this._directionality.value, new rw(r, e, n, i, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher) } position() { return this._positionBuilder } _createPaneElement(t) { const e = this._document.createElement("div"); return e.id = "cdk-overlay-" + fw++, e.classList.add("cdk-overlay-pane"), t.appendChild(e), e } _createHostElement() { const t = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(t), t } _createPortalOutlet(t) { return this._appRef || (this._appRef = this._injector.get(cu)), new F_(t, this._componentFactoryResolver, this._appRef, this._injector, this._document) } } return t.\u0275fac = function (e) { return new (e || t)(fr(W_), fr(nw), fr(za), fr(pw), fr(Q_), fr(mo), fr(Vc), fr(wu), fr(T_), fr(Fu), fr($_)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const gw = { provide: new Kn("cdk-connected-overlay-scroll-strategy"), deps: [mw], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }; let vw = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [mw, gw], imports: [[E_, B_, R_], R_] }), t })(); function yw(t, e = t_) { return n => n.lift(new bw(t, e)) } class bw { constructor(t, e) { this.dueTime = t, this.scheduler = e } call(t, e) { return e.subscribe(new _w(t, this.dueTime, this.scheduler)) } } class _w extends m { constructor(t, e, n) { super(t), this.dueTime = e, this.scheduler = n, this.debouncedSubscription = null, this.lastValue = null, this.hasValue = !1 } _next(t) { this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(ww, this.dueTime, this)) } _complete() { this.debouncedNext(), this.destination.complete() } debouncedNext() { if (this.clearDebounce(), this.hasValue) { const { lastValue: t } = this; this.lastValue = null, this.hasValue = !1, this.destination.next(t) } } clearDebounce() { const t = this.debouncedSubscription; null !== t && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null) } } function ww(t) { t.debouncedNext() } function Sw(t) { return e => e.lift(new xw(t)) } class xw { constructor(t) { this.total = t } call(t, e) { return e.subscribe(new Tw(t, this.total)) } } class Tw extends m { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { ++this.count > this.total && this.destination.next(t) } } let Ew = (() => { class t { create(t) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), Mw = (() => { class t { constructor(t) { this._mutationObserverFactory = t, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((t, e) => this._cleanupObserver(e)) } observe(t) { const e = Vb(t); return new w(t => { const n = this._observeElement(e).subscribe(t); return () => { n.unsubscribe(), this._unobserveElement(e) } }) } _observeElement(t) { if (this._observedElements.has(t)) this._observedElements.get(t).count++; else { const e = new M, n = this._mutationObserverFactory.create(t => e.next(t)); n && n.observe(t, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(t, { observer: n, stream: e, count: 1 }) } return this._observedElements.get(t).stream } _unobserveElement(t) { this._observedElements.has(t) && (this._observedElements.get(t).count--, this._observedElements.get(t).count || this._cleanupObserver(t)) } _cleanupObserver(t) { if (this._observedElements.has(t)) { const { observer: e, stream: n } = this._observedElements.get(t); e && e.disconnect(), n.complete(), this._observedElements.delete(t) } } } return t.\u0275fac = function (e) { return new (e || t)(fr(Ew)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(Ew)) }, token: t, providedIn: "root" }), t })(), Aw = (() => { class t { constructor(t, e, n) { this._contentObserver = t, this._elementRef = e, this._ngZone = n, this.event = new ec, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(t) { this._disabled = Bb(t), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(t) { this._debounce = Hb(t), this._subscribe() } ngAfterContentInit() { this._currentSubscription || this.disabled || this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const t = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? t.pipe(yw(this.debounce)) : t).subscribe(this.event) }) } _unsubscribe() { var t; null === (t = this._currentSubscription) || void 0 === t || t.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(Do(Mw), Do(Wa), Do(Vc)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), t })(), Cw = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [Ew] }), t })(); class Pw extends class { constructor(t) { this._items = t, this._activeItemIndex = -1, this._activeItem = null, this._wrap = !1, this._letterKeyStream = new M, this._typeaheadSubscription = d.EMPTY, this._vertical = !0, this._allowedModifierKeys = [], this._homeAndEnd = !1, this._skipPredicateFn = t => t.disabled, this._pressedLetters = [], this.tabOut = new M, this.change = new M, t instanceof rc && t.changes.subscribe(t => { if (this._activeItem) { const e = t.toArray().indexOf(this._activeItem); e > -1 && e !== this._activeItemIndex && (this._activeItemIndex = e) } }) } skipPredicate(t) { return this._skipPredicateFn = t, this } withWrap(t = !0) { return this._wrap = t, this } withVerticalOrientation(t = !0) { return this._vertical = t, this } withHorizontalOrientation(t) { return this._horizontal = t, this } withAllowedModifierKeys(t) { return this._allowedModifierKeys = t, this } withTypeAhead(t = 200) { return this._typeaheadSubscription.unsubscribe(), this._typeaheadSubscription = this._letterKeyStream.pipe(Dg(t => this._pressedLetters.push(t)), yw(t), od(() => this._pressedLetters.length > 0), P(() => this._pressedLetters.join(""))).subscribe(t => { const e = this._getItemsArray(); for (let n = 1; n < e.length + 1; n++) { const r = (this._activeItemIndex + n) % e.length, i = e[r]; if (!this._skipPredicateFn(i) && 0 === i.getLabel().toUpperCase().trim().indexOf(t)) { this.setActiveItem(r); break } } this._pressedLetters = [] }), this } withHomeAndEnd(t = !0) { return this._homeAndEnd = t, this } setActiveItem(t) { const e = this._activeItem; this.updateActiveItem(t), this._activeItem !== e && this.change.next(this._activeItemIndex) } onKeydown(t) { const e = t.keyCode, n = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(e => !t[e] || this._allowedModifierKeys.indexOf(e) > -1); switch (e) { case 9: return void this.tabOut.next(); case 40: if (this._vertical && n) { this.setNextItemActive(); break } return; case 38: if (this._vertical && n) { this.setPreviousItemActive(); break } return; case 39: if (this._horizontal && n) { "rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive(); break } return; case 37: if (this._horizontal && n) { "rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive(); break } return; case 36: if (this._homeAndEnd && n) { this.setFirstItemActive(); break } return; case 35: if (this._homeAndEnd && n) { this.setLastItemActive(); break } return; default: return void ((n || H_(t, "shiftKey")) && (t.key && 1 === t.key.length ? this._letterKeyStream.next(t.key.toLocaleUpperCase()) : (e >= 65 && e <= 90 || e >= 48 && e <= 57) && this._letterKeyStream.next(String.fromCharCode(e)))) }this._pressedLetters = [], t.preventDefault() } get activeItemIndex() { return this._activeItemIndex } get activeItem() { return this._activeItem } isTyping() { return this._pressedLetters.length > 0 } setFirstItemActive() { this._setActiveItemByIndex(0, 1) } setLastItemActive() { this._setActiveItemByIndex(this._items.length - 1, -1) } setNextItemActive() { this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1) } setPreviousItemActive() { this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1) } updateActiveItem(t) { const e = this._getItemsArray(), n = "number" == typeof t ? t : e.indexOf(t), r = e[n]; this._activeItem = null == r ? null : r, this._activeItemIndex = n } _setActiveItemByDelta(t) { this._wrap ? this._setActiveInWrapMode(t) : this._setActiveInDefaultMode(t) } _setActiveInWrapMode(t) { const e = this._getItemsArray(); for (let n = 1; n <= e.length; n++) { const r = (this._activeItemIndex + t * n + e.length) % e.length; if (!this._skipPredicateFn(e[r])) return void this.setActiveItem(r) } } _setActiveInDefaultMode(t) { this._setActiveItemByIndex(this._activeItemIndex + t, t) } _setActiveItemByIndex(t, e) { const n = this._getItemsArray(); if (n[t]) { for (; this._skipPredicateFn(n[t]);)if (!n[t += e]) return; this.setActiveItem(t) } } _getItemsArray() { return this._items instanceof rc ? this._items.toArray() : this._items } }{ constructor() { super(...arguments), this._origin = "program" } setFocusOrigin(t) { return this._origin = t, this } setActiveItem(t) { super.setActiveItem(t), this.activeItem && this.activeItem.focus(this._origin) } } let Rw = (() => { class t { constructor(t) { this._platform = t } isDisabled(t) { return t.hasAttribute("disabled") } isVisible(t) { return function (t) { return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length) }(t) && "visible" === getComputedStyle(t).visibility } isTabbable(t) { if (!this._platform.isBrowser) return !1; const e = function (t) { try { return t.frameElement } catch (wN) { return null } }((n = t).ownerDocument && n.ownerDocument.defaultView || window); var n; if (e) { if (-1 === kw(e)) return !1; if (!this.isVisible(e)) return !1 } let r = t.nodeName.toLowerCase(), i = kw(t); return t.hasAttribute("contenteditable") ? -1 !== i : "iframe" !== r && "object" !== r && !(this._platform.WEBKIT && this._platform.IOS && !function (t) { let e = t.nodeName.toLowerCase(), n = "input" === e && t.type; return "text" === n || "password" === n || "select" === e || "textarea" === e }(t)) && ("audio" === r ? !!t.hasAttribute("controls") && -1 !== i : "video" === r ? -1 !== i && (null !== i || this._platform.FIREFOX || t.hasAttribute("controls")) : t.tabIndex >= 0) } isFocusable(t, e) { return function (t) { return !function (t) { return function (t) { return "input" == t.nodeName.toLowerCase() }(t) && "hidden" == t.type }(t) && (function (t) { let e = t.nodeName.toLowerCase(); return "input" === e || "select" === e || "button" === e || "textarea" === e }(t) || function (t) { return function (t) { return "a" == t.nodeName.toLowerCase() }(t) && t.hasAttribute("href") }(t) || t.hasAttribute("contenteditable") || Lw(t)) }(t) && !this.isDisabled(t) && ((null == e ? void 0 : e.ignoreVisibility) || this.isVisible(t)) } } return t.\u0275fac = function (e) { return new (e || t)(fr(p_)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(p_)) }, token: t, providedIn: "root" }), t })(); function Lw(t) { if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1; let e = t.getAttribute("tabindex"); return "-32768" != e && !(!e || isNaN(parseInt(e, 10))) } function kw(t) { if (!Lw(t)) return null; const e = parseInt(t.getAttribute("tabindex") || "", 10); return isNaN(e) ? -1 : e } class Dw { constructor(t, e, n, r, i = !1) { this._element = t, this._checker = e, this._ngZone = n, this._document = r, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, i || this.attachAnchors() } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } destroy() { const t = this._startAnchor, e = this._endAnchor; t && (t.removeEventListener("focus", this.startAnchorListener), t.parentNode && t.parentNode.removeChild(t)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null, this._hasAttached = !1 } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusInitialElement(t))) }) } focusFirstTabbableElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusFirstTabbableElement(t))) }) } focusLastTabbableElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusLastTabbableElement(t))) }) } _getRegionBoundary(t) { let e = this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`); for (let n = 0; n < e.length; n++)e[n].hasAttribute(`cdk-focus-${t}`) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[n]) : e[n].hasAttribute(`cdk-focus-region-${t}`) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[n]); return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement(t) { const e = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); if (e) { if (e.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", e), !this._checker.isFocusable(e)) { const n = this._getFirstTabbableElement(e); return null == n || n.focus(t), !!n } return e.focus(t), !0 } return this.focusFirstTabbableElement(t) } focusFirstTabbableElement(t) { const e = this._getRegionBoundary("start"); return e && e.focus(t), !!e } focusLastTabbableElement(t) { const e = this._getRegionBoundary("end"); return e && e.focus(t), !!e } hasAttached() { return this._hasAttached } _getFirstTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = 0; n < e.length; n++) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[n]) : null; if (t) return t } return null } _getLastTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = e.length - 1; n >= 0; n--) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[n]) : null; if (t) return t } return null } _createAnchor() { const t = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t } _toggleAnchorTabIndex(t, e) { t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex") } toggleAnchors(t) { this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } _executeOnStable(t) { this._ngZone.isStable ? t() : this._ngZone.onStable.pipe(hg(1)).subscribe(t) } } let Iw = (() => { class t { constructor(t, e, n) { this._checker = t, this._ngZone = e, this._document = n } create(t, e = !1) { return new Dw(t, this._checker, this._ngZone, this._document, e) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Rw), fr(Vc), fr(wu)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(Rw), fr(Vc), fr(wu)) }, token: t, providedIn: "root" }), t })(); function Ow(t) { return 0 === t.buttons } function Fw(t) { const e = t.touches && t.touches[0] || t.changedTouches && t.changedTouches[0]; return !(!e || -1 !== e.identifier || null != e.radiusX && 1 !== e.radiusX || null != e.radiusY && 1 !== e.radiusY) } "undefined" != typeof Element && Element; const Nw = new Kn("cdk-input-modality-detector-options"), Bw = { ignoreKeys: [18, 17, 224, 91, 16] }, Hw = __({ passive: !0, capture: !0 }); let Uw = (() => { class t { constructor(t, e, n, r) { this._platform = t, this._mostRecentTarget = null, this._modality = new $m(null), this._lastTouchMs = 0, this._onKeydown = t => { var e, n; (null === (n = null === (e = this._options) || void 0 === e ? void 0 : e.ignoreKeys) || void 0 === n ? void 0 : n.some(e => e === t.keyCode)) || (this._modality.next("keyboard"), this._mostRecentTarget = Gw(t)) }, this._onMousedown = t => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(Ow(t) ? "keyboard" : "mouse"), this._mostRecentTarget = Gw(t)) }, this._onTouchstart = t => { Fw(t) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = Gw(t)) }, this._options = Object.assign(Object.assign({}, Bw), r), this.modalityDetected = this._modality.pipe(Sw(1)), this.modalityChanged = this.modalityDetected.pipe(Yb()), t.isBrowser && e.runOutsideAngular(() => { n.addEventListener("keydown", this._onKeydown, Hw), n.addEventListener("mousedown", this._onMousedown, Hw), n.addEventListener("touchstart", this._onTouchstart, Hw) }) } get mostRecentModality() { return this._modality.value } ngOnDestroy() { this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, Hw), document.removeEventListener("mousedown", this._onMousedown, Hw), document.removeEventListener("touchstart", this._onTouchstart, Hw)) } } return t.\u0275fac = function (e) { return new (e || t)(fr(p_), fr(Vc), fr(wu), fr(Nw, 8)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(p_), fr(Vc), fr(wu), fr(Nw, 8)) }, token: t, providedIn: "root" }), t })(); function Gw(t) { return t.composedPath ? t.composedPath()[0] : t.target } const Vw = new Kn("liveAnnouncerElement", { providedIn: "root", factory: function () { return null } }), zw = new Kn("LIVE_ANNOUNCER_DEFAULT_OPTIONS"); let jw = (() => { class t { constructor(t, e, n, r) { this._ngZone = e, this._defaultOptions = r, this._document = n, this._liveElement = t || this._createLiveElement() } announce(t, ...e) { const n = this._defaultOptions; let r, i; return 1 === e.length && "number" == typeof e[0] ? i = e[0] : [r, i] = e, this.clear(), clearTimeout(this._previousTimeout), r || (r = n && n.politeness ? n.politeness : "polite"), null == i && n && (i = n.duration), this._liveElement.setAttribute("aria-live", r), this._ngZone.runOutsideAngular(() => new Promise(e => { clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => { this._liveElement.textContent = t, e(), "number" == typeof i && (this._previousTimeout = setTimeout(() => this.clear(), i)) }, 100) })) } clear() { this._liveElement && (this._liveElement.textContent = "") } ngOnDestroy() { clearTimeout(this._previousTimeout), this._liveElement && this._liveElement.parentNode && (this._liveElement.parentNode.removeChild(this._liveElement), this._liveElement = null) } _createLiveElement() { const t = "cdk-live-announcer-element", e = this._document.getElementsByClassName(t), n = this._document.createElement("div"); for (let r = 0; r < e.length; r++)e[r].parentNode.removeChild(e[r]); return n.classList.add(t), n.classList.add("cdk-visually-hidden"), n.setAttribute("aria-atomic", "true"), n.setAttribute("aria-live", "polite"), this._document.body.appendChild(n), n } } return t.\u0275fac = function (e) { return new (e || t)(fr(Vw, 8), fr(Vc), fr(wu), fr(zw, 8)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(Vw, 8), fr(Vc), fr(wu), fr(zw, 8)) }, token: t, providedIn: "root" }), t })(); const Jw = new Kn("cdk-focus-monitor-default-options"), Xw = __({ passive: !0, capture: !0 }); let Ww = (() => { class t { constructor(t, e, n, r, i) { this._ngZone = t, this._platform = e, this._inputModalityDetector = n, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new M, this._rootNodeFocusAndBlurListener = t => { const e = Gw(t), n = "focus" === t.type ? this._onFocus : this._onBlur; for (let r = e; r; r = r.parentElement)n.call(this, t, r) }, this._document = r, this._detectionMode = (null == i ? void 0 : i.detectionMode) || 0 } monitor(t, e = !1) { const n = Vb(t); if (!this._platform.isBrowser || 1 !== n.nodeType) return id(null); const r = function (t) { if (function () { if (null == b_) { const t = "undefined" != typeof document ? document.head : null; b_ = !(!t || !t.createShadowRoot && !t.attachShadow) } return b_ }()) { const e = t.getRootNode ? t.getRootNode() : null; if ("undefined" != typeof ShadowRoot && ShadowRoot && e instanceof ShadowRoot) return e } return null }(n) || this._getDocument(), i = this._elementInfo.get(n); if (i) return e && (i.checkChildren = !0), i.subject; const s = { checkChildren: e, subject: new M, rootNode: r }; return this._elementInfo.set(n, s), this._registerGlobalListeners(s), s.subject } stopMonitoring(t) { const e = Vb(t), n = this._elementInfo.get(e); n && (n.subject.complete(), this._setClasses(e), this._elementInfo.delete(e), this._removeGlobalListeners(n)) } focusVia(t, e, n) { const r = Vb(t); r === this._getDocument().activeElement ? this._getClosestElementsInfo(r).forEach(([t, n]) => this._originChanged(t, e, n)) : (this._setOrigin(e), "function" == typeof r.focus && r.focus(n)) } ngOnDestroy() { this._elementInfo.forEach((t, e) => this.stopMonitoring(e)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _toggleClass(t, e, n) { n ? t.classList.add(e) : t.classList.remove(e) } _getFocusOrigin(t) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(t) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : "program" } _shouldBeAttributedToTouch(t) { return 1 === this._detectionMode || !!(null == t ? void 0 : t.contains(this._inputModalityDetector._mostRecentTarget)) } _setClasses(t, e) { this._toggleClass(t, "cdk-focused", !!e), this._toggleClass(t, "cdk-touch-focused", "touch" === e), this._toggleClass(t, "cdk-keyboard-focused", "keyboard" === e), this._toggleClass(t, "cdk-mouse-focused", "mouse" === e), this._toggleClass(t, "cdk-program-focused", "program" === e) } _setOrigin(t, e = !1) { this._ngZone.runOutsideAngular(() => { this._origin = t, this._originFromTouchInteraction = "touch" === t && e, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1)) }) } _onFocus(t, e) { const n = this._elementInfo.get(e), r = Gw(t); n && (n.checkChildren || e === r) && this._originChanged(e, this._getFocusOrigin(r), n) } _onBlur(t, e) { const n = this._elementInfo.get(e); !n || n.checkChildren && t.relatedTarget instanceof Node && e.contains(t.relatedTarget) || (this._setClasses(e), this._emitOrigin(n.subject, null)) } _emitOrigin(t, e) { this._ngZone.run(() => t.next(e)) } _registerGlobalListeners(t) { if (!this._platform.isBrowser) return; const e = t.rootNode, n = this._rootNodeFocusListenerCount.get(e) || 0; n || this._ngZone.runOutsideAngular(() => { e.addEventListener("focus", this._rootNodeFocusAndBlurListener, Xw), e.addEventListener("blur", this._rootNodeFocusAndBlurListener, Xw) }), this._rootNodeFocusListenerCount.set(e, n + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe(a_(this._stopInputModalityDetector)).subscribe(t => { this._setOrigin(t, !0) })) } _removeGlobalListeners(t) { const e = t.rootNode; if (this._rootNodeFocusListenerCount.has(e)) { const t = this._rootNodeFocusListenerCount.get(e); t > 1 ? this._rootNodeFocusListenerCount.set(e, t - 1) : (e.removeEventListener("focus", this._rootNodeFocusAndBlurListener, Xw), e.removeEventListener("blur", this._rootNodeFocusAndBlurListener, Xw), this._rootNodeFocusListenerCount.delete(e)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(t, e, n) { this._setClasses(t, e), this._emitOrigin(n.subject, e), this._lastFocusOrigin = e } _getClosestElementsInfo(t) { const e = []; return this._elementInfo.forEach((n, r) => { (r === t || n.checkChildren && r.contains(t)) && e.push([r, n]) }), e } } return t.\u0275fac = function (e) { return new (e || t)(fr(Vc), fr(p_), fr(Uw), fr(wu, 8), fr(Jw, 8)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(Vc), fr(p_), fr(Uw), fr(wu, 8), fr(Jw, 8)) }, token: t, providedIn: "root" }), t })(); const qw = "cdk-high-contrast-black-on-white", Zw = "cdk-high-contrast-white-on-black", Kw = "cdk-high-contrast-active"; let Yw = (() => { class t { constructor(t, e) { this._platform = t, this._document = e } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const t = this._document.createElement("div"); t.style.backgroundColor = "rgb(1,2,3)", t.style.position = "absolute", this._document.body.appendChild(t); const e = this._document.defaultView || window, n = e && e.getComputedStyle ? e.getComputedStyle(t) : null, r = (n && n.backgroundColor || "").replace(/ /g, ""); switch (this._document.body.removeChild(t), r) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const t = this._document.body.classList; t.remove(Kw), t.remove(qw), t.remove(Zw), this._hasCheckedHighContrastMode = !0; const e = this.getHighContrastMode(); 1 === e ? (t.add(Kw), t.add(qw)) : 2 === e && (t.add(Kw), t.add(Zw)) } } } return t.\u0275fac = function (e) { return new (e || t)(fr(p_), fr(wu)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(p_), fr(wu)) }, token: t, providedIn: "root" }), t })(); const Qw = new $a("12.1.1"), $w = new $a("12.1.1"), tS = new Kn("mat-sanity-checks", { providedIn: "root", factory: function () { return !0 } }); let eS, nS = (() => { class t { constructor(t, e, n) { this._hasDoneGlobalChecks = !1, this._document = n, t._applyBodyHighContrastModeCssClasses(), this._sanityChecks = e, this._hasDoneGlobalChecks || (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0) } _getWindow() { const t = this._document.defaultView || window; return "object" == typeof t && t ? t : null } _checksAreEnabled() { return nu() && !this._isTestEnv() } _isTestEnv() { const t = this._getWindow(); return t && (t.__karma__ || t.jasmine) } _checkDoctypeIsDefined() { this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.doctype) && !this._document.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.") } _checkThemeIsPresent() { if (!this._checksAreEnabled() || !1 === this._sanityChecks || !this._sanityChecks.theme || !this._document.body || "function" != typeof getComputedStyle) return; const t = this._document.createElement("div"); t.classList.add("mat-theme-loaded-marker"), this._document.body.appendChild(t); const e = getComputedStyle(t); e && "none" !== e.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), this._document.body.removeChild(t) } _checkCdkVersionMatch() { this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.version) && $w.full !== Qw.full && console.warn("The Angular Material version (" + $w.full + ") does not match the Angular CDK version (" + Qw.full + ").\nPlease ensure the versions of these two packages exactly match.") } } return t.\u0275fac = function (e) { return new (e || t)(fr(Yw), fr(tS, 8), fr(wu)) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[E_], E_] }), t })(); function rS(t) { return class extends t { constructor(...t) { super(...t), this._disabled = !1 } get disabled() { return this._disabled } set disabled(t) { this._disabled = Bb(t) } } } function iS(t, e) { return class extends t { constructor(...t) { super(...t), this.defaultColor = e, this.color = e } get color() { return this._color } set color(t) { const e = t || this.defaultColor; e !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), e && this._elementRef.nativeElement.classList.add(`mat-${e}`), this._color = e) } } } function sS(t) { return class extends t { constructor(...t) { super(...t), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = Bb(t) } } } function oS(t, e = 0) { return class extends t { constructor(...t) { super(...t), this._tabIndex = e, this.defaultTabIndex = e } get tabIndex() { return this.disabled ? -1 : this._tabIndex } set tabIndex(t) { this._tabIndex = null != t ? Hb(t) : this.defaultTabIndex } } } function aS(t) { return class extends t { constructor(...t) { super(...t), this.stateChanges = new M, this.errorState = !1 } updateErrorState() { const t = this.errorState, e = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm); e !== t && (this.errorState = e, this.stateChanges.next()) } } } try { eS = "undefined" != typeof Intl } catch (wN) { eS = !1 } let lS = (() => { class t { isErrorState(t, e) { return !!(t && t.invalid && (t.touched || e && e.submitted)) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); class cS { constructor(t, e, n) { this._renderer = t, this.element = e, this.config = n, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const uS = { enterDuration: 450, exitDuration: 400 }, hS = __({ passive: !0 }), dS = ["mousedown", "touchstart"], pS = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class fS { constructor(t, e, n, r) { this._target = t, this._ngZone = e, this._isPointerDown = !1, this._activeRipples = new Set, this._pointerUpEventsRegistered = !1, r.isBrowser && (this._containerElement = Vb(n)) } fadeInRipple(t, e, n = {}) { const r = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), i = Object.assign(Object.assign({}, uS), n.animation); n.centered && (t = r.left + r.width / 2, e = r.top + r.height / 2); const s = n.radius || function (t, e, n) { const r = Math.max(Math.abs(t - n.left), Math.abs(t - n.right)), i = Math.max(Math.abs(e - n.top), Math.abs(e - n.bottom)); return Math.sqrt(r * r + i * i) }(t, e, r), o = t - r.left, a = e - r.top, l = i.enterDuration, c = document.createElement("div"); c.classList.add("mat-ripple-element"), c.style.left = o - s + "px", c.style.top = a - s + "px", c.style.height = 2 * s + "px", c.style.width = 2 * s + "px", null != n.color && (c.style.backgroundColor = n.color), c.style.transitionDuration = `${l}ms`, this._containerElement.appendChild(c), window.getComputedStyle(c).getPropertyValue("opacity"), c.style.transform = "scale(1)"; const u = new cS(this, c, n); return u.state = 0, this._activeRipples.add(u), n.persistent || (this._mostRecentTransientRipple = u), this._runTimeoutOutsideZone(() => { const t = u === this._mostRecentTransientRipple; u.state = 1, n.persistent || t && this._isPointerDown || u.fadeOut() }, l), u } fadeOutRipple(t) { const e = this._activeRipples.delete(t); if (t === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), this._activeRipples.size || (this._containerRect = null), !e) return; const n = t.element, r = Object.assign(Object.assign({}, uS), t.config.animation); n.style.transitionDuration = `${r.exitDuration}ms`, n.style.opacity = "0", t.state = 2, this._runTimeoutOutsideZone(() => { t.state = 3, n.parentNode.removeChild(n) }, r.exitDuration) } fadeOutAll() { this._activeRipples.forEach(t => t.fadeOut()) } fadeOutAllNonPersistent() { this._activeRipples.forEach(t => { t.config.persistent || t.fadeOut() }) } setupTriggerEvents(t) { const e = Vb(t); e && e !== this._triggerElement && (this._removeTriggerEvents(), this._triggerElement = e, this._registerEvents(dS)) } handleEvent(t) { "mousedown" === t.type ? this._onMousedown(t) : "touchstart" === t.type ? this._onTouchStart(t) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._registerEvents(pS), this._pointerUpEventsRegistered = !0) } _onMousedown(t) { const e = Ow(t), n = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; this._target.rippleDisabled || e || n || (this._isPointerDown = !0, this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig)) } _onTouchStart(t) { if (!this._target.rippleDisabled && !Fw(t)) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const e = t.changedTouches; for (let t = 0; t < e.length; t++)this.fadeInRipple(e[t].clientX, e[t].clientY, this._target.rippleConfig) } } _onPointerUp() { this._isPointerDown && (this._isPointerDown = !1, this._activeRipples.forEach(t => { !t.config.persistent && (1 === t.state || t.config.terminateOnPointerUp && 0 === t.state) && t.fadeOut() })) } _runTimeoutOutsideZone(t, e = 0) { this._ngZone.runOutsideAngular(() => setTimeout(t, e)) } _registerEvents(t) { this._ngZone.runOutsideAngular(() => { t.forEach(t => { this._triggerElement.addEventListener(t, this, hS) }) }) } _removeTriggerEvents() { this._triggerElement && (dS.forEach(t => { this._triggerElement.removeEventListener(t, this, hS) }), this._pointerUpEventsRegistered && pS.forEach(t => { this._triggerElement.removeEventListener(t, this, hS) })) } } const mS = new Kn("mat-ripple-global-options"); let gS = (() => { class t { constructor(t, e, n, r, i) { this._elementRef = t, this._animationMode = i, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = r || {}, this._rippleRenderer = new fS(this, e, t, n) } get disabled() { return this._disabled } set disabled(t) { t && this.fadeOutAllNonPersistent(), this._disabled = t, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(t) { this._trigger = t, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } fadeOutAllNonPersistent() { this._rippleRenderer.fadeOutAllNonPersistent() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: Object.assign(Object.assign(Object.assign({}, this._globalOptions.animation), "NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}), this.animation), terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(t, e = 0, n) { return "number" == typeof t ? this._rippleRenderer.fadeInRipple(t, e, Object.assign(Object.assign({}, this.rippleConfig), n)) : this._rippleRenderer.fadeInRipple(0, 0, Object.assign(Object.assign({}, this.rippleConfig), t)) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(Vc), Do(p_), Do(mS, 8), Do(qm, 8)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function (t, e) { 2 & t && aa("mat-ripple-unbounded", e.unbounded) }, inputs: { radius: ["matRippleRadius", "radius"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"], color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], animation: ["matRippleAnimation", "animation"] }, exportAs: ["matRipple"] }), t })(), vS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[nS, f_], nS] }), t })(), yS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[nS]] }), t })(), bS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[vS, mh, nS, yS]] }), t })(); function _S(t, e) { } class wS { constructor() { this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.maxWidth = "80vw", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.autoFocus = !0, this.restoreFocus = !0, this.closeOnNavigation = !0 } } const SS = { dialogContainer: pp("dialogContainer", [vp("void, exit", gp({ opacity: 0, transform: "scale(0.7)" })), vp("enter", gp({ transform: "none" })), yp("* => enter", fp("150ms cubic-bezier(0, 0, 0.2, 1)", gp({ transform: "none", opacity: 1 }))), yp("* => void, * => exit", fp("75ms cubic-bezier(0.4, 0.0, 0.2, 1)", gp({ opacity: 0 })))]) }; let xS = (() => { class t extends O_ { constructor(t, e, n, r, i, s) { super(), this._elementRef = t, this._focusTrapFactory = e, this._changeDetectorRef = n, this._config = i, this._focusMonitor = s, this._animationStateChanged = new ec, this._elementFocusedBeforeDialogWasOpened = null, this._closeInteractionType = null, this.attachDomPortal = t => (this._portalOutlet.hasAttached(), this._portalOutlet.attachDomPortal(t)), this._ariaLabelledBy = i.ariaLabelledBy || null, this._document = r } _initializeWithAttachedContent() { this._setupFocusTrap(), this._capturePreviouslyFocusedElement(), this._focusDialogContainer() } attachComponentPortal(t) { return this._portalOutlet.hasAttached(), this._portalOutlet.attachComponentPortal(t) } attachTemplatePortal(t) { return this._portalOutlet.hasAttached(), this._portalOutlet.attachTemplatePortal(t) } _recaptureFocus() { this._containsFocus() || (!this._config.autoFocus || !this._focusTrap.focusInitialElement()) && this._elementRef.nativeElement.focus() } _trapFocus() { this._config.autoFocus ? this._focusTrap.focusInitialElementWhenReady() : this._containsFocus() || this._elementRef.nativeElement.focus() } _restoreFocus() { const t = this._elementFocusedBeforeDialogWasOpened; if (this._config.restoreFocus && t && "function" == typeof t.focus) { const e = S_(), n = this._elementRef.nativeElement; e && e !== this._document.body && e !== n && !n.contains(e) || (this._focusMonitor ? (this._focusMonitor.focusVia(t, this._closeInteractionType), this._closeInteractionType = null) : t.focus()) } this._focusTrap && this._focusTrap.destroy() } _setupFocusTrap() { this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement) } _capturePreviouslyFocusedElement() { this._document && (this._elementFocusedBeforeDialogWasOpened = S_()) } _focusDialogContainer() { this._elementRef.nativeElement.focus && this._elementRef.nativeElement.focus() } _containsFocus() { const t = this._elementRef.nativeElement, e = S_(); return t === e || t.contains(e) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(Iw), Do(bl), Do(wu, 8), Do(wS), Do(Ww)) }, t.\u0275dir = Yt({ type: t, viewQuery: function (t, e) { if (1 & t && fc(N_, 7), 2 & t) { let t; pc(t = gc()) && (e._portalOutlet = t.first) } }, features: [vo] }), t })(), TS = (() => { class t extends xS { constructor() { super(...arguments), this._state = "enter" } _onAnimationDone({ toState: t, totalTime: e }) { "enter" === t ? (this._trapFocus(), this._animationStateChanged.next({ state: "opened", totalTime: e })) : "exit" === t && (this._restoreFocus(), this._animationStateChanged.next({ state: "closed", totalTime: e })) } _onAnimationStart({ toState: t, totalTime: e }) { "enter" === t ? this._animationStateChanged.next({ state: "opening", totalTime: e }) : "exit" !== t && "void" !== t || this._animationStateChanged.next({ state: "closing", totalTime: e }) } _startExitAnimation() { this._state = "exit", this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = Jn(t)))(n || t) } }(), t.\u0275cmp = Jt({ type: t, selectors: [["mat-dialog-container"]], hostAttrs: ["tabindex", "-1", "aria-modal", "true", 1, "mat-dialog-container"], hostVars: 6, hostBindings: function (t, e) { 1 & t && Xo("@dialogContainer.start", function (t) { return e._onAnimationStart(t) })("@dialogContainer.done", function (t) { return e._onAnimationDone(t) }), 2 & t && (Sa("id", e._id), Ro("role", e._config.role)("aria-labelledby", e._config.ariaLabel ? null : e._ariaLabelledBy)("aria-label", e._config.ariaLabel)("aria-describedby", e._config.ariaDescribedBy || null), xa("@dialogContainer", e._state)) }, features: [vo], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function (t, e) { 1 & t && Lo(0, _S, 0, 0, "ng-template", 0) }, directives: [N_], styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"], encapsulation: 2, data: { animation: [SS.dialogContainer] } }), t })(), ES = 0; class MS { constructor(t, e, n = "mat-dialog-" + ES++) { this._overlayRef = t, this._containerInstance = e, this.id = n, this.disableClose = this._containerInstance._config.disableClose, this._afterOpened = new M, this._afterClosed = new M, this._beforeClosed = new M, this._state = 0, e._id = n, e._animationStateChanged.pipe(od(t => "opened" === t.state), hg(1)).subscribe(() => { this._afterOpened.next(), this._afterOpened.complete() }), e._animationStateChanged.pipe(od(t => "closed" === t.state), hg(1)).subscribe(() => { clearTimeout(this._closeFallbackTimeout), this._finishDialogClose() }), t.detachments().subscribe(() => { this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._afterClosed.next(this._result), this._afterClosed.complete(), this.componentInstance = null, this._overlayRef.dispose() }), t.keydownEvents().pipe(od(t => 27 === t.keyCode && !this.disableClose && !H_(t))).subscribe(t => { t.preventDefault(), AS(this, "keyboard") }), t.backdropClick().subscribe(() => { this.disableClose ? this._containerInstance._recaptureFocus() : AS(this, "mouse") }) } close(t) { this._result = t, this._containerInstance._animationStateChanged.pipe(od(t => "closing" === t.state), hg(1)).subscribe(e => { this._beforeClosed.next(t), this._beforeClosed.complete(), this._overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), e.totalTime + 100) }), this._state = 1, this._containerInstance._startExitAnimation() } afterOpened() { return this._afterOpened } afterClosed() { return this._afterClosed } beforeClosed() { return this._beforeClosed } backdropClick() { return this._overlayRef.backdropClick() } keydownEvents() { return this._overlayRef.keydownEvents() } updatePosition(t) { let e = this._getPositionStrategy(); return t && (t.left || t.right) ? t.left ? e.left(t.left) : e.right(t.right) : e.centerHorizontally(), t && (t.top || t.bottom) ? t.top ? e.top(t.top) : e.bottom(t.bottom) : e.centerVertically(), this._overlayRef.updatePosition(), this } updateSize(t = "", e = "") { return this._overlayRef.updateSize({ width: t, height: e }), this._overlayRef.updatePosition(), this } addPanelClass(t) { return this._overlayRef.addPanelClass(t), this } removePanelClass(t) { return this._overlayRef.removePanelClass(t), this } getState() { return this._state } _finishDialogClose() { this._state = 2, this._overlayRef.dispose() } _getPositionStrategy() { return this._overlayRef.getConfig().positionStrategy } } function AS(t, e, n) { return void 0 !== t._containerInstance && (t._containerInstance._closeInteractionType = e), t.close(n) } const CS = new Kn("MatDialogData"), PS = new Kn("mat-dialog-default-options"), RS = new Kn("mat-dialog-scroll-strategy"), LS = { provide: RS, deps: [mw], useFactory: function (t) { return () => t.scrollStrategies.block() } }; let kS = (() => { class t { constructor(t, e, n, r, i, s, o, a, l) { this._overlay = t, this._injector = e, this._defaultOptions = n, this._parentDialog = r, this._overlayContainer = i, this._dialogRefConstructor = o, this._dialogContainerType = a, this._dialogDataToken = l, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new M, this._afterOpenedAtThisLevel = new M, this._ariaHiddenElements = new Map, this.afterAllClosed = cg(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(fg(void 0))), this._scrollStrategy = s } get openDialogs() { return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel } get afterOpened() { return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel } _getAfterAllClosed() { const t = this._parentDialog; return t ? t._getAfterAllClosed() : this._afterAllClosedAtThisLevel } open(t, e) { (e = function (t, e) { return Object.assign(Object.assign({}, e), t) }(e, this._defaultOptions || new wS)).id && this.getDialogById(e.id); const n = this._createOverlay(e), r = this._attachDialogContainer(n, e), i = this._attachDialogContent(t, r, n, e); return this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push(i), i.afterClosed().subscribe(() => this._removeOpenDialog(i)), this.afterOpened.next(i), r._initializeWithAttachedContent(), i } closeAll() { this._closeDialogs(this.openDialogs) } getDialogById(t) { return this.openDialogs.find(e => e.id === t) } ngOnDestroy() { this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete() } _createOverlay(t) { const e = this._getOverlayConfig(t); return this._overlay.create(e) } _getOverlayConfig(t) { const e = new q_({ positionStrategy: this._overlay.position().global(), scrollStrategy: t.scrollStrategy || this._scrollStrategy(), panelClass: t.panelClass, hasBackdrop: t.hasBackdrop, direction: t.direction, minWidth: t.minWidth, minHeight: t.minHeight, maxWidth: t.maxWidth, maxHeight: t.maxHeight, disposeOnNavigation: t.closeOnNavigation }); return t.backdropClass && (e.backdropClass = t.backdropClass), e } _attachDialogContainer(t, e) { const n = mo.create({ parent: e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, providers: [{ provide: wS, useValue: e }] }), r = new k_(this._dialogContainerType, e.viewContainerRef, n, e.componentFactoryResolver); return t.attach(r).instance } _attachDialogContent(t, e, n, r) { const i = new this._dialogRefConstructor(n, e, r.id); if (t instanceof Tl) e.attachTemplatePortal(new D_(t, null, { $implicit: r.data, dialogRef: i })); else { const n = this._createInjector(r, i, e), s = e.attachComponentPortal(new k_(t, r.viewContainerRef, n)); i.componentInstance = s.instance } return i.updateSize(r.width, r.height).updatePosition(r.position), i } _createInjector(t, e, n) { const r = t && t.viewContainerRef && t.viewContainerRef.injector, i = [{ provide: this._dialogContainerType, useValue: n }, { provide: this._dialogDataToken, useValue: t.data }, { provide: this._dialogRefConstructor, useValue: e }]; return !t.direction || r && r.get(T_, null, xt.Optional) || i.push({ provide: T_, useValue: { value: t.direction, change: id() } }), mo.create({ parent: r || this._injector, providers: i }) } _removeOpenDialog(t) { const e = this.openDialogs.indexOf(t); e > -1 && (this.openDialogs.splice(e, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((t, e) => { t ? e.setAttribute("aria-hidden", t) : e.removeAttribute("aria-hidden") }), this._ariaHiddenElements.clear(), this._getAfterAllClosed().next())) } _hideNonDialogContentFromAssistiveTechnology() { const t = this._overlayContainer.getContainerElement(); if (t.parentElement) { const e = t.parentElement.children; for (let n = e.length - 1; n > -1; n--) { let r = e[n]; r === t || "SCRIPT" === r.nodeName || "STYLE" === r.nodeName || r.hasAttribute("aria-live") || (this._ariaHiddenElements.set(r, r.getAttribute("aria-hidden")), r.setAttribute("aria-hidden", "true")) } } } _closeDialogs(t) { let e = t.length; for (; e--;)t[e].close() } } return t.\u0275fac = function (e) { return new (e || t)(Do(mw), Do(mo), Do(void 0), Do(void 0), Do(nw), Do(void 0), Do(Qn), Do(Qn), Do(Kn)) }, t.\u0275dir = Yt({ type: t }), t })(), DS = (() => { class t extends kS { constructor(t, e, n, r, i, s, o) { super(t, e, r, s, o, i, MS, TS, CS) } } return t.\u0275fac = function (e) { return new (e || t)(fr(mw), fr(mo), fr(Fu, 8), fr(PS, 8), fr(RS), fr(t, 12), fr(nw)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), IS = (() => { class t { constructor(t, e, n) { this.dialogRef = t, this._elementRef = e, this._dialog = n, this.type = "button" } ngOnInit() { this.dialogRef || (this.dialogRef = function (t, e) { let n = t.nativeElement.parentElement; for (; n && !n.classList.contains("mat-dialog-container");)n = n.parentElement; return n ? e.find(t => t.id === n.id) : null }(this._elementRef, this._dialog.openDialogs)) } ngOnChanges(t) { const e = t._matDialogClose || t._matDialogCloseResult; e && (this.dialogResult = e.currentValue) } _onButtonClick(t) { AS(this.dialogRef, 0 === t.screenX && 0 === t.screenY ? "keyboard" : "mouse", this.dialogResult) } } return t.\u0275fac = function (e) { return new (e || t)(Do(MS, 8), Do(Wa), Do(DS)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "mat-dialog-close", ""], ["", "matDialogClose", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && Jo("click", function (t) { return e._onButtonClick(t) }), 2 & t && Ro("aria-label", e.ariaLabel || null)("type", e.type) }, inputs: { type: "type", dialogResult: ["mat-dialog-close", "dialogResult"], ariaLabel: ["aria-label", "ariaLabel"], _matDialogClose: ["matDialogClose", "_matDialogClose"] }, exportAs: ["matDialogClose"], features: [he] }), t })(), OS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["", "mat-dialog-content", ""], ["mat-dialog-content"], ["", "matDialogContent", ""]], hostAttrs: [1, "mat-dialog-content"] }), t })(), FS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["", "mat-dialog-actions", ""], ["mat-dialog-actions"], ["", "matDialogActions", ""]], hostAttrs: [1, "mat-dialog-actions"] }), t })(), NS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [DS, LS], imports: [[vw, B_, nS], nS] }), t })(); const BS = ["underline"], HS = ["connectionContainer"], US = ["inputContainer"], GS = ["label"]; function VS(t, e) { 1 & t && (Ho(0), Fo(1, "div", 14), Bo(2, "div", 15), Bo(3, "div", 16), Bo(4, "div", 17), No(), Fo(5, "div", 18), Bo(6, "div", 15), Bo(7, "div", 16), Bo(8, "div", 17), No(), Uo()) } function zS(t, e) { 1 & t && (Fo(0, "div", 19), $o(1, 1), No()) } function jS(t, e) { if (1 & t && (Ho(0), $o(1, 2), Fo(2, "span"), ya(3), No(), Uo()), 2 & t) { const t = Ko(2); ns(3), ba(t._control.placeholder) } } function JS(t, e) { 1 & t && $o(0, 3, ["*ngSwitchCase", "true"]) } function XS(t, e) { 1 & t && (Fo(0, "span", 23), ya(1, " *"), No()) } function WS(t, e) { if (1 & t) { const t = Go(); Fo(0, "label", 20, 21), Jo("cdkObserveContent", function () { return Oe(t), Ko().updateOutlineGap() }), Lo(2, jS, 4, 1, "ng-container", 12), Lo(3, JS, 1, 0, "ng-content", 12), Lo(4, XS, 2, 0, "span", 22), No() } if (2 & t) { const t = Ko(); aa("mat-empty", t._control.empty && !t._shouldAlwaysFloat())("mat-form-field-empty", t._control.empty && !t._shouldAlwaysFloat())("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color), Io("cdkObserveContentDisabled", "outline" != t.appearance)("id", t._labelId)("ngSwitch", t._hasLabel()), Ro("for", t._control.id)("aria-owns", t._control.id), ns(2), Io("ngSwitchCase", !1), ns(1), Io("ngSwitchCase", !0), ns(1), Io("ngIf", !t.hideRequiredMarker && t._control.required && !t._control.disabled) } } function qS(t, e) { 1 & t && (Fo(0, "div", 24), $o(1, 4), No()) } function ZS(t, e) { if (1 & t && (Fo(0, "div", 25, 26), Bo(2, "span", 27), No()), 2 & t) { const t = Ko(); ns(2), aa("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color) } } function KS(t, e) { 1 & t && (Fo(0, "div"), $o(1, 5), No()), 2 & t && Io("@transitionMessages", Ko()._subscriptAnimationState) } function YS(t, e) { if (1 & t && (Fo(0, "div", 31), ya(1), No()), 2 & t) { const t = Ko(2); Io("id", t._hintLabelId), ns(1), ba(t.hintLabel) } } function QS(t, e) { if (1 & t && (Fo(0, "div", 28), Lo(1, YS, 2, 2, "div", 29), $o(2, 6), Bo(3, "div", 30), $o(4, 7), No()), 2 & t) { const t = Ko(); Io("@transitionMessages", t._subscriptAnimationState), ns(1), Io("ngIf", t.hintLabel) } } const $S = ["*", [["", "matPrefix", ""]], [["mat-placeholder"]], [["mat-label"]], [["", "matSuffix", ""]], [["mat-error"]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]], tx = ["*", "[matPrefix]", "mat-placeholder", "mat-label", "[matSuffix]", "mat-error", "mat-hint:not([align='end'])", "mat-hint[align='end']"], ex = new Kn("MatError"), nx = { transitionMessages: pp("transitionMessages", [vp("enter", gp({ opacity: 1, transform: "translateY(0%)" })), yp("void => enter", [gp({ opacity: 0, transform: "translateY(-5px)" }), fp("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }; let rx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t }), t })(); const ix = new Kn("MatHint"); let sx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["mat-label"]] }), t })(), ox = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["mat-placeholder"]] }), t })(); const ax = new Kn("MatPrefix"), lx = new Kn("MatSuffix"); let cx = 0; const ux = iS(class { constructor(t) { this._elementRef = t } }, "primary"), hx = new Kn("MAT_FORM_FIELD_DEFAULT_OPTIONS"), dx = new Kn("MatFormField"); let px = (() => { class t extends ux { constructor(t, e, n, r, i, s, o, a) { super(t), this._changeDetectorRef = e, this._dir = r, this._defaults = i, this._platform = s, this._ngZone = o, this._outlineGapCalculationNeededImmediately = !1, this._outlineGapCalculationNeededOnStable = !1, this._destroyed = new M, this._showAlwaysAnimate = !1, this._subscriptAnimationState = "", this._hintLabel = "", this._hintLabelId = "mat-hint-" + cx++, this._labelId = "mat-form-field-label-" + cx++, this.floatLabel = this._getDefaultFloatLabelState(), this._animationsEnabled = "NoopAnimations" !== a, this.appearance = i && i.appearance ? i.appearance : "legacy", this._hideRequiredMarker = !(!i || null == i.hideRequiredMarker) && i.hideRequiredMarker } get appearance() { return this._appearance } set appearance(t) { const e = this._appearance; this._appearance = t || this._defaults && this._defaults.appearance || "legacy", "outline" === this._appearance && e !== t && (this._outlineGapCalculationNeededOnStable = !0) } get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(t) { this._hideRequiredMarker = Bb(t) } _shouldAlwaysFloat() { return "always" === this.floatLabel && !this._showAlwaysAnimate } _canLabelFloat() { return "never" !== this.floatLabel } get hintLabel() { return this._hintLabel } set hintLabel(t) { this._hintLabel = t, this._processHints() } get floatLabel() { return "legacy" !== this.appearance && "never" === this._floatLabel ? "auto" : this._floatLabel } set floatLabel(t) { t !== this._floatLabel && (this._floatLabel = t || this._getDefaultFloatLabelState(), this._changeDetectorRef.markForCheck()) } get _control() { return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic } set _control(t) { this._explicitFormFieldControl = t } getLabelId() { return this._hasFloatingLabel() ? this._labelId : null } getConnectedOverlayOrigin() { return this._connectionContainerRef || this._elementRef } ngAfterContentInit() { this._validateControlChild(); const t = this._control; t.controlType && this._elementRef.nativeElement.classList.add(`mat-form-field-type-${t.controlType}`), t.stateChanges.pipe(fg(null)).subscribe(() => { this._validatePlaceholders(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), t.ngControl && t.ngControl.valueChanges && t.ngControl.valueChanges.pipe(a_(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.pipe(a_(this._destroyed)).subscribe(() => { this._outlineGapCalculationNeededOnStable && this.updateOutlineGap() }) }), W(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._outlineGapCalculationNeededOnStable = !0, this._changeDetectorRef.markForCheck() }), this._hintChildren.changes.pipe(fg(null)).subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.pipe(fg(null)).subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._dir && this._dir.change.pipe(a_(this._destroyed)).subscribe(() => { "function" == typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => this.updateOutlineGap()) }) : this.updateOutlineGap() }) } ngAfterContentChecked() { this._validateControlChild(), this._outlineGapCalculationNeededImmediately && this.updateOutlineGap() } ngAfterViewInit() { this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _shouldForward(t) { const e = this._control ? this._control.ngControl : null; return e && e[t] } _hasPlaceholder() { return !!(this._control && this._control.placeholder || this._placeholderChild) } _hasLabel() { return !(!this._labelChildNonStatic && !this._labelChildStatic) } _shouldLabelFloat() { return this._canLabelFloat() && (this._control && this._control.shouldLabelFloat || this._shouldAlwaysFloat()) } _hideControlPlaceholder() { return "legacy" === this.appearance && !this._hasLabel() || this._hasLabel() && !this._shouldLabelFloat() } _hasFloatingLabel() { return this._hasLabel() || "legacy" === this.appearance && this._hasPlaceholder() } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _animateAndLockLabel() { this._hasFloatingLabel() && this._canLabelFloat() && (this._animationsEnabled && this._label && (this._showAlwaysAnimate = !0, zb(this._label.nativeElement, "transitionend").pipe(hg(1)).subscribe(() => { this._showAlwaysAnimate = !1 })), this.floatLabel = "always", this._changeDetectorRef.markForCheck()) } _validatePlaceholders() { } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { } _getDefaultFloatLabelState() { return this._defaults && this._defaults.floatLabel || "auto" } _syncDescribedByIds() { if (this._control) { let t = []; if (this._control.userAriaDescribedBy && "string" == typeof this._control.userAriaDescribedBy && t.push(...this._control.userAriaDescribedBy.split(" ")), "hint" === this._getDisplayedMessages()) { const e = this._hintChildren ? this._hintChildren.find(t => "start" === t.align) : null, n = this._hintChildren ? this._hintChildren.find(t => "end" === t.align) : null; e ? t.push(e.id) : this._hintLabel && t.push(this._hintLabelId), n && t.push(n.id) } else this._errorChildren && t.push(...this._errorChildren.map(t => t.id)); this._control.setDescribedByIds(t) } } _validateControlChild() { } updateOutlineGap() { const t = this._label ? this._label.nativeElement : null; if ("outline" !== this.appearance || !t || !t.children.length || !t.textContent.trim()) return; if (!this._platform.isBrowser) return; if (!this._isAttachedToDOM()) return void (this._outlineGapCalculationNeededImmediately = !0); let e = 0, n = 0; const r = this._connectionContainerRef.nativeElement, i = r.querySelectorAll(".mat-form-field-outline-start"), s = r.querySelectorAll(".mat-form-field-outline-gap"); if (this._label && this._label.nativeElement.children.length) { const i = r.getBoundingClientRect(); if (0 === i.width && 0 === i.height) return this._outlineGapCalculationNeededOnStable = !0, void (this._outlineGapCalculationNeededImmediately = !1); const s = this._getStartEnd(i), o = t.children, a = this._getStartEnd(o[0].getBoundingClientRect()); let l = 0; for (let t = 0; t < o.length; t++)l += o[t].offsetWidth; e = Math.abs(a - s) - 5, n = l > 0 ? .75 * l + 10 : 0 } for (let o = 0; o < i.length; o++)i[o].style.width = `${e}px`; for (let o = 0; o < s.length; o++)s[o].style.width = `${n}px`; this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1 } _getStartEnd(t) { return this._dir && "rtl" === this._dir.value ? t.right : t.left } _isAttachedToDOM() { const t = this._elementRef.nativeElement; if (t.getRootNode) { const e = t.getRootNode(); return e && e !== t } return document.documentElement.contains(t) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(bl), Do(Wa), Do(T_, 8), Do(hx, 8), Do(p_), Do(Vc), Do(qm, 8)) }, t.\u0275cmp = Jt({ type: t, selectors: [["mat-form-field"]], contentQueries: function (t, e, n) { if (1 & t && (mc(n, rx, 5), mc(n, rx, 7), mc(n, sx, 5), mc(n, sx, 7), mc(n, ox, 5), mc(n, ex, 5), mc(n, ix, 5), mc(n, ax, 5), mc(n, lx, 5)), 2 & t) { let t; pc(t = gc()) && (e._controlNonStatic = t.first), pc(t = gc()) && (e._controlStatic = t.first), pc(t = gc()) && (e._labelChildNonStatic = t.first), pc(t = gc()) && (e._labelChildStatic = t.first), pc(t = gc()) && (e._placeholderChild = t.first), pc(t = gc()) && (e._errorChildren = t), pc(t = gc()) && (e._hintChildren = t), pc(t = gc()) && (e._prefixChildren = t), pc(t = gc()) && (e._suffixChildren = t) } }, viewQuery: function (t, e) { if (1 & t && (fc(BS, 5), fc(HS, 7), fc(US, 5), fc(GS, 5)), 2 & t) { let t; pc(t = gc()) && (e.underlineRef = t.first), pc(t = gc()) && (e._connectionContainerRef = t.first), pc(t = gc()) && (e._inputContainerRef = t.first), pc(t = gc()) && (e._label = t.first) } }, hostAttrs: [1, "mat-form-field"], hostVars: 40, hostBindings: function (t, e) { 2 & t && aa("mat-form-field-appearance-standard", "standard" == e.appearance)("mat-form-field-appearance-fill", "fill" == e.appearance)("mat-form-field-appearance-outline", "outline" == e.appearance)("mat-form-field-appearance-legacy", "legacy" == e.appearance)("mat-form-field-invalid", e._control.errorState)("mat-form-field-can-float", e._canLabelFloat())("mat-form-field-should-float", e._shouldLabelFloat())("mat-form-field-has-label", e._hasFloatingLabel())("mat-form-field-hide-placeholder", e._hideControlPlaceholder())("mat-form-field-disabled", e._control.disabled)("mat-form-field-autofilled", e._control.autofilled)("mat-focused", e._control.focused)("ng-untouched", e._shouldForward("untouched"))("ng-touched", e._shouldForward("touched"))("ng-pristine", e._shouldForward("pristine"))("ng-dirty", e._shouldForward("dirty"))("ng-valid", e._shouldForward("valid"))("ng-invalid", e._shouldForward("invalid"))("ng-pending", e._shouldForward("pending"))("_mat-animation-noopable", !e._animationsEnabled) }, inputs: { color: "color", floatLabel: "floatLabel", appearance: "appearance", hideRequiredMarker: "hideRequiredMarker", hintLabel: "hintLabel" }, exportAs: ["matFormField"], features: [Ua([{ provide: dx, useExisting: t }]), vo], ngContentSelectors: tx, decls: 15, vars: 8, consts: [[1, "mat-form-field-wrapper"], [1, "mat-form-field-flex", 3, "click"], ["connectionContainer", ""], [4, "ngIf"], ["class", "mat-form-field-prefix", 4, "ngIf"], [1, "mat-form-field-infix"], ["inputContainer", ""], [1, "mat-form-field-label-wrapper"], ["class", "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "mat-empty", "mat-form-field-empty", "mat-accent", "mat-warn", "ngSwitch", "cdkObserveContent", 4, "ngIf"], ["class", "mat-form-field-suffix", 4, "ngIf"], ["class", "mat-form-field-underline", 4, "ngIf"], [1, "mat-form-field-subscript-wrapper", 3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "mat-form-field-hint-wrapper", 4, "ngSwitchCase"], [1, "mat-form-field-outline"], [1, "mat-form-field-outline-start"], [1, "mat-form-field-outline-gap"], [1, "mat-form-field-outline-end"], [1, "mat-form-field-outline", "mat-form-field-outline-thick"], [1, "mat-form-field-prefix"], [1, "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "ngSwitch", "cdkObserveContent"], ["label", ""], ["class", "mat-placeholder-required mat-form-field-required-marker", "aria-hidden", "true", 4, "ngIf"], ["aria-hidden", "true", 1, "mat-placeholder-required", "mat-form-field-required-marker"], [1, "mat-form-field-suffix"], [1, "mat-form-field-underline"], ["underline", ""], [1, "mat-form-field-ripple"], [1, "mat-form-field-hint-wrapper"], ["class", "mat-hint", 3, "id", 4, "ngIf"], [1, "mat-form-field-hint-spacer"], [1, "mat-hint", 3, "id"]], template: function (t, e) { 1 & t && (Qo($S), Fo(0, "div", 0), Fo(1, "div", 1, 2), Jo("click", function (t) { return e._control.onContainerClick && e._control.onContainerClick(t) }), Lo(3, VS, 9, 0, "ng-container", 3), Lo(4, zS, 2, 0, "div", 4), Fo(5, "div", 5, 6), $o(7), Fo(8, "span", 7), Lo(9, WS, 5, 16, "label", 8), No(), No(), Lo(10, qS, 2, 0, "div", 9), No(), Lo(11, ZS, 3, 4, "div", 10), Fo(12, "div", 11), Lo(13, KS, 2, 1, "div", 12), Lo(14, QS, 5, 2, "div", 13), No(), No()), 2 & t && (ns(3), Io("ngIf", "outline" == e.appearance), ns(1), Io("ngIf", e._prefixChildren.length), ns(5), Io("ngIf", e._hasFloatingLabel()), ns(1), Io("ngIf", e._suffixChildren.length), ns(1), Io("ngIf", "outline" != e.appearance), ns(1), Io("ngSwitch", e._getDisplayedMessages()), ns(1), Io("ngSwitchCase", "error"), ns(1), Io("ngSwitchCase", "hint")) }, directives: [th, ih, sh, Aw], styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n", '.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n', '.mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{opacity:0}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n', ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n"], encapsulation: 2, data: { animation: [nx.transitionMessages] }, changeDetection: 0 }), t })(), fx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[mh, nS, Cw], nS] }), t })(); function mx(...t) { if (1 === t.length) { const e = t[0]; if (c(e)) return gx(e, null); if (u(e) && Object.getPrototypeOf(e) === Object.prototype) { const t = Object.keys(e); return gx(t.map(t => e[t]), t) } } if ("function" == typeof t[t.length - 1]) { const e = t.pop(); return gx(t = 1 === t.length && c(t[0]) ? t[0] : t, null).pipe(P(t => e(...t))) } return gx(t, null) } function gx(t, e) { return new w(n => { const r = t.length; if (0 === r) return void n.complete(); const i = new Array(r); let s = 0, o = 0; for (let a = 0; a < r; a++) { const l = B(t[a]); let c = !1; n.add(l.subscribe({ next: t => { c || (c = !0, o++), i[a] = t }, error: t => n.error(t), complete: () => { s++, s !== r && c || (o === r && n.next(e ? e.reduce((t, e, n) => (t[e] = i[n], t), {}) : i), n.complete()) } })) } }) } let vx = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } setProperty(t, e) { this._renderer.setProperty(this._elementRef.nativeElement, t, e) } registerOnTouched(t) { this.onTouched = t } registerOnChange(t) { this.onChange = t } setDisabledState(t) { this.setProperty("disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ka), Do(Wa)) }, t.\u0275dir = Yt({ type: t }), t })(), yx = (() => { class t extends vx { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = Jn(t)))(n || t) } }(), t.\u0275dir = Yt({ type: t, features: [vo] }), t })(); const bx = new Kn("NgValueAccessor"), _x = { provide: bx, useExisting: at(() => Sx), multi: !0 }, wx = new Kn("CompositionEventMode"); let Sx = (() => { class t extends vx { constructor(t, e, n) { super(t, e), this._compositionMode = n, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const t = _u() ? _u().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(t) { this.setProperty("value", null == t ? "" : t) } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ka), Do(Wa), Do(wx, 8)) }, t.\u0275dir = Yt({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (t, e) { 1 & t && Jo("input", function (t) { return e._handleInput(t.target.value) })("blur", function () { return e.onTouched() })("compositionstart", function () { return e._compositionStart() })("compositionend", function (t) { return e._compositionEnd(t.target.value) }) }, features: [Ua([_x]), vo] }), t })(); function xx(t) { return null == t || 0 === t.length } function Tx(t) { return null != t && "number" == typeof t.length } const Ex = new Kn("NgValidators"), Mx = new Kn("NgAsyncValidators"), Ax = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class Cx { static min(t) { return Px(t) } static max(t) { return Rx(t) } static required(t) { return function (t) { return xx(t.value) ? { required: !0 } : null }(t) } static requiredTrue(t) { return function (t) { return !0 === t.value ? null : { required: !0 } }(t) } static email(t) { return function (t) { return xx(t.value) || Ax.test(t.value) ? null : { email: !0 } }(t) } static minLength(t) { return function (t) { return e => xx(e.value) || !Tx(e.value) ? null : e.value.length < t ? { minlength: { requiredLength: t, actualLength: e.value.length } } : null }(t) } static maxLength(t) { return function (t) { return e => Tx(e.value) && e.value.length > t ? { maxlength: { requiredLength: t, actualLength: e.value.length } } : null }(t) } static pattern(t) { return function (t) { if (!t) return Lx; let e, n; return "string" == typeof t ? (n = "", "^" !== t.charAt(0) && (n += "^"), n += t, "$" !== t.charAt(t.length - 1) && (n += "$"), e = new RegExp(n)) : (n = t.toString(), e = t), t => { if (xx(t.value)) return null; const r = t.value; return e.test(r) ? null : { pattern: { requiredPattern: n, actualValue: r } } } }(t) } static nullValidator(t) { return null } static compose(t) { return Nx(t) } static composeAsync(t) { return Hx(t) } } function Px(t) { return e => { if (xx(e.value) || xx(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n < t ? { min: { min: t, actual: e.value } } : null } } function Rx(t) { return e => { if (xx(e.value) || xx(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n > t ? { max: { max: t, actual: e.value } } : null } } function Lx(t) { return null } function kx(t) { return null != t } function Dx(t) { const e = Vo(t) ? B(t) : t; return jo(e), e } function Ix(t) { let e = {}; return t.forEach(t => { e = null != t ? Object.assign(Object.assign({}, e), t) : e }), 0 === Object.keys(e).length ? null : e } function Ox(t, e) { return e.map(e => e(t)) } function Fx(t) { return t.map(t => function (t) { return !t.validate }(t) ? t : e => t.validate(e)) } function Nx(t) { if (!t) return null; const e = t.filter(kx); return 0 == e.length ? null : function (t) { return Ix(Ox(t, e)) } } function Bx(t) { return null != t ? Nx(Fx(t)) : null } function Hx(t) { if (!t) return null; const e = t.filter(kx); return 0 == e.length ? null : function (t) { return mx(Ox(t, e).map(Dx)).pipe(P(Ix)) } } function Ux(t) { return null != t ? Hx(Fx(t)) : null } function Gx(t, e) { return null === t ? [e] : Array.isArray(t) ? [...t, e] : [t, e] } function Vx(t) { return t._rawValidators } function zx(t) { return t._rawAsyncValidators } let jx = (() => { class t { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = Bx(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = Ux(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t }), t })(), Jx = (() => { class t extends jx { get formDirective() { return null } get path() { return null } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = Jn(t)))(n || t) } }(), t.\u0275dir = Yt({ type: t, features: [vo] }), t })(); class Xx extends jx { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class Wx { constructor(t) { this._cd = t } is(t) { var e, n, r; return "submitted" === t ? !!(null === (e = this._cd) || void 0 === e ? void 0 : e.submitted) : !!(null === (r = null === (n = this._cd) || void 0 === n ? void 0 : n.control) || void 0 === r ? void 0 : r[t]) } } let qx = (() => { class t extends Wx { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Xx, 2)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && aa("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending")) }, features: [vo] }), t })(), Zx = (() => { class t extends Wx { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Jx, 10)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (t, e) { 2 & t && aa("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending"))("ng-submitted", e.is("submitted")) }, features: [vo] }), t })(); function Kx(t, e) { $x(t, e), e.valueAccessor.writeValue(t.value), function (t, e) { e.valueAccessor.registerOnChange(n => { t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && eT(t, e) }) }(t, e), function (t, e) { const n = (t, n) => { e.valueAccessor.writeValue(t), n && e.viewToModelUpdate(t) }; t.registerOnChange(n), e._registerOnDestroy(() => { t._unregisterOnChange(n) }) }(t, e), function (t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && eT(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), function (t, e) { if (e.valueAccessor.setDisabledState) { const n = t => { e.valueAccessor.setDisabledState(t) }; t.registerOnDisabledChange(n), e._registerOnDestroy(() => { t._unregisterOnDisabledChange(n) }) } }(t, e) } function Yx(t, e, n = !0) { const r = () => { }; e.valueAccessor && (e.valueAccessor.registerOnChange(r), e.valueAccessor.registerOnTouched(r)), tT(t, e), t && (e._invokeOnDestroyCallbacks(), t._registerOnCollectionChange(() => { })) } function Qx(t, e) { t.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(e) }) } function $x(t, e) { const n = Vx(t); null !== e.validator ? t.setValidators(Gx(n, e.validator)) : "function" == typeof n && t.setValidators([n]); const r = zx(t); null !== e.asyncValidator ? t.setAsyncValidators(Gx(r, e.asyncValidator)) : "function" == typeof r && t.setAsyncValidators([r]); const i = () => t.updateValueAndValidity(); Qx(e._rawValidators, i), Qx(e._rawAsyncValidators, i) } function tT(t, e) { let n = !1; if (null !== t) { if (null !== e.validator) { const r = Vx(t); if (Array.isArray(r) && r.length > 0) { const i = r.filter(t => t !== e.validator); i.length !== r.length && (n = !0, t.setValidators(i)) } } if (null !== e.asyncValidator) { const r = zx(t); if (Array.isArray(r) && r.length > 0) { const i = r.filter(t => t !== e.asyncValidator); i.length !== r.length && (n = !0, t.setAsyncValidators(i)) } } } const r = () => { }; return Qx(e._rawValidators, r), Qx(e._rawAsyncValidators, r), n } function eT(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function nT(t, e) { $x(t, e) } function rT(t, e) { t._syncPendingControls(), e.forEach(t => { const e = t.control; "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1) }) } function iT(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } const sT = "VALID", oT = "INVALID", aT = "PENDING", lT = "DISABLED"; function cT(t) { return (pT(t) ? t.validators : t) || null } function uT(t) { return Array.isArray(t) ? Bx(t) : t || null } function hT(t, e) { return (pT(e) ? e.asyncValidators : t) || null } function dT(t) { return Array.isArray(t) ? Ux(t) : t || null } function pT(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class fT { constructor(t, e) { this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = e, this._composedValidatorFn = uT(this._rawValidators), this._composedAsyncValidatorFn = dT(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === sT } get invalid() { return this.status === oT } get pending() { return this.status == aT } get disabled() { return this.status === lT } get enabled() { return this.status !== lT } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = uT(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = dT(t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = aT, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = lT, this.errors = null, this._forEachChild(e => { e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = sT, this._forEachChild(e => { e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), this.status !== sT && this.status !== aT || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? lT : sT } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = aT, this._hasOwnPendingAsyncValidator = !0; const e = Dx(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(e => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(e, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function (t, e, n) { if (null == e) return null; if (Array.isArray(e) || (e = e.split(".")), Array.isArray(e) && 0 === e.length) return null; let r = t; return e.forEach(t => { r = r instanceof gT ? r.controls.hasOwnProperty(t) ? r.controls[t] : null : r instanceof vT && r.at(t) || null }), r }(this, t) } getError(t, e) { const n = e ? this.get(e) : this; return n && n.errors ? n.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new ec, this.statusChanges = new ec } _calculateStatus() { return this._allControlsDisabled() ? lT : this.errors ? oT : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(aT) ? aT : this._anyControlsHaveStatus(oT) ? oT : sT } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { pT(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } } class mT extends fT { constructor(t = null, e, n) { super(cT(e), hT(n, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { iT(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { iT(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class gT extends fT { constructor(t, e, n) { super(cT(e), hT(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e, n = {}) { this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } removeControl(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } setControl(t, e, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(n => { this._throwIfControlMissing(n), this.controls[n].setValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (Object.keys(t).forEach(n => { this.controls[n] && this.controls[n].patchValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = {}, e = {}) { this._forEachChild((n, r) => { n.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, n) => (t[n] = e instanceof mT ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => { const n = this.controls[e]; n && t(n, e) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const e of Object.keys(this.controls)) { const n = this.controls[e]; if (this.contains(e) && t(n)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (t, e, n) => ((e.enabled || this.disabled) && (t[n] = e.value), t)) } _reduceChildren(t, e) { let n = t; return this._forEachChild((t, r) => { n = e(n, t, r) }), n } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control with name: '${n}'.`) }) } } class vT extends fT { constructor(t, e, n) { super(cT(e), hT(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(t) { return this.controls[t] } push(t, e = {}) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } insert(t, e, n = {}) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity({ emitEvent: n.emitEvent }) } removeAt(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity({ emitEvent: e.emitEvent }) } setControl(t, e, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((t, n) => { this._throwIfControlMissing(n), this.at(n).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (t.forEach((t, n) => { this.at(n) && this.at(n).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = [], e = {}) { this._forEachChild((n, r) => { n.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof mT ? t.value : t.getRawValue()) } clear(t = {}) { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: t.emitEvent })) } _syncPendingControls() { let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`) } _forEachChild(t) { this.controls.forEach((e, n) => { t(e, n) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control at index: ${n}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const yT = { provide: Jx, useExisting: at(() => _T) }, bT = (() => Promise.resolve(null))(); let _T = (() => { class t extends Jx { constructor(t, e) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new ec, this.form = new gT({}, Bx(t), Ux(e)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { bT.then(() => { const e = this._findContainer(t.path); t.control = e.registerControl(t.name, t.control), Kx(t.control, t), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { bT.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name), iT(this._directives, t) }) } addFormGroup(t) { bT.then(() => { const e = this._findContainer(t.path), n = new gT({}); nT(n, t), e.registerControl(t.name, n), n.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { bT.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, e) { bT.then(() => { this.form.get(t.path).setValue(e) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, rT(this.form, this._directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ex, 10), Do(Mx, 10)) }, t.\u0275dir = Yt({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (t, e) { 1 & t && Jo("submit", function (t) { return e.onSubmit(t) })("reset", function () { return e.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [Ua([yT]), vo] }), t })(), wT = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), t })(); const ST = { provide: bx, useExisting: at(() => xT), multi: !0 }; let xT = (() => { class t extends yx { writeValue(t) { this.setProperty("value", null == t ? "" : t) } registerOnChange(t) { this.onChange = e => { t("" == e ? null : parseFloat(e)) } } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = Jn(t)))(n || t) } }(), t.\u0275dir = Yt({ type: t, selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && Jo("input", function (t) { return e.onChange(t.target.value) })("blur", function () { return e.onTouched() }) }, features: [Ua([ST]), vo] }), t })(), TT = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({}), t })(); const ET = new Kn("NgModelWithFormControlWarning"), MT = { provide: Jx, useExisting: at(() => AT) }; let AT = (() => { class t extends Jx { constructor(t, e) { super(), this.validators = t, this.asyncValidators = e, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new ec, this._setValidators(t), this._setAsyncValidators(e) } ngOnChanges(t) { this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (tT(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(t) { const e = this.form.get(t.path); return Kx(e, t), e.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(t), e } getControl(t) { return this.form.get(t.path) } removeControl(t) { Yx(t.control || null, t, !1), iT(this.directives, t) } addFormGroup(t) { this._setUpFormContainer(t) } removeFormGroup(t) { this._cleanUpFormContainer(t) } getFormGroup(t) { return this.form.get(t.path) } addFormArray(t) { this._setUpFormContainer(t) } removeFormArray(t) { this._cleanUpFormContainer(t) } getFormArray(t) { return this.form.get(t.path) } updateModel(t, e) { this.form.get(t.path).setValue(e) } onSubmit(t) { return this.submitted = !0, rT(this.form, this.directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _updateDomValue() { this.directives.forEach(t => { const e = t.control, n = this.form.get(t.path); e !== n && (Yx(e || null, t), n instanceof mT && (Kx(n, t), t.control = n)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(t) { const e = this.form.get(t.path); nT(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(t) { if (this.form) { const e = this.form.get(t.path); e && function (t, e) { return tT(t, e) }(e, t) && e.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { $x(this.form, this), this._oldForm && tT(this._oldForm, this) } _checkFormPresent() { } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ex, 10), Do(Mx, 10)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "formGroup", ""]], hostBindings: function (t, e) { 1 & t && Jo("submit", function (t) { return e.onSubmit(t) })("reset", function () { return e.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [Ua([MT]), vo, he] }), t })(); const CT = { provide: Xx, useExisting: at(() => PT) }; let PT = (() => { class t extends Xx { constructor(t, e, n, r, i) { super(), this._ngModelWarningConfig = i, this._added = !1, this.update = new ec, this._ngModelWarningSent = !1, this._parent = t, this._setValidators(e), this._setAsyncValidators(n), this.valueAccessor = function (t, e) { if (!e) return null; let n, r, i; return Array.isArray(e), e.forEach(t => { t.constructor === Sx ? n = t : Object.getPrototypeOf(t.constructor) === yx ? r = t : i = t }), i || r || n || null }(0, r) } set isDisabled(t) { } ngOnChanges(t) { this._added || this._setUpControl(), function (t, e) { if (!t.hasOwnProperty("model")) return !1; const n = t.model; return !!n.isFirstChange() || !Object.is(e, n.currentValue) }(t, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } get path() { return function (t, e) { return [...e.path, t] }(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this._added = !0 } } return t.\u0275fac = function (e) { return new (e || t)(Do(Jx, 13), Do(Ex, 10), Do(Mx, 10), Do(bx, 10), Do(ET, 8)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "formControlName", ""]], inputs: { isDisabled: ["disabled", "isDisabled"], name: ["formControlName", "name"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [Ua([CT]), vo, he] }), t._ngModelWarningSentOnce = !1, t })(), RT = (() => { class t { constructor() { this._validator = Lx } handleChanges(t) { if (this.inputName in t) { const e = this.normalizeInput(t[this.inputName].currentValue); this._validator = this.createValidator(e), this._onChange && this._onChange() } } validate(t) { return this._validator(t) } registerOnValidatorChange(t) { this._onChange = t } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t }), t })(); const LT = { provide: Ex, useExisting: at(() => kT), multi: !0 }; let kT = (() => { class t extends RT { constructor() { super(...arguments), this.inputName = "max", this.normalizeInput = t => parseFloat(t), this.createValidator = t => Rx(t) } ngOnChanges(t) { this.handleChanges(t) } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = Jn(t)))(n || t) } }(), t.\u0275dir = Yt({ type: t, selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]], hostVars: 1, hostBindings: function (t, e) { if (2 & t) { let t; Ro("max", null !== (t = e.max) && void 0 !== t ? t : null) } }, inputs: { max: "max" }, features: [Ua([LT]), vo, he] }), t })(); const DT = { provide: Ex, useExisting: at(() => IT), multi: !0 }; let IT = (() => { class t extends RT { constructor() { super(...arguments), this.inputName = "min", this.normalizeInput = t => parseFloat(t), this.createValidator = t => Px(t) } ngOnChanges(t) { this.handleChanges(t) } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = Jn(t)))(n || t) } }(), t.\u0275dir = Yt({ type: t, selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]], hostVars: 1, hostBindings: function (t, e) { if (2 & t) { let t; Ro("min", null !== (t = e.min) && void 0 !== t ? t : null) } }, inputs: { min: "min" }, features: [Ua([DT]), vo, he] }), t })(), OT = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[TT]] }), t })(), FT = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [OT] }), t })(), NT = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: ET, useValue: e.warnOnNgModelWithFormControl }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [OT] }), t })(); const BT = __({ passive: !0 }); let HT = (() => { class t { constructor(t, e) { this._platform = t, this._ngZone = e, this._monitoredElements = new Map } monitor(t) { if (!this._platform.isBrowser) return Xd; const e = Vb(t), n = this._monitoredElements.get(e); if (n) return n.subject; const r = new M, i = "cdk-text-field-autofilled", s = t => { "cdk-text-field-autofill-start" !== t.animationName || e.classList.contains(i) ? "cdk-text-field-autofill-end" === t.animationName && e.classList.contains(i) && (e.classList.remove(i), this._ngZone.run(() => r.next({ target: t.target, isAutofilled: !1 }))) : (e.classList.add(i), this._ngZone.run(() => r.next({ target: t.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { e.addEventListener("animationstart", s, BT), e.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(e, { subject: r, unlisten: () => { e.removeEventListener("animationstart", s, BT) } }), r } stopMonitoring(t) { const e = Vb(t), n = this._monitoredElements.get(e); n && (n.unlisten(), n.subject.complete(), e.classList.remove("cdk-text-field-autofill-monitored"), e.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(e)) } ngOnDestroy() { this._monitoredElements.forEach((t, e) => this.stopMonitoring(e)) } } return t.\u0275fac = function (e) { return new (e || t)(fr(p_), fr(Vc)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(p_), fr(Vc)) }, token: t, providedIn: "root" }), t })(), UT = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[f_]] }), t })(); const GT = new Kn("MAT_INPUT_VALUE_ACCESSOR"), VT = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]; let zT = 0; const jT = aS(class { constructor(t, e, n, r) { this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = n, this.ngControl = r } }); let JT = (() => { class t extends jT { constructor(t, e, n, r, i, s, o, a, l, c) { super(s, r, i, n), this._elementRef = t, this._platform = e, this._autofillMonitor = a, this._formField = c, this._uid = "mat-input-" + zT++, this.focused = !1, this.stateChanges = new M, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._required = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(t => g_().has(t)); const u = this._elementRef.nativeElement, h = u.nodeName.toLowerCase(); this._inputValueAccessor = o || u, this._previousNativeValue = this.value, this.id = this.id, e.IOS && l.runOutsideAngular(() => { t.nativeElement.addEventListener("keyup", t => { const e = t.target; e.value || 0 !== e.selectionStart || 0 !== e.selectionEnd || (e.setSelectionRange(1, 1), e.setSelectionRange(0, 0)) }) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === h, this._isTextarea = "textarea" === h, this._isInFormField = !!c, this._isNativeSelect && (this.controlType = u.multiple ? "mat-native-select-multiple" : "mat-native-select") } get disabled() { return this.ngControl && null !== this.ngControl.disabled ? this.ngControl.disabled : this._disabled } set disabled(t) { this._disabled = Bb(t), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(t) { this._id = t || this._uid } get required() { return this._required } set required(t) { this._required = Bb(t) } get type() { return this._type } set type(t) { this._type = t || "text", this._validateType(), !this._isTextarea && g_().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(t) { t !== this.value && (this._inputValueAccessor.value = t, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(t) { this._readonly = Bb(t) } ngAfterViewInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(t => { this.autofilled = t.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement) } ngDoCheck() { this.ngControl && this.updateErrorState(), this._dirtyCheckNativeValue(), this._dirtyCheckPlaceholder() } focus(t) { this._elementRef.nativeElement.focus(t) } _focusChanged(t) { t === this.focused || this.readonly && t || (this.focused = t, this.stateChanges.next()) } _onInput() { } _dirtyCheckPlaceholder() { var t, e; const n = (null === (e = null === (t = this._formField) || void 0 === t ? void 0 : t._hideControlPlaceholder) || void 0 === e ? void 0 : e.call(t)) ? null : this.placeholder; if (n !== this._previousPlaceholder) { const t = this._elementRef.nativeElement; this._previousPlaceholder = n, n ? t.setAttribute("placeholder", n) : t.removeAttribute("placeholder") } } _dirtyCheckNativeValue() { const t = this._elementRef.nativeElement.value; this._previousNativeValue !== t && (this._previousNativeValue = t, this.stateChanges.next()) } _validateType() { VT.indexOf(this._type) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let t = this._elementRef.nativeElement.validity; return t && t.badInput } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const t = this._elementRef.nativeElement, e = t.options[0]; return this.focused || t.multiple || !this.empty || !!(t.selectedIndex > -1 && e && e.label) } return this.focused || !this.empty } setDescribedByIds(t) { t.length ? this._elementRef.nativeElement.setAttribute("aria-describedby", t.join(" ")) : this._elementRef.nativeElement.removeAttribute("aria-describedby") } onContainerClick() { this.focused || this.focus() } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(p_), Do(Xx, 10), Do(_T, 8), Do(AT, 8), Do(lS), Do(GT, 10), Do(HT), Do(Vc), Do(dx, 8)) }, t.\u0275dir = Yt({ type: t, selectors: [["input", "matInput", ""], ["textarea", "matInput", ""], ["select", "matNativeControl", ""], ["input", "matNativeControl", ""], ["textarea", "matNativeControl", ""]], hostAttrs: [1, "mat-input-element", "mat-form-field-autofill-control"], hostVars: 9, hostBindings: function (t, e) { 1 & t && Jo("focus", function () { return e._focusChanged(!0) })("blur", function () { return e._focusChanged(!1) })("input", function () { return e._onInput() }), 2 & t && (Sa("disabled", e.disabled)("required", e.required), Ro("id", e.id)("data-placeholder", e.placeholder)("readonly", e.readonly && !e._isNativeSelect || null)("aria-invalid", e.empty && e.required ? null : e.errorState)("aria-required", e.required), aa("mat-input-server", e._isServer)) }, inputs: { id: "id", disabled: "disabled", required: "required", type: "type", value: "value", readonly: "readonly", placeholder: "placeholder", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"] }, exportAs: ["matInput"], features: [Ua([{ provide: rx, useExisting: t }]), vo, he] }), t })(), XT = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [lS], imports: [[UT, fx, nS], UT, fx] }), t })(); const WT = ["mat-button", ""], qT = ["*"], ZT = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"], KT = iS(rS(sS(class { constructor(t) { this._elementRef = t } }))); let YT = (() => { class t extends KT { constructor(t, e, n) { super(t), this._focusMonitor = e, this._animationMode = n, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button"); for (const r of ZT) this._hasHostAttributes(r) && this._getHostElement().classList.add(r); t.nativeElement.classList.add("mat-button-base"), this.isRoundButton && (this.color = "accent") } ngAfterViewInit() { this._focusMonitor.monitor(this._elementRef, !0) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(t, e) { t ? this._focusMonitor.focusVia(this._getHostElement(), t, e) : this._getHostElement().focus(e) } _getHostElement() { return this._elementRef.nativeElement } _isRippleDisabled() { return this.disableRipple || this.disabled } _hasHostAttributes(...t) { return t.some(t => this._getHostElement().hasAttribute(t)) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(Ww), Do(qm, 8)) }, t.\u0275cmp = Jt({ type: t, selectors: [["button", "mat-button", ""], ["button", "mat-raised-button", ""], ["button", "mat-icon-button", ""], ["button", "mat-fab", ""], ["button", "mat-mini-fab", ""], ["button", "mat-stroked-button", ""], ["button", "mat-flat-button", ""]], viewQuery: function (t, e) { if (1 & t && fc(gS, 5), 2 & t) { let t; pc(t = gc()) && (e.ripple = t.first) } }, hostAttrs: [1, "mat-focus-indicator"], hostVars: 5, hostBindings: function (t, e) { 2 & t && (Ro("disabled", e.disabled || null), aa("_mat-animation-noopable", "NoopAnimations" === e._animationMode)("mat-button-disabled", e.disabled)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [vo], attrs: WT, ngContentSelectors: qT, decls: 4, vars: 5, consts: [[1, "mat-button-wrapper"], ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"], [1, "mat-button-focus-overlay"]], template: function (t, e) { 1 & t && (Qo(), Fo(0, "span", 0), $o(1), No(), Bo(2, "span", 1), Bo(3, "span", 2)), 2 & t && (ns(2), aa("mat-button-ripple-round", e.isRoundButton || e.isIconButton), Io("matRippleDisabled", e._isRippleDisabled())("matRippleCentered", e.isIconButton)("matRippleTrigger", e._getHostElement())) }, directives: [gS], styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), QT = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[vS, nS], nS] }), t })(); const $T = ["*"]; function tE(t) { return Error(`Unable to find icon with the name "${t}"`) } function eE(t) { return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`) } function nE(t) { return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`) } class rE { constructor(t, e, n) { this.url = t, this.svgText = e, this.options = n } } let iE = (() => { class t { constructor(t, e, n, r) { this._httpClient = t, this._sanitizer = e, this._errorHandler = r, this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._resolvers = [], this._defaultFontSetClass = "material-icons", this._document = n } addSvgIcon(t, e, n) { return this.addSvgIconInNamespace("", t, e, n) } addSvgIconLiteral(t, e, n) { return this.addSvgIconLiteralInNamespace("", t, e, n) } addSvgIconInNamespace(t, e, n, r) { return this._addSvgIconConfig(t, e, new rE(n, null, r)) } addSvgIconResolver(t) { return this._resolvers.push(t), this } addSvgIconLiteralInNamespace(t, e, n, r) { const i = this._sanitizer.sanitize(ri.HTML, n); if (!i) throw nE(n); return this._addSvgIconConfig(t, e, new rE("", i, r)) } addSvgIconSet(t, e) { return this.addSvgIconSetInNamespace("", t, e) } addSvgIconSetLiteral(t, e) { return this.addSvgIconSetLiteralInNamespace("", t, e) } addSvgIconSetInNamespace(t, e, n) { return this._addSvgIconSetConfig(t, new rE(e, null, n)) } addSvgIconSetLiteralInNamespace(t, e, n) { const r = this._sanitizer.sanitize(ri.HTML, e); if (!r) throw nE(e); return this._addSvgIconSetConfig(t, new rE("", r, n)) } registerFontClassAlias(t, e = t) { return this._fontCssClassesByAlias.set(t, e), this } classNameForFontAlias(t) { return this._fontCssClassesByAlias.get(t) || t } setDefaultFontSetClass(t) { return this._defaultFontSetClass = t, this } getDefaultFontSetClass() { return this._defaultFontSetClass } getSvgIconFromUrl(t) { const e = this._sanitizer.sanitize(ri.RESOURCE_URL, t); if (!e) throw eE(t); const n = this._cachedIconsByUrl.get(e); return n ? id(sE(n)) : this._loadSvgIconFromConfig(new rE(t, null)).pipe(Dg(t => this._cachedIconsByUrl.set(e, t)), P(t => sE(t))) } getNamedSvgIcon(t, e = "") { const n = oE(e, t); let r = this._svgIconConfigs.get(n); if (r) return this._getSvgFromConfig(r); if (r = this._getIconConfigFromResolvers(e, t), r) return this._svgIconConfigs.set(n, r), this._getSvgFromConfig(r); const i = this._iconSetConfigs.get(e); return i ? this._getSvgFromIconSetConfigs(t, i) : qd(tE(n)) } ngOnDestroy() { this._resolvers = [], this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear() } _getSvgFromConfig(t) { return t.svgText ? id(sE(this._svgElementFromConfig(t))) : this._loadSvgIconFromConfig(t).pipe(P(t => sE(t))) } _getSvgFromIconSetConfigs(t, e) { const n = this._extractIconWithNameFromAnySet(t, e); return n ? id(n) : mx(e.filter(t => !t.svgText).map(t => this._loadSvgIconSetFromConfig(t).pipe(yg(e => { const n = this._sanitizer.sanitize(ri.RESOURCE_URL, t.url); return this._errorHandler.handleError(new Error(`Loading icon set URL: ${n} failed: ${e.message}`)), id(null) })))).pipe(P(() => { const n = this._extractIconWithNameFromAnySet(t, e); if (!n) throw tE(t); return n })) } _extractIconWithNameFromAnySet(t, e) { for (let n = e.length - 1; n >= 0; n--) { const r = e[n]; if (r.svgText && r.svgText.indexOf(t) > -1) { const e = this._svgElementFromConfig(r), n = this._extractSvgIconFromSet(e, t, r.options); if (n) return n } } return null } _loadSvgIconFromConfig(t) { return this._fetchIcon(t).pipe(Dg(e => t.svgText = e), P(() => this._svgElementFromConfig(t))) } _loadSvgIconSetFromConfig(t) { return t.svgText ? id(null) : this._fetchIcon(t).pipe(Dg(e => t.svgText = e)) } _extractSvgIconFromSet(t, e, n) { const r = t.querySelector(`[id="${e}"]`); if (!r) return null; const i = r.cloneNode(!0); if (i.removeAttribute("id"), "svg" === i.nodeName.toLowerCase()) return this._setSvgAttributes(i, n); if ("symbol" === i.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(i), n); const s = this._svgElementFromString("<svg></svg>"); return s.appendChild(i), this._setSvgAttributes(s, n) } _svgElementFromString(t) { const e = this._document.createElement("DIV"); e.innerHTML = t; const n = e.querySelector("svg"); if (!n) throw Error("<svg> tag not found"); return n } _toSvgElement(t) { const e = this._svgElementFromString("<svg></svg>"), n = t.attributes; for (let r = 0; r < n.length; r++) { const { name: t, value: i } = n[r]; "id" !== t && e.setAttribute(t, i) } for (let r = 0; r < t.childNodes.length; r++)t.childNodes[r].nodeType === this._document.ELEMENT_NODE && e.appendChild(t.childNodes[r].cloneNode(!0)); return e } _setSvgAttributes(t, e) { return t.setAttribute("fit", ""), t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.setAttribute("preserveAspectRatio", "xMidYMid meet"), t.setAttribute("focusable", "false"), e && e.viewBox && t.setAttribute("viewBox", e.viewBox), t } _fetchIcon(t) { var e; const { url: n, options: r } = t, i = null !== (e = null == r ? void 0 : r.withCredentials) && void 0 !== e && e; if (!this._httpClient) throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports."); if (null == n) throw Error(`Cannot fetch icon from URL "${n}".`); const s = this._sanitizer.sanitize(ri.RESOURCE_URL, n); if (!s) throw eE(n); const o = this._inProgressUrlFetches.get(s); if (o) return o; const a = this._httpClient.get(s, { responseType: "text", withCredentials: i }).pipe(Fg(() => this._inProgressUrlFetches.delete(s)), et()); return this._inProgressUrlFetches.set(s, a), a } _addSvgIconConfig(t, e, n) { return this._svgIconConfigs.set(oE(t, e), n), this } _addSvgIconSetConfig(t, e) { const n = this._iconSetConfigs.get(t); return n ? n.push(e) : this._iconSetConfigs.set(t, [e]), this } _svgElementFromConfig(t) { if (!t.svgElement) { const e = this._svgElementFromString(t.svgText); this._setSvgAttributes(e, t.options), t.svgElement = e } return t.svgElement } _getIconConfigFromResolvers(t, e) { for (let r = 0; r < this._resolvers.length; r++) { const i = this._resolvers[r](e, t); if (i) return (n = i).url && n.options ? new rE(i.url, null, i.options) : new rE(i, null) } var n } } return t.\u0275fac = function (e) { return new (e || t)(fr(Ad, 8), fr(Zh), fr(wu, 8), fr(di)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(Ad, 8), fr(Zh), fr(wu, 8), fr(di)) }, token: t, providedIn: "root" }), t })(); function sE(t) { return t.cloneNode(!0) } function oE(t, e) { return t + ":" + e } const aE = iS(class { constructor(t) { this._elementRef = t } }), lE = new Kn("mat-icon-location", { providedIn: "root", factory: function () { const t = mr(wu), e = t ? t.location : null; return { getPathname: () => e ? e.pathname + e.search : "" } } }), cE = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"], uE = cE.map(t => `[${t}]`).join(", "), hE = /^url\(['"]?#(.*?)['"]?\)$/; let dE = (() => { class t extends aE { constructor(t, e, n, r, i) { super(t), this._iconRegistry = e, this._location = r, this._errorHandler = i, this._inline = !1, this._currentIconFetch = d.EMPTY, n || t.nativeElement.setAttribute("aria-hidden", "true") } get inline() { return this._inline } set inline(t) { this._inline = Bb(t) } get svgIcon() { return this._svgIcon } set svgIcon(t) { t !== this._svgIcon && (t ? this._updateSvgIcon(t) : this._svgIcon && this._clearSvgElement(), this._svgIcon = t) } get fontSet() { return this._fontSet } set fontSet(t) { const e = this._cleanupFontValue(t); e !== this._fontSet && (this._fontSet = e, this._updateFontIconClasses()) } get fontIcon() { return this._fontIcon } set fontIcon(t) { const e = this._cleanupFontValue(t); e !== this._fontIcon && (this._fontIcon = e, this._updateFontIconClasses()) } _splitIconName(t) { if (!t) return ["", ""]; const e = t.split(":"); switch (e.length) { case 1: return ["", e[0]]; case 2: return e; default: throw Error(`Invalid icon name: "${t}"`) } } ngOnInit() { this._updateFontIconClasses() } ngAfterViewChecked() { const t = this._elementsWithExternalReferences; if (t && t.size) { const t = this._location.getPathname(); t !== this._previousPath && (this._previousPath = t, this._prependPathToReferences(t)) } } ngOnDestroy() { this._currentIconFetch.unsubscribe(), this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear() } _usingFontIcon() { return !this.svgIcon } _setSvgElement(t) { this._clearSvgElement(); const e = t.querySelectorAll("style"); for (let r = 0; r < e.length; r++)e[r].textContent += " "; const n = this._location.getPathname(); this._previousPath = n, this._cacheChildrenWithExternalReferences(t), this._prependPathToReferences(n), this._elementRef.nativeElement.appendChild(t) } _clearSvgElement() { const t = this._elementRef.nativeElement; let e = t.childNodes.length; for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); e--;) { const n = t.childNodes[e]; 1 === n.nodeType && "svg" !== n.nodeName.toLowerCase() || t.removeChild(n) } } _updateFontIconClasses() { if (!this._usingFontIcon()) return; const t = this._elementRef.nativeElement, e = this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet) : this._iconRegistry.getDefaultFontSetClass(); e != this._previousFontSetClass && (this._previousFontSetClass && t.classList.remove(this._previousFontSetClass), e && t.classList.add(e), this._previousFontSetClass = e), this.fontIcon != this._previousFontIconClass && (this._previousFontIconClass && t.classList.remove(this._previousFontIconClass), this.fontIcon && t.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon) } _cleanupFontValue(t) { return "string" == typeof t ? t.trim().split(" ")[0] : t } _prependPathToReferences(t) { const e = this._elementsWithExternalReferences; e && e.forEach((e, n) => { e.forEach(e => { n.setAttribute(e.name, `url('${t}#${e.value}')`) }) }) } _cacheChildrenWithExternalReferences(t) { const e = t.querySelectorAll(uE), n = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map; for (let r = 0; r < e.length; r++)cE.forEach(t => { const i = e[r], s = i.getAttribute(t), o = s ? s.match(hE) : null; if (o) { let e = n.get(i); e || (e = [], n.set(i, e)), e.push({ name: t, value: o[1] }) } }) } _updateSvgIcon(t) { if (this._svgNamespace = null, this._svgName = null, this._currentIconFetch.unsubscribe(), t) { const [e, n] = this._splitIconName(t); e && (this._svgNamespace = e), n && (this._svgName = n), this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(n, e).pipe(hg(1)).subscribe(t => this._setSvgElement(t), t => { this._errorHandler.handleError(new Error(`Error retrieving icon ${e}:${n}! ${t.message}`)) }) } } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(iE), Wn("aria-hidden"), Do(lE), Do(di)) }, t.\u0275cmp = Jt({ type: t, selectors: [["mat-icon"]], hostAttrs: ["role", "img", 1, "mat-icon", "notranslate"], hostVars: 7, hostBindings: function (t, e) { 2 & t && (Ro("data-mat-icon-type", e._usingFontIcon() ? "font" : "svg")("data-mat-icon-name", e._svgName || e.fontIcon)("data-mat-icon-namespace", e._svgNamespace || e.fontSet), aa("mat-icon-inline", e.inline)("mat-icon-no-color", "primary" !== e.color && "accent" !== e.color && "warn" !== e.color)) }, inputs: { color: "color", inline: "inline", svgIcon: "svgIcon", fontSet: "fontSet", fontIcon: "fontIcon" }, exportAs: ["matIcon"], features: [vo], ngContentSelectors: $T, decls: 1, vars: 0, template: function (t, e) { 1 & t && (Qo(), $o(0)) }, styles: [".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"], encapsulation: 2, changeDetection: 0 }), t })(), pE = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[nS], nS] }), t })(); const fE = { provide: new Kn("mat-select-scroll-strategy"), deps: [mw], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }; let mE = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [fE], imports: [[mh, vw, bS, nS], P_, fx, bS, nS] }), t })(), gE = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[mh, NS, fx, QT, NT, XT, pE, mE]] }), t })(); function vE(t, e, n, r) { return new (n || (n = Promise))(function (i, s) { function o(t) { try { l(r.next(t)) } catch (e) { s(e) } } function a(t) { try { l(r.throw(t)) } catch (e) { s(e) } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } l((r = r.apply(t, e || [])).next()) }) } var yE = n(6776), bE = n(2024), _E = n(2519), wE = n(9267); const SE = "homestead", xE = [{ inputs: [{ internalType: "uint256", name: "_saleStartTimestamp", type: "uint256" }, { internalType: "uint256", name: "_revealSupply", type: "uint256" }, { internalType: "uint256", name: "_maxSupply", type: "uint256" }], stateMutability: "nonpayable", type: "constructor" }, { anonymous: !1, inputs: [{ indexed: !0, internalType: "address", name: "owner", type: "address" }, { indexed: !0, internalType: "address", name: "approved", type: "address" }, { indexed: !0, internalType: "uint256", name: "tokenId", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: !1, inputs: [{ indexed: !0, internalType: "address", name: "owner", type: "address" }, { indexed: !0, internalType: "address", name: "operator", type: "address" }, { indexed: !1, internalType: "bool", name: "approved", type: "bool" }], name: "ApprovalForAll", type: "event" }, { anonymous: !1, inputs: [{ indexed: !0, internalType: "address", name: "previousOwner", type: "address" }, { indexed: !0, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: !1, inputs: [{ indexed: !0, internalType: "address", name: "from", type: "address" }, { indexed: !0, internalType: "address", name: "to", type: "address" }, { indexed: !0, internalType: "uint256", name: "tokenId", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [], name: "MAX_PURCHASE", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "PRICE", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "PROVENANCE", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }], name: "approve", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "burn", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "getApproved", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "operator", type: "address" }], name: "isApprovedForAll", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "maxSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "numberOfNfts", type: "uint256" }], name: "mintNFT", outputs: [], stateMutability: "payable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "offset", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "offsetBlock", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "ownerOf", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "reveal", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "revealSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }, { internalType: "bytes", name: "_data", type: "bytes" }], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "saleStartTimestamp", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "operator", type: "address" }, { internalType: "bool", name: "approved", type: "bool" }], name: "setApprovalForAll", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }], name: "supportsInterface", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "index", type: "uint256" }], name: "tokenByIndex", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "uint256", name: "index", type: "uint256" }], name: "tokenOfOwnerByIndex", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }], name: "tokenURI", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "tokenId", type: "uint256" }], name: "transferFrom", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "withdraw", outputs: [], stateMutability: "nonpayable", type: "function" }], TE = [{ constant: !0, inputs: [], name: "name", outputs: [{ name: "", type: "string" }], payable: !1, stateMutability: "view", type: "function" }, { constant: !1, inputs: [{ name: "_spender", type: "address" }, { name: "_value", type: "uint256" }], name: "approve", outputs: [{ name: "", type: "bool" }], payable: !1, stateMutability: "nonpayable", type: "function" }, { constant: !0, inputs: [], name: "totalSupply", outputs: [{ name: "", type: "uint256" }], payable: !1, stateMutability: "view", type: "function" }, { constant: !1, inputs: [{ name: "_from", type: "address" }, { name: "_to", type: "address" }, { name: "_value", type: "uint256" }], name: "transferFrom", outputs: [{ name: "", type: "bool" }], payable: !1, stateMutability: "nonpayable", type: "function" }, { constant: !0, inputs: [], name: "decimals", outputs: [{ name: "", type: "uint8" }], payable: !1, stateMutability: "view", type: "function" }, { constant: !0, inputs: [{ name: "_owner", type: "address" }], name: "balanceOf", outputs: [{ name: "balance", type: "uint256" }], payable: !1, stateMutability: "view", type: "function" }, { constant: !0, inputs: [], name: "symbol", outputs: [{ name: "", type: "string" }], payable: !1, stateMutability: "view", type: "function" }, { constant: !1, inputs: [{ name: "_to", type: "address" }, { name: "_value", type: "uint256" }], name: "transfer", outputs: [{ name: "", type: "bool" }], payable: !1, stateMutability: "nonpayable", type: "function" }, { constant: !0, inputs: [{ name: "_owner", type: "address" }, { name: "_spender", type: "address" }], name: "allowance", outputs: [{ name: "", type: "uint256" }], payable: !1, stateMutability: "view", type: "function" }, { payable: !0, stateMutability: "payable", type: "fallback" }, { anonymous: !1, inputs: [{ indexed: !0, name: "owner", type: "address" }, { indexed: !0, name: "spender", type: "address" }, { indexed: !1, name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: !1, inputs: [{ indexed: !0, name: "from", type: "address" }, { indexed: !0, name: "to", type: "address" }, { indexed: !1, name: "value", type: "uint256" }], name: "Transfer", type: "event" }], EE = new Set; let ME, AE = (() => { class t { constructor(t) { this._platform = t, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : CE } matchMedia(t) { return this._platform.WEBKIT && function (t) { if (!EE.has(t)) try { ME || (ME = document.createElement("style"), ME.setAttribute("type", "text/css"), document.head.appendChild(ME)), ME.sheet && (ME.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`, 0), EE.add(t)) } catch (e) { console.error(e) } }(t), this._matchMedia(t) } } return t.\u0275fac = function (e) { return new (e || t)(fr(p_)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(p_)) }, token: t, providedIn: "root" }), t })(); function CE(t) { return { matches: "all" === t || "" === t, media: t, addListener: () => { }, removeListener: () => { } } } let PE = (() => { class t { constructor(t, e) { this._mediaMatcher = t, this._zone = e, this._queries = new Map, this._destroySubject = new M } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(t) { return RE(Ub(t)).some(t => this._registerQuery(t).mql.matches) } observe(t) { let e = ig(RE(Ub(t)).map(t => this._registerQuery(t).observable)); return e = lg(e.pipe(hg(1)), e.pipe(Sw(1), yw(0))), e.pipe(P(t => { const e = { matches: !1, breakpoints: {} }; return t.forEach(({ matches: t, query: n }) => { e.matches = e.matches || t, e.breakpoints[n] = t }), e })) } _registerQuery(t) { if (this._queries.has(t)) return this._queries.get(t); const e = this._mediaMatcher.matchMedia(t), n = { observable: new w(t => { const n = e => this._zone.run(() => t.next(e)); return e.addListener(n), () => { e.removeListener(n) } }).pipe(fg(e), P(({ matches: e }) => ({ query: t, matches: e })), a_(this._destroySubject)), mql: e }; return this._queries.set(t, n), n } } return t.\u0275fac = function (e) { return new (e || t)(fr(AE), fr(Vc)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(AE), fr(Vc)) }, token: t, providedIn: "root" }), t })(); function RE(t) { return t.map(t => t.split(",")).reduce((t, e) => t.concat(e)).map(t => t.trim()) } function LE(t, e) { if (1 & t) { const t = Go(); Fo(0, "div", 1), Fo(1, "button", 2), Jo("click", function () { return Oe(t), Ko().action() }), ya(2), No(), No() } if (2 & t) { const t = Ko(); ns(2), ba(t.data.action) } } function kE(t, e) { } const DE = new Kn("MatSnackBarData"); class IE { constructor() { this.politeness = "assertive", this.announcementMessage = "", this.duration = 0, this.data = null, this.horizontalPosition = "center", this.verticalPosition = "bottom" } } const OE = Math.pow(2, 31) - 1; class FE { constructor(t, e) { this._overlayRef = e, this._afterDismissed = new M, this._afterOpened = new M, this._onAction = new M, this._dismissedByAction = !1, this.containerInstance = t, this.onAction().subscribe(() => this.dismiss()), t._onExit.subscribe(() => this._finishDismiss()) } dismiss() { this._afterDismissed.closed || this.containerInstance.exit(), clearTimeout(this._durationTimeoutId) } dismissWithAction() { this._onAction.closed || (this._dismissedByAction = !0, this._onAction.next(), this._onAction.complete()), clearTimeout(this._durationTimeoutId) } closeWithAction() { this.dismissWithAction() } _dismissAfter(t) { this._durationTimeoutId = setTimeout(() => this.dismiss(), Math.min(t, OE)) } _open() { this._afterOpened.closed || (this._afterOpened.next(), this._afterOpened.complete()) } _finishDismiss() { this._overlayRef.dispose(), this._onAction.closed || this._onAction.complete(), this._afterDismissed.next({ dismissedByAction: this._dismissedByAction }), this._afterDismissed.complete(), this._dismissedByAction = !1 } afterDismissed() { return this._afterDismissed } afterOpened() { return this.containerInstance._onEnter } onAction() { return this._onAction } } let NE = (() => { class t { constructor(t, e) { this.snackBarRef = t, this.data = e } action() { this.snackBarRef.dismissWithAction() } get hasAction() { return !!this.data.action } } return t.\u0275fac = function (e) { return new (e || t)(Do(FE), Do(DE)) }, t.\u0275cmp = Jt({ type: t, selectors: [["simple-snack-bar"]], hostAttrs: [1, "mat-simple-snackbar"], decls: 3, vars: 2, consts: [["class", "mat-simple-snackbar-action", 4, "ngIf"], [1, "mat-simple-snackbar-action"], ["mat-button", "", 3, "click"]], template: function (t, e) { 1 & t && (Fo(0, "span"), ya(1), No(), Lo(2, LE, 3, 1, "div", 0)), 2 & t && (ns(1), ba(e.data.message), ns(1), Io("ngIf", e.hasAction)) }, directives: [th, YT], styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}\n"], encapsulation: 2, changeDetection: 0 }), t })(); const BE = { snackBarState: pp("state", [vp("void, hidden", gp({ transform: "scale(0.8)", opacity: 0 })), vp("visible", gp({ transform: "scale(1)", opacity: 1 })), yp("* => visible", fp("150ms cubic-bezier(0, 0, 0.2, 1)")), yp("* => void, * => hidden", fp("75ms cubic-bezier(0.4, 0.0, 1, 1)", gp({ opacity: 0 })))]) }; let HE = (() => { class t extends O_ { constructor(t, e, n, r, i) { super(), this._ngZone = t, this._elementRef = e, this._changeDetectorRef = n, this._platform = r, this.snackBarConfig = i, this._announceDelay = 150, this._destroyed = !1, this._onAnnounce = new M, this._onExit = new M, this._onEnter = new M, this._animationState = "void", this.attachDomPortal = t => (this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachDomPortal(t)), this._live = "assertive" !== i.politeness || i.announcementMessage ? "off" === i.politeness ? "off" : "polite" : "assertive", this._platform.FIREFOX && ("polite" === this._live && (this._role = "status"), "assertive" === this._live && (this._role = "alert")) } attachComponentPortal(t) { return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachComponentPortal(t) } attachTemplatePortal(t) { return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachTemplatePortal(t) } onAnimationEnd(t) { const { fromState: e, toState: n } = t; if (("void" === n && "void" !== e || "hidden" === n) && this._completeExit(), "visible" === n) { const t = this._onEnter; this._ngZone.run(() => { t.next(), t.complete() }) } } enter() { this._destroyed || (this._animationState = "visible", this._changeDetectorRef.detectChanges(), this._screenReaderAnnounce()) } exit() { return this._animationState = "hidden", this._elementRef.nativeElement.setAttribute("mat-exit", ""), clearTimeout(this._announceTimeoutId), this._onExit } ngOnDestroy() { this._destroyed = !0, this._completeExit() } _completeExit() { this._ngZone.onMicrotaskEmpty.pipe(hg(1)).subscribe(() => { this._onExit.next(), this._onExit.complete() }) } _applySnackBarClasses() { const t = this._elementRef.nativeElement, e = this.snackBarConfig.panelClass; e && (Array.isArray(e) ? e.forEach(e => t.classList.add(e)) : t.classList.add(e)), "center" === this.snackBarConfig.horizontalPosition && t.classList.add("mat-snack-bar-center"), "top" === this.snackBarConfig.verticalPosition && t.classList.add("mat-snack-bar-top") } _assertNotAttached() { this._portalOutlet.hasAttached() } _screenReaderAnnounce() { this._announceTimeoutId || this._ngZone.runOutsideAngular(() => { this._announceTimeoutId = setTimeout(() => { const t = this._elementRef.nativeElement.querySelector("[aria-hidden]"), e = this._elementRef.nativeElement.querySelector("[aria-live]"); if (t && e) { let n = null; this._platform.isBrowser && document.activeElement instanceof HTMLElement && t.contains(document.activeElement) && (n = document.activeElement), t.removeAttribute("aria-hidden"), e.appendChild(t), null == n || n.focus(), this._onAnnounce.next(), this._onAnnounce.complete() } }, this._announceDelay) }) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Vc), Do(Wa), Do(bl), Do(p_), Do(IE)) }, t.\u0275cmp = Jt({ type: t, selectors: [["snack-bar-container"]], viewQuery: function (t, e) { if (1 & t && fc(N_, 7), 2 & t) { let t; pc(t = gc()) && (e._portalOutlet = t.first) } }, hostAttrs: [1, "mat-snack-bar-container"], hostVars: 1, hostBindings: function (t, e) { 1 & t && Xo("@state.done", function (t) { return e.onAnimationEnd(t) }), 2 & t && xa("@state", e._animationState) }, features: [vo], decls: 3, vars: 2, consts: [["aria-hidden", "true"], ["cdkPortalOutlet", ""]], template: function (t, e) { 1 & t && (Fo(0, "div", 0), Lo(1, kE, 0, 0, "ng-template", 1), No(), Bo(2, "div")), 2 & t && (ns(2), Ro("aria-live", e._live)("role", e._role)) }, directives: [N_], styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"], encapsulation: 2, data: { animation: [BE.snackBarState] } }), t })(), UE = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[vw, B_, mh, QT, nS], nS] }), t })(); const GE = new Kn("mat-snack-bar-default-options", { providedIn: "root", factory: function () { return new IE } }); let VE = (() => { class t { constructor(t, e, n, r, i, s) { this._overlay = t, this._live = e, this._injector = n, this._breakpointObserver = r, this._parentSnackBar = i, this._defaultConfig = s, this._snackBarRefAtThisLevel = null, this.simpleSnackBarComponent = NE, this.snackBarContainerComponent = HE, this.handsetCssClass = "mat-snack-bar-handset" } get _openedSnackBarRef() { const t = this._parentSnackBar; return t ? t._openedSnackBarRef : this._snackBarRefAtThisLevel } set _openedSnackBarRef(t) { this._parentSnackBar ? this._parentSnackBar._openedSnackBarRef = t : this._snackBarRefAtThisLevel = t } openFromComponent(t, e) { return this._attach(t, e) } openFromTemplate(t, e) { return this._attach(t, e) } open(t, e = "", n) { const r = Object.assign(Object.assign({}, this._defaultConfig), n); return r.data = { message: t, action: e }, r.announcementMessage === t && (r.announcementMessage = void 0), this.openFromComponent(this.simpleSnackBarComponent, r) } dismiss() { this._openedSnackBarRef && this._openedSnackBarRef.dismiss() } ngOnDestroy() { this._snackBarRefAtThisLevel && this._snackBarRefAtThisLevel.dismiss() } _attachSnackBarContainer(t, e) { const n = mo.create({ parent: e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, providers: [{ provide: IE, useValue: e }] }), r = new k_(this.snackBarContainerComponent, e.viewContainerRef, n), i = t.attach(r); return i.instance.snackBarConfig = e, i.instance } _attach(t, e) { const n = Object.assign(Object.assign(Object.assign({}, new IE), this._defaultConfig), e), r = this._createOverlay(n), i = this._attachSnackBarContainer(r, n), s = new FE(i, r); if (t instanceof Tl) { const e = new D_(t, null, { $implicit: n.data, snackBarRef: s }); s.instance = i.attachTemplatePortal(e) } else { const e = this._createInjector(n, s), r = new k_(t, void 0, e), o = i.attachComponentPortal(r); s.instance = o.instance } return this._breakpointObserver.observe("(max-width: 599.98px) and (orientation: portrait)").pipe(a_(r.detachments())).subscribe(t => { const e = r.overlayElement.classList; t.matches ? e.add(this.handsetCssClass) : e.remove(this.handsetCssClass) }), n.announcementMessage && i._onAnnounce.subscribe(() => { this._live.announce(n.announcementMessage, n.politeness) }), this._animateSnackBar(s, n), this._openedSnackBarRef = s, this._openedSnackBarRef } _animateSnackBar(t, e) { t.afterDismissed().subscribe(() => { this._openedSnackBarRef == t && (this._openedSnackBarRef = null), e.announcementMessage && this._live.clear() }), this._openedSnackBarRef ? (this._openedSnackBarRef.afterDismissed().subscribe(() => { t.containerInstance.enter() }), this._openedSnackBarRef.dismiss()) : t.containerInstance.enter(), e.duration && e.duration > 0 && t.afterOpened().subscribe(() => t._dismissAfter(e.duration)) } _createOverlay(t) { const e = new q_; e.direction = t.direction; let n = this._overlay.position().global(); const r = "rtl" === t.direction, i = "left" === t.horizontalPosition || "start" === t.horizontalPosition && !r || "end" === t.horizontalPosition && r, s = !i && "center" !== t.horizontalPosition; return i ? n.left("0") : s ? n.right("0") : n.centerHorizontally(), "top" === t.verticalPosition ? n.top("0") : n.bottom("0"), e.positionStrategy = n, this._overlay.create(e) } _createInjector(t, e) { return mo.create({ parent: t && t.viewContainerRef && t.viewContainerRef.injector || this._injector, providers: [{ provide: FE, useValue: e }, { provide: DE, useValue: t.data }] }) } } return t.\u0275fac = function (e) { return new (e || t)(fr(mw), fr(jw), fr(mo), fr(PE), fr(t, 12), fr(GE)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(mw), fr(jw), fr($s), fr(PE), fr(t, 12), fr(GE)) }, token: t, providedIn: UE }), t })(), zE = (() => { class t { constructor(t, e) { this.http = t, this.snackBar = e } connect() { return vE(this, void 0, void 0, function* () { yield ethereum.request({ method: "eth_requestAccounts" }); const t = new wE.Q(ethereum), [e] = yield t.listAccounts(); return t.getSigner(e), yield this.assertNetwork(SE), e }) } watchDisconnect() { return (null === window || void 0 === window ? void 0 : window.ethereum) ? new w(t => { ethereum.on("accountsChanged", e => { 0 == e.length && t.next() }) }) : id() } isConnected() { return vE(this, void 0, void 0, function* () { if (!(null === window || void 0 === window ? void 0 : window.ethereum)) return null; const t = new wE.Q(ethereum), [e] = yield t.listAccounts(); return t.getUncheckedSigner(e), yield this.assertNetwork(SE), e }) } assertNetwork(t) { return vE(this, void 0, void 0, function* () { const e = new wE.Q(ethereum), { name: n } = yield e.getNetwork(); t !== n && this.snackBar.open(`Invalid blockchain network. Please select ${t} in your wallet`, void 0, { panelClass: "error-snackbar", duration: 0 }) }) } getBalance() { return vE(this, void 0, void 0, function* () { const t = new wE.Q(ethereum), [e] = yield t.listAccounts(); return t.getBalance(e) }) } getEthBalance(t) { return vE(this, void 0, void 0, function* () { return new wE.Q(ethereum).getBalance(t) }) } getLinkBalance(t) { return vE(this, void 0, void 0, function* () { const e = new wE.Q(ethereum); return new yE.Contract("0x514910771AF9Ca656af840dff83E8264EcF986CA", TE, e).balanceOf(t) }) } static getReadOnlyVoxContract(t) { const e = new wE.Q(ethereum); return t ? new yE.Contract(t, xE, e) : { PRICE: () => Promise.resolve("88800000000000000"), maxSupply: () => Promise.resolve(8888), totalSupply: () => Promise.resolve(0), saleStartTimestamp: () => Promise.resolve(bE.O$.from(1628632800)), tokenURI: () => Promise.resolve() } } static getWritableVoxContract(t) { return vE(this, void 0, void 0, function* () { const e = new wE.Q(ethereum), [n] = yield e.listAccounts(), r = e.getSigner(n); return new yE.Contract(t, xE, r) }) } getVoxByOwner(t) { return vE(this, void 0, void 0, function* () { if (!t) return []; const e = new wE.Q(ethereum), n = new yE.Contract(t, xE, e), [r] = yield e.listAccounts(), i = yield n.balanceOf(r), s = []; for (let t = 0; t < i; t++)s.push(yield n.tokenOfOwnerByIndex(r, t)); return s }) } getVoxMetadata(e, n) { var r; return vE(this, void 0, void 0, function* () { const i = { image: "assets/vox-mystery.png", name: "Unknown", attributes: [] }, s = new TextDecoder, o = t.getReadOnlyVoxContract(e), a = yield o.offset(); if (a.isZero()) return i; const l = yield o.maxSupply(), c = +_E.formatUnits(n, 0), u = +_E.formatUnits(l, 0), h = (c + +_E.formatUnits(a, 0)) % u, d = yield o.tokenURI(n); try { const t = yield this.http.get(d, { responseType: "arraybuffer" }).toPromise(), e = JSON.parse(s.decode(t)); return e.id = h, e.uri = d, e.image = null === (r = e.image) || void 0 === r ? void 0 : r.replace("ipfs://", "https://vox.mypinata.cloud/ipfs/"), e.raw = t, e } catch (p) { return i } }) } watchTransaction(t) { return vE(this, void 0, void 0, function* () { return new wE.Q(ethereum).waitForTransaction(t.hash) }) } static buf2hex(t) { return [...new Uint8Array(t)].map(t => t.toString(16).padStart(2, "0")).join("") } } return t.\u0275fac = function (e) { return new (e || t)(fr(Ad), fr(VE)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), jE = (() => { class t { constructor(t, e, n) { this.router = t, this.location = e, this.blockchain = n, this.selfSubject = new $m(null), this.self$ = this.selfSubject.pipe(Yb()), this.blockchain.watchDisconnect().subscribe(() => this.selfSubject.next(null)) } setSelf(t) { const e = { ethAddress: t }; return this.selfSubject.next(e), id(e) } goToLogin() { const t = this.location.path().split("?")[0]; this.router.navigate(["/login"], { queryParams: { referrer: t } }) } clearSelf() { this.selfSubject.next(null) } } return t.\u0275fac = function (e) { return new (e || t)(fr(fb), fr(Fu), fr(zE)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), JE = (() => { class t { constructor(t, e) { this.router = t, this.platformId = e } canActivate(t, e) { return !(!(null === window || void 0 === window ? void 0 : window.ethereum) && !vh(this.platformId)) || this.router.parseUrl("/login") } } return t.\u0275fac = function (e) { return new (e || t)(fr(fb), fr(Ac)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); var XE = n(9555), WE = n.n(XE); let qE = (() => { class t { constructor(t, e) { this.state = t, this.platformId = e, this.sanityClient = WE()({ projectId: "jt6n1rzj", dataset: "production", token: null, apiVersion: "2021-03-25" }) } fetch(t) { const e = t.toString(), n = this.state.get(e, null); if (n) return this.state.remove(e), id(n); const r = setTimeout(() => { }, 1e4); return B(this.sanityClient.fetch(t)).pipe(Dg(t => { vh(this.platformId) && this.state.set(e, t), clearTimeout(r) })) } } return t.\u0275fac = function (e) { return new (e || t)(fr(ed), fr(Ac)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), ZE = (() => { class t extends qE { getDrop(t) { return this.fetch(`*[_type == "drop" && slug.current == "${t}"][0] {\n      _type,\n      name,\n      address,\n      subtitle,\n      description,\n      "slug": slug.current,\n      "bannerUrl": banner.asset->url,\n      bannerColor,\n      tags,\n      passwordHash,\n      passwordDuration\n  }`) } getContracts() { return this.fetch('*[_type == "drop"] {\n      address,\n      "slug": slug.current\n  }') } getFaqs() { return this.fetch('*[_type == "faq"] {\n      _type,\n      question,\n      answer,\n      _createdAt\n  }') } getTermsAndConditions() { return this.fetch('*[_type == "terms-and-conditions"] {\n        title,\n        content\n      }') } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = Jn(t)))(n || t) } }(), t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const KE = function (t, e, n) { return [t, e, n] }, YE = ["*"]; let QE = (() => { class t { constructor(t) { this.platformId = t, this.variant = "solid", this.size = "normal", this.target = "_blank" } openLink(t) { gh(this.platformId) && this.url && window.open(this.url, this.target) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ac)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-button"]], inputs: { color: "color", variant: "variant", size: "size", disabled: "disabled", url: "url", target: "target" }, ngContentSelectors: YE, decls: 2, vars: 6, consts: [[1, "button", "w-full", 3, "ngClass", "disabled", "click"]], template: function (t, e) { var n, r, i, s, o, a; 1 & t && (Qo(), Fo(0, "button", 0), Jo("click", function (t) { return e.openLink(t) }), $o(1), No()), 2 & t && Io("ngClass", (n = 2, r = KE, i = "button-" + e.color, s = "button-" + e.variant, o = "button-" + e.size, function (t, e, n, r, i, s, o, a) { const l = e + n; return function (t, e, n, r, i) { const s = Po(t, e, n, r); return Co(t, e + 2, i) || s }(t, l, i, s, o) ? Ao(t, l + 3, a ? r.call(a, i, s, o) : r(i, s, o)) : Xl(t, l + 3) }(De(), ze(), n, r, i, s, o, a)))("disabled", e.disabled) }, directives: [Ku], styles: [""] }), t })(); function $E(t, e) { 1 & t && (Fo(0, "ga-button", 6), ya(1, "OK"), No()) } function tM(t, e) { if (1 & t && (Fo(0, "ga-button", 7), ya(1), No()), 2 & t) { const t = Ko(); Io("url", null == t.data || null == t.data.link ? null : t.data.link.url), ns(1), ba(null == t.data || null == t.data.link ? null : t.data.link.text) } } let eM = (() => { class t { constructor(t) { this.data = t } } return t.\u0275fac = function (e) { return new (e || t)(Do(CS)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ng-component"]], decls: 7, vars: 4, consts: [[1, "text-center"], ["mat-dialog-content", "", 1, "flex", "flex-col", "justify-center"], [1, "text-center", 3, "innerHTML"], ["mat-dialog-actions", "", 1, "justify-center"], ["color", "primary", "mat-dialog-close", "", 4, "ngIf"], ["color", "primary", 3, "url", 4, "ngIf"], ["color", "primary", "mat-dialog-close", ""], ["color", "primary", 3, "url"]], template: function (t, e) { 1 & t && (Fo(0, "h2", 0), ya(1), No(), Fo(2, "div", 1), Bo(3, "div", 2), No(), Fo(4, "div", 3), Lo(5, $E, 2, 0, "ga-button", 4), Lo(6, tM, 2, 2, "ga-button", 5), No()), 2 & t && (ns(1), ba(e.data.title), ns(2), Io("innerHTML", e.data.text, ii), ns(2), Io("ngIf", !e.data.link), ns(1), Io("ngIf", null == e.data || null == e.data.link ? null : e.data.link.url)) }, directives: [OS, FS, th, QE, IS], encapsulation: 2 }), t })(); function nM(t, e) { if (1 & t && (Fo(0, "ga-button", 7), ya(1), No()), 2 & t) { const t = Ko(); Io("mat-dialog-close", !1), ns(1), _a(" ", t.data.noText, " ") } } let rM = (() => { class t { constructor(t) { this.data = t } } return t.\u0275fac = function (e) { return new (e || t)(Do(CS)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ng-component"]], decls: 9, vars: 5, consts: [[1, "flex", "flex-col", "items-center"], [1, "text-center"], ["mat-dialog-content", "", 1, "flex", "flex-col", "text-center"], [3, "innerHTML"], ["mat-dialog-actions", ""], [3, "mat-dialog-close", 4, "ngIf"], ["color", "primary", 3, "mat-dialog-close"], [3, "mat-dialog-close"]], template: function (t, e) { 1 & t && (Fo(0, "div", 0), Fo(1, "h2", 1), ya(2), No(), Fo(3, "div", 2), Bo(4, "div", 3), No(), Fo(5, "div", 4), Lo(6, nM, 2, 2, "ga-button", 5), Fo(7, "ga-button", 6), ya(8), No(), No(), No()), 2 & t && (ns(2), ba(e.data.title), ns(2), Io("innerHTML", e.data.text, ii), ns(2), Io("ngIf", e.data.noText), ns(1), Io("mat-dialog-close", !0), ns(1), _a(" ", e.data.yesText || "Yes", " ")) }, directives: [OS, FS, th, QE, IS], encapsulation: 2 }), t })(), iM = (() => { class t { constructor(t) { this.snackBar = t } info(t, e) { return this.snackBar.open(t, e, { duration: 4e3 }) } error(t, e) { return this.snackBar.open(t, e, { panelClass: "error-snackbar", duration: 4e3 }) } success(t, e) { return this.snackBar.open(t, e, { panelClass: "success-snackbar", duration: 4e3 }) } handle(t) { return b(yg((t, e) => (t instanceof Error ? this.error(t.toString()) : this.error(t.error.error), qd(t.toString()))), Dg(() => this.success(t))) } dismiss() { this.snackBar.dismiss() } } return t.\u0275fac = function (e) { return new (e || t)(fr(VE)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(); const sM = ["container"]; function oM(t, e) { if (1 & t) { const t = Go(); Fo(0, "ga-button", 7), Jo("click", function () { return Oe(t), Ko().close() }), ya(1), No() } if (2 & t) { const t = Ko(); Io("disabled", t.formDialogable.formGroup.invalid || t.saving), ns(1), _a(" ", t.formDialogable.confirmText || "OK", "") } } function aM(t, e) { if (1 & t) { const t = Go(); Fo(0, "ga-button", 7), Jo("click", function () { return Oe(t), Ko().submit() }), ya(1), No() } if (2 & t) { const t = Ko(); Io("disabled", t.formDialogable.formGroup.invalid || t.saving), ns(1), ba(t.formDialogable.confirmText || "OK") } } let lM = (() => { class t { constructor(t, e, n, r) { this._data = t, this.resolver = e, this.dialogRef = n, this.snackbar = r, this._submitSource = new $m(void 0), this.saving = !1, this.submit$ = this._submitSource.asObservable() } get data() { return this._data.data } ngOnInit() { const t = this.resolver.resolveComponentFactory(this._data.component), e = this.vcr.createComponent(t); this.formDialogable = e.instance } displayError(t) { this.snackbar.error(t) } submit() { this._submitSource.next(this.formDialogable.result) } close() { this.dialogRef.close(this.formDialogable.result) } } return t.\u0275fac = function (e) { return new (e || t)(Do(CS), Do(za), Do(MS), Do(iM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ng-component"]], viewQuery: function (t, e) { if (1 & t && fc(sM, 7, Ll), 2 & t) { let t; pc(t = gc()) && (e.vcr = t.first) } }, decls: 12, vars: 4, consts: [[1, "text-center", "mb-6"], ["mat-dialog-content", ""], ["container", ""], ["mat-dialog-actions", "", 1, "justify-center"], ["mat-dialog-close", "", "color", "secondary", "variant", "outline", 1, "mr-4"], ["color", "primary", 3, "disabled", "click", 4, "ngIf", "ngIfElse"], ["submitBlock", ""], ["color", "primary", 3, "disabled", "click"]], template: function (t, e) { if (1 & t && (Fo(0, "div"), Fo(1, "h2", 0), ya(2), No(), Fo(3, "div", 1), Ho(4, null, 2), Uo(), No(), Fo(6, "div", 3), Fo(7, "ga-button", 4), ya(8), No(), Lo(9, oM, 2, 2, "ga-button", 5), Lo(10, aM, 2, 2, "ng-template", null, 6, _c), No(), No()), 2 & t) { const t = ko(11); ns(2), ba(e.formDialogable.title), ns(6), _a(" ", e.formDialogable.cancelText || "Cancel", " "), ns(1), Io("ngIf", e.formDialogable.closeOnConfirm)("ngIfElse", t) } }, directives: [OS, FS, QE, IS, th], encapsulation: 2 }), t })(), cM = (() => { class t { constructor(t) { this.data = t } } return t.\u0275fac = function (e) { return new (e || t)(Do(CS)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-image"]], decls: 1, vars: 2, consts: [[1, "w-full", "lg:w-auto", "lg:h-screen-3/4", 3, "src", "alt"]], template: function (t, e) { 1 & t && Bo(0, "img", 0), 2 & t && Io("src", e.data.src, si)("alt", e.data.alt) }, styles: [""] }), t })(); function uM(t, e) { if (1 & t && (Ho(0), Fo(1, "mat-form-field", 7), Bo(2, "input", 8), No(), Uo()), 2 & t) { const t = Ko(); ns(2), Io("type", t.data.type || "text")("placeholder", t.data.placeholder) } } function hM(t, e) { if (1 & t && (Ho(0), Fo(1, "mat-form-field", 7), Bo(2, "textarea", 9), No(), Uo()), 2 & t) { const t = Ko(); ns(2), Io("placeholder", t.data.placeholder) } } let dM = (() => { class t { constructor(t, e) { this.dialogRef = t, this.data = e, this.formGroup = new gT({ prompt: new mT("", Cx.required) }), e.value && this.formGroup.setValue({ prompt: e.value }) } close() { this.dialogRef.close(this.formGroup.value.prompt) } } return t.\u0275fac = function (e) { return new (e || t)(Do(MS), Do(CS)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ng-component"]], decls: 12, vars: 6, consts: [[3, "formGroup", "ngSubmit"], [1, "text-center", "mb-4"], [3, "innerHTML"], [4, "ngIf"], ["mat-dialog-actions", "", 1, "flex", "justify-center"], ["color", "primary", "variant", "outline", "mat-dialog-close", "", 1, "mr-4"], ["color", "primary", "type", "submit", 3, "disabled"], ["fxFlex", "100%"], ["matInput", "", "formControlName", "prompt", 1, "w-full", 3, "type", "placeholder"], ["matInput", "", "formControlName", "prompt", 3, "placeholder"]], template: function (t, e) { 1 & t && (Fo(0, "form", 0), Jo("ngSubmit", function () { return e.close() }), Fo(1, "h2", 1), ya(2), No(), Fo(3, "div"), Bo(4, "div", 2), Lo(5, uM, 3, 2, "ng-container", 3), Lo(6, hM, 3, 1, "ng-container", 3), No(), Fo(7, "div", 4), Fo(8, "ga-button", 5), ya(9, "Cancel"), No(), Fo(10, "ga-button", 6), ya(11, " OK "), No(), No(), No()), 2 & t && (Io("formGroup", e.formGroup), ns(2), ba(e.data.title), ns(2), Io("innerHTML", e.data.prompt, ii), ns(1), Io("ngIf", !e.data.textarea), ns(1), Io("ngIf", e.data.textarea), ns(4), Io("disabled", e.formGroup.invalid)) }, directives: [wT, Zx, AT, th, FS, QE, IS, px, JT, Sx, qx, PT], encapsulation: 2 }), t })(); const pM = "700px", fM = { width: "500px" }; let mM = (() => { class t { constructor(t) { this.dialog = t } open(t, e, n = fM) { return this.dialog.open(t, Object.assign({ data: e }, n)).afterClosed() } prompt(t, e, n, r, i) { return this.dialog.open(dM, { data: { title: t, prompt: e, placeholder: n, type: r, value: i }, width: pM }).afterClosed().pipe(od(t => !!t)) } confirm(t, e, n = null) { return this.dialog.open(rM, { data: Object.assign({ title: t, text: e }, n), width: pM }).afterClosed().pipe(od(t => !!t)) } alert(t, e, n) { return this.dialog.open(eM, Object.assign({ data: { title: t, text: e, link: n } }, fM)).afterClosed() } form(t, e, n = null) { return this.dialog.open(lM, Object.assign(Object.assign({}, n), { data: { component: t, data: e } })).afterClosed().pipe(od(t => !!t)) } formWithSubmit(t, e, n = null) { return this.dialog.open(lM, Object.assign(Object.assign({}, n), { data: { component: t, data: e } })).componentInstance } lightbox(t, e) { return this.open(cM, { src: t, alt: e }, { panelClass: "lightbox", backdropClass: "lightbox" }) } lightboxWithWidth(t, e, n) { return this.open(cM, { src: t, alt: e }, { panelClass: "lightbox", backdropClass: "lightbox", width: n }) } closeAll() { this.dialog.closeAll() } } return t.\u0275fac = function (e) { return new (e || t)(fr(DS)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), gM = (() => { class t { constructor() { } eventEmitter(t, e, n = null, r = null) { gtag("send", "event", { eventCategory: t, eventLabel: n, eventAction: e, eventValue: r }) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), vM = (() => { class t { constructor() { this.loadingSubject = new $m(!1), this.loading$ = this.loadingSubject.pipe(Yb()) } watch(...t) { return this.loadingSubject.next(!0), ig([...t]).pipe(Dg(() => { this.loadingSubject.next(!1) })) } next(t) { this.loadingSubject.next(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), yM = (() => { class t { constructor(t) { this.blockchain = t, this.sessionSubject = new $m({ address: "", authenticated: !1, sessionId: "" }), this.session$ = this.sessionSubject.pipe(Yb()), t.watchDisconnect().subscribe(() => this.sessionSubject.next({ address: "", authenticated: !1, sessionId: "" })) } connect() { return B(this.blockchain.connect()).pipe(Dg(t => this.sessionSubject.next({ authenticated: !0, sessionId: "", address: t }))) } checkConnected() { return B(this.blockchain.isConnected()).pipe(ep(t => t ? id(t) : Xd), Dg(t => this.sessionSubject.next({ authenticated: !0, sessionId: "", address: t }))) } } return t.\u0275fac = function (e) { return new (e || t)(fr(zE)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), bM = (() => { class t { constructor(t, e, n) { this.http = t, this.state = e, this.platformId = n, this.isServer = vh(this.platformId) } get(t, e) { const n = t, r = this.state.get(n, null); return r ? (this.state.remove(n), id(r)) : this.http.get(t, e).pipe(P(t => (this.isServer && this.state.set(n, t), t))) } post(t, e, n) { const r = t, i = this.state.get(r, null); return i ? (this.state.remove(r), id(i)) : this.http.post(t, e, n).pipe(P(t => (this.isServer && this.state.set(r, t), t))) } put(t, e, n) { return this.http.put(t, e, n) } delete(t, e) { return this.http.delete(t, e) } } return t.\u0275fac = function (e) { return new (e || t)(fr(Ad), fr(ed), fr(Ac)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac }), t })(), _M = (() => { class t { constructor(t) { this.http = t, this.baseUrl = "https://api.opensea.io/api/v1/" } getAsset(t, e) { return this.http.get(`${this.baseUrl}asset/${t}/${e}`) } } return t.\u0275fac = function (e) { return new (e || t)(fr(bM)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); var wM = (() => (function (t) { t[t.BEFORE = 1] = "BEFORE", t[t.DURING = 2] = "DURING", t[t.ENDING_SOON = 3] = "ENDING_SOON", t[t.ENDING_VERY_SOON = 4] = "ENDING_VERY_SOON", t[t.AFTER = 5] = "AFTER" }(wM || (wM = {})), wM))(); var SM = (() => (function (t) { t[t.UNSPECIFIED = 0] = "UNSPECIFIED", t[t.NOT_HIGH_BID = 1] = "NOT_HIGH_BID", t[t.BIDDING_NOT_STARTED = 2] = "BIDDING_NOT_STARTED", t[t.BIDDING_OVER = 3] = "BIDDING_OVER" }(SM || (SM = {})), SM))(); function xM(...t) { const e = t.length; if (0 === e) throw new Error("list of properties cannot be empty."); return n => P(function (t, e) { return n => { let r = n; for (let i = 0; i < e; i++) { const e = null != r ? r[t[i]] : void 0; if (void 0 === e) return; r = e } return r } }(t, e))(n) } function TM(...t) { return e => { let n; return "function" == typeof t[t.length - 1] && (n = t.pop()), e.lift(new EM(t, n)) } } class EM { constructor(t, e) { this.observables = t, this.project = e } call(t, e) { return e.subscribe(new MM(t, this.observables, this.project)) } } class MM extends tg { constructor(t, e, n) { super(t), this.observables = e, this.project = n, this.toRespond = []; const r = e.length; this.values = new Array(r); for (let i = 0; i < r; i++)this.toRespond.push(i); for (let i = 0; i < r; i++)this.add(ng(this, e[i], void 0, i)) } notifyNext(t, e, n) { this.values[n] = e; const r = this.toRespond; if (r.length > 0) { const t = r.indexOf(n); -1 !== t && r.splice(t, 1) } } notifyComplete() { } _next(t) { if (0 === this.toRespond.length) { const e = [t, ...this.values]; this.project ? this._tryProject(e) : this.destination.next(e) } } _tryProject(t) { let e; try { e = this.project.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } let AM = (() => { class t { transform(t, ...e) { if (null != t) return +_E.formatUnits(t, e[0]) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275pipe = Qt({ name: "bigNumber", type: t, pure: !0 }), t })(); function CM(t, e) { if (1 & t && (Fo(0, "form", 12), Bo(1, "hr", 13), Fo(2, "label", 14), ya(3, "Quantity"), No(), Fo(4, "mat-form-field", 15), Bo(5, "input", 16), Zl(6, "bigNumber"), No(), Fo(7, "p", 17), ya(8), Zl(9, "bigNumber"), No(), Bo(10, "hr", 13), No()), 2 & t) { const t = e.ngIf; Io("formGroup", Ko().ngIf), ns(5), Io("max", Yl(6, 3, t, 0)), ns(3), _a("Enter quantity (maximum ", Yl(9, 6, t, 0), ")") } } function PM(t, e) { if (1 & t) { const t = Go(); Ho(0), Fo(1, "button", 1), Jo("click", function () { return Oe(t), Ko().close() }), Fo(2, "mat-icon"), ya(3, "close"), No(), No(), Fo(4, "div", 2), Fo(5, "h2"), ya(6, "Checkout"), No(), Fo(7, "p"), ya(8, "Use this section to verify your information and mint your VOX"), No(), Fo(9, "div", 3), Fo(10, "p"), ya(11, "Current Ethereum Address"), No(), Fo(12, "p", 4), ya(13), Zl(14, "async"), No(), No(), No(), Fo(15, "div", 5), Lo(16, CM, 11, 9, "form", 6), Zl(17, "async"), No(), Fo(18, "div", 7), Fo(19, "ga-button", 8), Jo("click", function () { return Oe(t), Ko().placePurchase() }), ya(20, " Confirm Purchase "), No(), Fo(21, "p", 9), ya(22, "By clicking Confirm Purchase you are indicating that you have read and agree to our "), Fo(23, "a", 10), ya(24, "Terms and Conditions"), No(), ya(25, " and "), Fo(26, "a", 11), ya(27, "Privacy Policy"), No(), No(), No(), Uo() } if (2 & t) { const t = e.ngIf, n = Ko(); ns(13), ba(Kl(14, 3, n.ethAddress$)), ns(3), Io("ngIf", Kl(17, 5, n.maxPurchase$)), ns(3), Io("disabled", t.invalid) } } let RM = (() => { class t { constructor(t, e, n, r) { this.dialogRef = t, this.sessionService = e, this.blockchain = n, this.data = r, this.maxPurchase$ = B(cg(() => this.voxContract.MAX_PURCHASE())).pipe(u_()), this.formGroup$ = this.maxPurchase$.pipe(P(t => +_E.formatUnits(t, 0)), P(t => new gT({ quantity: new mT(1, [Cx.min(1), Cx.max(t)]) })), u_()), this.saving = !1, this.ethAddress$ = this.sessionService.session$.pipe(P(t => t.address)), this.voxContract = zE.getReadOnlyVoxContract(this.data.drop.address) } placePurchase() { this.formGroup$.subscribe(t => { var e; this.dialogRef.close({ quantity: null === (e = t.get("quantity")) || void 0 === e ? void 0 : e.value }) }) } close() { this.dialogRef.close() } } return t.\u0275fac = function (e) { return new (e || t)(Do(MS), Do(yM), Do(zE), Do(CS)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-buy-payment-confirmation-dialog"]], decls: 2, vars: 3, consts: [[4, "ngIf"], [1, "mat-close", 3, "click"], ["mat-dialog-title", "", 1, "text-center"], [1, "eth-address", "mt-4"], [1, "font-mono", "truncate"], ["mat-dialog-content", ""], [3, "formGroup", 4, "ngIf"], ["mat-dialog-actions", "", 1, "text-center"], ["color", "primary", 1, "w-full", 3, "disabled", "click"], [1, "text-sm", "mt-4"], ["target", "_blank", "routerLink", "terms-and-conditions"], ["target", "_blank", "href", "https://app.gala.games/privacy-policy"], [3, "formGroup"], [1, "-mx-20", "my-8"], ["for", "quantity", 1, "h5"], [1, "w-full"], ["matInput", "", "id", "quantity", "name", "quantity", "type", "number", "formControlName", "quantity", "min", "1", 3, "max"], [1, "text-sm", "text-gray-dark", "mt-1"]], template: function (t, e) { 1 & t && (Lo(0, PM, 28, 7, "ng-container", 0), Zl(1, "async")), 2 & t && Io("ngIf", Kl(1, 1, e.formGroup$)) }, directives: [th, dE, QE, gb, wT, Zx, AT, px, JT, xT, IT, kT, Sx, qx, PT], pipes: [hh, AM], styles: [".eth-address[_ngcontent-%COMP%]{border-radius:1rem;font-size:.875rem;line-height:1.25rem;padding:1rem 2rem;--tw-bg-opacity:1;background-color:rgba(251,249,240,var(--tw-bg-opacity));color:#666;border:1px solid var(--gray-color)}"] }), t })(); function LM(t) { if (null === t || !0 === t || !1 === t) return NaN; var e = Number(t); return isNaN(e) ? e : e < 0 ? Math.ceil(e) : Math.floor(e) } function kM(t, e) { if (e.length < t) throw new TypeError(t + " argument" + (t > 1 ? "s" : "") + " required, but only " + e.length + " present") } function DM(t) { kM(1, arguments); var e = Object.prototype.toString.call(t); return t instanceof Date || "object" == typeof t && "[object Date]" === e ? new Date(t.getTime()) : "number" == typeof t || "[object Number]" === e ? new Date(t) : ("string" != typeof t && "[object String]" !== e || "undefined" == typeof console || (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"), console.warn((new Error).stack)), new Date(NaN)) } function IM(t, e) { kM(2, arguments); var n = DM(t).getTime(), r = LM(e); return new Date(n + r) } function OM(t, e) { if (1 & t && (Fo(0, "div", 3), ya(1), No()), 2 & t) { const t = e.$implicit; ns(1), _a(" ", t, " ") } } let FM = (() => { class t { constructor() { this.moreInfo = new ec } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-auction-information"]], inputs: { drop: "drop" }, outputs: { moreInfo: "moreInfo" }, decls: 9, vars: 3, consts: [[1, "h2"], [1, "mt-8", "mb-4"], ["class", "pill-outline-sm mr-4 mb-4 h5 inline-block", 4, "ngFor", "ngForOf"], [1, "pill-outline-sm", "mr-4", "mb-4", "h5", "inline-block"]], template: function (t, e) { 1 & t && (Fo(0, "h1", 0), ya(1), No(), Fo(2, "p"), ya(3), No(), Fo(4, "p", 1), Fo(5, "b"), ya(6, "What is included:"), No(), No(), Fo(7, "div"), Lo(8, OM, 2, 1, "div", 2), No()), 2 & t && (ns(1), ba(e.drop.subtitle), ns(2), _a(" ", e.drop.description, "\n"), ns(5), Io("ngForOf", e.drop.tags)) }, directives: [Qu], styles: [".pill-dark[_ngcontent-%COMP%]{background-color:#000;color:#fff;display:inline-flex}"] }), t })(); function NM(t, e) { kM(2, arguments); var n = DM(t), r = DM(e), i = n.getTime() - r.getTime(); return i < 0 ? -1 : i > 0 ? 1 : i } function BM(t, e) { kM(2, arguments); var n = DM(t), r = DM(e); return n.getFullYear() - r.getFullYear() } function HM(t, e) { kM(2, arguments); var n = DM(t), r = DM(e), i = NM(n, r), s = Math.abs(BM(n, r)); n.setFullYear("1584"), r.setFullYear("1584"); var o = NM(n, r) === -i, a = i * (s - o); return 0 === a ? 0 : a } function UM(t, e) { kM(2, arguments); var n = DM(t), r = DM(e), i = n.getFullYear() - r.getFullYear(), s = n.getMonth() - r.getMonth(); return 12 * i + s } function GM(t) { kM(1, arguments); var e = DM(t); return e.setHours(23, 59, 59, 999), e } function VM(t) { kM(1, arguments); var e = DM(t), n = e.getMonth(); return e.setFullYear(e.getFullYear(), n + 1, 0), e.setHours(23, 59, 59, 999), e } function zM(t) { kM(1, arguments); var e = DM(t); return GM(e).getTime() === VM(e).getTime() } function jM(t, e) { kM(2, arguments); var n, r = DM(t), i = DM(e), s = NM(r, i), o = Math.abs(UM(r, i)); if (o < 1) n = 0; else { 1 === r.getMonth() && r.getDate() > 27 && r.setDate(30), r.setMonth(r.getMonth() - s * o); var a = NM(r, i) === -s; zM(DM(t)) && 1 === o && 1 === NM(t, i) && (a = !1), n = s * (o - a) } return 0 === n ? 0 : n } function JM(t) { var e = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds())); return e.setUTCFullYear(t.getFullYear()), t.getTime() - e.getTime() } function XM(t) { kM(1, arguments); var e = DM(t); return e.setHours(0, 0, 0, 0), e } var WM = 864e5; function qM(t, e) { kM(2, arguments); var n = XM(t), r = XM(e), i = n.getTime() - JM(n), s = r.getTime() - JM(r); return Math.round((i - s) / WM) } function ZM(t, e) { var n = t.getFullYear() - e.getFullYear() || t.getMonth() - e.getMonth() || t.getDate() - e.getDate() || t.getHours() - e.getHours() || t.getMinutes() - e.getMinutes() || t.getSeconds() - e.getSeconds() || t.getMilliseconds() - e.getMilliseconds(); return n < 0 ? -1 : n > 0 ? 1 : n } function KM(t, e) { kM(2, arguments); var n = DM(t), r = DM(e), i = ZM(n, r), s = Math.abs(qM(n, r)); n.setDate(n.getDate() - i * s); var o = ZM(n, r) === -i, a = i * (s - o); return 0 === a ? 0 : a } function YM(t, e) { kM(2, arguments); var n = DM(t), r = DM(e); return n.getTime() - r.getTime() } var QM = 36e5; function $M(t, e) { kM(2, arguments); var n = YM(t, e) / QM; return n > 0 ? Math.floor(n) : Math.ceil(n) } function tA(t, e) { kM(2, arguments); var n = YM(t, e) / 6e4; return n > 0 ? Math.floor(n) : Math.ceil(n) } function eA(t, e) { kM(2, arguments); var n = YM(t, e) / 1e3; return n > 0 ? Math.floor(n) : Math.ceil(n) } function nA(t) { kM(1, arguments); var e = DM(t); return !isNaN(e) } function rA(t, e) { kM(2, arguments); var n = DM(t), r = LM(e); return isNaN(r) ? new Date(NaN) : r ? (n.setDate(n.getDate() + r), n) : n } function iA(t, e) { kM(2, arguments); var n = LM(e); return rA(t, -n) } function sA(t, e) { kM(2, arguments); var n = DM(t), r = LM(e); if (isNaN(r)) return new Date(NaN); if (!r) return n; var i = n.getDate(), s = new Date(n.getTime()); s.setMonth(n.getMonth() + r + 1, 0); var o = s.getDate(); return i >= o ? s : (n.setFullYear(s.getFullYear(), s.getMonth(), i), n) } function oA(t, e) { kM(2, arguments); var n = LM(e); return sA(t, -n) } function aA(t, e) { if (kM(2, arguments), !e || "object" != typeof e) return new Date(NaN); var n = "years" in e ? LM(e.years) : 0, r = "months" in e ? LM(e.months) : 0, i = "weeks" in e ? LM(e.weeks) : 0, s = "days" in e ? LM(e.days) : 0, o = "hours" in e ? LM(e.hours) : 0, a = "minutes" in e ? LM(e.minutes) : 0, l = "seconds" in e ? LM(e.seconds) : 0, c = oA(DM(t), r + 12 * n), u = iA(c, s + 7 * i), h = a + 60 * o, d = l + 60 * h, p = 1e3 * d, f = new Date(u.getTime() - p); return f } function lA(t, e) { if (1 & t && (Fo(0, "div", 6), Fo(1, "span", 7), ya(2), Zl(3, "number"), No(), Fo(4, "span", 8), ya(5, "DAYS"), No(), No()), 2 & t) { const t = Ko(2).ngIf; ns(2), ba(Yl(3, 1, t.days, "2.0-0")) } } function cA(t, e) { if (1 & t && (Fo(0, "div", 4), Lo(1, lA, 6, 4, "div", 5), Fo(2, "div", 6), Fo(3, "span", 7), ya(4), Zl(5, "number"), No(), Fo(6, "span", 8), ya(7, "HRS"), No(), No(), Fo(8, "div", 6), Fo(9, "span", 7), ya(10), Zl(11, "number"), No(), Fo(12, "span", 8), ya(13, "MINS"), No(), No(), Fo(14, "div", 6), Fo(15, "span", 7), ya(16), Zl(17, "number"), No(), Fo(18, "span", 8), ya(19, "SECS"), No(), No(), No()), 2 & t) { const t = Ko().ngIf; ns(1), Io("ngIf", t.days), ns(3), ba(Yl(5, 4, t.hours, "2.0-0")), ns(6), ba(Yl(11, 7, t.minutes, "2.0-0")), ns(6), ba(Yl(17, 10, t.seconds, "2.0-0")) } } function uA(t, e) { if (1 & t && (Fo(0, "div", 10), Fo(1, "div", 7), ya(2), Zl(3, "number"), No(), Fo(4, "div", 11), ya(5, "DAYS"), No(), No()), 2 & t) { const t = Ko(2).ngIf; ns(2), ba(Yl(3, 1, t.days, "2.0-0")) } } function hA(t, e) { if (1 & t && (Ho(0), Lo(1, uA, 6, 4, "div", 9), Fo(2, "div", 10), Fo(3, "div", 7), ya(4), Zl(5, "number"), No(), Fo(6, "span", 11), ya(7, "HRS"), No(), No(), Fo(8, "div", 10), Fo(9, "div", 7), ya(10), Zl(11, "number"), No(), Fo(12, "div", 11), ya(13, "MINS"), No(), No(), Fo(14, "div", 10), Fo(15, "div", 7), ya(16), Zl(17, "number"), No(), Fo(18, "div", 11), ya(19, "SECS"), No(), No(), Uo()), 2 & t) { const t = Ko().ngIf; ns(1), Io("ngIf", t.days), ns(3), ba(Yl(5, 4, t.hours, "2.0-0")), ns(6), ba(Yl(11, 7, t.minutes, "2.0-0")), ns(6), ba(Yl(17, 10, t.seconds, "2.0-0")) } } const dA = function (t) { return { "text-gray": t } }; function pA(t, e) { if (1 & t && (Fo(0, "div", 1), Lo(1, cA, 20, 13, "div", 2), Lo(2, hA, 20, 13, "ng-container", 3), No()), 2 & t) { const t = Ko(); 4, n = dA, r = t.ended, function (t, e, n, r) { const i = Ie(), s = Xe(2); i.firstUpdatePass && ha(i, null, s, r); const o = De(); if (n !== es && Co(o, s, n)) { const a = i.data[an()]; if (va(a, r) && !ua(i, s)) { let t = a.classesWithoutHost; null !== t && (n = st(t, n || "")), Oo(i, a, o, n, r) } else !function (t, e, n, r, i, s, o, a) { i === es && (i = Ft); let l = 0, c = 0, u = 0 < i.length ? i[0] : null, h = 0 < s.length ? s[0] : null; for (; null !== u || null !== h;) { const o = l < i.length ? i[l + 1] : void 0, d = c < s.length ? s[c + 1] : void 0; let p, f = null; u === h ? (l += 2, c += 2, o !== d && (f = h, p = d)) : null === h || null !== u && u < h ? (l += 2, f = u) : (c += 2, f = h, p = d), null !== f && fa(t, e, n, r, f, p, !0, a), u = l < i.length ? i[l] : null, h = c < s.length ? s[c] : null } }(i, a, o, o[11], o[s + 1], o[s + 1] = function (t, e, n) { if (null == n || "" === n) return Ft; const r = [], i = Lr(n); if (Array.isArray(i)) for (let s = 0; s < i.length; s++)t(r, i[s], !0); else if ("object" == typeof i) for (const s in i) i.hasOwnProperty(s) && t(r, s, i[s]); else "string" == typeof i && e(r, i); return r }(t, e, n), 0, s) } }(ir, la, Wl(De(), ze(), 4, n, r, void 0), !0), ns(1), Io("ngIf", "horizontal" === t.variant), ns(1), Io("ngIf", "horizontal" != t.variant) } var n, r } let fA = (() => { class t { constructor(t) { this.platformId = t, this.strings$ = id(this.dateObject()), this.ended = !0 } dateObject() { const t = new Date, e = new Date(this.date || Date()); return this.ended = t > e, this.ended ? { hours: 0, minutes: 0, seconds: 0 } : function (t) { var e = t.start, n = t.end; kM(1, arguments); var r = DM(e), i = DM(n); if (!nA(r)) throw new RangeError("Start Date is invalid"); if (!nA(i)) throw new RangeError("End Date is invalid"); var s = { years: 0, months: 0, days: 0, hours: 0, minutes: 0, seconds: 0 }, o = NM(r, i); s.years = Math.abs(HM(r, i)); var a = aA(r, { years: o * s.years }); s.months = Math.abs(jM(a, i)); var l = aA(a, { months: o * s.months }); s.days = Math.abs(KM(l, i)); var c = aA(l, { days: o * s.days }); s.hours = Math.abs($M(c, i)); var u = aA(c, { hours: o * s.hours }); s.minutes = Math.abs(tA(u, i)); var h = aA(u, { minutes: o * s.minutes }); return s.seconds = Math.abs(eA(h, i)), s }({ start: t, end: e }) } ngOnInit() { return vE(this, void 0, void 0, function* () { gh(this.platformId) && (this.ended = !1, this.strings$ = i_(0, 1e3).pipe(P(() => this.dateObject()))) }) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ac)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-count-down"]], inputs: { date: "date", variant: "variant" }, decls: 2, vars: 3, consts: [["class", "flex items-center", 3, "class", 4, "ngIf"], [1, "flex", "items-center"], ["class", "flex", 4, "ngIf"], [4, "ngIf"], [1, "flex"], ["class", "pr-5", 4, "ngIf"], [1, "pr-5"], [1, "blockquote"], [1, "h5", "align-text-top"], ["class", "flex flex-col content-center", 4, "ngIf"], [1, "flex", "flex-col", "content-center"], [1, "h5"]], template: function (t, e) { 1 & t && (Lo(0, pA, 3, 6, "div", 0), Zl(1, "async")), 2 & t && Io("ngIf", Kl(1, 1, e.strings$)) }, directives: [th], pipes: [hh, fh], styles: [".blockquote[_ngcontent-%COMP%], .h5[_ngcontent-%COMP%]{padding-left:.5rem;padding-right:.5rem;text-align:center}.blockquote[_ngcontent-%COMP%]{--tw-text-opacity:1;color:rgba(255,128,0,var(--tw-text-opacity));width:4rem}"] }), t })(); function mA(t, e) { 1 & t && Bo(0, "ga-count-down", 4), 2 & t && Io("date", Ko().start) } function gA(t, e) { 1 & t && (Fo(0, "p", 5), ya(1, "OPEN"), No()) } function vA(t, e) { 1 & t && (Fo(0, "p", 5), ya(1, "CLOSED"), No()) } let yA = (() => { class t { constructor() { this.phaseType = wM } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-auction-count-down"]], inputs: { phase: "phase", start: "start" }, decls: 6, vars: 4, consts: [[1, "-mb-2"], [1, "h5"], [3, "date", 4, "ngIf"], ["class", "blockquote text-primary", 4, "ngIf"], [3, "date"], [1, "blockquote", "text-primary"]], template: function (t, e) { 1 & t && (Fo(0, "div", 0), Fo(1, "p", 1), ya(2), No(), Lo(3, mA, 1, 1, "ga-count-down", 2), Lo(4, gA, 2, 0, "p", 3), Lo(5, vA, 2, 0, "p", 3), No()), 2 & t && (ns(2), _a(" ", e.phase === e.phaseType.BEFORE ? "Starting In" : "Sale Status", " "), ns(1), Io("ngIf", e.phase === e.phaseType.BEFORE), ns(1), Io("ngIf", e.phase === e.phaseType.DURING), ns(1), Io("ngIf", e.phase === e.phaseType.AFTER)) }, directives: [th, fA], styles: ["p[_ngcontent-%COMP%]{text-align:center}"] }), t })(); function bA(t, e) { if (1 & t) { const t = Go(); Ho(0), Fo(1, "div", 1), Fo(2, "div", 2), Fo(3, "div", 3), Bo(4, "ga-auction-information", 4), No(), Fo(5, "div", 5), Fo(6, "div", 6), Bo(7, "ga-auction-count-down", 7), No(), Fo(8, "div"), Fo(9, "p", 8), ya(10, "Price Per VOX"), No(), Fo(11, "p", 9), ya(12), Zl(13, "bigNumber"), No(), No(), Fo(14, "div"), Fo(15, "p", 8), ya(16, "VOX Remaining"), No(), Fo(17, "p", 9), ya(18), Zl(19, "bigNumber"), No(), Fo(20, "p", 8), ya(21), Zl(22, "bigNumber"), No(), No(), Fo(23, "div", 6), Fo(24, "div", 10), Fo(25, "ga-button", 11), Jo("click", function () { const e = Oe(t).ngIf, n = Ko(); return null != e.session && e.session.address ? n.confirmPurchase().subscribe() : n.login() }), ya(26, " Buy VOX "), No(), No(), No(), No(), No(), No(), Uo() } if (2 & t) { const t = e.ngIf, n = Ko(); ns(4), Io("drop", n.drop), ns(3), Io("phase", t.phase)("start", t.start), ns(5), _a(" ", Kl(13, 7, t.price), " ETH "), ns(6), _a(" ", Yl(19, 9, t.supply - t.sold, 0), " "), ns(3), _a("", Yl(22, 12, t.sold, 0), " VOX Sold"), ns(4), Io("disabled", t.phase === n.phaseType.BEFORE || t.phase === n.phaseType.AFTER) } } let _A = (() => { class t { constructor(t, e, n, r, i, s, o, a) { this.dialog = t, this.selfService = e, this.sessionService = n, this.blockchain = r, this.snackbar = i, this.router = s, this.platformId = o, this.gaService = a, this.changes$ = new $m(void 0), this.drop$ = this.changes$.pipe(P(() => this.drop)), this.biddingError = SM, this.session$ = this.sessionService.session$, this.phaseType = wM, this.contract$ = this.drop$.pipe(P(t => zE.getReadOnlyVoxContract(this.drop.address)), u_()), this.price$ = this.contract$.pipe(V(t => t.PRICE())), this.supply$ = this.contract$.pipe(V(t => t.maxSupply())), this.sold$ = i_(0, 15e3).pipe(TM(this.contract$), V(([, t]) => B(t.totalSupply()))), this.start$ = this.contract$.pipe(V(t => t.saleStartTimestamp())).pipe(P(t => { const e = new Date(0); return e.setUTCSeconds(t.toNumber()), e })), this.passwordEnd$ = this.start$.pipe(P(t => function (t, e) { kM(2, arguments); var n = LM(e); return IM(t, 1e3 * n) }(t, this.drop.passwordDuration || 0))), this.phase$ = ig([gh(this.platformId) ? i_(0, 1e3) : id(!0), this.start$, this.supply$, this.sold$]).pipe(P(([, t, e, n]) => this.getPhase(t, e, n))), this.data$ = ig([this.session$, this.price$, this.supply$, this.sold$, this.start$, this.phase$]).pipe(P(([t, e, n, r, i, s]) => ({ session: t, price: e, supply: n, sold: r, start: i, phase: s }))) } login() { this.selfService.goToLogin() } confirmPurchase() { return this.passwordEnd$.pipe(V(t => this.drop.passwordHash && this.drop.passwordDuration && new Date < t ? this.dialog.prompt("Enter the Secret Password", "Password", "", "password").pipe(V(t => vE(this, void 0, void 0, function* () { const e = (new TextEncoder).encode(t); return zE.buf2hex(yield crypto.subtle.digest("SHA-256", e)) })), V(t => '834611dfa9a04560d0a1388bc07d51aec677af00eec2810efe5dcdfc5d6d7e1b' !== this.drop.passwordHash ? (this.snackbar.error("Incorrect password"), Xd) : id(null))) : id(null)), V(() => this.dialog.open(RM, { drop: this.drop, auctionDisplay: "Open Edition" })), od(t => !!(null == t ? void 0 : t.quantity)), P(t => t), ep(({ quantity: t }) => vE(this, void 0, void 0, function* () { const e = yield zE.getWritableVoxContract(this.drop.address), n = yield e.PRICE(); return this.gaService.eventEmitter("Open Edition", "purchase", "on buy VOX", t), e.mintNFT(t, { value: n.mul(t) }) })), yg(t => (this.handleMetamaskError(null == t ? void 0 : t.code), Xd)), V(t => (this.displayPendingTransactionPopup().subscribe(), B(this.blockchain.watchTransaction(t)))), V(t => (this.dialog.closeAll(), t.status ? this.displaySuccessfulTransactionPopup() : this.displayUnsuccessfulTransactionPopup()))) } displaySuccessfulTransactionPopup() { return this.dialog.confirm("Transaction Successful!", "Congratulations you have successfully purchased a VOX!", { yesText: "View Collection" }).pipe(Dg(() => { this.gaService.eventEmitter("Open Edition", "purchase", "on naviagate to collection"), this.router.navigate(["profile/collection"]) })) } displayUnsuccessfulTransactionPopup() { return this.dialog.confirm("Transaction Unsuccessful", "The transaction failed to process.", { yesText: "Continue" }) } displayPendingTransactionPopup() { return this.dialog.confirm("Pending Transaction", "Waiting for minting transaction to complete. Once minted your VOX will appear in your collection page.", { yesText: "Continue" }) } handleMetamaskError(t) { switch (t) { case 4001: break; default: this.snackbar.error("An error occured while processing the transaction") } } getPhase(t, e, n) { return new Date < t ? wM.BEFORE : e.sub(n).isZero() ? wM.AFTER : wM.DURING } ngOnChanges(t) { t.drop && this.changes$.next(this.drop) } } return t.\u0275fac = function (e) { return new (e || t)(Do(mM), Do(jE), Do(yM), Do(zE), Do(iM), Do(fb), Do(Ac), Do(gM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-open-edition-auction"]], inputs: { drop: "drop" }, features: [he], decls: 2, vars: 3, consts: [[4, "ngIf"], [1, "container", "flex", "flex-col"], [1, "flex", "flex-col", "lg:flex-row", "justify-between"], [1, "lg:mr-20", "xl:mr-40", "lg:max-w-md", "xl:max-w-lg"], [3, "drop"], [1, "bidding-control-container", "mt-8", "lg:mt-0", "text-center", "md:text-left"], [1, "md:col-span-2", "items-center"], [3, "phase", "start"], [1, "h5"], [1, "blockquote", "text-primary"], [1, "mb-4", "w-full", "max-w-sm"], ["color", "primary", 1, "w-full", 3, "disabled", "click"]], template: function (t, e) { 1 & t && (Lo(0, bA, 27, 15, "ng-container", 0), Zl(1, "async")), 2 & t && Io("ngIf", Kl(1, 1, e.data$)) }, directives: [th, FM, yA, QE], pipes: [hh, AM], styles: [""] }), t })(); function wA(t, e, n) { return 0 === n ? [e] : (t.push(e), t) } function SA() { return function (t, e) { return arguments.length >= 2 ? function (n) { return b(mg(t, e), wg(1), Cg(e))(n) } : function (e) { return b(mg((e, n, r) => t(e, n, r + 1)), wg(1))(e) } }(wA, []) } let xA = 0; const TA = new Kn("CdkAccordion"); let EA = (() => { class t { constructor() { this._stateChanges = new M, this._openCloseAllActions = new M, this.id = "cdk-accordion-" + xA++, this._multi = !1 } get multi() { return this._multi } set multi(t) { this._multi = Bb(t) } openAll() { this._multi && this._openCloseAllActions.next(!0) } closeAll() { this._openCloseAllActions.next(!1) } ngOnChanges(t) { this._stateChanges.next(t) } ngOnDestroy() { this._stateChanges.complete(), this._openCloseAllActions.complete() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["cdk-accordion"], ["", "cdkAccordion", ""]], inputs: { multi: "multi" }, exportAs: ["cdkAccordion"], features: [Ua([{ provide: TA, useExisting: t }]), he] }), t })(), MA = 0, AA = (() => { class t { constructor(t, e, n) { this.accordion = t, this._changeDetectorRef = e, this._expansionDispatcher = n, this._openCloseAllSubscription = d.EMPTY, this.closed = new ec, this.opened = new ec, this.destroyed = new ec, this.expandedChange = new ec, this.id = "cdk-accordion-child-" + MA++, this._expanded = !1, this._disabled = !1, this._removeUniqueSelectionListener = () => { }, this._removeUniqueSelectionListener = n.listen((t, e) => { this.accordion && !this.accordion.multi && this.accordion.id === e && this.id !== t && (this.expanded = !1) }), this.accordion && (this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions()) } get expanded() { return this._expanded } set expanded(t) { t = Bb(t), this._expanded !== t && (this._expanded = t, this.expandedChange.emit(t), t ? (this.opened.emit(), this._expansionDispatcher.notify(this.id, this.accordion ? this.accordion.id : this.id)) : this.closed.emit(), this._changeDetectorRef.markForCheck()) } get disabled() { return this._disabled } set disabled(t) { this._disabled = Bb(t) } ngOnDestroy() { this.opened.complete(), this.closed.complete(), this.destroyed.emit(), this.destroyed.complete(), this._removeUniqueSelectionListener(), this._openCloseAllSubscription.unsubscribe() } toggle() { this.disabled || (this.expanded = !this.expanded) } close() { this.disabled || (this.expanded = !1) } open() { this.disabled || (this.expanded = !0) } _subscribeToOpenCloseAllActions() { return this.accordion._openCloseAllActions.subscribe(t => { this.disabled || (this.expanded = t) }) } } return t.\u0275fac = function (e) { return new (e || t)(Do(TA, 12), Do(bl), Do(M_)) }, t.\u0275dir = Yt({ type: t, selectors: [["cdk-accordion-item"], ["", "cdkAccordionItem", ""]], inputs: { expanded: "expanded", disabled: "disabled" }, outputs: { closed: "closed", opened: "opened", destroyed: "destroyed", expandedChange: "expandedChange" }, exportAs: ["cdkAccordionItem"], features: [Ua([{ provide: TA, useValue: void 0 }])] }), t })(); const CA = ["body"]; function PA(t, e) { } const RA = [[["mat-expansion-panel-header"]], "*", [["mat-action-row"]]], LA = ["mat-expansion-panel-header", "*", "mat-action-row"]; function kA(t, e) { 1 & t && Bo(0, "span", 2), 2 & t && Io("@indicatorRotate", Ko()._getExpandedState()) } const DA = [[["mat-panel-title"]], [["mat-panel-description"]], "*"], IA = ["mat-panel-title", "mat-panel-description", "*"], OA = new Kn("MAT_ACCORDION"), FA = "225ms cubic-bezier(0.4,0.0,0.2,1)", NA = { indicatorRotate: pp("indicatorRotate", [vp("collapsed, void", gp({ transform: "rotate(0deg)" })), vp("expanded", gp({ transform: "rotate(180deg)" })), yp("expanded <=> collapsed, void => collapsed", fp(FA))]), bodyExpansion: pp("bodyExpansion", [vp("collapsed, void", gp({ height: "0px", visibility: "hidden" })), vp("expanded", gp({ height: "*", visibility: "visible" })), yp("expanded <=> collapsed, void => collapsed", fp(FA))]) }; let BA = (() => { class t { constructor(t) { this._template = t } } return t.\u0275fac = function (e) { return new (e || t)(Do(Tl)) }, t.\u0275dir = Yt({ type: t, selectors: [["ng-template", "matExpansionPanelContent", ""]] }), t })(), HA = 0; const UA = new Kn("MAT_EXPANSION_PANEL_DEFAULT_OPTIONS"); let GA = (() => { class t extends AA { constructor(t, e, n, r, i, s, o) { super(t, e, n), this._viewContainerRef = r, this._animationMode = s, this._hideToggle = !1, this.afterExpand = new ec, this.afterCollapse = new ec, this._inputChanges = new M, this._headerId = "mat-expansion-panel-header-" + HA++, this._bodyAnimationDone = new M, this.accordion = t, this._document = i, this._bodyAnimationDone.pipe(Yb((t, e) => t.fromState === e.fromState && t.toState === e.toState)).subscribe(t => { "void" !== t.fromState && ("expanded" === t.toState ? this.afterExpand.emit() : "collapsed" === t.toState && this.afterCollapse.emit()) }), o && (this.hideToggle = o.hideToggle) } get hideToggle() { return this._hideToggle || this.accordion && this.accordion.hideToggle } set hideToggle(t) { this._hideToggle = Bb(t) } get togglePosition() { return this._togglePosition || this.accordion && this.accordion.togglePosition } set togglePosition(t) { this._togglePosition = t } _hasSpacing() { return !!this.accordion && this.expanded && "default" === this.accordion.displayMode } _getExpandedState() { return this.expanded ? "expanded" : "collapsed" } toggle() { this.expanded = !this.expanded } close() { this.expanded = !1 } open() { this.expanded = !0 } ngAfterContentInit() { this._lazyContent && this.opened.pipe(fg(null), od(() => this.expanded && !this._portal), hg(1)).subscribe(() => { this._portal = new D_(this._lazyContent._template, this._viewContainerRef) }) } ngOnChanges(t) { this._inputChanges.next(t) } ngOnDestroy() { super.ngOnDestroy(), this._bodyAnimationDone.complete(), this._inputChanges.complete() } _containsFocus() { if (this._body) { const t = this._document.activeElement, e = this._body.nativeElement; return t === e || e.contains(t) } return !1 } } return t.\u0275fac = function (e) { return new (e || t)(Do(OA, 12), Do(bl), Do(M_), Do(Ll), Do(wu), Do(qm, 8), Do(UA, 8)) }, t.\u0275cmp = Jt({ type: t, selectors: [["mat-expansion-panel"]], contentQueries: function (t, e, n) { if (1 & t && mc(n, BA, 5), 2 & t) { let t; pc(t = gc()) && (e._lazyContent = t.first) } }, viewQuery: function (t, e) { if (1 & t && fc(CA, 5), 2 & t) { let t; pc(t = gc()) && (e._body = t.first) } }, hostAttrs: [1, "mat-expansion-panel"], hostVars: 6, hostBindings: function (t, e) { 2 & t && aa("mat-expanded", e.expanded)("_mat-animation-noopable", "NoopAnimations" === e._animationMode)("mat-expansion-panel-spacing", e._hasSpacing()) }, inputs: { disabled: "disabled", expanded: "expanded", hideToggle: "hideToggle", togglePosition: "togglePosition" }, outputs: { opened: "opened", closed: "closed", expandedChange: "expandedChange", afterExpand: "afterExpand", afterCollapse: "afterCollapse" }, exportAs: ["matExpansionPanel"], features: [Ua([{ provide: OA, useValue: void 0 }]), vo, he], ngContentSelectors: LA, decls: 7, vars: 4, consts: [["role", "region", 1, "mat-expansion-panel-content", 3, "id"], ["body", ""], [1, "mat-expansion-panel-body"], [3, "cdkPortalOutlet"]], template: function (t, e) { 1 & t && (Qo(RA), $o(0), Fo(1, "div", 0, 1), Jo("@bodyExpansion.done", function (t) { return e._bodyAnimationDone.next(t) }), Fo(3, "div", 2), $o(4, 1), Lo(5, PA, 0, 0, "ng-template", 3), No(), $o(6, 2), No()), 2 & t && (ns(1), Io("@bodyExpansion", e._getExpandedState())("id", e.id), Ro("aria-labelledby", e._headerId), ns(4), Io("cdkPortalOutlet", e._portal)) }, directives: [N_], styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);position:relative}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}.cdk-high-contrast-active .mat-expansion-panel{outline:solid 1px}.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel,.mat-expansion-panel._mat-animation-noopable{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base,.mat-action-row button.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base,[dir=rtl] .mat-action-row button.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"], encapsulation: 2, data: { animation: [NA.bodyExpansion] }, changeDetection: 0 }), t })(); class VA { } const zA = oS(VA); let jA = (() => { class t extends zA { constructor(t, e, n, r, i, s, o) { super(), this.panel = t, this._element = e, this._focusMonitor = n, this._changeDetectorRef = r, this._animationMode = s, this._parentChangeSubscription = d.EMPTY; const a = t.accordion ? t.accordion._stateChanges.pipe(od(t => !(!t.hideToggle && !t.togglePosition))) : Xd; this.tabIndex = parseInt(o || "") || 0, this._parentChangeSubscription = W(t.opened, t.closed, a, t._inputChanges.pipe(od(t => !!(t.hideToggle || t.disabled || t.togglePosition)))).subscribe(() => this._changeDetectorRef.markForCheck()), t.closed.pipe(od(() => t._containsFocus())).subscribe(() => n.focusVia(e, "program")), i && (this.expandedHeight = i.expandedHeight, this.collapsedHeight = i.collapsedHeight) } get disabled() { return this.panel.disabled } _toggle() { this.disabled || this.panel.toggle() } _isExpanded() { return this.panel.expanded } _getExpandedState() { return this.panel._getExpandedState() } _getPanelId() { return this.panel.id } _getTogglePosition() { return this.panel.togglePosition } _showToggle() { return !this.panel.hideToggle && !this.panel.disabled } _getHeaderHeight() { const t = this._isExpanded(); return t && this.expandedHeight ? this.expandedHeight : !t && this.collapsedHeight ? this.collapsedHeight : null } _keydown(t) { switch (t.keyCode) { case 32: case 13: H_(t) || (t.preventDefault(), this._toggle()); break; default: return void (this.panel.accordion && this.panel.accordion._handleHeaderKeydown(t)) } } focus(t, e) { t ? this._focusMonitor.focusVia(this._element, t, e) : this._element.nativeElement.focus(e) } ngAfterViewInit() { this._focusMonitor.monitor(this._element).subscribe(t => { t && this.panel.accordion && this.panel.accordion._handleHeaderFocus(this) }) } ngOnDestroy() { this._parentChangeSubscription.unsubscribe(), this._focusMonitor.stopMonitoring(this._element) } } return t.\u0275fac = function (e) { return new (e || t)(Do(GA, 1), Do(Wa), Do(Ww), Do(bl), Do(UA, 8), Do(qm, 8), Wn("tabindex")) }, t.\u0275cmp = Jt({ type: t, selectors: [["mat-expansion-panel-header"]], hostAttrs: ["role", "button", 1, "mat-expansion-panel-header", "mat-focus-indicator"], hostVars: 15, hostBindings: function (t, e) { 1 & t && Jo("click", function () { return e._toggle() })("keydown", function (t) { return e._keydown(t) }), 2 & t && (Ro("id", e.panel._headerId)("tabindex", e.tabIndex)("aria-controls", e._getPanelId())("aria-expanded", e._isExpanded())("aria-disabled", e.panel.disabled), oa("height", e._getHeaderHeight()), aa("mat-expanded", e._isExpanded())("mat-expansion-toggle-indicator-after", "after" === e._getTogglePosition())("mat-expansion-toggle-indicator-before", "before" === e._getTogglePosition())("_mat-animation-noopable", "NoopAnimations" === e._animationMode)) }, inputs: { tabIndex: "tabIndex", expandedHeight: "expandedHeight", collapsedHeight: "collapsedHeight" }, features: [vo], ngContentSelectors: IA, decls: 5, vars: 1, consts: [[1, "mat-content"], ["class", "mat-expansion-indicator", 4, "ngIf"], [1, "mat-expansion-indicator"]], template: function (t, e) { 1 & t && (Qo(DA), Fo(0, "span", 0), $o(1), $o(2, 1), $o(3, 2), No(), Lo(4, kA, 1, 1, "span", 1)), 2 & t && (ns(4), Io("ngIf", e._showToggle())) }, directives: [th], styles: ['.mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit;transition:height 225ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel-header._mat-animation-noopable{transition:none}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:"";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}.cdk-high-contrast-active .mat-expansion-panel .mat-expansion-panel-header.cdk-keyboard-focused:not([aria-disabled=true])::before,.cdk-high-contrast-active .mat-expansion-panel .mat-expansion-panel-header.cdk-program-focused:not([aria-disabled=true])::before,.cdk-high-contrast-active .mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:hover:not([aria-disabled=true])::before{top:0;left:0;right:0;bottom:0;position:absolute;box-sizing:border-box;pointer-events:none;border:3px solid;border-radius:4px;content:""}\n'], encapsulation: 2, data: { animation: [NA.indicatorRotate] }, changeDetection: 0 }), t })(), JA = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["mat-panel-title"]], hostAttrs: [1, "mat-expansion-panel-header-title"] }), t })(), XA = (() => { class t extends EA { constructor() { super(...arguments), this._ownHeaders = new rc, this._hideToggle = !1, this.displayMode = "default", this.togglePosition = "after" } get hideToggle() { return this._hideToggle } set hideToggle(t) { this._hideToggle = Bb(t) } ngAfterContentInit() { this._headers.changes.pipe(fg(this._headers)).subscribe(t => { this._ownHeaders.reset(t.filter(t => t.panel.accordion === this)), this._ownHeaders.notifyOnChanges() }), this._keyManager = new Pw(this._ownHeaders).withWrap().withHomeAndEnd() } _handleHeaderKeydown(t) { this._keyManager.onKeydown(t) } _handleHeaderFocus(t) { this._keyManager.updateActiveItem(t) } ngOnDestroy() { super.ngOnDestroy(), this._ownHeaders.destroy() } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = Jn(t)))(n || t) } }(), t.\u0275dir = Yt({ type: t, selectors: [["mat-accordion"]], contentQueries: function (t, e, n) { if (1 & t && mc(n, jA, 5), 2 & t) { let t; pc(t = gc()) && (e._headers = t) } }, hostAttrs: [1, "mat-accordion"], hostVars: 2, hostBindings: function (t, e) { 2 & t && aa("mat-accordion-multi", e.multi) }, inputs: { multi: "multi", displayMode: "displayMode", togglePosition: "togglePosition", hideToggle: "hideToggle" }, exportAs: ["matAccordion"], features: [Ua([{ provide: OA, useExisting: t }]), vo] }), t })(); function WA(t, e) { if (1 & t && (Fo(0, "mat-expansion-panel"), Fo(1, "mat-expansion-panel-header"), Fo(2, "mat-panel-title"), Fo(3, "h4"), ya(4), No(), No(), No(), Bo(5, "p", 1), No()), 2 & t) { const t = e.$implicit; ns(4), ba(t.question), ns(1), Io("innerHTML", t.answer, ii) } } const qA = n(4585); let ZA = (() => { class t { constructor(t) { this.content = t, this.faqs$ = this.content.getFaqs().pipe(V(t => B(t.sort((t, e) => new Date(t._createdAt) < new Date(e._createdAt) ? -1 : 1))), P(t => { const e = qA({ blocks: t.answer }); return { question: t.question, answer: e } }), SA()) } } return t.\u0275fac = function (e) { return new (e || t)(Do(ZE)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-faq"]], decls: 3, vars: 3, consts: [[4, "ngFor", "ngForOf"], [3, "innerHTML"]], template: function (t, e) { 1 & t && (Fo(0, "mat-accordion"), Lo(1, WA, 6, 2, "mat-expansion-panel", 0), Zl(2, "async"), No()), 2 & t && (ns(1), Io("ngForOf", Kl(2, 1, e.faqs$))) }, directives: [XA, Qu, GA, jA, JA], pipes: [hh], styles: [""] }), t })(); function KA(t, e) { if (1 & t && Bo(0, "img", 6), 2 & t) { const t = Ko().ngIf; Io("src", t.drop.imageUrl, si)("alt", t.drop.name) } } function YA(t, e) { if (1 & t && (Fo(0, "video", 7), Bo(1, "source", 8), No()), 2 & t) { const t = Ko().ngIf; ns(1), Io("src", t.drop.bannerUrl, si) } } function QA(t, e) { if (1 & t && (Ho(0), Bo(1, "ga-open-edition-auction", 9), Fo(2, "div", 10), Fo(3, "h2"), ya(4, "FAQs"), No(), Bo(5, "ga-faq"), No(), Uo()), 2 & t) { const t = Ko().ngIf; ns(1), Io("drop", t.drop) } } function $A(t, e) { if (1 & t && (Ho(0), Fo(1, "div", 1), Fo(2, "div", 2), Lo(3, KA, 1, 2, "img", 3), Lo(4, YA, 2, 1, "video", 4), No(), Fo(5, "div", 5), Lo(6, QA, 6, 1, "ng-container", 0), No(), No(), Uo()), 2 & t) { const t = e.ngIf; ns(2), oa("background-color", t.drop.bannerColor), ns(1), Io("ngIf", "png" == t.fileType || "jpg" == t.fileType || "gif" == t.fileType), ns(1), Io("ngIf", "mp4" == t.fileType), ns(2), Io("ngIf", t.drop) } } let tC = (() => { class t { constructor(t, e, n, r) { this.route = t, this.content = e, this.dialog = n, this.loadingService = r, this.slug$ = this.route.params.pipe(xM("slug")), this.drop$ = this.slug$.pipe(V(t => this.content.getDrop(t)), u_()), this.fileType$ = this.drop$.pipe(P(t => t.bannerUrl.slice(-3))), this.loaded$ = this.loadingService.watch(this.drop$, this.fileType$).pipe(P(([t, e]) => ({ drop: t, fileType: e }))) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Xv), Do(ZE), Do(mM), Do(vM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-drop"]], decls: 2, vars: 3, consts: [[4, "ngIf"], [1, "flex", "flex-col"], [1, "flex", "items-center", "lg:py-8", "flex", "justify-center", "items-center", "xl:h-screen-3/4"], ["class", "w-full mx-auto lg:w-auto lg:h-screen-1/2", 3, "src", "alt", 4, "ngIf"], ["autoplay", "", "muted", "", "loop", "", "class", "h-full", 4, "ngIf"], [1, "mat-elevation-z16", "flex-grow", "bg-gray-lightest"], [1, "w-full", "mx-auto", "lg:w-auto", "lg:h-screen-1/2", 3, "src", "alt"], ["autoplay", "", "muted", "", "loop", "", 1, "h-full"], ["type", "video/mp4", 3, "src"], [3, "drop"], [1, "container", "py-16", "faqs"]], template: function (t, e) { 1 & t && (Lo(0, $A, 7, 5, "ng-container", 0), Zl(1, "async")), 2 & t && Io("ngIf", Kl(1, 1, e.loaded$)) }, directives: [th, _A, ZA], pipes: [hh], styles: ["[_nghost-%COMP%]{flex-grow:1}.faqs[_ngcontent-%COMP%]{max-width:1000px}"] }), t })(), eC = (() => { class t { constructor() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-faqs"]], decls: 9, vars: 0, consts: [[1, "container"], [1, "grid", "md:grid-cols-2", "gap-8", "mb-16"], ["src", "assets/lumberjack-vox.png", 1, "w-full"], [1, "flex", "flex-col", "justify-center"], [1, "display-4"]], template: function (t, e) { 1 & t && (Fo(0, "div", 0), Fo(1, "div", 1), Bo(2, "img", 2), Fo(3, "div", 3), Fo(4, "h1", 4), ya(5, "FAQs"), No(), Fo(6, "h3"), ya(7, "We know you will have lots of questions\u2026"), No(), No(), No(), Bo(8, "ga-faq"), No()) }, directives: [ZA], styles: [".container[_ngcontent-%COMP%]{max-width:1000px}"] }), t })(); const nC = 100, rC = 1e3, iC = 1001, sC = 1002, oC = 1003, aC = 1004, lC = 1005, cC = 1006, uC = 1008, hC = 1009, dC = 1012, pC = 1014, fC = 1015, mC = 1016, gC = 1020, vC = 1022, yC = 1023, bC = 1026, _C = 1027, wC = 2300, SC = 2301, xC = 2302, TC = 2400, EC = 2401, MC = 2402, AC = 3e3, CC = 3001, PC = 7680, RC = 35044, LC = 35048, kC = "300 es"; class DC { addEventListener(t, e) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e) } hasEventListener(t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) } removeEventListener(t, e) { if (void 0 === this._listeners) return; const n = this._listeners[t]; if (void 0 !== n) { const t = n.indexOf(e); -1 !== t && n.splice(t, 1) } } dispatchEvent(t) { if (void 0 === this._listeners) return; const e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; const n = e.slice(0); for (let e = 0, r = n.length; e < r; e++)n[e].call(this, t); t.target = null } } } const IC = []; for (let Oz = 0; Oz < 256; Oz++)IC[Oz] = (Oz < 16 ? "0" : "") + Oz.toString(16); let OC = 1234567; const FC = Math.PI / 180, NC = 180 / Math.PI; function BC() { const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (IC[255 & t] + IC[t >> 8 & 255] + IC[t >> 16 & 255] + IC[t >> 24 & 255] + "-" + IC[255 & e] + IC[e >> 8 & 255] + "-" + IC[e >> 16 & 15 | 64] + IC[e >> 24 & 255] + "-" + IC[63 & n | 128] + IC[n >> 8 & 255] + "-" + IC[n >> 16 & 255] + IC[n >> 24 & 255] + IC[255 & r] + IC[r >> 8 & 255] + IC[r >> 16 & 255] + IC[r >> 24 & 255]).toUpperCase() } function HC(t, e, n) { return Math.max(e, Math.min(n, t)) } function UC(t, e) { return (t % e + e) % e } function GC(t, e, n) { return (1 - n) * t + n * e } function VC(t) { return 0 == (t & t - 1) && 0 !== t } function zC(t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) } function jC(t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) } var JC = Object.freeze({ __proto__: null, DEG2RAD: FC, RAD2DEG: NC, generateUUID: BC, clamp: HC, euclideanModulo: UC, mapLinear: function (t, e, n, r, i) { return r + (t - e) * (i - r) / (n - e) }, inverseLerp: function (t, e, n) { return t !== e ? (n - t) / (e - t) : 0 }, lerp: GC, damp: function (t, e, n, r) { return GC(t, e, 1 - Math.exp(-n * r)) }, pingpong: function (t, e = 1) { return e - Math.abs(UC(t, 2 * e) - e) }, smoothstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, seededRandom: function (t) { return void 0 !== t && (OC = t % 2147483647), OC = 16807 * OC % 2147483647, (OC - 1) / 2147483646 }, degToRad: function (t) { return t * FC }, radToDeg: function (t) { return t * NC }, isPowerOfTwo: VC, ceilPowerOfTwo: zC, floorPowerOfTwo: jC, setQuaternionFromProperEuler: function (t, e, n, r, i) { const s = Math.cos, o = Math.sin, a = s(n / 2), l = o(n / 2), c = s((e + r) / 2), u = o((e + r) / 2), h = s((e - r) / 2), d = o((e - r) / 2), p = s((r - e) / 2), f = o((r - e) / 2); switch (i) { case "XYX": t.set(a * u, l * h, l * d, a * c); break; case "YZY": t.set(l * d, a * u, l * h, a * c); break; case "ZXZ": t.set(l * h, l * d, a * u, a * c); break; case "XZX": t.set(a * u, l * f, l * p, a * c); break; case "YXY": t.set(l * p, a * u, l * f, a * c); break; case "ZYZ": t.set(l * f, l * p, a * u, a * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i) } } }); class XC { constructor(t = 0, e = 0) { this.x = t, this.y = e } get width() { return this.x } set width(t) { this.x = t } get height() { return this.y } set height(t) { this.y = t } set(t, e) { return this.x = t, this.y = e, this } setScalar(t) { return this.x = t, this.y = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y) } copy(t) { return this.x = t.x, this.y = t.y, this } add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) } addScalar(t) { return this.x += t, this.y += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this } sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) } subScalar(t) { return this.x -= t, this.y -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this } divide(t) { return this.x /= t.x, this.y /= t.y, this } divideScalar(t) { return this.multiplyScalar(1 / t) } applyMatrix3(t) { const e = this.x, n = this.y, r = t.elements; return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(t) { return this.x * t.x + this.y * t.y } cross(t) { return this.x * t.y - this.y * t.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, n = this.y - t.y; return e * e + n * n } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this } equals(t) { return t.x === this.x && t.y === this.y } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t } fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this } rotateAround(t, e) { const n = Math.cos(e), r = Math.sin(e), i = this.x - t.x, s = this.y - t.y; return this.x = i * n - s * r + t.x, this.y = i * r + s * n + t.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } } XC.prototype.isVector2 = !0; class WC { constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } set(t, e, n, r, i, s, o, a, l) { const c = this.elements; return c[0] = t, c[1] = r, c[2] = o, c[3] = e, c[4] = i, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this } extractBasis(t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this } multiply(t) { return this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const n = t.elements, r = e.elements, i = this.elements, s = n[0], o = n[3], a = n[6], l = n[1], c = n[4], u = n[7], h = n[2], d = n[5], p = n[8], f = r[0], m = r[3], g = r[6], v = r[1], y = r[4], b = r[7], _ = r[2], w = r[5], S = r[8]; return i[0] = s * f + o * v + a * _, i[3] = s * m + o * y + a * w, i[6] = s * g + o * b + a * S, i[1] = l * f + c * v + u * _, i[4] = l * m + c * y + u * w, i[7] = l * g + c * b + u * S, i[2] = h * f + d * v + p * _, i[5] = h * m + d * y + p * w, i[8] = h * g + d * b + p * S, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this } determinant() { const t = this.elements, e = t[0], n = t[1], r = t[2], i = t[3], s = t[4], o = t[5], a = t[6], l = t[7], c = t[8]; return e * s * c - e * o * l - n * i * c + n * o * a + r * i * l - r * s * a } invert() { const t = this.elements, e = t[0], n = t[1], r = t[2], i = t[3], s = t[4], o = t[5], a = t[6], l = t[7], c = t[8], u = c * s - o * l, h = o * a - c * i, d = l * i - s * a, p = e * u + n * h + r * d; if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const f = 1 / p; return t[0] = u * f, t[1] = (r * l - c * n) * f, t[2] = (o * n - r * s) * f, t[3] = h * f, t[4] = (c * e - r * a) * f, t[5] = (r * i - o * e) * f, t[6] = d * f, t[7] = (n * a - l * e) * f, t[8] = (s * e - n * i) * f, this } transpose() { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this } getNormalMatrix(t) { return this.setFromMatrix4(t).invert().transpose() } transposeIntoArray(t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this } setUvTransform(t, e, n, r, i, s, o) { const a = Math.cos(i), l = Math.sin(i); return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -r * l, r * a, -r * (-l * s + a * o) + o + e, 0, 0, 1), this } scale(t, e) { const n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this } rotate(t) { const e = Math.cos(t), n = Math.sin(t), r = this.elements, i = r[0], s = r[3], o = r[6], a = r[1], l = r[4], c = r[7]; return r[0] = e * i + n * a, r[3] = e * s + n * l, r[6] = e * o + n * c, r[1] = -n * i + e * a, r[4] = -n * s + e * l, r[7] = -n * o + e * c, this } translate(t, e) { const n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this } equals(t) { const e = this.elements, n = t.elements; for (let r = 0; r < 9; r++)if (e[r] !== n[r]) return !1; return !0 } fromArray(t, e = 0) { for (let n = 0; n < 9; n++)this.elements[n] = t[n + e]; return this } toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t } clone() { return (new this.constructor).fromArray(this.elements) } } let qC; WC.prototype.isMatrix3 = !0; class ZC { static getDataURL(t) { if (/^data:/i.test(t.src)) return t.src; if ("undefined" == typeof HTMLCanvasElement) return t.src; let e; if (t instanceof HTMLCanvasElement) e = t; else { void 0 === qC && (qC = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), qC.width = t.width, qC.height = t.height; const n = qC.getContext("2d"); t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = qC } return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png") } } let KC = 0; class YC extends DC { constructor(t = YC.DEFAULT_IMAGE, e = YC.DEFAULT_MAPPING, n = 1001, r = 1001, i = 1006, s = 1008, o = 1023, a = 1009, l = 1, c = 3e3) { super(), Object.defineProperty(this, "id", { value: KC++ }), this.uuid = BC(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new XC(0, 0), this.repeat = new XC(1, 1), this.center = new XC(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new WC, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this } toJSON(t) { const e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const r = this.image; if (void 0 === r.uuid && (r.uuid = BC()), !e && void 0 === t.images[r.uuid]) { let e; if (Array.isArray(r)) { e = []; for (let t = 0, n = r.length; t < n; t++)e.push(QC(r[t].isDataTexture ? r[t].image : r[t])) } else e = QC(r); t.images[r.uuid] = { uuid: r.uuid, url: e } } n.image = r.uuid } return e || (t.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(t) { if (300 !== this.mapping) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) { case rC: t.x = t.x - Math.floor(t.x); break; case iC: t.x = t.x < 0 ? 0 : 1; break; case sC: t.x = 1 === Math.abs(Math.floor(t.x) % 2) ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x) }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case rC: t.y = t.y - Math.floor(t.y); break; case iC: t.y = t.y < 0 ? 0 : 1; break; case sC: t.y = 1 === Math.abs(Math.floor(t.y) % 2) ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } set needsUpdate(t) { !0 === t && this.version++ } } function QC(t) { return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? ZC.getDataURL(t) : t.data ? { data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } YC.DEFAULT_IMAGE = void 0, YC.DEFAULT_MAPPING = 300, YC.prototype.isTexture = !0; class $C { constructor(t = 0, e = 0, n = 0, r = 1) { this.x = t, this.y = e, this.z = n, this.w = r } get width() { return this.z } set width(t) { this.z = t } get height() { return this.w } set height(t) { this.w = t } set(t, e, n, r) { return this.x = t, this.y = e, this.z = n, this.w = r, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this.w = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setW(t) { return this.w = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this } add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) } addScalar(t) { return this.x += t, this.y += t, this.z += t, this.w += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this } sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this } applyMatrix4(t) { const e = this.x, n = this.y, r = this.z, i = this.w, s = t.elements; return this.x = s[0] * e + s[4] * n + s[8] * r + s[12] * i, this.y = s[1] * e + s[5] * n + s[9] * r + s[13] * i, this.z = s[2] * e + s[6] * n + s[10] * r + s[14] * i, this.w = s[3] * e + s[7] * n + s[11] * r + s[15] * i, this } divideScalar(t) { return this.multiplyScalar(1 / t) } setAxisAngleFromQuaternion(t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this } setAxisAngleFromRotationMatrix(t) { let e, n, r, i; const s = .01, o = .1, a = t.elements, l = a[0], c = a[4], u = a[8], h = a[1], d = a[5], p = a[9], f = a[2], m = a[6], g = a[10]; if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) { if (Math.abs(c + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this; e = Math.PI; const t = (l + 1) / 2, a = (d + 1) / 2, v = (g + 1) / 2, y = (c + h) / 4, b = (u + f) / 4, _ = (p + m) / 4; return t > a && t > v ? t < s ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(t), r = y / n, i = b / n) : a > v ? a < s ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(a), n = y / r, i = _ / r) : v < s ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(v), n = b / i, r = _ / i), this.set(n, r, i, e), this } let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)); return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t } fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } } $C.prototype.isVector4 = !0; class tP extends DC { constructor(t, e, n) { super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new $C(0, 0, t, e), this.scissorTest = !1, this.viewport = new $C(0, 0, t, e), this.texture = new YC(void 0, (n = n || {}).mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = 1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : cC, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } setTexture(t) { t.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t } setSize(t, e, n = 1) { this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = { ...this.texture.image }, this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } tP.prototype.isWebGLRenderTarget = !0, class extends tP { constructor(t, e, n) { super(t, e); const r = this.texture; this.texture = []; for (let i = 0; i < n; i++)this.texture[i] = r.clone() } setSize(t, e, n = 1) { if (this.width !== t || this.height !== e || this.depth !== n) { this.width = t, this.height = e, this.depth = n; for (let r = 0, i = this.texture.length; r < i; r++)this.texture[r].image.width = t, this.texture[r].image.height = e, this.texture[r].image.depth = n; this.dispose() } return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this } copy(t) { this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0; for (let e = 0, n = t.texture.length; e < n; e++)this.texture[e] = t.texture[e].clone(); return this } }.prototype.isWebGLMultipleRenderTargets = !0; class eP extends tP { constructor(t, e, n) { super(t, e, n), this.samples = 4 } copy(t) { return super.copy.call(this, t), this.samples = t.samples, this } } eP.prototype.isWebGLMultisampleRenderTarget = !0; class nP { constructor(t = 0, e = 0, n = 0, r = 1) { this._x = t, this._y = e, this._z = n, this._w = r } static slerp(t, e, n, r) { return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, r) } static slerpFlat(t, e, n, r, i, s, o) { let a = n[r + 0], l = n[r + 1], c = n[r + 2], u = n[r + 3]; const h = i[s + 0], d = i[s + 1], p = i[s + 2], f = i[s + 3]; if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void (t[e + 3] = u); if (1 === o) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = p, void (t[e + 3] = f); if (u !== f || a !== h || l !== d || c !== p) { let t = 1 - o; const e = a * h + l * d + c * p + u * f, n = e >= 0 ? 1 : -1, r = 1 - e * e; if (r > Number.EPSILON) { const i = Math.sqrt(r), s = Math.atan2(i, e * n); t = Math.sin(t * s) / i, o = Math.sin(o * s) / i } const i = o * n; if (a = a * t + h * i, l = l * t + d * i, c = c * t + p * i, u = u * t + f * i, t === 1 - o) { const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u); a *= t, l *= t, c *= t, u *= t } } t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = u } static multiplyQuaternionsFlat(t, e, n, r, i, s) { const o = n[r], a = n[r + 1], l = n[r + 2], c = n[r + 3], u = i[s], h = i[s + 1], d = i[s + 2], p = i[s + 3]; return t[e] = o * p + c * u + a * d - l * h, t[e + 1] = a * p + c * h + l * u - o * d, t[e + 2] = l * p + c * d + o * h - a * u, t[e + 3] = c * p - o * u - a * h - l * d, t } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get w() { return this._w } set w(t) { this._w = t, this._onChangeCallback() } set(t, e, n, r) { return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this } setFromEuler(t, e) { if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const n = t._x, r = t._y, i = t._z, s = t._order, o = Math.cos, a = Math.sin, l = o(n / 2), c = o(r / 2), u = o(i / 2), h = a(n / 2), d = a(r / 2), p = a(i / 2); switch (s) { case "XYZ": this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p; break; case "YXZ": this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p; break; case "ZXY": this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p; break; case "ZYX": this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p; break; case "YZX": this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p; break; case "XZY": this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s) }return !1 !== e && this._onChangeCallback(), this } setFromAxisAngle(t, e) { const n = e / 2, r = Math.sin(n); return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(t) { const e = t.elements, n = e[0], r = e[4], i = e[8], s = e[1], o = e[5], a = e[9], l = e[2], c = e[6], u = e[10], h = n + o + u; if (h > 0) { const t = .5 / Math.sqrt(h + 1); this._w = .25 / t, this._x = (c - a) * t, this._y = (i - l) * t, this._z = (s - r) * t } else if (n > o && n > u) { const t = 2 * Math.sqrt(1 + n - o - u); this._w = (c - a) / t, this._x = .25 * t, this._y = (r + s) / t, this._z = (i + l) / t } else if (o > u) { const t = 2 * Math.sqrt(1 + o - n - u); this._w = (i - l) / t, this._x = (r + s) / t, this._y = .25 * t, this._z = (a + c) / t } else { const t = 2 * Math.sqrt(1 + u - n - o); this._w = (s - r) / t, this._x = (i + l) / t, this._y = (a + c) / t, this._z = .25 * t } return this._onChangeCallback(), this } setFromUnitVectors(t, e) { let n = t.dot(e) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() } angleTo(t) { return 2 * Math.acos(Math.abs(HC(this.dot(t), -1, 1))) } rotateTowards(t, e) { const n = this.angleTo(t); if (0 === n) return this; const r = Math.min(1, e / n); return this.slerp(t, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this } multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) } premultiply(t) { return this.multiplyQuaternions(t, this) } multiplyQuaternions(t, e) { const n = t._x, r = t._y, i = t._z, s = t._w, o = e._x, a = e._y, l = e._z, c = e._w; return this._x = n * c + s * o + r * l - i * a, this._y = r * c + s * a + i * o - n * l, this._z = i * c + s * l + n * a - r * o, this._w = s * c - n * o - r * a - i * l, this._onChangeCallback(), this } slerp(t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); const n = this._x, r = this._y, i = this._z, s = this._w; let o = s * t._w + n * t._x + r * t._y + i * t._z; if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = r, this._z = i, this; const a = 1 - o * o; if (a <= Number.EPSILON) { const t = 1 - e; return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * r + e * this._y, this._z = t * i + e * this._z, this.normalize(), this._onChangeCallback(), this } const l = Math.sqrt(a), c = Math.atan2(l, o), u = Math.sin((1 - e) * c) / l, h = Math.sin(e * c) / l; return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = r * u + this._y * h, this._z = i * u + this._z * h, this._onChangeCallback(), this } slerpQuaternions(t, e, n) { this.copy(t).slerp(e, n) } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w } fromArray(t, e = 0) { return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this } toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t } fromBufferAttribute(t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } } nP.prototype.isQuaternion = !0; class rP { constructor(t = 0, e = 0, n = 0) { this.x = t, this.y = e, this.z = n } set(t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this } add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) } addScalar(t) { return this.x += t, this.y += t, this.z += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this } sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this } multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this } multiplyVectors(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this } applyEuler(t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(sP.setFromEuler(t)) } applyAxisAngle(t, e) { return this.applyQuaternion(sP.setFromAxisAngle(t, e)) } applyMatrix3(t) { const e = this.x, n = this.y, r = this.z, i = t.elements; return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this } applyNormalMatrix(t) { return this.applyMatrix3(t).normalize() } applyMatrix4(t) { const e = this.x, n = this.y, r = this.z, i = t.elements, s = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]); return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * s, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * s, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * s, this } applyQuaternion(t) { const e = this.x, n = this.y, r = this.z, i = t.x, s = t.y, o = t.z, a = t.w, l = a * e + s * r - o * n, c = a * n + o * e - i * r, u = a * r + i * n - s * e, h = -i * e - s * n - o * r; return this.x = l * a + h * -i + c * -o - u * -s, this.y = c * a + h * -s + u * -i - l * -o, this.z = u * a + h * -o + l * -s - c * -i, this } project(t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) } unproject(t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) } transformDirection(t) { const e = this.x, n = this.y, r = this.z, i = t.elements; return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize() } divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this } divideScalar(t) { return this.multiplyScalar(1 / t) } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this } cross(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) } crossVectors(t, e) { const n = t.x, r = t.y, i = t.z, s = e.x, o = e.y, a = e.z; return this.x = r * a - i * o, this.y = i * s - n * a, this.z = n * o - r * s, this } projectOnVector(t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) } projectOnPlane(t) { return iP.copy(this).projectOnVector(t), this.sub(iP) } reflect(t) { return this.sub(iP.copy(t).multiplyScalar(2 * this.dot(t))) } angleTo(t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const n = this.dot(t) / e; return Math.acos(HC(n, -1, 1)) } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, n = this.y - t.y, r = this.z - t.z; return e * e + n * n + r * r } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) } setFromSpherical(t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) } setFromSphericalCoords(t, e, n) { const r = Math.sin(e) * t; return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this } setFromCylindrical(t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) } setFromCylindricalCoords(t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this } setFromMatrixPosition(t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this } setFromMatrixScale(t) { const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), r = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = n, this.z = r, this } setFromMatrixColumn(t, e) { return this.fromArray(t.elements, 4 * e) } setFromMatrix3Column(t, e) { return this.fromArray(t.elements, 3 * e) } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t } fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } } rP.prototype.isVector3 = !0; const iP = new rP, sP = new nP; class oP { constructor(t = new rP(1 / 0, 1 / 0, 1 / 0), e = new rP(-1 / 0, -1 / 0, -1 / 0)) { this.min = t, this.max = e } set(t, e) { return this.min.copy(t), this.max.copy(e), this } setFromArray(t) { let e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, s = -1 / 0, o = -1 / 0; for (let a = 0, l = t.length; a < l; a += 3) { const l = t[a], c = t[a + 1], u = t[a + 2]; l < e && (e = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > s && (s = c), u > o && (o = u) } return this.min.set(e, n, r), this.max.set(i, s, o), this } setFromBufferAttribute(t) { let e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, s = -1 / 0, o = -1 / 0; for (let a = 0, l = t.count; a < l; a++) { const l = t.getX(a), c = t.getY(a), u = t.getZ(a); l < e && (e = l), c < n && (n = c), u < r && (r = u), l > i && (i = l), c > s && (s = c), u > o && (o = u) } return this.min.set(e, n, r), this.max.set(i, s, o), this } setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this } setFromCenterAndSize(t, e) { const n = lP.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } setFromObject(t) { return this.makeEmpty(), this.expandByObject(t) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(t) { return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new rP), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(t) { return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new rP), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) } expandByPoint(t) { return this.min.min(t), this.max.max(t), this } expandByVector(t) { return this.min.sub(t), this.max.add(t), this } expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this } expandByObject(t) { t.updateWorldMatrix(!1, !1); const e = t.geometry; void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), cP.copy(e.boundingBox), cP.applyMatrix4(t.matrixWorld), this.union(cP)); const n = t.children; for (let r = 0, i = n.length; r < i; r++)this.expandByObject(n[r]); return this } containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) } containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z } getParameter(t, e) { return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new rP), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) } intersectsSphere(t) { return this.clampPoint(t.center, lP), lP.distanceToSquared(t.center) <= t.radius * t.radius } intersectsPlane(t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant } intersectsTriangle(t) { if (this.isEmpty()) return !1; this.getCenter(gP), vP.subVectors(this.max, gP), uP.subVectors(t.a, gP), hP.subVectors(t.b, gP), dP.subVectors(t.c, gP), pP.subVectors(hP, uP), fP.subVectors(dP, hP), mP.subVectors(uP, dP); let e = [0, -pP.z, pP.y, 0, -fP.z, fP.y, 0, -mP.z, mP.y, pP.z, 0, -pP.x, fP.z, 0, -fP.x, mP.z, 0, -mP.x, -pP.y, pP.x, 0, -fP.y, fP.x, 0, -mP.y, mP.x, 0]; return !!_P(e, uP, hP, dP, vP) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!_P(e, uP, hP, dP, vP) && (yP.crossVectors(pP, fP), e = [yP.x, yP.y, yP.z], _P(e, uP, hP, dP, vP))) } clampPoint(t, e) { return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new rP), e.copy(t).clamp(this.min, this.max) } distanceToPoint(t) { return lP.copy(t).clamp(this.min, this.max).sub(t).length() } getBoundingSphere(t) { return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(lP).length(), t } intersect(t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this } union(t) { return this.min.min(t.min), this.max.max(t.max), this } applyMatrix4(t) { return this.isEmpty() || (aP[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), aP[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), aP[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), aP[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), aP[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), aP[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), aP[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), aP[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(aP)), this } translate(t) { return this.min.add(t), this.max.add(t), this } equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) } } oP.prototype.isBox3 = !0; const aP = [new rP, new rP, new rP, new rP, new rP, new rP, new rP, new rP], lP = new rP, cP = new oP, uP = new rP, hP = new rP, dP = new rP, pP = new rP, fP = new rP, mP = new rP, gP = new rP, vP = new rP, yP = new rP, bP = new rP; function _P(t, e, n, r, i) { for (let s = 0, o = t.length - 3; s <= o; s += 3) { bP.fromArray(t, s); const o = i.x * Math.abs(bP.x) + i.y * Math.abs(bP.y) + i.z * Math.abs(bP.z), a = e.dot(bP), l = n.dot(bP), c = r.dot(bP); if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1 } return !0 } const wP = new oP, SP = new rP, xP = new rP, TP = new rP; class EP { constructor(t = new rP, e = -1) { this.center = t, this.radius = e } set(t, e) { return this.center.copy(t), this.radius = e, this } setFromPoints(t, e) { const n = this.center; void 0 !== e ? n.copy(e) : wP.setFromPoints(t).getCenter(n); let r = 0; for (let i = 0, s = t.length; i < s; i++)r = Math.max(r, n.distanceToSquared(t[i])); return this.radius = Math.sqrt(r), this } copy(t) { return this.center.copy(t.center), this.radius = t.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(t) { return t.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(t) { return t.distanceTo(this.center) - this.radius } intersectsSphere(t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e } intersectsBox(t) { return t.intersectsSphere(this) } intersectsPlane(t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius } clampPoint(t, e) { const n = this.center.distanceToSquared(t); return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new rP), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e } getBoundingBox(t) { return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new oP), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) } applyMatrix4(t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this } translate(t) { return this.center.add(t), this } expandByPoint(t) { TP.subVectors(t, this.center); const e = TP.lengthSq(); if (e > this.radius * this.radius) { const t = Math.sqrt(e), n = .5 * (t - this.radius); this.center.add(TP.multiplyScalar(n / t)), this.radius += n } return this } union(t) { return xP.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(SP.copy(t.center).add(xP)), this.expandByPoint(SP.copy(t.center).sub(xP)), this } equals(t) { return t.center.equals(this.center) && t.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const MP = new rP, AP = new rP, CP = new rP, PP = new rP, RP = new rP, LP = new rP, kP = new rP; class DP { constructor(t = new rP, e = new rP(0, 0, -1)) { this.origin = t, this.direction = e } set(t, e) { return this.origin.copy(t), this.direction.copy(e), this } copy(t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this } at(t, e) { return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new rP), e.copy(this.direction).multiplyScalar(t).add(this.origin) } lookAt(t) { return this.direction.copy(t).sub(this.origin).normalize(), this } recast(t) { return this.origin.copy(this.at(t, MP)), this } closestPointToPoint(t, e) { void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new rP), e.subVectors(t, this.origin); const n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) } distanceToPoint(t) { return Math.sqrt(this.distanceSqToPoint(t)) } distanceSqToPoint(t) { const e = MP.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (MP.copy(this.direction).multiplyScalar(e).add(this.origin), MP.distanceToSquared(t)) } distanceSqToSegment(t, e, n, r) { AP.copy(t).add(e).multiplyScalar(.5), CP.copy(e).sub(t).normalize(), PP.copy(this.origin).sub(AP); const i = .5 * t.distanceTo(e), s = -this.direction.dot(CP), o = PP.dot(this.direction), a = -PP.dot(CP), l = PP.lengthSq(), c = Math.abs(1 - s * s); let u, h, d, p; if (c > 0) if (u = s * a - o, h = s * o - a, p = i * c, u >= 0) if (h >= -p) if (h <= p) { const t = 1 / c; u *= t, h *= t, d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l } else h = i, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l; else h = -i, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l; else h <= -p ? (u = Math.max(0, -(-s * i + o)), h = u > 0 ? -i : Math.min(Math.max(-i, -a), i), d = -u * u + h * (h + 2 * a) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-i, -a), i), d = h * (h + 2 * a) + l) : (u = Math.max(0, -(s * i + o)), h = u > 0 ? i : Math.min(Math.max(-i, -a), i), d = -u * u + h * (h + 2 * a) + l); else h = s > 0 ? -i : i, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l; return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(CP).multiplyScalar(h).add(AP), d } intersectSphere(t, e) { MP.subVectors(t.center, this.origin); const n = MP.dot(this.direction), r = MP.dot(MP) - n * n, i = t.radius * t.radius; if (r > i) return null; const s = Math.sqrt(i - r), o = n - s, a = n + s; return o < 0 && a < 0 ? null : this.at(o < 0 ? a : o, e) } intersectsSphere(t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius } distanceToPlane(t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null } intersectPlane(t, e) { const n = this.distanceToPlane(t); return null === n ? null : this.at(n, e) } intersectsPlane(t) { const e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 } intersectBox(t, e) { let n, r, i, s, o, a; const l = 1 / this.direction.x, c = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin; return l >= 0 ? (n = (t.min.x - h.x) * l, r = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l, r = (t.min.x - h.x) * l), c >= 0 ? (i = (t.min.y - h.y) * c, s = (t.max.y - h.y) * c) : (i = (t.max.y - h.y) * c, s = (t.min.y - h.y) * c), n > s || i > r ? null : ((i > n || n != n) && (n = i), (s < r || r != r) && (r = s), u >= 0 ? (o = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || o > r ? null : ((o > n || n != n) && (n = o), (a < r || r != r) && (r = a), r < 0 ? null : this.at(n >= 0 ? n : r, e))) } intersectsBox(t) { return null !== this.intersectBox(t, MP) } intersectTriangle(t, e, n, r, i) { RP.subVectors(e, t), LP.subVectors(n, t), kP.crossVectors(RP, LP); let s, o = this.direction.dot(kP); if (o > 0) { if (r) return null; s = 1 } else { if (!(o < 0)) return null; s = -1, o = -o } PP.subVectors(this.origin, t); const a = s * this.direction.dot(LP.crossVectors(PP, LP)); if (a < 0) return null; const l = s * this.direction.dot(RP.cross(PP)); if (l < 0) return null; if (a + l > o) return null; const c = -s * PP.dot(kP); return c < 0 ? null : this.at(c / o, i) } applyMatrix4(t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this } equals(t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class IP { constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } set(t, e, n, r, i, s, o, a, l, c, u, h, d, p, f, m) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = r, g[1] = i, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new IP).fromArray(this.elements) } copy(t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this } copyPosition(t) { const e = this.elements, n = t.elements; return e[12] = n[12], e[13] = n[13], e[14] = n[14], this } setFromMatrix3(t) { const e = t.elements; return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this } extractBasis(t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(t) { const e = this.elements, n = t.elements, r = 1 / OP.setFromMatrixColumn(t, 0).length(), i = 1 / OP.setFromMatrixColumn(t, 1).length(), s = 1 / OP.setFromMatrixColumn(t, 2).length(); return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromEuler(t) { t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const e = this.elements, n = t.x, r = t.y, i = t.z, s = Math.cos(n), o = Math.sin(n), a = Math.cos(r), l = Math.sin(r), c = Math.cos(i), u = Math.sin(i); if ("XYZ" === t.order) { const t = s * c, n = s * u, r = o * c, i = o * u; e[0] = a * c, e[4] = -a * u, e[8] = l, e[1] = n + r * l, e[5] = t - i * l, e[9] = -o * a, e[2] = i - t * l, e[6] = r + n * l, e[10] = s * a } else if ("YXZ" === t.order) { const t = a * c, n = a * u, r = l * c, i = l * u; e[0] = t + i * o, e[4] = r * o - n, e[8] = s * l, e[1] = s * u, e[5] = s * c, e[9] = -o, e[2] = n * o - r, e[6] = i + t * o, e[10] = s * a } else if ("ZXY" === t.order) { const t = a * c, n = a * u, r = l * c, i = l * u; e[0] = t - i * o, e[4] = -s * u, e[8] = r + n * o, e[1] = n + r * o, e[5] = s * c, e[9] = i - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a } else if ("ZYX" === t.order) { const t = s * c, n = s * u, r = o * c, i = o * u; e[0] = a * c, e[4] = r * l - n, e[8] = t * l + i, e[1] = a * u, e[5] = i * l + t, e[9] = n * l - r, e[2] = -l, e[6] = o * a, e[10] = s * a } else if ("YZX" === t.order) { const t = s * a, n = s * l, r = o * a, i = o * l; e[0] = a * c, e[4] = i - t * u, e[8] = r * u + n, e[1] = u, e[5] = s * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * u + r, e[10] = t - i * u } else if ("XZY" === t.order) { const t = s * a, n = s * l, r = o * a, i = o * l; e[0] = a * c, e[4] = -u, e[8] = l * c, e[1] = t * u + i, e[5] = s * c, e[9] = n * u - r, e[2] = r * u - n, e[6] = o * c, e[10] = i * u + t } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromQuaternion(t) { return this.compose(NP, t, BP) } lookAt(t, e, n) { const r = this.elements; return GP.subVectors(t, e), 0 === GP.lengthSq() && (GP.z = 1), GP.normalize(), HP.crossVectors(n, GP), 0 === HP.lengthSq() && (1 === Math.abs(n.z) ? GP.x += 1e-4 : GP.z += 1e-4, GP.normalize(), HP.crossVectors(n, GP)), HP.normalize(), UP.crossVectors(GP, HP), r[0] = HP.x, r[4] = UP.x, r[8] = GP.x, r[1] = HP.y, r[5] = UP.y, r[9] = GP.y, r[2] = HP.z, r[6] = UP.z, r[10] = GP.z, this } multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const n = t.elements, r = e.elements, i = this.elements, s = n[0], o = n[4], a = n[8], l = n[12], c = n[1], u = n[5], h = n[9], d = n[13], p = n[2], f = n[6], m = n[10], g = n[14], v = n[3], y = n[7], b = n[11], _ = n[15], w = r[0], S = r[4], x = r[8], T = r[12], E = r[1], M = r[5], A = r[9], C = r[13], P = r[2], R = r[6], L = r[10], k = r[14], D = r[3], I = r[7], O = r[11], F = r[15]; return i[0] = s * w + o * E + a * P + l * D, i[4] = s * S + o * M + a * R + l * I, i[8] = s * x + o * A + a * L + l * O, i[12] = s * T + o * C + a * k + l * F, i[1] = c * w + u * E + h * P + d * D, i[5] = c * S + u * M + h * R + d * I, i[9] = c * x + u * A + h * L + d * O, i[13] = c * T + u * C + h * k + d * F, i[2] = p * w + f * E + m * P + g * D, i[6] = p * S + f * M + m * R + g * I, i[10] = p * x + f * A + m * L + g * O, i[14] = p * T + f * C + m * k + g * F, i[3] = v * w + y * E + b * P + _ * D, i[7] = v * S + y * M + b * R + _ * I, i[11] = v * x + y * A + b * L + _ * O, i[15] = v * T + y * C + b * k + _ * F, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this } determinant() { const t = this.elements, e = t[0], n = t[4], r = t[8], i = t[12], s = t[1], o = t[5], a = t[9], l = t[13], c = t[2], u = t[6], h = t[10], d = t[14]; return t[3] * (+i * a * u - r * l * u - i * o * h + n * l * h + r * o * d - n * a * d) + t[7] * (+e * a * d - e * l * h + i * s * h - r * s * d + r * l * c - i * a * c) + t[11] * (+e * l * u - e * o * d - i * s * u + n * s * d + i * o * c - n * l * c) + t[15] * (-r * o * c - e * a * u + e * o * h + r * s * u - n * s * h + n * a * c) } transpose() { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this } setPosition(t, e, n) { const r = this.elements; return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this } invert() { const t = this.elements, e = t[0], n = t[1], r = t[2], i = t[3], s = t[4], o = t[5], a = t[6], l = t[7], c = t[8], u = t[9], h = t[10], d = t[11], p = t[12], f = t[13], m = t[14], g = t[15], v = u * m * l - f * h * l + f * a * d - o * m * d - u * a * g + o * h * g, y = p * h * l - c * m * l - p * a * d + s * m * d + c * a * g - s * h * g, b = c * f * l - p * u * l + p * o * d - s * f * d - c * o * g + s * u * g, _ = p * u * a - c * f * a - p * o * h + s * f * h + c * o * m - s * u * m, w = e * v + n * y + r * b + i * _; if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const S = 1 / w; return t[0] = v * S, t[1] = (f * h * i - u * m * i - f * r * d + n * m * d + u * r * g - n * h * g) * S, t[2] = (o * m * i - f * a * i + f * r * l - n * m * l - o * r * g + n * a * g) * S, t[3] = (u * a * i - o * h * i - u * r * l + n * h * l + o * r * d - n * a * d) * S, t[4] = y * S, t[5] = (c * m * i - p * h * i + p * r * d - e * m * d - c * r * g + e * h * g) * S, t[6] = (p * a * i - s * m * i - p * r * l + e * m * l + s * r * g - e * a * g) * S, t[7] = (s * h * i - c * a * i + c * r * l - e * h * l - s * r * d + e * a * d) * S, t[8] = b * S, t[9] = (p * u * i - c * f * i - p * n * d + e * f * d + c * n * g - e * u * g) * S, t[10] = (s * f * i - p * o * i + p * n * l - e * f * l - s * n * g + e * o * g) * S, t[11] = (c * o * i - s * u * i - c * n * l + e * u * l + s * n * d - e * o * d) * S, t[12] = _ * S, t[13] = (c * f * r - p * u * r + p * n * h - e * f * h - c * n * m + e * u * m) * S, t[14] = (p * o * r - s * f * r - p * n * a + e * f * a + s * n * m - e * o * m) * S, t[15] = (s * u * r - c * o * r + c * n * a - e * u * a - s * n * h + e * o * h) * S, this } scale(t) { const e = this.elements, n = t.x, r = t.y, i = t.z; return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this } getMaxScaleOnAxis() { const t = this.elements; return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10])) } makeTranslation(t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this } makeRotationY(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this } makeRotationZ(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(t, e) { const n = Math.cos(e), r = Math.sin(e), i = 1 - n, s = t.x, o = t.y, a = t.z, l = i * s, c = i * o; return this.set(l * s + n, l * o - r * a, l * a + r * o, 0, l * o + r * a, c * o + n, c * a - r * s, 0, l * a - r * o, c * a + r * s, i * a * a + n, 0, 0, 0, 0, 1), this } makeScale(t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(t, e, n, r, i, s) { return this.set(1, n, i, 0, t, 1, s, 0, e, r, 1, 0, 0, 0, 0, 1), this } compose(t, e, n) { const r = this.elements, i = e._x, s = e._y, o = e._z, a = e._w, l = i + i, c = s + s, u = o + o, h = i * l, d = i * c, p = i * u, f = s * c, m = s * u, g = o * u, v = a * l, y = a * c, b = a * u, _ = n.x, w = n.y, S = n.z; return r[0] = (1 - (f + g)) * _, r[1] = (d + b) * _, r[2] = (p - y) * _, r[3] = 0, r[4] = (d - b) * w, r[5] = (1 - (h + g)) * w, r[6] = (m + v) * w, r[7] = 0, r[8] = (p + y) * S, r[9] = (m - v) * S, r[10] = (1 - (h + f)) * S, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this } decompose(t, e, n) { const r = this.elements; let i = OP.set(r[0], r[1], r[2]).length(); const s = OP.set(r[4], r[5], r[6]).length(), o = OP.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], FP.copy(this); const a = 1 / i, l = 1 / s, c = 1 / o; return FP.elements[0] *= a, FP.elements[1] *= a, FP.elements[2] *= a, FP.elements[4] *= l, FP.elements[5] *= l, FP.elements[6] *= l, FP.elements[8] *= c, FP.elements[9] *= c, FP.elements[10] *= c, e.setFromRotationMatrix(FP), n.x = i, n.y = s, n.z = o, this } makePerspective(t, e, n, r, i, s) { void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const o = this.elements, a = 2 * i / (n - r), l = (e + t) / (e - t), c = (n + r) / (n - r), u = -(s + i) / (s - i), h = -2 * s * i / (s - i); return o[0] = 2 * i / (e - t), o[4] = 0, o[8] = l, o[12] = 0, o[1] = 0, o[5] = a, o[9] = c, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = h, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this } makeOrthographic(t, e, n, r, i, s) { const o = this.elements, a = 1 / (e - t), l = 1 / (n - r), c = 1 / (s - i), u = (e + t) * a, h = (n + r) * l, d = (s + i) * c; return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this } equals(t) { const e = this.elements, n = t.elements; for (let r = 0; r < 16; r++)if (e[r] !== n[r]) return !1; return !0 } fromArray(t, e = 0) { for (let n = 0; n < 16; n++)this.elements[n] = t[n + e]; return this } toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t } } IP.prototype.isMatrix4 = !0; const OP = new rP, FP = new IP, NP = new rP(0, 0, 0), BP = new rP(1, 1, 1), HP = new rP, UP = new rP, GP = new rP, VP = new IP, zP = new nP; class jP { constructor(t = 0, e = 0, n = 0, r = jP.DefaultOrder) { this._x = t, this._y = e, this._z = n, this._order = r } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get order() { return this._order } set order(t) { this._order = t, this._onChangeCallback() } set(t, e, n, r) { return this._x = t, this._y = e, this._z = n, this._order = r || this._order, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this } setFromRotationMatrix(t, e, n) { const r = t.elements, i = r[0], s = r[4], o = r[8], a = r[1], l = r[5], c = r[9], u = r[2], h = r[6], d = r[10]; switch (e = e || this._order) { case "XYZ": this._y = Math.asin(HC(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(h, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-HC(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-u, i), this._z = 0); break; case "ZXY": this._x = Math.asin(HC(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, i)); break; case "ZYX": this._y = Math.asin(-HC(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(a, i)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(HC(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(o, d)); break; case "XZY": this._z = Math.asin(-HC(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-c, d), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e) }return this._order = e, !1 !== n && this._onChangeCallback(), this } setFromQuaternion(t, e, n) { return VP.makeRotationFromQuaternion(t), this.setFromRotationMatrix(VP, e, n) } setFromVector3(t, e) { return this.set(t.x, t.y, t.z, e || this._order) } reorder(t) { return zP.setFromEuler(this), this.setFromQuaternion(zP, t) } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order } fromArray(t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this } toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t } toVector3(t) { return t ? t.set(this._x, this._y, this._z) : new rP(this._x, this._y, this._z) } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } } jP.prototype.isEuler = !0, jP.DefaultOrder = "XYZ", jP.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class JP { constructor() { this.mask = 1 } set(t) { this.mask = 1 << t | 0 } enable(t) { this.mask |= 1 << t | 0 } enableAll() { this.mask = -1 } toggle(t) { this.mask ^= 1 << t | 0 } disable(t) { this.mask &= ~(1 << t | 0) } disableAll() { this.mask = 0 } test(t) { return 0 != (this.mask & t.mask) } } let XP = 0; const WP = new rP, qP = new nP, ZP = new IP, KP = new rP, YP = new rP, QP = new rP, $P = new nP, tR = new rP(1, 0, 0), eR = new rP(0, 1, 0), nR = new rP(0, 0, 1), rR = { type: "added" }, iR = { type: "removed" }; class sR extends DC { constructor() { super(), Object.defineProperty(this, "id", { value: XP++ }), this.uuid = BC(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = sR.DefaultUp.clone(); const t = new rP, e = new jP, n = new nP, r = new rP(1, 1, 1); e._onChange(function () { n.setFromEuler(e, !1) }), n._onChange(function () { e.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new IP }, normalMatrix: { value: new WC } }), this.matrix = new IP, this.matrixWorld = new IP, this.matrixAutoUpdate = sR.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new JP, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(t) { return this.quaternion.premultiply(t), this } setRotationFromAxisAngle(t, e) { this.quaternion.setFromAxisAngle(t, e) } setRotationFromEuler(t) { this.quaternion.setFromEuler(t, !0) } setRotationFromMatrix(t) { this.quaternion.setFromRotationMatrix(t) } setRotationFromQuaternion(t) { this.quaternion.copy(t) } rotateOnAxis(t, e) { return qP.setFromAxisAngle(t, e), this.quaternion.multiply(qP), this } rotateOnWorldAxis(t, e) { return qP.setFromAxisAngle(t, e), this.quaternion.premultiply(qP), this } rotateX(t) { return this.rotateOnAxis(tR, t) } rotateY(t) { return this.rotateOnAxis(eR, t) } rotateZ(t) { return this.rotateOnAxis(nR, t) } translateOnAxis(t, e) { return WP.copy(t).applyQuaternion(this.quaternion), this.position.add(WP.multiplyScalar(e)), this } translateX(t) { return this.translateOnAxis(tR, t) } translateY(t) { return this.translateOnAxis(eR, t) } translateZ(t) { return this.translateOnAxis(nR, t) } localToWorld(t) { return t.applyMatrix4(this.matrixWorld) } worldToLocal(t) { return t.applyMatrix4(ZP.copy(this.matrixWorld).invert()) } lookAt(t, e, n) { t.isVector3 ? KP.copy(t) : KP.set(t, e, n); const r = this.parent; this.updateWorldMatrix(!0, !1), YP.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ZP.lookAt(YP, KP, this.up) : ZP.lookAt(KP, YP, this.up), this.quaternion.setFromRotationMatrix(ZP), r && (ZP.extractRotation(r.matrixWorld), qP.setFromRotationMatrix(ZP), this.quaternion.premultiply(qP.invert())) } add(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(rR)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) } remove(t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(iR)), this } removeFromParent() { const t = this.parent; return null !== t && t.remove(this), this } clear() { for (let t = 0; t < this.children.length; t++) { const e = this.children[t]; e.parent = null, e.dispatchEvent(iR) } return this.children.length = 0, this } attach(t) { return this.updateWorldMatrix(!0, !1), ZP.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), ZP.multiply(t.parent.matrixWorld)), t.applyMatrix4(ZP), this.add(t), t.updateWorldMatrix(!1, !0), this } getObjectById(t) { return this.getObjectByProperty("id", t) } getObjectByName(t) { return this.getObjectByProperty("name", t) } getObjectByProperty(t, e) { if (this[t] === e) return this; for (let n = 0, r = this.children.length; n < r; n++) { const r = this.children[n].getObjectByProperty(t, e); if (void 0 !== r) return r } } getWorldPosition(t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new rP), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new nP), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(YP, t, QP), t } getWorldScale(t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new rP), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(YP, $P, t), t } getWorldDirection(t) { void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new rP), this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() } raycast() { } traverse(t) { t(this); const e = this.children; for (let n = 0, r = e.length; n < r; n++)e[n].traverse(t) } traverseVisible(t) { if (!1 === this.visible) return; t(this); const e = this.children; for (let n = 0, r = e.length; n < r; n++)e[n].traverseVisible(t) } traverseAncestors(t) { const e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let n = 0, r = e.length; n < r; n++)e[n].updateMatrixWorld(t) } updateWorldMatrix(t, e) { const n = this.parent; if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, n = t.length; e < n; e++)t[e].updateWorldMatrix(!1, !0) } } toJSON(t) { const e = void 0 === t || "string" == typeof t, n = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const r = {}; function i(e, n) { return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid } if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isMesh || this.isLine || this.isPoints) { r.geometry = i(t.geometries, this.geometry); const e = this.geometry.parameters; if (void 0 !== e && void 0 !== e.shapes) { const n = e.shapes; if (Array.isArray(n)) for (let e = 0, r = n.length; e < r; e++)i(t.shapes, n[e]); else i(t.shapes, n) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const e = []; for (let n = 0, r = this.material.length; n < r; n++)e.push(i(t.materials, this.material[n])); r.material = e } else r.material = i(t.materials, this.material); if (this.children.length > 0) { r.children = []; for (let e = 0; e < this.children.length; e++)r.children.push(this.children[e].toJSON(t).object) } if (this.animations.length > 0) { r.animations = []; for (let e = 0; e < this.animations.length; e++)r.animations.push(i(t.animations, this.animations[e])) } if (e) { const e = s(t.geometries), r = s(t.materials), i = s(t.textures), o = s(t.images), a = s(t.shapes), l = s(t.skeletons), c = s(t.animations); e.length > 0 && (n.geometries = e), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c) } return n.object = r, n; function s(t) { const e = []; for (const n in t) { const r = t[n]; delete r.metadata, e.push(r) } return e } } clone(t) { return (new this.constructor).copy(this, t) } copy(t, e = !0) { if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let n = 0; n < t.children.length; n++)this.add(t.children[n].clone()); return this } } sR.DefaultUp = new rP(0, 1, 0), sR.DefaultMatrixAutoUpdate = !0, sR.prototype.isObject3D = !0; const oR = new rP, aR = new rP, lR = new WC; class cR { constructor(t = new rP(1, 0, 0), e = 0) { this.normal = t, this.constant = e } set(t, e) { return this.normal.copy(t), this.constant = e, this } setComponents(t, e, n, r) { return this.normal.set(t, e, n), this.constant = r, this } setFromNormalAndCoplanarPoint(t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this } setFromCoplanarPoints(t, e, n) { const r = oR.subVectors(n, e).cross(aR.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(r, t), this } copy(t) { return this.normal.copy(t.normal), this.constant = t.constant, this } normalize() { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(t) { return this.normal.dot(t) + this.constant } distanceToSphere(t) { return this.distanceToPoint(t.center) - t.radius } projectPoint(t, e) { return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new rP), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) } intersectLine(t, e) { void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new rP); const n = t.delta(oR), r = this.normal.dot(n); if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null; const i = -(t.start.dot(this.normal) + this.constant) / r; return i < 0 || i > 1 ? null : e.copy(n).multiplyScalar(i).add(t.start) } intersectsLine(t) { const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end); return e < 0 && n > 0 || n < 0 && e > 0 } intersectsBox(t) { return t.intersectsPlane(this) } intersectsSphere(t) { return t.intersectsPlane(this) } coplanarPoint(t) { return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new rP), t.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(t, e) { const n = e || lR.getNormalMatrix(t), r = this.coplanarPoint(oR).applyMatrix4(t), i = this.normal.applyMatrix3(n).normalize(); return this.constant = -r.dot(i), this } translate(t) { return this.constant -= t.dot(this.normal), this } equals(t) { return t.normal.equals(this.normal) && t.constant === this.constant } clone() { return (new this.constructor).copy(this) } } cR.prototype.isPlane = !0; const uR = new rP, hR = new rP, dR = new rP, pR = new rP, fR = new rP, mR = new rP, gR = new rP, vR = new rP, yR = new rP, bR = new rP; class _R { constructor(t = new rP, e = new rP, n = new rP) { this.a = t, this.b = e, this.c = n } static getNormal(t, e, n, r) { void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new rP), r.subVectors(n, e), uR.subVectors(t, e), r.cross(uR); const i = r.lengthSq(); return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0) } static getBarycoord(t, e, n, r, i) { uR.subVectors(r, e), hR.subVectors(n, e), dR.subVectors(t, e); const s = uR.dot(uR), o = uR.dot(hR), a = uR.dot(dR), l = hR.dot(hR), c = hR.dot(dR), u = s * l - o * o; if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new rP), 0 === u) return i.set(-2, -1, -1); const h = 1 / u, d = (l * a - o * c) * h, p = (s * c - o * a) * h; return i.set(1 - d - p, p, d) } static containsPoint(t, e, n, r) { return this.getBarycoord(t, e, n, r, pR), pR.x >= 0 && pR.y >= 0 && pR.x + pR.y <= 1 } static getUV(t, e, n, r, i, s, o, a) { return this.getBarycoord(t, e, n, r, pR), a.set(0, 0), a.addScaledVector(i, pR.x), a.addScaledVector(s, pR.y), a.addScaledVector(o, pR.z), a } static isFrontFacing(t, e, n, r) { return uR.subVectors(n, e), hR.subVectors(t, e), uR.cross(hR).dot(r) < 0 } set(t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this } setFromPointsAndIndices(t, e, n, r) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this } getArea() { return uR.subVectors(this.c, this.b), hR.subVectors(this.a, this.b), .5 * uR.cross(hR).length() } getMidpoint(t) { return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new rP), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(t) { return _R.getNormal(this.a, this.b, this.c, t) } getPlane(t) { return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new cR), t.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(t, e) { return _R.getBarycoord(t, this.a, this.b, this.c, e) } getUV(t, e, n, r, i) { return _R.getUV(t, this.a, this.b, this.c, e, n, r, i) } containsPoint(t) { return _R.containsPoint(t, this.a, this.b, this.c) } isFrontFacing(t) { return _R.isFrontFacing(this.a, this.b, this.c, t) } intersectsBox(t) { return t.intersectsTriangle(this) } closestPointToPoint(t, e) { void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new rP); const n = this.a, r = this.b, i = this.c; let s, o; fR.subVectors(r, n), mR.subVectors(i, n), vR.subVectors(t, n); const a = fR.dot(vR), l = mR.dot(vR); if (a <= 0 && l <= 0) return e.copy(n); yR.subVectors(t, r); const c = fR.dot(yR), u = mR.dot(yR); if (c >= 0 && u <= c) return e.copy(r); const h = a * u - c * l; if (h <= 0 && a >= 0 && c <= 0) return s = a / (a - c), e.copy(n).addScaledVector(fR, s); bR.subVectors(t, i); const d = fR.dot(bR), p = mR.dot(bR); if (p >= 0 && d <= p) return e.copy(i); const f = d * l - a * p; if (f <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(n).addScaledVector(mR, o); const m = c * p - d * u; if (m <= 0 && u - c >= 0 && d - p >= 0) return gR.subVectors(i, r), o = (u - c) / (u - c + (d - p)), e.copy(r).addScaledVector(gR, o); const g = 1 / (m + f + h); return s = f * g, o = h * g, e.copy(n).addScaledVector(fR, s).addScaledVector(mR, o) } equals(t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } } let wR = 0; class SR extends DC { constructor() { super(), Object.defineProperty(this, "id", { value: wR++ }), this.uuid = BC(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = nC, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = PC, this.stencilZFail = PC, this.stencilZPass = PC, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } onBuild() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(t) { if (void 0 !== t) for (const e in t) { const n = t[e]; if (void 0 === n) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue } if ("shading" === e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n; continue } const r = this[e]; void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") } } toJSON(t) { const e = void 0 === t || "string" == typeof t; e && (t = { textures: {}, images: {} }); const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function r(t) { const e = []; for (const n in t) { const r = t[n]; delete r.metadata, e.push(r) } return e } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) { const e = r(t.textures), i = r(t.images); e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i) } return n } clone() { return (new this.constructor).copy(this) } copy(t) { this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; const e = t.clippingPlanes; let n = null; if (null !== e) { const t = e.length; n = new Array(t); for (let r = 0; r !== t; ++r)n[r] = e[r].clone() } return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(t) { !0 === t && this.version++ } } SR.prototype.isMaterial = !0; const xR = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, TR = { h: 0, s: 0, l: 0 }, ER = { h: 0, s: 0, l: 0 }; function MR(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t } function AR(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } function CR(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } let PR = (() => { class t { constructor(t, e, n) { return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) } set(t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this } setScalar(t) { return this.r = t, this.g = t, this.b = t, this } setHex(t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this } setRGB(t, e, n) { return this.r = t, this.g = e, this.b = n, this } setHSL(t, e, n) { if (t = UC(t, 1), e = HC(e, 0, 1), n = HC(n, 0, 1), 0 === e) this.r = this.g = this.b = n; else { const r = n <= .5 ? n * (1 + e) : n + e - n * e, i = 2 * n - r; this.r = MR(i, r, t + 1 / 3), this.g = MR(i, r, t), this.b = MR(i, r, t - 1 / 3) } return this } setStyle(t) { function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let n; if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) { let t; const r = n[2]; switch (n[1]) { case "rgb": case "rgba": if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this; if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this; break; case "hsl": case "hsla": if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) { const n = parseFloat(t[1]) / 360, r = parseInt(t[2], 10) / 100, i = parseInt(t[3], 10) / 100; return e(t[4]), this.setHSL(n, r, i) } } } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) { const t = n[1], e = t.length; if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this; if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this } return t && t.length > 0 ? this.setColorName(t) : this } setColorName(t) { const e = xR[t.toLowerCase()]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this } copyGammaToLinear(t, e = 2) { return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this } copyLinearToGamma(t, e = 2) { const n = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this } convertGammaToLinear(t) { return this.copyGammaToLinear(this, t), this } convertLinearToGamma(t) { return this.copyLinearToGamma(this, t), this } copySRGBToLinear(t) { return this.r = AR(t.r), this.g = AR(t.g), this.b = AR(t.b), this } copyLinearToSRGB(t) { return this.r = CR(t.r), this.g = CR(t.g), this.b = CR(t.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) } getHSL(t) { void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 }); const e = this.r, n = this.g, r = this.b, i = Math.max(e, n, r), s = Math.min(e, n, r); let o, a; const l = (s + i) / 2; if (s === i) o = 0, a = 0; else { const t = i - s; switch (a = l <= .5 ? t / (i + s) : t / (2 - i - s), i) { case e: o = (n - r) / t + (n < r ? 6 : 0); break; case n: o = (r - e) / t + 2; break; case r: o = (e - n) / t + 4 }o /= 6 } return t.h = o, t.s = a, t.l = l, t } getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } offsetHSL(t, e, n) { return this.getHSL(TR), TR.h += t, TR.s += e, TR.l += n, this.setHSL(TR.h, TR.s, TR.l), this } add(t) { return this.r += t.r, this.g += t.g, this.b += t.b, this } addColors(t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this } addScalar(t) { return this.r += t, this.g += t, this.b += t, this } sub(t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this } multiply(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this } multiplyScalar(t) { return this.r *= t, this.g *= t, this.b *= t, this } lerp(t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this } lerpColors(t, e, n) { return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this } lerpHSL(t, e) { this.getHSL(TR), t.getHSL(ER); const n = GC(TR.h, ER.h, e), r = GC(TR.s, ER.s, e), i = GC(TR.l, ER.l, e); return this.setHSL(n, r, i), this } equals(t) { return t.r === this.r && t.g === this.g && t.b === this.b } fromArray(t, e = 0) { return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this } toArray(t = [], e = 0) { return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t } fromBufferAttribute(t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } } return t.NAMES = xR, t })(); PR.prototype.isColor = !0, PR.prototype.r = 1, PR.prototype.g = 1, PR.prototype.b = 1; class RR extends SR { constructor(t) { super(), this.type = "MeshBasicMaterial", this.color = new PR(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this } } RR.prototype.isMeshBasicMaterial = !0; const LR = new rP, kR = new XC; class DR { constructor(t, e, n) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = RC, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(t) { !0 === t && this.version++ } setUsage(t) { return this.usage = t, this } copy(t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this } copyAt(t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let r = 0, i = this.itemSize; r < i; r++)this.array[t + r] = e.array[n + r]; return this } copyArray(t) { return this.array.set(t), this } copyColorsArray(t) { const e = this.array; let n = 0; for (let r = 0, i = t.length; r < i; r++) { let i = t[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new PR), e[n++] = i.r, e[n++] = i.g, e[n++] = i.b } return this } copyVector2sArray(t) { const e = this.array; let n = 0; for (let r = 0, i = t.length; r < i; r++) { let i = t[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new XC), e[n++] = i.x, e[n++] = i.y } return this } copyVector3sArray(t) { const e = this.array; let n = 0; for (let r = 0, i = t.length; r < i; r++) { let i = t[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new rP), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z } return this } copyVector4sArray(t) { const e = this.array; let n = 0; for (let r = 0, i = t.length; r < i; r++) { let i = t[r]; void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new $C), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z, e[n++] = i.w } return this } applyMatrix3(t) { if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)kR.fromBufferAttribute(this, e), kR.applyMatrix3(t), this.setXY(e, kR.x, kR.y); else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)LR.fromBufferAttribute(this, e), LR.applyMatrix3(t), this.setXYZ(e, LR.x, LR.y, LR.z); return this } applyMatrix4(t) { for (let e = 0, n = this.count; e < n; e++)LR.x = this.getX(e), LR.y = this.getY(e), LR.z = this.getZ(e), LR.applyMatrix4(t), this.setXYZ(e, LR.x, LR.y, LR.z); return this } applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++)LR.x = this.getX(e), LR.y = this.getY(e), LR.z = this.getZ(e), LR.applyNormalMatrix(t), this.setXYZ(e, LR.x, LR.y, LR.z); return this } transformDirection(t) { for (let e = 0, n = this.count; e < n; e++)LR.x = this.getX(e), LR.y = this.getY(e), LR.z = this.getZ(e), LR.transformDirection(t), this.setXYZ(e, LR.x, LR.y, LR.z); return this } set(t, e = 0) { return this.array.set(t, e), this } getX(t) { return this.array[t * this.itemSize] } setX(t, e) { return this.array[t * this.itemSize] = e, this } getY(t) { return this.array[t * this.itemSize + 1] } setY(t, e) { return this.array[t * this.itemSize + 1] = e, this } getZ(t) { return this.array[t * this.itemSize + 2] } setZ(t, e) { return this.array[t * this.itemSize + 2] = e, this } getW(t) { return this.array[t * this.itemSize + 3] } setW(t, e) { return this.array[t * this.itemSize + 3] = e, this } setXY(t, e, n) { return this.array[0 + (t *= this.itemSize)] = e, this.array[t + 1] = n, this } setXYZ(t, e, n, r) { return this.array[0 + (t *= this.itemSize)] = e, this.array[t + 1] = n, this.array[t + 2] = r, this } setXYZW(t, e, n, r, i) { return this.array[0 + (t *= this.itemSize)] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this } onUpload(t) { return this.onUploadCallback = t, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; return "" !== this.name && (t.name = this.name), this.usage !== RC && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t } } DR.prototype.isBufferAttribute = !0; class IR extends DR { constructor(t, e, n) { super(new Uint16Array(t), e, n) } } class OR extends DR { constructor(t, e, n) { super(new Uint32Array(t), e, n) } } (class extends DR { constructor(t, e, n) { super(new Uint16Array(t), e, n) } }).prototype.isFloat16BufferAttribute = !0; class FR extends DR { constructor(t, e, n) { super(new Float32Array(t), e, n) } } function NR(t) { if (0 === t.length) return -1 / 0; let e = t[0]; for (let n = 1, r = t.length; n < r; ++n)t[n] > e && (e = t[n]); return e } Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array; let BR = 0; const HR = new IP, UR = new sR, GR = new rP, VR = new oP, zR = new oP, jR = new rP; class JR extends DC { constructor() { super(), Object.defineProperty(this, "id", { value: BR++ }), this.uuid = BC(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(t) { return this.index = Array.isArray(t) ? new (NR(t) > 65535 ? OR : IR)(t, 1) : t, this } getAttribute(t) { return this.attributes[t] } setAttribute(t, e) { return this.attributes[t] = e, this } deleteAttribute(t) { return delete this.attributes[t], this } hasAttribute(t) { return void 0 !== this.attributes[t] } addGroup(t, e, n = 0) { this.groups.push({ start: t, count: e, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(t, e) { this.drawRange.start = t, this.drawRange.count = e } applyMatrix4(t) { const e = this.attributes.position; void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const e = (new WC).getNormalMatrix(t); n.applyNormalMatrix(e), n.needsUpdate = !0 } const r = this.attributes.tangent; return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(t) { return HR.makeRotationFromQuaternion(t), this.applyMatrix4(HR), this } rotateX(t) { return HR.makeRotationX(t), this.applyMatrix4(HR), this } rotateY(t) { return HR.makeRotationY(t), this.applyMatrix4(HR), this } rotateZ(t) { return HR.makeRotationZ(t), this.applyMatrix4(HR), this } translate(t, e, n) { return HR.makeTranslation(t, e, n), this.applyMatrix4(HR), this } scale(t, e, n) { return HR.makeScale(t, e, n), this.applyMatrix4(HR), this } lookAt(t) { return UR.lookAt(t), UR.updateMatrix(), this.applyMatrix4(UR.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(GR).negate(), this.translate(GR.x, GR.y, GR.z), this } setFromPoints(t) { const e = []; for (let n = 0, r = t.length; n < r; n++) { const r = t[n]; e.push(r.x, r.y, r.z || 0) } return this.setAttribute("position", new FR(e, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new oP); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new rP(-1 / 0, -1 / 0, -1 / 0), new rP(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== t) { if (this.boundingBox.setFromBufferAttribute(t), e) for (let n = 0, r = e.length; n < r; n++)VR.setFromBufferAttribute(e[n]), this.morphTargetsRelative ? (jR.addVectors(this.boundingBox.min, VR.min), this.boundingBox.expandByPoint(jR), jR.addVectors(this.boundingBox.max, VR.max), this.boundingBox.expandByPoint(jR)) : (this.boundingBox.expandByPoint(VR.min), this.boundingBox.expandByPoint(VR.max)) } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new EP); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new rP, 1 / 0); if (t) { const n = this.boundingSphere.center; if (VR.setFromBufferAttribute(t), e) for (let t = 0, i = e.length; t < i; t++)zR.setFromBufferAttribute(e[t]), this.morphTargetsRelative ? (jR.addVectors(VR.min, zR.min), VR.expandByPoint(jR), jR.addVectors(VR.max, zR.max), VR.expandByPoint(jR)) : (VR.expandByPoint(zR.min), VR.expandByPoint(zR.max)); VR.getCenter(n); let r = 0; for (let e = 0, i = t.count; e < i; e++)jR.fromBufferAttribute(t, e), r = Math.max(r, n.distanceToSquared(jR)); if (e) for (let i = 0, s = e.length; i < s; i++) { const s = e[i], o = this.morphTargetsRelative; for (let e = 0, i = s.count; e < i; e++)jR.fromBufferAttribute(s, e), o && (GR.fromBufferAttribute(t, e), jR.add(GR)), r = Math.max(r, n.distanceToSquared(jR)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeFaceNormals() { } computeTangents() { const t = this.index, e = this.attributes; if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const n = t.array, r = e.position.array, i = e.normal.array, s = e.uv.array, o = r.length / 3; void 0 === e.tangent && this.setAttribute("tangent", new DR(new Float32Array(4 * o), 4)); const a = e.tangent.array, l = [], c = []; for (let E = 0; E < o; E++)l[E] = new rP, c[E] = new rP; const u = new rP, h = new rP, d = new rP, p = new XC, f = new XC, m = new XC, g = new rP, v = new rP; function y(t, e, n) { u.fromArray(r, 3 * t), h.fromArray(r, 3 * e), d.fromArray(r, 3 * n), p.fromArray(s, 2 * t), f.fromArray(s, 2 * e), m.fromArray(s, 2 * n), h.sub(u), d.sub(u), f.sub(p), m.sub(p); const i = 1 / (f.x * m.y - m.x * f.y); isFinite(i) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(i), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(i), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v)) } let b = this.groups; 0 === b.length && (b = [{ start: 0, count: n.length }]); for (let E = 0, M = b.length; E < M; ++E) { const t = b[E], e = t.start; for (let r = e, i = e + t.count; r < i; r += 3)y(n[r + 0], n[r + 1], n[r + 2]) } const _ = new rP, w = new rP, S = new rP, x = new rP; function T(t) { S.fromArray(i, 3 * t), x.copy(S); const e = l[t]; _.copy(e), _.sub(S.multiplyScalar(S.dot(e))).normalize(), w.crossVectors(x, e); const n = w.dot(c[t]) < 0 ? -1 : 1; a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n } for (let E = 0, M = b.length; E < M; ++E) { const t = b[E], e = t.start; for (let r = e, i = e + t.count; r < i; r += 3)T(n[r + 0]), T(n[r + 1]), T(n[r + 2]) } } computeVertexNormals() { const t = this.index, e = this.getAttribute("position"); if (void 0 !== e) { let n = this.getAttribute("normal"); if (void 0 === n) n = new DR(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n); else for (let t = 0, e = n.count; t < e; t++)n.setXYZ(t, 0, 0, 0); const r = new rP, i = new rP, s = new rP, o = new rP, a = new rP, l = new rP, c = new rP, u = new rP; if (t) for (let h = 0, d = t.count; h < d; h += 3) { const d = t.getX(h + 0), p = t.getX(h + 1), f = t.getX(h + 2); r.fromBufferAttribute(e, d), i.fromBufferAttribute(e, p), s.fromBufferAttribute(e, f), c.subVectors(s, i), u.subVectors(r, i), c.cross(u), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), o.add(c), a.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, l.x, l.y, l.z) } else for (let t = 0, h = e.count; t < h; t += 3)r.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), c.subVectors(s, i), u.subVectors(r, i), c.cross(u), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z); this.normalizeNormals(), n.needsUpdate = !0 } } merge(t, e) { if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t); void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const n = this.attributes; for (const r in n) { if (void 0 === t.attributes[r]) continue; const i = n[r].array, s = t.attributes[r], o = s.array, a = s.itemSize * e, l = Math.min(o.length, i.length - a); for (let t = 0, e = a; t < l; t++, e++)i[e] = o[t] } return this } normalizeNormals() { const t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++)jR.fromBufferAttribute(t, e), jR.normalize(), t.setXYZ(e, jR.x, jR.y, jR.z) } toNonIndexed() { function t(t, e) { const n = t.array, r = t.itemSize, i = t.normalized, s = new n.constructor(e.length * r); let o = 0, a = 0; for (let l = 0, c = e.length; l < c; l++) { o = e[l] * r; for (let t = 0; t < r; t++)s[a++] = n[o++] } return new DR(s, r, i) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const e = new JR, n = this.index.array, r = this.attributes; for (const o in r) { const i = t(r[o], n); e.setAttribute(o, i) } const i = this.morphAttributes; for (const o in i) { const r = [], s = i[o]; for (let e = 0, i = s.length; e < i; e++) { const i = t(s[e], n); r.push(i) } e.morphAttributes[o] = r } e.morphTargetsRelative = this.morphTargetsRelative; const s = this.groups; for (let o = 0, a = s.length; o < a; o++) { const t = s[o]; e.addGroup(t.start, t.count, t.materialIndex) } return e } toJSON() { const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t } t.data = { attributes: {} }; const e = this.index; null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }); const n = this.attributes; for (const a in n) t.data.attributes[a] = n[a].toJSON(t.data); const r = {}; let i = !1; for (const a in this.morphAttributes) { const e = this.morphAttributes[a], n = []; for (let r = 0, i = e.length; r < i; r++)n.push(e[r].toJSON(t.data)); n.length > 0 && (r[a] = n, i = !0) } i && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative); const s = this.groups; s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s))); const o = this.boundingSphere; return null !== o && (t.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), t } clone() { return (new JR).copy(this) } copy(t) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const e = {}; this.name = t.name; const n = t.index; null !== n && this.setIndex(n.clone(e)); const r = t.attributes; for (const l in r) this.setAttribute(l, r[l].clone(e)); const i = t.morphAttributes; for (const l in i) { const t = [], n = i[l]; for (let r = 0, i = n.length; r < i; r++)t.push(n[r].clone(e)); this.morphAttributes[l] = t } this.morphTargetsRelative = t.morphTargetsRelative; const s = t.groups; for (let l = 0, c = s.length; l < c; l++) { const t = s[l]; this.addGroup(t.start, t.count, t.materialIndex) } const o = t.boundingBox; null !== o && (this.boundingBox = o.clone()); const a = t.boundingSphere; return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } JR.prototype.isBufferGeometry = !0; const XR = new IP, WR = new DP, qR = new EP, ZR = new rP, KR = new rP, YR = new rP, QR = new rP, $R = new rP, tL = new rP, eL = new rP, nL = new rP, rL = new rP, iL = new XC, sL = new XC, oL = new XC, aL = new rP, lL = new rP; class cL extends sR { constructor(t = new JR, e = new RR) { super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets() } copy(t) { return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this } updateMorphTargets() { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } raycast(t, e) { const n = this.geometry, r = this.material, i = this.matrixWorld; if (void 0 === r) return; if (null === n.boundingSphere && n.computeBoundingSphere(), qR.copy(n.boundingSphere), qR.applyMatrix4(i), !1 === t.ray.intersectsSphere(qR)) return; if (XR.copy(i).invert(), WR.copy(t.ray).applyMatrix4(XR), null !== n.boundingBox && !1 === WR.intersectsBox(n.boundingBox)) return; let s; if (n.isBufferGeometry) { const i = n.index, o = n.attributes.position, a = n.morphAttributes.position, l = n.morphTargetsRelative, c = n.attributes.uv, u = n.attributes.uv2, h = n.groups, d = n.drawRange; if (null !== i) if (Array.isArray(r)) for (let n = 0, p = h.length; n < p; n++) { const p = h[n], f = r[p.materialIndex]; for (let n = Math.max(p.start, d.start), r = Math.min(p.start + p.count, d.start + d.count); n < r; n += 3) { const r = i.getX(n), h = i.getX(n + 1), d = i.getX(n + 2); s = uL(this, f, t, WR, o, a, l, c, u, r, h, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s)) } } else for (let n = Math.max(0, d.start), p = Math.min(i.count, d.start + d.count); n < p; n += 3) { const h = i.getX(n), d = i.getX(n + 1), p = i.getX(n + 2); s = uL(this, r, t, WR, o, a, l, c, u, h, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s)) } else if (void 0 !== o) if (Array.isArray(r)) for (let n = 0, p = h.length; n < p; n++) { const i = h[n], p = r[i.materialIndex]; for (let n = Math.max(i.start, d.start), r = Math.min(i.start + i.count, d.start + d.count); n < r; n += 3)s = uL(this, p, t, WR, o, a, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, e.push(s)) } else for (let n = Math.max(0, d.start), p = Math.min(o.count, d.start + d.count); n < p; n += 3)s = uL(this, r, t, WR, o, a, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s)) } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } function uL(t, e, n, r, i, s, o, a, l, c, u, h) { ZR.fromBufferAttribute(i, c), KR.fromBufferAttribute(i, u), YR.fromBufferAttribute(i, h); const d = t.morphTargetInfluences; if (e.morphTargets && s && d) { eL.set(0, 0, 0), nL.set(0, 0, 0), rL.set(0, 0, 0); for (let t = 0, e = s.length; t < e; t++) { const e = d[t], n = s[t]; 0 !== e && (QR.fromBufferAttribute(n, c), $R.fromBufferAttribute(n, u), tL.fromBufferAttribute(n, h), o ? (eL.addScaledVector(QR, e), nL.addScaledVector($R, e), rL.addScaledVector(tL, e)) : (eL.addScaledVector(QR.sub(ZR), e), nL.addScaledVector($R.sub(KR), e), rL.addScaledVector(tL.sub(YR), e))) } ZR.add(eL), KR.add(nL), YR.add(rL) } t.isSkinnedMesh && (t.boneTransform(c, ZR), t.boneTransform(u, KR), t.boneTransform(h, YR)); const p = function (t, e, n, r, i, s, o, a) { let l; if (l = 1 === e.side ? r.intersectTriangle(o, s, i, !0, a) : r.intersectTriangle(i, s, o, 2 !== e.side, a), null === l) return null; lL.copy(a), lL.applyMatrix4(t.matrixWorld); const c = n.ray.origin.distanceTo(lL); return c < n.near || c > n.far ? null : { distance: c, point: lL.clone(), object: t } }(t, e, n, r, ZR, KR, YR, aL); if (p) { a && (iL.fromBufferAttribute(a, c), sL.fromBufferAttribute(a, u), oL.fromBufferAttribute(a, h), p.uv = _R.getUV(aL, ZR, KR, YR, iL, sL, oL, new XC)), l && (iL.fromBufferAttribute(l, c), sL.fromBufferAttribute(l, u), oL.fromBufferAttribute(l, h), p.uv2 = _R.getUV(aL, ZR, KR, YR, iL, sL, oL, new XC)); const t = { a: c, b: u, c: h, normal: new rP, materialIndex: 0 }; _R.getNormal(ZR, KR, YR, t.normal), p.face = t } return p } cL.prototype.isMesh = !0; class hL extends JR { constructor(t = 1, e = 1, n = 1, r = 1, i = 1, s = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: r, heightSegments: i, depthSegments: s }; const o = this; r = Math.floor(r), i = Math.floor(i), s = Math.floor(s); const a = [], l = [], c = [], u = []; let h = 0, d = 0; function p(t, e, n, r, i, s, p, f, m, g, v) { const y = s / m, b = p / g, _ = s / 2, w = p / 2, S = f / 2, x = m + 1, T = g + 1; let E = 0, M = 0; const A = new rP; for (let o = 0; o < T; o++) { const s = o * b - w; for (let a = 0; a < x; a++)A[t] = (a * y - _) * r, A[e] = s * i, A[n] = S, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = f > 0 ? 1 : -1, c.push(A.x, A.y, A.z), u.push(a / m), u.push(1 - o / g), E += 1 } for (let o = 0; o < g; o++)for (let t = 0; t < m; t++) { const e = h + t + x * (o + 1), n = h + (t + 1) + x * (o + 1), r = h + (t + 1) + x * o; a.push(h + t + x * o, e, r), a.push(e, n, r), M += 6 } o.addGroup(d, M, v), d += M, h += E } p("z", "y", "x", -1, -1, n, e, t, s, i, 0), p("z", "y", "x", 1, -1, n, e, -t, s, i, 1), p("x", "z", "y", 1, 1, t, n, e, r, s, 2), p("x", "z", "y", 1, -1, t, n, -e, r, s, 3), p("x", "y", "z", 1, -1, t, e, n, r, i, 4), p("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(a), this.setAttribute("position", new FR(l, 3)), this.setAttribute("normal", new FR(c, 3)), this.setAttribute("uv", new FR(u, 2)) } } function dL(t) { const e = {}; for (const n in t) { e[n] = {}; for (const r in t[n]) { const i = t[n][r]; e[n][r] = i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.clone() : Array.isArray(i) ? i.slice() : i } } return e } function pL(t) { const e = {}; for (let n = 0; n < t.length; n++) { const r = dL(t[n]); for (const t in r) e[t] = r[t] } return e } const fL = { clone: dL, merge: pL }; class mL extends SR { constructor(t) { super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } copy(t) { return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = dL(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this } toJSON(t) { const e = super.toJSON(t); e.glslVersion = this.glslVersion, e.uniforms = {}; for (const r in this.uniforms) { const n = this.uniforms[r].value; e.uniforms[r] = n && n.isTexture ? { type: "t", value: n.toJSON(t).uuid } : n && n.isColor ? { type: "c", value: n.getHex() } : n && n.isVector2 ? { type: "v2", value: n.toArray() } : n && n.isVector3 ? { type: "v3", value: n.toArray() } : n && n.isVector4 ? { type: "v4", value: n.toArray() } : n && n.isMatrix3 ? { type: "m3", value: n.toArray() } : n && n.isMatrix4 ? { type: "m4", value: n.toArray() } : { value: n } } Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader; const n = {}; for (const r in this.extensions) !0 === this.extensions[r] && (n[r] = !0); return Object.keys(n).length > 0 && (e.extensions = n), e } } mL.prototype.isShaderMaterial = !0; class gL extends sR { constructor() { super(), this.type = "Camera", this.matrixWorldInverse = new IP, this.projectionMatrix = new IP, this.projectionMatrixInverse = new IP } copy(t, e) { return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this } getWorldDirection(t) { void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new rP), this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() } updateMatrixWorld(t) { super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(t, e) { super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } gL.prototype.isCamera = !0; class vL extends gL { constructor(t = 50, e = 1, n = .1, r = 2e3) { super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(t, e) { return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this } setFocalLength(t) { const e = .5 * this.getFilmHeight() / t; this.fov = 2 * NC * Math.atan(e), this.updateProjectionMatrix() } getFocalLength() { const t = Math.tan(.5 * FC * this.fov); return .5 * this.getFilmHeight() / t } getEffectiveFOV() { return 2 * NC * Math.atan(Math.tan(.5 * FC * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(t, e, n, r, i, s) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const t = this.near; let e = t * Math.tan(.5 * FC * this.fov) / this.zoom, n = 2 * e, r = this.aspect * n, i = -.5 * r; const s = this.view; if (null !== this.view && this.view.enabled) { const t = s.fullWidth, o = s.fullHeight; i += s.offsetX * r / t, e -= s.offsetY * n / o, r *= s.width / t, n *= s.height / o } const o = this.filmOffset; 0 !== o && (i += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(t) { const e = super.toJSON(t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } } vL.prototype.isPerspectiveCamera = !0; const yL = 90; class bL extends sR { constructor(t, e, n) { if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = n; const r = new vL(yL, 1, t, e); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new rP(1, 0, 0)), this.add(r); const i = new vL(yL, 1, t, e); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new rP(-1, 0, 0)), this.add(i); const s = new vL(yL, 1, t, e); s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new rP(0, 1, 0)), this.add(s); const o = new vL(yL, 1, t, e); o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new rP(0, -1, 0)), this.add(o); const a = new vL(yL, 1, t, e); a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new rP(0, 0, 1)), this.add(a); const l = new vL(yL, 1, t, e); l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new rP(0, 0, -1)), this.add(l) } update(t, e) { null === this.parent && this.updateMatrixWorld(); const n = this.renderTarget, [r, i, s, o, a, l] = this.children, c = t.xr.enabled, u = t.getRenderTarget(); t.xr.enabled = !1; const h = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, i), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(u), t.xr.enabled = c } } class _L extends YC { constructor(t, e, n, r, i, s, o, a, l, c) { super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, n, r, i, s, o = void 0 !== o ? o : vC, a, l, c), this._needsFlipEnvMap = !0, this.flipY = !1 } get images() { return this.image } set images(t) { this.image = t } } _L.prototype.isCubeTexture = !0; class wL extends tP { constructor(t, e, n) { Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), this.texture = new _L(void 0, (e = e || {}).mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : cC, this.texture._needsFlipEnvMap = !1 } fromEquirectangularTexture(t, e) { this.texture.type = e.type, this.texture.format = yC, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter; const n = new hL(5, 5, 5), r = new mL({ name: "CubemapFromEquirect", uniforms: dL({ tEquirect: { value: null } }), vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t", side: 1, blending: 0 }); r.uniforms.tEquirect.value = e; const i = new cL(n, r), s = e.minFilter; return e.minFilter === uC && (e.minFilter = cC), new bL(1, 10, this).update(t, i), e.minFilter = s, i.geometry.dispose(), i.material.dispose(), this } clear(t, e, n, r) { const i = t.getRenderTarget(); for (let s = 0; s < 6; s++)t.setRenderTarget(this, s), t.clear(e, n, r); t.setRenderTarget(i) } } wL.prototype.isWebGLCubeRenderTarget = !0; const SL = new EP, xL = new rP; class TL { constructor(t = new cR, e = new cR, n = new cR, r = new cR, i = new cR, s = new cR) { this.planes = [t, e, n, r, i, s] } set(t, e, n, r, i, s) { const o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(s), this } copy(t) { const e = this.planes; for (let n = 0; n < 6; n++)e[n].copy(t.planes[n]); return this } setFromProjectionMatrix(t) { const e = this.planes, n = t.elements, r = n[0], i = n[1], s = n[2], o = n[3], a = n[4], l = n[5], c = n[6], u = n[7], h = n[8], d = n[9], p = n[10], f = n[11], m = n[12], g = n[13], v = n[14], y = n[15]; return e[0].setComponents(o - r, u - a, f - h, y - m).normalize(), e[1].setComponents(o + r, u + a, f + h, y + m).normalize(), e[2].setComponents(o + i, u + l, f + d, y + g).normalize(), e[3].setComponents(o - i, u - l, f - d, y - g).normalize(), e[4].setComponents(o - s, u - c, f - p, y - v).normalize(), e[5].setComponents(o + s, u + c, f + p, y + v).normalize(), this } intersectsObject(t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), SL.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(SL) } intersectsSprite(t) { return SL.center.set(0, 0, 0), SL.radius = .7071067811865476, SL.applyMatrix4(t.matrixWorld), this.intersectsSphere(SL) } intersectsSphere(t) { const e = this.planes, n = t.center, r = -t.radius; for (let i = 0; i < 6; i++)if (e[i].distanceToPoint(n) < r) return !1; return !0 } intersectsBox(t) { const e = this.planes; for (let n = 0; n < 6; n++) { const r = e[n]; if (xL.x = r.normal.x > 0 ? t.max.x : t.min.x, xL.y = r.normal.y > 0 ? t.max.y : t.min.y, xL.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(xL) < 0) return !1 } return !0 } containsPoint(t) { const e = this.planes; for (let n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function EL() { let t = null, e = !1, n = null, r = null; function i(e, s) { n(e, s), r = t.requestAnimationFrame(i) } return { start: function () { !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0) }, stop: function () { t.cancelAnimationFrame(r), e = !1 }, setAnimationLoop: function (t) { n = t }, setContext: function (e) { t = e } } } function ML(t, e) { const n = e.isWebGL2, r = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), r.get(t) }, remove: function (e) { e.isInterleavedBufferAttribute && (e = e.data); const n = r.get(e); n && (t.deleteBuffer(n.buffer), r.delete(e)) }, update: function (e, i) { if (e.isGLBufferAttribute) { const t = r.get(e); return void ((!t || t.version < e.version) && r.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })) } e.isInterleavedBufferAttribute && (e = e.data); const s = r.get(e); void 0 === s ? r.set(e, function (e, r) { const i = e.array, s = e.usage, o = t.createBuffer(); t.bindBuffer(r, o), t.bufferData(r, i, s), e.onUploadCallback(); let a = 5126; return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : (i instanceof Uint8Array || i instanceof Uint8ClampedArray) && (a = 5121), { buffer: o, type: a, bytesPerElement: i.BYTES_PER_ELEMENT, version: e.version } }(e, i)) : s.version < e.version && (function (e, r, i) { const s = r.array, o = r.updateRange; t.bindBuffer(i, e), -1 === o.count ? t.bufferSubData(i, 0, s) : (n ? t.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1) }(s.buffer, e, i), s.version = e.version) } } } class AL extends JR { constructor(t = 1, e = 1, n = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: r }; const i = t / 2, s = e / 2, o = Math.floor(n), a = Math.floor(r), l = o + 1, c = a + 1, u = t / o, h = e / a, d = [], p = [], f = [], m = []; for (let g = 0; g < c; g++) { const t = g * h - s; for (let e = 0; e < l; e++)p.push(e * u - i, -t, 0), f.push(0, 0, 1), m.push(e / o), m.push(1 - g / a) } for (let g = 0; g < a; g++)for (let t = 0; t < o; t++) { const e = t + l * (g + 1), n = t + 1 + l * (g + 1), r = t + 1 + l * g; d.push(t + l * g, e, r), d.push(e, n, r) } this.setIndex(d), this.setAttribute("position", new FR(p, 3)), this.setAttribute("normal", new FR(f, 3)), this.setAttribute("uv", new FR(m, 2)) } } const CL = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );\n\tvec3 f90 = vec3( 1.0 );\n\tvec3 f_transmission = totalTransmission * getIBLVolumeRefraction(\n\t\tnormal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance);\n\tdiffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\tfloat NdotV = saturate(dot(n, viewDir));\n\t\tvec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);\n\t\tvec3 specularColor = f0 * brdf.x + f90 * brdf.y;\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef USE_TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t\tfloat thicknessFactor = thickness;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\tvec3 rawDiffuseColor = diffuseColor.rgb;\n\t#include <transmission_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, PL = { common: { diffuse: { value: new PR(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new WC }, uv2Transform: { value: new WC }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new XC(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new PR(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new PR(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new WC } }, sprite: { diffuse: { value: new PR(16777215) }, opacity: { value: 1 }, center: { value: new XC(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new WC } } }, RL = { basic: { uniforms: pL([PL.common, PL.specularmap, PL.envmap, PL.aomap, PL.lightmap, PL.fog]), vertexShader: CL.meshbasic_vert, fragmentShader: CL.meshbasic_frag }, lambert: { uniforms: pL([PL.common, PL.specularmap, PL.envmap, PL.aomap, PL.lightmap, PL.emissivemap, PL.fog, PL.lights, { emissive: { value: new PR(0) } }]), vertexShader: CL.meshlambert_vert, fragmentShader: CL.meshlambert_frag }, phong: { uniforms: pL([PL.common, PL.specularmap, PL.envmap, PL.aomap, PL.lightmap, PL.emissivemap, PL.bumpmap, PL.normalmap, PL.displacementmap, PL.fog, PL.lights, { emissive: { value: new PR(0) }, specular: { value: new PR(1118481) }, shininess: { value: 30 } }]), vertexShader: CL.meshphong_vert, fragmentShader: CL.meshphong_frag }, standard: { uniforms: pL([PL.common, PL.envmap, PL.aomap, PL.lightmap, PL.emissivemap, PL.bumpmap, PL.normalmap, PL.displacementmap, PL.roughnessmap, PL.metalnessmap, PL.fog, PL.lights, { emissive: { value: new PR(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: CL.meshphysical_vert, fragmentShader: CL.meshphysical_frag }, toon: { uniforms: pL([PL.common, PL.aomap, PL.lightmap, PL.emissivemap, PL.bumpmap, PL.normalmap, PL.displacementmap, PL.gradientmap, PL.fog, PL.lights, { emissive: { value: new PR(0) } }]), vertexShader: CL.meshtoon_vert, fragmentShader: CL.meshtoon_frag }, matcap: { uniforms: pL([PL.common, PL.bumpmap, PL.normalmap, PL.displacementmap, PL.fog, { matcap: { value: null } }]), vertexShader: CL.meshmatcap_vert, fragmentShader: CL.meshmatcap_frag }, points: { uniforms: pL([PL.points, PL.fog]), vertexShader: CL.points_vert, fragmentShader: CL.points_frag }, dashed: { uniforms: pL([PL.common, PL.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: CL.linedashed_vert, fragmentShader: CL.linedashed_frag }, depth: { uniforms: pL([PL.common, PL.displacementmap]), vertexShader: CL.depth_vert, fragmentShader: CL.depth_frag }, normal: { uniforms: pL([PL.common, PL.bumpmap, PL.normalmap, PL.displacementmap, { opacity: { value: 1 } }]), vertexShader: CL.normal_vert, fragmentShader: CL.normal_frag }, sprite: { uniforms: pL([PL.sprite, PL.fog]), vertexShader: CL.sprite_vert, fragmentShader: CL.sprite_frag }, background: { uniforms: { uvTransform: { value: new WC }, t2D: { value: null } }, vertexShader: CL.background_vert, fragmentShader: CL.background_frag }, cube: { uniforms: pL([PL.envmap, { opacity: { value: 1 } }]), vertexShader: CL.cube_vert, fragmentShader: CL.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: CL.equirect_vert, fragmentShader: CL.equirect_frag }, distanceRGBA: { uniforms: pL([PL.common, PL.displacementmap, { referencePosition: { value: new rP }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: CL.distanceRGBA_vert, fragmentShader: CL.distanceRGBA_frag }, shadow: { uniforms: pL([PL.lights, PL.fog, { color: { value: new PR(0) }, opacity: { value: 1 } }]), vertexShader: CL.shadow_vert, fragmentShader: CL.shadow_frag } }; function LL(t, e, n, r, i) { const s = new PR(0); let o, a, l = 0, c = null, u = 0, h = null; function d(t, e) { n.buffers.color.setClear(t.r, t.g, t.b, e, i) } return { getClearColor: function () { return s }, setClearColor: function (t, e = 1) { s.set(t), l = e, d(s, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (t) { l = t, d(s, l) }, render: function (n, i) { let p = !1, f = !0 === i.isScene ? i.background : null; f && f.isTexture && (f = e.get(f)); const m = t.xr, g = m.getSession && m.getSession(); g && "additive" === g.environmentBlendMode && (f = null), null === f ? d(s, l) : f && f.isColor && (d(f, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || 306 === f.mapping) ? (void 0 === a && (a = new cL(new hL(1, 1, 1), new mL({ name: "BackgroundCubeMaterial", uniforms: dL(RL.cube.uniforms), vertexShader: RL.cube.vertexShader, fragmentShader: RL.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function (t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(a.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(a)), a.material.uniforms.envMap.value = f, a.material.uniforms.flipEnvMap.value = f.isCubeTexture && f._needsFlipEnvMap ? -1 : 1, c === f && u === f.version && h === t.toneMapping || (a.material.needsUpdate = !0, c = f, u = f.version, h = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new cL(new AL(2, 2), new mL({ name: "BackgroundMaterial", uniforms: dL(RL.background.uniforms), vertexShader: RL.background.vertexShader, fragmentShader: RL.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(o)), o.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), o.material.uniforms.uvTransform.value.copy(f.matrix), c === f && u === f.version && h === t.toneMapping || (o.material.needsUpdate = !0, c = f, u = f.version, h = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) } } } function kL(t, e, n, r) { const i = t.getParameter(34921), s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = r.isWebGL2 || null !== s, a = {}, l = d(null); let c = l; function u(e) { return r.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e) } function h(e) { return r.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e) } function d(t) { const e = [], n = [], r = []; for (let s = 0; s < i; s++)e[s] = 0, n[s] = 0, r[s] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: r, object: t, attributes: {}, index: null } } function p() { const t = c.newAttributes; for (let e = 0, n = t.length; e < n; e++)t[e] = 0 } function f(t) { m(t, 0) } function m(n, i) { const s = c.enabledAttributes, o = c.attributeDivisors; c.newAttributes[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), o[n] !== i && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), o[n] = i) } function g() { const e = c.newAttributes, n = c.enabledAttributes; for (let r = 0, i = n.length; r < i; r++)n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0) } function v(e, n, i, s, o, a) { !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? t.vertexAttribPointer(e, n, i, s, o, a) : t.vertexAttribIPointer(e, n, i, o, a) } function y() { b(), c !== l && (c = l, u(c.object)) } function b() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: function (i, l, h, y, b) { let _ = !1; if (o) { const e = function (e, n, i) { const o = !0 === i.wireframe; let l = a[e.id]; void 0 === l && (l = {}, a[e.id] = l); let c = l[n.id]; void 0 === c && (c = {}, l[n.id] = c); let u = c[o]; return void 0 === u && (u = d(r.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[o] = u), u }(y, h, l); c !== e && (c = e, u(c.object)), _ = function (t, e) { const n = c.attributes, r = t.attributes; let i = 0; for (const s in r) { const t = n[s], e = r[s]; if (void 0 === t) return !0; if (t.attribute !== e) return !0; if (t.data !== e.data) return !0; i++ } return c.attributesNum !== i || c.index !== e }(y, b), _ && function (t, e) { const n = {}, r = t.attributes; let i = 0; for (const s in r) { const t = r[s], e = {}; e.attribute = t, t.data && (e.data = t.data), n[s] = e, i++ } c.attributes = n, c.attributesNum = i, c.index = e }(y, b) } else { const t = !0 === l.wireframe; c.geometry === y.id && c.program === h.id && c.wireframe === t || (c.geometry = y.id, c.program = h.id, c.wireframe = t, _ = !0) } !0 === i.isInstancedMesh && (_ = !0), null !== b && n.update(b, 34963), _ && (function (i, s, o, a) { if (!1 === r.isWebGL2 && (i.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return; p(); const l = a.attributes, c = o.getAttributes(), u = s.defaultAttributeValues; for (const e in c) { const r = c[e]; if (r >= 0) { const s = l[e]; if (void 0 !== s) { const e = s.normalized, i = s.itemSize, o = n.get(s); if (void 0 === o) continue; const l = o.buffer, c = o.type, u = o.bytesPerElement; if (s.isInterleavedBufferAttribute) { const n = s.data, o = n.stride, h = s.offset; n && n.isInstancedInterleavedBuffer ? (m(r, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : f(r), t.bindBuffer(34962, l), v(r, i, c, e, o * u, h * u) } else s.isInstancedBufferAttribute ? (m(r, s.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)) : f(r), t.bindBuffer(34962, l), v(r, i, c, e, 0, 0) } else if ("instanceMatrix" === e) { const e = n.get(i.instanceMatrix); if (void 0 === e) continue; const s = e.buffer, o = e.type; m(r + 0, 1), m(r + 1, 1), m(r + 2, 1), m(r + 3, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(r + 0, 4, o, !1, 64, 0), t.vertexAttribPointer(r + 1, 4, o, !1, 64, 16), t.vertexAttribPointer(r + 2, 4, o, !1, 64, 32), t.vertexAttribPointer(r + 3, 4, o, !1, 64, 48) } else if ("instanceColor" === e) { const e = n.get(i.instanceColor); if (void 0 === e) continue; const s = e.buffer, o = e.type; m(r, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(r, 3, o, !1, 12, 0) } else if (void 0 !== u) { const n = u[e]; if (void 0 !== n) switch (n.length) { case 2: t.vertexAttrib2fv(r, n); break; case 3: t.vertexAttrib3fv(r, n); break; case 4: t.vertexAttrib4fv(r, n); break; default: t.vertexAttrib1fv(r, n) } } } } g() }(i, l, h, y), null !== b && t.bindBuffer(34963, n.get(b).buffer)) }, reset: y, resetDefaultState: b, dispose: function () { y(); for (const t in a) { const e = a[t]; for (const t in e) { const n = e[t]; for (const t in n) h(n[t].object), delete n[t]; delete e[t] } delete a[t] } }, releaseStatesOfGeometry: function (t) { if (void 0 === a[t.id]) return; const e = a[t.id]; for (const n in e) { const t = e[n]; for (const e in t) h(t[e].object), delete t[e]; delete e[n] } delete a[t.id] }, releaseStatesOfProgram: function (t) { for (const e in a) { const n = a[e]; if (void 0 === n[t.id]) continue; const r = n[t.id]; for (const t in r) h(r[t].object), delete r[t]; delete n[t.id] } }, initAttributes: p, enableAttribute: f, disableUnusedAttributes: g } } function DL(t, e, n, r) { const i = r.isWebGL2; let s; this.setMode = function (t) { s = t }, this.render = function (e, r) { t.drawArrays(s, e, r), n.update(r, s, 1) }, this.renderInstances = function (r, o, a) { if (0 === a) return; let l, c; if (i) l = t, c = "drawArraysInstanced"; else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[c](s, r, o, a), n.update(o, s, a) } } function IL(t, e, n) { let r; function i(e) { if ("highp" === e) { if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; e = "mediump" } return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext; let o = void 0 !== n.precision ? n.precision : "highp"; const a = i(o); a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a); const l = s || e.has("WEBGL_draw_buffers"), c = !0 === n.logarithmicDepthBuffer, u = t.getParameter(34930), h = t.getParameter(35660), d = t.getParameter(3379), p = t.getParameter(34076), f = t.getParameter(34921), m = t.getParameter(36347), g = t.getParameter(36348), v = t.getParameter(36349), y = h > 0, b = s || e.has("OES_texture_float"); return { isWebGL2: s, drawBuffers: l, getMaxAnisotropy: function () { if (void 0 !== r) return r; if (!0 === e.has("EXT_texture_filter_anisotropic")) { const n = e.get("EXT_texture_filter_anisotropic"); r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else r = 0; return r }, getMaxPrecision: i, precision: o, logarithmicDepthBuffer: c, maxTextures: u, maxVertexTextures: h, maxTextureSize: d, maxCubemapSize: p, maxAttributes: f, maxVertexUniforms: m, maxVaryings: g, maxFragmentUniforms: v, vertexTextures: y, floatFragmentTextures: b, floatVertexTextures: y && b, maxSamples: s ? t.getParameter(36183) : 0 } } function OL(t) { const e = this; let n = null, r = 0, i = !1, s = !1; const o = new cR, a = new WC, l = { value: null, needsUpdate: !1 }; function c() { l.value !== n && (l.value = n, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0 } function u(t, n, r, i) { const s = null !== t ? t.length : 0; let c = null; if (0 !== s) { if (c = l.value, !0 !== i || null === c) { const e = r + 4 * s, i = n.matrixWorldInverse; a.getNormalMatrix(i), (null === c || c.length < e) && (c = new Float32Array(e)); for (let n = 0, l = r; n !== s; ++n, l += 4)o.copy(t[n]).applyMatrix4(i, a), o.normal.toArray(c, l), c[l + 3] = o.constant } l.value = c, l.needsUpdate = !0 } return e.numPlanes = s, e.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, s) { const o = 0 !== t.length || e || 0 !== r || i; return i = e, n = u(t, s, 0), r = t.length, o }, this.beginShadows = function () { s = !0, u(null) }, this.endShadows = function () { s = !1, c() }, this.setState = function (e, o, a) { const h = e.clippingPlanes, d = e.clipIntersection, p = e.clipShadows, f = t.get(e); if (!i || null === h || 0 === h.length || s && !p) s ? u(null) : c(); else { const t = s ? 0 : r, e = 4 * t; let i = f.clippingState || null; l.value = i, i = u(h, o, e, a); for (let r = 0; r !== e; ++r)i[r] = n[r]; f.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t } } } function FL(t) { let e = new WeakMap; function n(t, e) { return 303 === e ? t.mapping = 301 : 304 === e && (t.mapping = 302), t } function r(t) { const n = t.target; n.removeEventListener("dispose", r); const i = e.get(n); void 0 !== i && (e.delete(n), i.dispose()) } return { get: function (i) { if (i && i.isTexture) { const s = i.mapping; if (303 === s || 304 === s) { if (e.has(i)) return n(e.get(i).texture, i.mapping); { const s = i.image; if (s && s.height > 0) { const o = t.getRenderTarget(), a = new wL(s.height / 2); return a.fromEquirectangularTexture(t, i), e.set(i, a), t.setRenderTarget(o), i.addEventListener("dispose", r), n(a.texture, i.mapping) } return null } } } return i }, dispose: function () { e = new WeakMap } } } function NL(t) { const e = {}; function n(n) { if (void 0 !== e[n]) return e[n]; let r; switch (n) { case "WEBGL_depth_texture": r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = t.getExtension(n) }return e[n] = r, r } return { has: function (t) { return null !== n(t) }, init: function (t) { t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float") }, get: function (t) { const e = n(t); return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e } } } function BL(t, e, n, r) { const i = {}, s = new WeakMap; function o(t) { const a = t.target; null !== a.index && e.remove(a.index); for (const n in a.attributes) e.remove(a.attributes[n]); a.removeEventListener("dispose", o), delete i[a.id]; const l = s.get(a); l && (e.remove(l), s.delete(a)), r.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries-- } function a(t) { const n = [], r = t.index, i = t.attributes.position; let o = 0; if (null !== r) { const t = r.array; o = r.version; for (let e = 0, r = t.length; e < r; e += 3) { const r = t[e + 0], i = t[e + 1], s = t[e + 2]; n.push(r, i, i, s, s, r) } } else { o = i.version; for (let t = 0, e = i.array.length / 3 - 1; t < e; t += 3) { const e = t + 0, r = t + 1, i = t + 2; n.push(e, r, r, i, i, e) } } const a = new (NR(n) > 65535 ? OR : IR)(n, 1); a.version = o; const l = s.get(t); l && e.remove(l), s.set(t, a) } return { get: function (t, e) { return !0 === i[e.id] || (e.addEventListener("dispose", o), i[e.id] = !0, n.memory.geometries++), e }, update: function (t) { const n = t.attributes; for (const i in n) e.update(n[i], 34962); const r = t.morphAttributes; for (const i in r) { const t = r[i]; for (let n = 0, r = t.length; n < r; n++)e.update(t[n], 34962) } }, getWireframeAttribute: function (t) { const e = s.get(t); if (e) { const n = t.index; null !== n && e.version < n.version && a(t) } else a(t); return s.get(t) } } } function HL(t, e, n, r) { const i = r.isWebGL2; let s, o, a; this.setMode = function (t) { s = t }, this.setIndex = function (t) { o = t.type, a = t.bytesPerElement }, this.render = function (e, r) { t.drawElements(s, r, o, e * a), n.update(r, s, 1) }, this.renderInstances = function (r, l, c) { if (0 === c) return; let u, h; if (i) u = t, h = "drawElementsInstanced"; else if (u = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); u[h](s, l, o, r * a, c), n.update(l, s, c) } } function UL(t) { const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 }, update: function (t, n, r) { switch (e.calls++, n) { case 4: e.triangles += r * (t / 3); break; case 1: e.lines += r * (t / 2); break; case 3: e.lines += r * (t - 1); break; case 2: e.lines += r * t; break; case 0: e.points += r * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } } function GL(t, e) { return t[0] - e[0] } function VL(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function zL(t) { const e = {}, n = new Float32Array(8), r = []; for (let i = 0; i < 8; i++)r[i] = [i, 0]; return { update: function (i, s, o, a) { const l = i.morphTargetInfluences, c = void 0 === l ? 0 : l.length; let u = e[s.id]; if (void 0 === u) { u = []; for (let t = 0; t < c; t++)u[t] = [t, 0]; e[s.id] = u } for (let t = 0; t < c; t++) { const e = u[t]; e[0] = t, e[1] = l[t] } u.sort(VL); for (let t = 0; t < 8; t++)t < c && u[t][1] ? (r[t][0] = u[t][0], r[t][1] = u[t][1]) : (r[t][0] = Number.MAX_SAFE_INTEGER, r[t][1] = 0); r.sort(GL); const h = o.morphTargets && s.morphAttributes.position, d = o.morphNormals && s.morphAttributes.normal; let p = 0; for (let t = 0; t < 8; t++) { const e = r[t], i = e[0], o = e[1]; i !== Number.MAX_SAFE_INTEGER && o ? (h && s.getAttribute("morphTarget" + t) !== h[i] && s.setAttribute("morphTarget" + t, h[i]), d && s.getAttribute("morphNormal" + t) !== d[i] && s.setAttribute("morphNormal" + t, d[i]), n[t] = o, p += o) : (h && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t), d && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t), n[t] = 0) } const f = s.morphTargetsRelative ? 1 : 1 - p; a.getUniforms().setValue(t, "morphTargetBaseInfluence", f), a.getUniforms().setValue(t, "morphTargetInfluences", n) } } } function jL(t, e, n, r) { let i = new WeakMap; function s(t) { const e = t.target; e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor) } return { update: function (t) { const o = r.render.frame, a = e.get(t, t.geometry); return i.get(a) !== o && (e.update(a), i.set(a, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), a }, dispose: function () { i = new WeakMap } } } RL.physical = { uniforms: pL([RL.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new XC(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new PR(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new XC }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new PR(0) } }]), vertexShader: CL.meshphysical_vert, fragmentShader: CL.meshphysical_frag }; class JL extends YC { constructor(t = null, e = 1, n = 1, r = 1) { super(null), this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = oC, this.minFilter = oC, this.wrapR = iC, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } JL.prototype.isDataTexture2DArray = !0; class XL extends YC { constructor(t = null, e = 1, n = 1, r = 1) { super(null), this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = oC, this.minFilter = oC, this.wrapR = iC, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } XL.prototype.isDataTexture3D = !0; const WL = new YC, qL = new JL, ZL = new XL, KL = new _L, YL = [], QL = [], $L = new Float32Array(16), tk = new Float32Array(9), ek = new Float32Array(4); function nk(t, e, n) { const r = t[0]; if (r <= 0 || r > 0) return t; const i = e * n; let s = YL[i]; if (void 0 === s && (s = new Float32Array(i), YL[i] = s), 0 !== e) { r.toArray(s, 0); for (let r = 1, i = 0; r !== e; ++r)i += n, t[r].toArray(s, i) } return s } function rk(t, e) { if (t.length !== e.length) return !1; for (let n = 0, r = t.length; n < r; n++)if (t[n] !== e[n]) return !1; return !0 } function ik(t, e) { for (let n = 0, r = e.length; n < r; n++)t[n] = e[n] } function sk(t, e) { let n = QL[e]; void 0 === n && (n = new Int32Array(e), QL[e] = n); for (let r = 0; r !== e; ++r)n[r] = t.allocateTextureUnit(); return n } function ok(t, e) { const n = this.cache; n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e) } function ak(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (rk(n, e)) return; t.uniform2fv(this.addr, e), ik(n, e) } } function lk(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else { if (rk(n, e)) return; t.uniform3fv(this.addr, e), ik(n, e) } } function ck(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (rk(n, e)) return; t.uniform4fv(this.addr, e), ik(n, e) } } function uk(t, e) { const n = this.cache, r = e.elements; if (void 0 === r) { if (rk(n, e)) return; t.uniformMatrix2fv(this.addr, !1, e), ik(n, e) } else { if (rk(n, r)) return; ek.set(r), t.uniformMatrix2fv(this.addr, !1, ek), ik(n, r) } } function hk(t, e) { const n = this.cache, r = e.elements; if (void 0 === r) { if (rk(n, e)) return; t.uniformMatrix3fv(this.addr, !1, e), ik(n, e) } else { if (rk(n, r)) return; tk.set(r), t.uniformMatrix3fv(this.addr, !1, tk), ik(n, r) } } function dk(t, e) { const n = this.cache, r = e.elements; if (void 0 === r) { if (rk(n, e)) return; t.uniformMatrix4fv(this.addr, !1, e), ik(n, e) } else { if (rk(n, r)) return; $L.set(r), t.uniformMatrix4fv(this.addr, !1, $L), ik(n, r) } } function pk(t, e) { const n = this.cache; n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e) } function fk(t, e) { const n = this.cache; rk(n, e) || (t.uniform2iv(this.addr, e), ik(n, e)) } function mk(t, e) { const n = this.cache; rk(n, e) || (t.uniform3iv(this.addr, e), ik(n, e)) } function gk(t, e) { const n = this.cache; rk(n, e) || (t.uniform4iv(this.addr, e), ik(n, e)) } function vk(t, e) { const n = this.cache; n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e) } function yk(t, e) { const n = this.cache; rk(n, e) || (t.uniform2uiv(this.addr, e), ik(n, e)) } function bk(t, e) { const n = this.cache; rk(n, e) || (t.uniform3uiv(this.addr, e), ik(n, e)) } function _k(t, e) { const n = this.cache; rk(n, e) || (t.uniform4uiv(this.addr, e), ik(n, e)) } function wk(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(e || WL, i) } function Sk(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || ZL, i) } function xk(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(e || KL, i) } function Tk(t, e, n) { const r = this.cache, i = n.allocateTextureUnit(); r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || qL, i) } function Ek(t, e) { t.uniform1fv(this.addr, e) } function Mk(t, e) { const n = nk(e, this.size, 2); t.uniform2fv(this.addr, n) } function Ak(t, e) { const n = nk(e, this.size, 3); t.uniform3fv(this.addr, n) } function Ck(t, e) { const n = nk(e, this.size, 4); t.uniform4fv(this.addr, n) } function Pk(t, e) { const n = nk(e, this.size, 4); t.uniformMatrix2fv(this.addr, !1, n) } function Rk(t, e) { const n = nk(e, this.size, 9); t.uniformMatrix3fv(this.addr, !1, n) } function Lk(t, e) { const n = nk(e, this.size, 16); t.uniformMatrix4fv(this.addr, !1, n) } function kk(t, e) { t.uniform1iv(this.addr, e) } function Dk(t, e) { t.uniform2iv(this.addr, e) } function Ik(t, e) { t.uniform3iv(this.addr, e) } function Ok(t, e) { t.uniform4iv(this.addr, e) } function Fk(t, e) { t.uniform1uiv(this.addr, e) } function Nk(t, e) { t.uniform2uiv(this.addr, e) } function Bk(t, e) { t.uniform3uiv(this.addr, e) } function Hk(t, e) { t.uniform4uiv(this.addr, e) } function Uk(t, e, n) { const r = e.length, i = sk(n, r); t.uniform1iv(this.addr, i); for (let s = 0; s !== r; ++s)n.safeSetTexture2D(e[s] || WL, i[s]) } function Gk(t, e, n) { const r = e.length, i = sk(n, r); t.uniform1iv(this.addr, i); for (let s = 0; s !== r; ++s)n.safeSetTextureCube(e[s] || KL, i[s]) } function Vk(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) { switch (t) { case 5126: return ok; case 35664: return ak; case 35665: return lk; case 35666: return ck; case 35674: return uk; case 35675: return hk; case 35676: return dk; case 5124: case 35670: return pk; case 35667: case 35671: return fk; case 35668: case 35672: return mk; case 35669: case 35673: return gk; case 5125: return vk; case 36294: return yk; case 36295: return bk; case 36296: return _k; case 35678: case 36198: case 36298: case 36306: case 35682: return wk; case 35679: case 36299: case 36307: return Sk; case 35680: case 36300: case 36308: case 36293: return xk; case 36289: case 36303: case 36311: case 36292: return Tk } }(e.type) } function zk(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return Ek; case 35664: return Mk; case 35665: return Ak; case 35666: return Ck; case 35674: return Pk; case 35675: return Rk; case 35676: return Lk; case 5124: case 35670: return kk; case 35667: case 35671: return Dk; case 35668: case 35672: return Ik; case 35669: case 35673: return Ok; case 5125: return Fk; case 36294: return Nk; case 36295: return Bk; case 36296: return Hk; case 35678: case 36198: case 36298: case 36306: case 35682: return Uk; case 35680: case 36300: case 36308: case 36293: return Gk } }(e.type) } function jk(t) { this.id = t, this.seq = [], this.map = {} } zk.prototype.updateCache = function (t) { const e = this.cache; t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), ik(e, t) }, jk.prototype.setValue = function (t, e, n) { const r = this.seq; for (let i = 0, s = r.length; i !== s; ++i) { const s = r[i]; s.setValue(t, e[s.id], n) } }; const Jk = /(\w+)(\])?(\[|\.)?/g; function Xk(t, e) { t.seq.push(e), t.map[e.id] = e } function Wk(t, e, n) { const r = t.name, i = r.length; for (Jk.lastIndex = 0; ;) { const s = Jk.exec(r), o = Jk.lastIndex; let a = s[1]; const l = s[3]; if ("]" === s[2] && (a |= 0), void 0 === l || "[" === l && o + 2 === i) { Xk(n, void 0 === l ? new Vk(a, t, e) : new zk(a, t, e)); break } { let t = n.map[a]; void 0 === t && (t = new jk(a), Xk(n, t)), n = t } } } function qk(t, e) { this.seq = [], this.map = {}; const n = t.getProgramParameter(e, 35718); for (let r = 0; r < n; ++r) { const n = t.getActiveUniform(e, r); Wk(n, t.getUniformLocation(e, n.name), this) } } function Zk(t, e, n) { const r = t.createShader(e); return t.shaderSource(r, n), t.compileShader(r), r } qk.prototype.setValue = function (t, e, n, r) { const i = this.map[e]; void 0 !== i && i.setValue(t, n, r) }, qk.prototype.setOptional = function (t, e, n) { const r = e[n]; void 0 !== r && this.setValue(t, n, r) }, qk.upload = function (t, e, n, r) { for (let i = 0, s = e.length; i !== s; ++i) { const s = e[i], o = n[s.id]; !1 !== o.needsUpdate && s.setValue(t, o.value, r) } }, qk.seqWithValue = function (t, e) { const n = []; for (let r = 0, i = t.length; r !== i; ++r) { const i = t[r]; i.id in e && n.push(i) } return n }; let Kk = 0; function Yk(t) { switch (t) { case AC: return ["Linear", "( value )"]; case CC: return ["sRGB", "( value )"]; case 3002: return ["RGBE", "( value )"]; case 3004: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case 3003: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"] } } function Qk(t, e, n) { const r = t.getShaderParameter(e, 35713), i = t.getShaderInfoLog(e).trim(); return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function (t) { const e = t.split("\n"); for (let n = 0; n < e.length; n++)e[n] = n + 1 + ": " + e[n]; return e.join("\n") }(t.getShaderSource(e)) } function $k(t, e) { const n = Yk(e); return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" } function tD(t, e) { const n = Yk(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" } function eD(t, e) { let n; switch (e) { case 1: n = "Linear"; break; case 2: n = "Reinhard"; break; case 3: n = "OptimizedCineon"; break; case 4: n = "ACESFilmic"; break; case 5: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear" }return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function nD(t) { return "" !== t } function rD(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function iD(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const sD = /^[ \t]*#include +<([\w\d./]+)>/gm; function oD(t) { return t.replace(sD, aD) } function aD(t, e) { const n = CL[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return oD(n) } const lD = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, cD = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function uD(t) { return t.replace(cD, dD).replace(lD, hD) } function hD(t, e, n, r) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), dD(0, e, n, r) } function dD(t, e, n, r) { let i = ""; for (let s = parseInt(e); s < parseInt(n); s++)i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s); return i } function pD(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e } function fD(t, e, n, r) { const i = t.getContext(), s = n.defines; let o = n.vertexShader, a = n.fragmentShader; const l = function (t) { let e = "SHADOWMAP_TYPE_BASIC"; return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e }(n), c = function (t) { let e = "ENVMAP_TYPE_CUBE"; if (t.envMap) switch (t.envMapMode) { case 301: case 302: e = "ENVMAP_TYPE_CUBE"; break; case 306: case 307: e = "ENVMAP_TYPE_CUBE_UV" }return e }(n), u = function (t) { let e = "ENVMAP_MODE_REFLECTION"; if (t.envMap) switch (t.envMapMode) { case 302: case 307: e = "ENVMAP_MODE_REFRACTION" }return e }(n), h = function (t) { let e = "ENVMAP_BLENDING_NONE"; if (t.envMap) switch (t.combine) { case 0: e = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: e = "ENVMAP_BLENDING_MIX"; break; case 2: e = "ENVMAP_BLENDING_ADD" }return e }(n), d = t.gammaFactor > 0 ? t.gammaFactor : 1, p = n.isWebGL2 ? "" : function (t) { return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission > 0) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(nD).join("\n") }(n), f = function (t) { const e = []; for (const n in t) { const r = t[n]; !1 !== r && e.push("#define " + n + " " + r) } return e.join("\n") }(s), m = i.createProgram(); let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? (g = [f].filter(nD).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(nD).join("\n"), v.length > 0 && (v += "\n")) : (g = [pD(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(nD).join("\n"), v = [p, pD(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? CL.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? eD("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", CL.encodings_pars_fragment, n.map ? $k("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? $k("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? $k("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? $k("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? $k("lightMapTexelToLinear", n.lightMapEncoding) : "", tD("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(nD).join("\n")), o = oD(o), o = rD(o, n), o = iD(o, n), a = oD(a), a = rD(a, n), a = iD(a, n), o = uD(o), a = uD(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === kC ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === kC ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v); const b = y + v + a, _ = Zk(i, 35633, y + g + o), w = Zk(i, 35632, b); if (i.attachShader(m, _), i.attachShader(m, w), void 0 !== n.index0AttributeName ? i.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m), t.debug.checkShaderErrors) { const t = i.getProgramInfoLog(m).trim(), e = i.getShaderInfoLog(_).trim(), n = i.getShaderInfoLog(w).trim(); let r = !0, s = !0; if (!1 === i.getProgramParameter(m, 35714)) { r = !1; const e = Qk(i, _, "vertex"), n = Qk(i, w, "fragment"); console.error("THREE.WebGLProgram: shader error: ", i.getError(), "35715", i.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, n) } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (s = !1); s && (this.diagnostics = { runnable: r, programLog: t, vertexShader: { log: e, prefix: g }, fragmentShader: { log: n, prefix: v } }) } let S, x; return i.deleteShader(_), i.deleteShader(w), this.getUniforms = function () { return void 0 === S && (S = new qk(i, m)), S }, this.getAttributes = function () { return void 0 === x && (x = function (t, e) { const n = {}, r = t.getProgramParameter(e, 35721); for (let i = 0; i < r; i++) { const r = t.getActiveAttrib(e, i).name; n[r] = t.getAttribLocation(e, r) } return n }(i, m)), x }, this.destroy = function () { r.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0 }, this.name = n.shaderName, this.id = Kk++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = _, this.fragmentShader = w, this } function mD(t, e, n, r, i, s) { const o = [], a = r.isWebGL2, l = r.logarithmicDepthBuffer, c = r.floatVertexTextures, u = r.maxVertexUniforms, h = r.vertexTextures; let d = r.precision; const p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"]; function m(t) { let e; return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = AC, e } return { getParameters: function (i, o, f, g, v) { const y = g.fog, b = e.get(i.envMap || (i.isMeshStandardMaterial ? g.environment : null)), _ = p[i.type], w = v.isSkinnedMesh ? function (t) { const e = t.skeleton.bones; if (c) return 1024; { const t = Math.floor((u - 20) / 4), n = Math.min(t, e.length); return n < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + n + "."), 0) : n } }(v) : 0; let S, x; if (null !== i.precision && (d = r.getMaxPrecision(i.precision), d !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", d, "instead.")), _) { const t = RL[_]; S = t.vertexShader, x = t.fragmentShader } else S = i.vertexShader, x = i.fragmentShader; const T = t.getRenderTarget(); return { isWebGL2: a, shaderID: _, shaderName: i.type, vertexShader: S, fragmentShader: x, defines: i.defines, isRawShaderMaterial: !0 === i.isRawShaderMaterial, glslVersion: i.glslVersion, precision: d, instancing: !0 === v.isInstancedMesh, instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor, supportsVertexTextures: h, outputEncoding: null !== T ? m(T.texture) : t.outputEncoding, map: !!i.map, mapEncoding: m(i.map), matcap: !!i.matcap, matcapEncoding: m(i.matcap), envMap: !!b, envMapMode: b && b.mapping, envMapEncoding: m(b), envMapCubeUV: !!b && (306 === b.mapping || 307 === b.mapping), lightMap: !!i.lightMap, lightMapEncoding: m(i.lightMap), aoMap: !!i.aoMap, emissiveMap: !!i.emissiveMap, emissiveMapEncoding: m(i.emissiveMap), bumpMap: !!i.bumpMap, normalMap: !!i.normalMap, objectSpaceNormalMap: 1 === i.normalMapType, tangentSpaceNormalMap: 0 === i.normalMapType, clearcoatMap: !!i.clearcoatMap, clearcoatRoughnessMap: !!i.clearcoatRoughnessMap, clearcoatNormalMap: !!i.clearcoatNormalMap, displacementMap: !!i.displacementMap, roughnessMap: !!i.roughnessMap, metalnessMap: !!i.metalnessMap, specularMap: !!i.specularMap, alphaMap: !!i.alphaMap, gradientMap: !!i.gradientMap, sheen: !!i.sheen, transmission: !!i.transmission, transmissionMap: !!i.transmissionMap, thicknessMap: !!i.thicknessMap, combine: i.combine, vertexTangents: i.normalMap && i.vertexTangents, vertexColors: i.vertexColors, vertexAlphas: !0 === i.vertexColors && v.geometry && v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize, vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmission || i.transmissionMap || i.thicknessMap), uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmission || i.transmissionMap || i.thicknessMap || !i.displacementMap), fog: !!y, useFog: i.fog, fogExp2: y && y.isFogExp2, flatShading: !!i.flatShading, sizeAttenuation: i.sizeAttenuation, logarithmicDepthBuffer: l, skinning: !0 === v.isSkinnedMesh && w > 0, maxBones: w, useVertexTexture: c, morphTargets: i.morphTargets, morphNormals: i.morphNormals, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, dithering: i.dithering, shadowMapEnabled: t.shadowMap.enabled && f.length > 0, shadowMapType: t.shadowMap.type, toneMapping: i.toneMapped ? t.toneMapping : 0, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: i.premultipliedAlpha, alphaTest: i.alphaTest, doubleSided: 2 === i.side, flipSided: 1 === i.side, depthPacking: void 0 !== i.depthPacking && i.depthPacking, index0AttributeName: i.index0AttributeName, extensionDerivatives: i.extensions && i.extensions.derivatives, extensionFragDepth: i.extensions && i.extensions.fragDepth, extensionDrawBuffers: i.extensions && i.extensions.drawBuffers, extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD, rendererExtensionFragDepth: a || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"), customProgramCacheKey: i.customProgramCacheKey() } }, getProgramCacheKey: function (e) { const n = []; if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (const t in e.defines) n.push(t), n.push(e.defines[t]); if (!1 === e.isRawShaderMaterial) { for (let t = 0; t < f.length; t++)n.push(e[f[t]]); n.push(t.outputEncoding), n.push(t.gammaFactor) } return n.push(e.customProgramCacheKey), n.join() }, getUniforms: function (t) { const e = p[t.type]; let n; return n = e ? fL.clone(RL[e].uniforms) : t.uniforms, n }, acquireProgram: function (e, n) { let r; for (let t = 0, i = o.length; t < i; t++) { const e = o[t]; if (e.cacheKey === n) { r = e, ++r.usedTimes; break } } return void 0 === r && (r = new fD(t, n, e, i), o.push(r)), r }, releaseProgram: function (t) { if (0 == --t.usedTimes) { const e = o.indexOf(t); o[e] = o[o.length - 1], o.pop(), t.destroy() } }, programs: o } } function gD() { let t = new WeakMap; return { get: function (e) { let n = t.get(e); return void 0 === n && (n = {}, t.set(e, n)), n }, remove: function (e) { t.delete(e) }, update: function (e, n, r) { t.get(e)[n] = r }, dispose: function () { t = new WeakMap } } } function vD(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function yD(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function bD(t) { const e = []; let n = 0; const r = [], i = [], s = [], o = { id: -1 }; function a(r, i, s, a, l, c) { let u = e[n]; const h = t.get(s); return void 0 === u ? (u = { id: r.id, object: r, geometry: i, material: s, program: h.program || o, groupOrder: a, renderOrder: r.renderOrder, z: l, group: c }, e[n] = u) : (u.id = r.id, u.object = r, u.geometry = i, u.material = s, u.program = h.program || o, u.groupOrder = a, u.renderOrder = r.renderOrder, u.z = l, u.group = c), n++, u } return { opaque: r, transmissive: i, transparent: s, init: function () { n = 0, r.length = 0, i.length = 0, s.length = 0 }, push: function (t, e, n, o, l, c) { const u = a(t, e, n, o, l, c); n.transmission > 0 ? i.push(u) : !0 === n.transparent ? s.push(u) : r.push(u) }, unshift: function (t, e, n, o, l, c) { const u = a(t, e, n, o, l, c); n.transmission > 0 ? i.unshift(u) : !0 === n.transparent ? s.unshift(u) : r.unshift(u) }, finish: function () { for (let t = n, r = e.length; t < r; t++) { const n = e[t]; if (null === n.id) break; n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null } }, sort: function (t, e) { r.length > 1 && r.sort(t || vD), i.length > 1 && i.sort(e || yD), s.length > 1 && s.sort(e || yD) } } } function _D(t) { let e = new WeakMap; return { get: function (n, r) { let i; return !1 === e.has(n) ? (i = new bD(t), e.set(n, [i])) : r >= e.get(n).length ? (i = new bD(t), e.get(n).push(i)) : i = e.get(n)[r], i }, dispose: function () { e = new WeakMap } } } function wD() { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": n = { direction: new rP, color: new PR }; break; case "SpotLight": n = { position: new rP, direction: new rP, color: new PR, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new rP, color: new PR, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new rP, skyColor: new PR, groundColor: new PR }; break; case "RectAreaLight": n = { color: new PR, position: new rP, halfWidth: new rP, halfHeight: new rP } }return t[e.id] = n, n } } } let SD = 0; function xD(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) } function TD(t, e) { const n = new wD, r = function () { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new XC }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new XC, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return t[e.id] = n, n } } }(), i = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let l = 0; l < 9; l++)i.probe.push(new rP); const s = new rP, o = new IP, a = new IP; return { setup: function (s) { let o = 0, a = 0, l = 0; for (let t = 0; t < 9; t++)i.probe[t].set(0, 0, 0); let c = 0, u = 0, h = 0, d = 0, p = 0, f = 0, m = 0, g = 0; s.sort(xD); for (let t = 0, e = s.length; t < e; t++) { const e = s[t], v = e.color, y = e.intensity, b = e.distance, _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null; if (e.isAmbientLight) o += v.r * y, a += v.g * y, l += v.b * y; else if (e.isLightProbe) for (let t = 0; t < 9; t++)i.probe[t].addScaledVector(e.sh.coefficients[t], y); else if (e.isDirectionalLight) { const t = n.get(e); if (t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow) { const t = e.shadow, n = r.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.directionalShadow[c] = n, i.directionalShadowMap[c] = _, i.directionalShadowMatrix[c] = e.shadow.matrix, f++ } i.directional[c] = t, c++ } else if (e.isSpotLight) { const t = n.get(e); if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(v).multiplyScalar(y), t.distance = b, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) { const t = e.shadow, n = r.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.spotShadow[h] = n, i.spotShadowMap[h] = _, i.spotShadowMatrix[h] = e.shadow.matrix, g++ } i.spot[h] = t, h++ } else if (e.isRectAreaLight) { const t = n.get(e); t.color.copy(v).multiplyScalar(y), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), i.rectArea[d] = t, d++ } else if (e.isPointLight) { const t = n.get(e); if (t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) { const t = e.shadow, n = r.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, i.pointShadow[u] = n, i.pointShadowMap[u] = _, i.pointShadowMatrix[u] = e.shadow.matrix, m++ } i.point[u] = t, u++ } else if (e.isHemisphereLight) { const t = n.get(e); t.skyColor.copy(e.color).multiplyScalar(y), t.groundColor.copy(e.groundColor).multiplyScalar(y), i.hemi[p] = t, p++ } } d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = PL.LTC_FLOAT_1, i.rectAreaLTC2 = PL.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = PL.LTC_HALF_1, i.rectAreaLTC2 = PL.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = o, i.ambient[1] = a, i.ambient[2] = l; const v = i.hash; v.directionalLength === c && v.pointLength === u && v.spotLength === h && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (i.directional.length = c, i.spot.length = h, i.rectArea.length = d, i.point.length = u, i.hemi.length = p, i.directionalShadow.length = f, i.directionalShadowMap.length = f, i.pointShadow.length = m, i.pointShadowMap.length = m, i.spotShadow.length = g, i.spotShadowMap.length = g, i.directionalShadowMatrix.length = f, i.pointShadowMatrix.length = m, i.spotShadowMatrix.length = g, v.directionalLength = c, v.pointLength = u, v.spotLength = h, v.rectAreaLength = d, v.hemiLength = p, v.numDirectionalShadows = f, v.numPointShadows = m, v.numSpotShadows = g, i.version = SD++) }, setupView: function (t, e) { let n = 0, r = 0, l = 0, c = 0, u = 0; const h = e.matrixWorldInverse; for (let d = 0, p = t.length; d < p; d++) { const e = t[d]; if (e.isDirectionalLight) { const t = i.directional[n]; t.direction.setFromMatrixPosition(e.matrixWorld), s.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), n++ } else if (e.isSpotLight) { const t = i.spot[l]; t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(e.matrixWorld), s.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), l++ } else if (e.isRectAreaLight) { const t = i.rectArea[c]; t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(h), a.identity(), o.copy(e.matrixWorld), o.premultiply(h), a.extractRotation(o), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++ } else if (e.isPointLight) { const t = i.point[r]; t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(h), r++ } else if (e.isHemisphereLight) { const t = i.hemi[u]; t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(h), t.direction.normalize(), u++ } } }, state: i } } function ED(t, e) { const n = new TD(t, e), r = [], i = []; return { init: function () { r.length = 0, i.length = 0 }, state: { lightsArray: r, shadowsArray: i, lights: n }, setupLights: function () { n.setup(r) }, setupLightsView: function (t) { n.setupView(r, t) }, pushLight: function (t) { r.push(t) }, pushShadow: function (t) { i.push(t) } } } function MD(t, e) { let n = new WeakMap; return { get: function (r, i = 0) { let s; return !1 === n.has(r) ? (s = new ED(t, e), n.set(r, [s])) : i >= n.get(r).length ? (s = new ED(t, e), n.get(r).push(s)) : s = n.get(r)[i], s }, dispose: function () { n = new WeakMap } } } class AD extends SR { constructor(t) { super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) } copy(t) { return super.copy(t), this.depthPacking = t.depthPacking, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this } } AD.prototype.isMeshDepthMaterial = !0; class CD extends SR { constructor(t) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new rP, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) } copy(t) { return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this } } function PD(t, e, n) { let r = new TL; const i = new XC, s = new XC, o = new $C, a = [], l = [], c = {}, u = n.maxTextureSize, h = { 0: 1, 1: 0, 2: 2 }, d = new mL({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new XC }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p = d.clone(); p.defines.HORIZONTAL_PASS = 1; const f = new JR; f.setAttribute("position", new DR(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const m = new cL(f, d), g = this; function v(n, r) { const i = e.update(m); d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, i, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, i, p, m, null) } function y(t) { const e = t << 0; let n = a[e]; return void 0 === n && (n = new AD({ depthPacking: 3201, morphTargets: t }), a[e] = n), n } function b(t) { const e = t << 0; let n = l[e]; return void 0 === n && (n = new CD({ morphTargets: t }), l[e] = n), n } function _(e, n, r, i, s, o, a) { let l = null, u = y, d = e.customDepthMaterial; if (!0 === i.isPointLight && (u = b, d = e.customDistanceMaterial), void 0 === d) { let t = !1; !0 === r.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0), l = u(t) } else l = d; if (t.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) { const t = l.uuid, e = r.uuid; let n = c[t]; void 0 === n && (n = {}, c[t] = n); let i = n[e]; void 0 === i && (i = l.clone(), n[e] = i), l = i } return l.visible = r.visible, l.wireframe = r.wireframe, l.side = 3 === a ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : h[r.side], l.clipShadows = r.clipShadows, l.clippingPlanes = r.clippingPlanes, l.clipIntersection = r.clipIntersection, l.wireframeLinewidth = r.wireframeLinewidth, l.linewidth = r.linewidth, !0 === i.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(i.matrixWorld), l.nearDistance = s, l.farDistance = o), l } function w(n, i, s, o, a) { if (!1 === n.visible) return; if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || r.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld); const r = e.update(n), i = n.material; if (Array.isArray(i)) { const e = r.groups; for (let l = 0, c = e.length; l < c; l++) { const c = e[l], u = i[c.materialIndex]; if (u && u.visible) { const e = _(n, r, u, o, s.near, s.far, a); t.renderBufferDirect(s, null, r, e, n, c) } } } else if (i.visible) { const e = _(n, r, i, o, s.near, s.far, a); t.renderBufferDirect(s, null, r, e, n, null) } } const l = n.children; for (let t = 0, e = l.length; t < e; t++)w(l[t], i, s, o, a) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, n, a) { if (!1 === g.enabled) return; if (!1 === g.autoUpdate && !1 === g.needsUpdate) return; if (0 === e.length) return; const l = t.getRenderTarget(), c = t.getActiveCubeFace(), h = t.getActiveMipmapLevel(), d = t.state; d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1); for (let p = 0, f = e.length; p < f; p++) { const l = e[p], c = l.shadow; if (void 0 === c) { console.warn("THREE.WebGLShadowMap:", l, "has no shadow."); continue } if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue; i.copy(c.mapSize); const h = c.getFrameExtents(); if (i.multiply(h), s.copy(c.mapSize), (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / h.x), i.x = s.x * h.x, c.mapSize.x = s.x), i.y > u && (s.y = Math.floor(u / h.y), i.y = s.y * h.y, c.mapSize.y = s.y)), null === c.map && !c.isPointLightShadow && 3 === this.type) { const t = { minFilter: cC, magFilter: cC, format: yC }; c.map = new tP(i.x, i.y, t), c.map.texture.name = l.name + ".shadowMap", c.mapPass = new tP(i.x, i.y, t), c.camera.updateProjectionMatrix() } null === c.map && (c.map = new tP(i.x, i.y, { minFilter: oC, magFilter: oC, format: yC }), c.map.texture.name = l.name + ".shadowMap", c.camera.updateProjectionMatrix()), t.setRenderTarget(c.map), t.clear(); const f = c.getViewportCount(); for (let t = 0; t < f; t++) { const e = c.getViewport(t); o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(o), c.updateMatrices(l, t), r = c.getFrustum(), w(n, a, c.camera, l, this.type) } c.isPointLightShadow || 3 !== this.type || v(c, a), c.needsUpdate = !1 } g.needsUpdate = !1, t.setRenderTarget(l, c, h) } } function RD(t, e, n) { const r = n.isWebGL2, i = new function () { let e = !1; const n = new $C; let r = null; const i = new $C(0, 0, 0, 0); return { setMask: function (n) { r === n || e || (t.colorMask(n, n, n, n), r = n) }, setLocked: function (t) { e = t }, setClear: function (e, r, s, o, a) { !0 === a && (e *= o, r *= o, s *= o), n.set(e, r, s, o), !1 === i.equals(n) && (t.clearColor(e, r, s, o), i.copy(n)) }, reset: function () { e = !1, r = null, i.set(-1, 0, 0, 0) } } }, s = new function () { let e = !1, n = null, r = null, i = null; return { setTest: function (t) { t ? N(2929) : B(2929) }, setMask: function (r) { n === r || e || (t.depthMask(r), n = r) }, setFunc: function (e) { if (r !== e) { if (e) switch (e) { case 0: t.depthFunc(512); break; case 1: t.depthFunc(519); break; case 2: t.depthFunc(513); break; case 3: t.depthFunc(515); break; case 4: t.depthFunc(514); break; case 5: t.depthFunc(518); break; case 6: t.depthFunc(516); break; case 7: t.depthFunc(517); break; default: t.depthFunc(515) } else t.depthFunc(515); r = e } }, setLocked: function (t) { e = t }, setClear: function (e) { i !== e && (t.clearDepth(e), i = e) }, reset: function () { e = !1, n = null, r = null, i = null } } }, o = new function () { let e = !1, n = null, r = null, i = null, s = null, o = null, a = null, l = null, c = null; return { setTest: function (t) { e || (t ? N(2960) : B(2960)) }, setMask: function (r) { n === r || e || (t.stencilMask(r), n = r) }, setFunc: function (e, n, o) { r === e && i === n && s === o || (t.stencilFunc(e, n, o), r = e, i = n, s = o) }, setOp: function (e, n, r) { o === e && a === n && l === r || (t.stencilOp(e, n, r), o = e, a = n, l = r) }, setLocked: function (t) { e = t }, setClear: function (e) { c !== e && (t.clearStencil(e), c = e) }, reset: function () { e = !1, n = null, r = null, i = null, s = null, o = null, a = null, l = null, c = null } } }; let a = {}, l = null, c = {}, u = null, h = !1, d = null, p = null, f = null, m = null, g = null, v = null, y = null, b = !1, _ = null, w = null, S = null, x = null, T = null; const E = t.getParameter(35661); let M = !1, A = 0; const C = t.getParameter(7938); -1 !== C.indexOf("WebGL") ? (A = parseFloat(/^WebGL (\d)/.exec(C)[1]), M = A >= 1) : -1 !== C.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL ES (\d)/.exec(C)[1]), M = A >= 2); let P = null, R = {}; const L = t.getParameter(3088), k = t.getParameter(2978), D = (new $C).fromArray(L), I = (new $C).fromArray(k); function O(e, n, r) { const i = new Uint8Array(4), s = t.createTexture(); t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728); for (let o = 0; o < r; o++)t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i); return s } const F = {}; function N(e) { !0 !== a[e] && (t.enable(e), a[e] = !0) } function B(e) { !1 !== a[e] && (t.disable(e), a[e] = !1) } F[3553] = O(3553, 3553, 1), F[34067] = O(34067, 34069, 6), i.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), N(2929), s.setFunc(3), V(!1), z(1), N(2884), G(0); const H = { [nC]: 32774, 101: 32778, 102: 32779 }; if (r) H[103] = 32775, H[104] = 32776; else { const t = e.get("EXT_blend_minmax"); null !== t && (H[103] = t.MIN_EXT, H[104] = t.MAX_EXT) } const U = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 }; function G(e, n, r, i, s, o, a, l) { if (0 !== e) { if (!1 === h && (N(3042), h = !0), 5 === e) s = s || n, o = o || r, a = a || i, n === p && s === g || (t.blendEquationSeparate(H[n], H[s]), p = n, g = s), r === f && i === m && o === v && a === y || (t.blendFuncSeparate(U[r], U[i], U[o], U[a]), f = r, m = i, v = o, y = a), d = e, b = null; else if (e !== d || l !== b) { if (p === nC && g === nC || (t.blendEquation(32774), p = nC, g = nC), l) switch (e) { case 1: t.blendFuncSeparate(1, 771, 1, 771); break; case 2: t.blendFunc(1, 1); break; case 3: t.blendFuncSeparate(0, 0, 769, 771); break; case 4: t.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case 1: t.blendFuncSeparate(770, 771, 1, 771); break; case 2: t.blendFunc(770, 1); break; case 3: t.blendFunc(0, 769); break; case 4: t.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }f = null, m = null, v = null, y = null, d = e, b = l } } else !0 === h && (B(3042), h = !1) } function V(e) { _ !== e && (t.frontFace(e ? 2304 : 2305), _ = e) } function z(e) { 0 !== e ? (N(2884), e !== w && t.cullFace(1 === e ? 1029 : 2 === e ? 1028 : 1032)) : B(2884), w = e } function j(e, n, r) { e ? (N(32823), x === n && T === r || (t.polygonOffset(n, r), x = n, T = r)) : B(32823) } function J(e) { void 0 === e && (e = 33984 + E - 1), P !== e && (t.activeTexture(e), P = e) } return { buffers: { color: i, depth: s, stencil: o }, enable: N, disable: B, bindFramebuffer: function (e, n) { return null === n && null !== l && (n = l), c[e] !== n && (t.bindFramebuffer(e, n), c[e] = n, r && (36009 === e && (c[36160] = n), 36160 === e && (c[36009] = n)), !0) }, bindXRFramebuffer: function (e) { e !== l && (t.bindFramebuffer(36160, e), l = e) }, useProgram: function (e) { return u !== e && (t.useProgram(e), u = e, !0) }, setBlending: G, setMaterial: function (t, e) { 2 === t.side ? B(2884) : N(2884); let n = 1 === t.side; e && (n = !n), V(n), 1 === t.blending && !1 === t.transparent ? G(0) : G(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), i.setMask(t.colorWrite); const r = t.stencilWrite; o.setTest(r), r && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), j(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? N(32926) : B(32926) }, setFlipSided: V, setCullFace: z, setLineWidth: function (e) { e !== S && (M && t.lineWidth(e), S = e) }, setPolygonOffset: j, setScissorTest: function (t) { t ? N(3089) : B(3089) }, activeTexture: J, bindTexture: function (e, n) { null === P && J(); let r = R[P]; void 0 === r && (r = { type: void 0, texture: void 0 }, R[P] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || F[e]), r.type = e, r.texture = n) }, unbindTexture: function () { const e = R[P]; void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { t.texImage3D.apply(t, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (e) { !1 === D.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), D.copy(e)) }, viewport: function (e) { !1 === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), I.copy(e)) }, reset: function () { t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === r && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), a = {}, P = null, R = {}, l = null, c = {}, u = null, h = !1, d = null, p = null, f = null, m = null, g = null, v = null, y = null, b = !1, _ = null, w = null, S = null, x = null, T = null, D.set(0, 0, t.canvas.width, t.canvas.height), I.set(0, 0, t.canvas.width, t.canvas.height), i.reset(), s.reset(), o.reset() } } } function LD(t, e, n, r, i, s, o) { const a = i.isWebGL2, l = i.maxTextures, c = i.maxCubemapSize, u = i.maxTextureSize, h = i.maxSamples, d = new WeakMap; let p, f = !1; try { f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (N) { } function m(t, e) { return f ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function g(t, e, n, r) { let i = 1; if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { const r = e ? jC : Math.floor, s = r(i * t.width), o = r(i * t.height); void 0 === p && (p = m(s, o)); const a = n ? m(s, o) : p; return a.width = s, a.height = o, a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a } return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t } return t } function v(t) { return VC(t.width) && VC(t.height) } function y(t, e) { return t.generateMipmaps && e && t.minFilter !== oC && t.minFilter !== cC } function b(e, n, i, s) { t.generateMipmap(e), r.get(n).__maxMipLevel = Math.log2(Math.max(i, s)) } function _(n, r, i) { if (!1 === a) return r; if (null !== n) { if (void 0 !== t[n]) return t[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let s = r; return 6403 === r && (5126 === i && (s = 33326), 5131 === i && (s = 33325), 5121 === i && (s = 33321)), 6407 === r && (5126 === i && (s = 34837), 5131 === i && (s = 34843), 5121 === i && (s = 32849)), 6408 === r && (5126 === i && (s = 34836), 5131 === i && (s = 34842), 5121 === i && (s = 32856)), 33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"), s } function w(t) { return t === oC || t === aC || t === lC ? 9728 : 9729 } function S(e) { const n = e.target; n.removeEventListener("dispose", S), function (e) { const n = r.get(e); void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), r.remove(e)) }(n), n.isVideoTexture && d.delete(n), o.memory.textures-- } function x(e) { const n = e.target; n.removeEventListener("dispose", x), function (e) { const n = e.texture, i = r.get(e), s = r.get(n); if (e) { if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), o.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++)t.deleteFramebuffer(i.__webglFramebuffer[e]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[e]); else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && t.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer && t.deleteRenderbuffer(i.__webglColorRenderbuffer), i.__webglDepthRenderbuffer && t.deleteRenderbuffer(i.__webglDepthRenderbuffer); if (e.isWebGLMultipleRenderTargets) for (let e = 0, i = n.length; e < i; e++) { const i = r.get(n[e]); i.__webglTexture && (t.deleteTexture(i.__webglTexture), o.memory.textures--), r.remove(n[e]) } r.remove(n), r.remove(e) } }(n) } let T = 0; function E(t, e) { const i = r.get(t); if (t.isVideoTexture && function (t) { const e = o.render.frame; d.get(t) !== e && (d.set(t, e), t.update()) }(t), t.version > 0 && i.__version !== t.version) { const n = t.image; if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== n.complete) return void L(i, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture) } function M(e, i) { const o = r.get(e); e.version > 0 && o.__version !== e.version ? function (e, r, i) { if (6 !== r.image.length) return; R(e, r), n.activeTexture(33984 + i), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0); const o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture), l = r.image[0] && r.image[0].isDataTexture, u = []; for (let t = 0; t < 6; t++)u[t] = o || l ? l ? r.image[t].image : r.image[t] : g(r.image[t], !1, !0, c); const h = u[0], d = v(h) || a, p = s.convert(r.format), f = s.convert(r.type), m = _(r.internalFormat, p, f); let w; if (P(34067, r, d), o) { for (let t = 0; t < 6; t++) { w = u[t].mipmaps; for (let e = 0; e < w.length; e++) { const i = w[e]; r.format !== yC && r.format !== vC ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, i.width, i.height, 0, p, f, i.data) } } e.__maxMipLevel = w.length - 1 } else { w = r.mipmaps; for (let t = 0; t < 6; t++)if (l) { n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, p, f, u[t].data); for (let e = 0; e < w.length; e++) { const r = w[e].image[t].image; n.texImage2D(34069 + t, e + 1, m, r.width, r.height, 0, p, f, r.data) } } else { n.texImage2D(34069 + t, 0, m, p, f, u[t]); for (let e = 0; e < w.length; e++)n.texImage2D(34069 + t, e + 1, m, p, f, w[e].image[t]) } e.__maxMipLevel = w.length } y(r, d) && b(34067, r, h.width, h.height), e.__version = r.version, r.onUpdate && r.onUpdate(r) }(o, e, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture)) } const A = { [rC]: 10497, [iC]: 33071, [sC]: 33648 }, C = { [oC]: 9728, [aC]: 9984, [lC]: 9986, [cC]: 9729, 1007: 9985, [uC]: 9987 }; function P(n, s, o) { if (o ? (t.texParameteri(n, 10242, A[s.wrapS]), t.texParameteri(n, 10243, A[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[s.wrapR]), t.texParameteri(n, 10240, C[s.magFilter]), t.texParameteri(n, 10241, C[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === iC && s.wrapT === iC || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, w(s.magFilter)), t.texParameteri(n, 10241, w(s.minFilter)), s.minFilter !== oC && s.minFilter !== cC && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) { const o = e.get("EXT_texture_filter_anisotropic"); if (s.type === fC && !1 === e.has("OES_texture_float_linear")) return; if (!1 === a && s.type === mC && !1 === e.has("OES_texture_half_float_linear")) return; (s.anisotropy > 1 || r.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, i.getMaxAnisotropy())), r.get(s).__currentAnisotropy = s.anisotropy) } } function R(e, n) { void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", S), e.__webglTexture = t.createTexture(), o.memory.textures++) } function L(e, r, i) { let o = 3553; r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), R(e, r), n.activeTexture(33984 + i), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0); const l = function (t) { return !a && (t.wrapS !== iC || t.wrapT !== iC || t.minFilter !== oC && t.minFilter !== cC) }(r) && !1 === v(r.image), c = g(r.image, l, !1, u), h = v(c) || a, d = s.convert(r.format); let p, f = s.convert(r.type), m = _(r.internalFormat, d, f); P(o, r, h); const w = r.mipmaps; if (r.isDepthTexture) m = 6402, a ? m = r.type === fC ? 36012 : r.type === pC ? 33190 : r.type === gC ? 35056 : 33189 : r.type === fC && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === bC && 6402 === m && r.type !== dC && r.type !== pC && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = dC, f = s.convert(r.type)), r.format === _C && 6402 === m && (m = 34041, r.type !== gC && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = gC, f = s.convert(r.type))), n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null); else if (r.isDataTexture) if (w.length > 0 && h) { for (let t = 0, e = w.length; t < e; t++)p = w[t], n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data); r.generateMipmaps = !1, e.__maxMipLevel = w.length - 1 } else n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data), e.__maxMipLevel = 0; else if (r.isCompressedTexture) { for (let t = 0, e = w.length; t < e; t++)p = w[t], r.format !== yC && r.format !== vC ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data); e.__maxMipLevel = w.length - 1 } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), e.__maxMipLevel = 0; else if (r.isDataTexture3D) n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), e.__maxMipLevel = 0; else if (w.length > 0 && h) { for (let t = 0, e = w.length; t < e; t++)p = w[t], n.texImage2D(3553, t, m, d, f, p); r.generateMipmaps = !1, e.__maxMipLevel = w.length - 1 } else n.texImage2D(3553, 0, m, d, f, c), e.__maxMipLevel = 0; y(r, h) && b(o, r, c.width, c.height), e.__version = r.version, r.onUpdate && r.onUpdate(r) } function k(e, i, o, a, l) { const c = s.convert(o.format), u = s.convert(o.type), h = _(o.internalFormat, c, u); 32879 === l || 35866 === l ? n.texImage3D(l, 0, h, i.width, i.height, i.depth, 0, c, u, null) : n.texImage2D(l, 0, h, i.width, i.height, 0, c, u, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, l, r.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null) } function D(e, n, r) { if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) { let i = 33189; if (r) { const e = n.depthTexture; e && e.isDepthTexture && (e.type === fC ? i = 36012 : e.type === pC && (i = 33190)); const r = I(n); t.renderbufferStorageMultisample(36161, r, i, n.width, n.height) } else t.renderbufferStorage(36161, i, n.width, n.height); t.framebufferRenderbuffer(36160, 36096, 36161, e) } else if (n.depthBuffer && n.stencilBuffer) { if (r) { const e = I(n); t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height) } else t.renderbufferStorage(36161, 34041, n.width, n.height); t.framebufferRenderbuffer(36160, 33306, 36161, e) } else { const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture, i = s.convert(e.format), o = s.convert(e.type), a = _(e.internalFormat, i, o); if (r) { const e = I(n); t.renderbufferStorageMultisample(36161, e, a, n.width, n.height) } else t.renderbufferStorage(36161, a, n.width, n.height) } t.bindRenderbuffer(36161, null) } function I(t) { return a && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0 } let O = !1, F = !1; this.allocateTextureUnit = function () { const t = T; return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), T += 1, t }, this.resetTextureUnits = function () { T = 0 }, this.setTexture2D = E, this.setTexture2DArray = function (t, e) { const i = r.get(t); t.version > 0 && i.__version !== t.version ? L(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture)) }, this.setTexture3D = function (t, e) { const i = r.get(t); t.version > 0 && i.__version !== t.version ? L(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture)) }, this.setTextureCube = M, this.setupRenderTarget = function (e) { const l = e.texture, c = r.get(e), u = r.get(l); e.addEventListener("dispose", x), !0 !== e.isWebGLMultipleRenderTargets && (u.__webglTexture = t.createTexture(), u.__version = l.version, o.memory.textures++); const h = !0 === e.isWebGLCubeRenderTarget, d = !0 === e.isWebGLMultipleRenderTargets, p = !0 === e.isWebGLMultisampleRenderTarget, f = l.isDataTexture3D || l.isDataTexture2DArray, m = v(e) || a; if (!a || l.format !== vC || l.type !== fC && l.type !== mC || (l.format = yC, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) { c.__webglFramebuffer = []; for (let e = 0; e < 6; e++)c.__webglFramebuffer[e] = t.createFramebuffer() } else if (c.__webglFramebuffer = t.createFramebuffer(), d) if (i.drawBuffers) { const n = e.texture; for (let e = 0, i = n.length; e < i; e++) { const i = r.get(n[e]); void 0 === i.__webglTexture && (i.__webglTexture = t.createTexture(), o.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (p) if (a) { c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer); const r = s.convert(l.format), i = s.convert(l.type), o = _(l.internalFormat, r, i), a = I(e); t.renderbufferStorageMultisample(36161, a, o, e.width, e.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), D(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (h) { n.bindTexture(34067, u.__webglTexture), P(34067, l, m); for (let t = 0; t < 6; t++)k(c.__webglFramebuffer[t], e, l, 36064, 34069 + t); y(l, m) && b(34067, l, e.width, e.height), n.bindTexture(34067, null) } else if (d) { const t = e.texture; for (let i = 0, s = t.length; i < s; i++) { const s = t[i], o = r.get(s); n.bindTexture(3553, o.__webglTexture), P(3553, s, m), k(c.__webglFramebuffer, e, s, 36064 + i, 3553), y(s, m) && b(3553, s, e.width, e.height) } n.bindTexture(3553, null) } else { let t = 3553; f && (a ? t = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, u.__webglTexture), P(t, l, m), k(c.__webglFramebuffer, e, l, 36064, t), y(l, m) && b(3553, l, e.width, e.height), n.bindTexture(3553, null) } e.depthBuffer && function (e) { const i = r.get(e), s = !0 === e.isWebGLCubeRenderTarget; if (e.depthTexture) { if (s) throw new Error("target.depthTexture not supported in Cube render targets"); !function (e, i) { if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), E(i.depthTexture, 0); const s = r.get(i.depthTexture).__webglTexture; if (i.depthTexture.format === bC) t.framebufferTexture2D(36160, 36096, 3553, s, 0); else { if (i.depthTexture.format !== _C) throw new Error("Unknown depthTexture format"); t.framebufferTexture2D(36160, 33306, 3553, s, 0) } }(i.__webglFramebuffer, e) } else if (s) { i.__webglDepthbuffer = []; for (let r = 0; r < 6; r++)n.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = t.createRenderbuffer(), D(i.__webglDepthbuffer[r], e, !1) } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), D(i.__webglDepthbuffer, e, !1); n.bindFramebuffer(36160, null) }(e) }, this.updateRenderTargetMipmap = function (t) { const e = v(t) || a, i = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]; for (let s = 0, o = i.length; s < o; s++) { const o = i[s]; if (y(o, e)) { const e = t.isWebGLCubeRenderTarget ? 34067 : 3553, i = r.get(o).__webglTexture; n.bindTexture(e, i), b(e, o, t.width, t.height), n.bindTexture(e, null) } } }, this.updateMultisampleRenderTarget = function (e) { if (e.isWebGLMultisampleRenderTarget) if (a) { const i = e.width, s = e.height; let o = 16384; e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024); const a = r.get(e); n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, i, s, 0, 0, i, s, o, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (t, e) { t && t.isWebGLRenderTarget && (!1 === O && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), O = !0), t = t.texture), E(t, e) }, this.safeSetTextureCube = function (t, e) { t && t.isWebGLCubeRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), F = !0), t = t.texture), M(t, e) } } function kD(t, e, n) { const r = n.isWebGL2; return { convert: function (t) { let n; if (t === hC) return 5121; if (1017 === t) return 32819; if (1018 === t) return 32820; if (1019 === t) return 33635; if (1010 === t) return 5120; if (1011 === t) return 5122; if (t === dC) return 5123; if (1013 === t) return 5124; if (t === pC) return 5125; if (t === fC) return 5126; if (t === mC) return r ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null); if (1021 === t) return 6406; if (t === vC) return 6407; if (t === yC) return 6408; if (1024 === t) return 6409; if (1025 === t) return 6410; if (t === bC) return 6402; if (t === _C) return 34041; if (1028 === t) return 6403; if (1029 === t) return 36244; if (1030 === t) return 33319; if (1031 === t) return 33320; if (1032 === t) return 36248; if (1033 === t) return 36249; if (33776 === t || 33777 === t || 33778 === t || 33779 === t) { if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null; if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === t || 35841 === t || 35842 === t || 35843 === t) { if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null; if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) { if (37492 === t) return n.COMPRESSED_RGB8_ETC2; if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC } return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === gC ? r ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0 } } } CD.prototype.isMeshDistanceMaterial = !0; class DD extends vL { constructor(t = []) { super(), this.cameras = t } } DD.prototype.isArrayCamera = !0; class ID extends sR { constructor() { super(), this.type = "Group" } } ID.prototype.isGroup = !0; const OD = { type: "move" }; class FD { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new ID, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new ID, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new rP, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new rP), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new ID, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new rP, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new rP), this._grip } dispatchEvent(t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this } disconnect(t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(t, e, n) { let r = null, i = null, s = null; const o = this._targetRay, a = this._grip, l = this._hand; if (t && "visible-blurred" !== e.session.visibilityState) if (null !== o && (r = e.getPose(t.targetRaySpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(OD))), l && t.hand) { s = !0; for (const s of t.hand.values()) { const t = e.getJointPose(s, n); if (void 0 === l.joints[s.jointName]) { const t = new ID; t.matrixAutoUpdate = !1, t.visible = !1, l.joints[s.jointName] = t, l.add(t) } const r = l.joints[s.jointName]; null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t } const r = l.joints["index-finger-tip"].position.distanceTo(l.joints["thumb-tip"].position), i = .02, o = .005; l.inputState.pinching && r > i + o ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !l.inputState.pinching && r <= i - o && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this })) } else null !== a && t.gripSpace && (i = e.getPose(t.gripSpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1)); return null !== o && (o.visible = null !== r), null !== a && (a.visible = null !== i), null !== l && (l.visible = null !== s), this } } class ND extends DC { constructor(t, e) { super(); const n = this, r = t.state; let i = null, s = 1, o = null, a = "local-floor", l = null; const c = [], u = new Map, h = new vL; h.layers.enable(1), h.viewport = new $C; const d = new vL; d.layers.enable(2), d.viewport = new $C; const p = [h, d], f = new DD; f.layers.enable(1), f.layers.enable(2); let m = null, g = null; function v(t) { const e = u.get(t.inputSource); e && e.dispatchEvent({ type: t.type, data: t.inputSource }) } function y() { u.forEach(function (t, e) { t.disconnect(e) }), u.clear(), m = null, g = null, r.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), T.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function b(t) { const e = i.inputSources; for (let n = 0; n < c.length; n++)u.set(e[n], c[n]); for (let n = 0; n < t.removed.length; n++) { const e = t.removed[n], r = u.get(e); r && (r.dispatchEvent({ type: "disconnected", data: e }), u.delete(e)) } for (let n = 0; n < t.added.length; n++) { const e = t.added[n], r = u.get(e); r && r.dispatchEvent({ type: "connected", data: e }) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (t) { let e = c[t]; return void 0 === e && (e = new FD, c[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function (t) { let e = c[t]; return void 0 === e && (e = new FD, c[t] = e), e.getGripSpace() }, this.getHand = function (t) { let e = c[t]; return void 0 === e && (e = new FD, c[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function (t) { s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (t) { a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return o }, this.getSession = function () { return i }, this.setSession = async function (t) { if (i = t, null !== i) { i.addEventListener("select", v), i.addEventListener("selectstart", v), i.addEventListener("selectend", v), i.addEventListener("squeeze", v), i.addEventListener("squeezestart", v), i.addEventListener("squeezeend", v), i.addEventListener("end", y), i.addEventListener("inputsourceschange", b); const t = e.getContextAttributes(); !0 !== t.xrCompatible && await e.makeXRCompatible(); const r = new XRWebGLLayer(i, e, { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: s }); i.updateRenderState({ baseLayer: r }), o = await i.requestReferenceSpace(a), T.setContext(i), T.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }; const _ = new rP, w = new rP; function S(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert() } this.updateCamera = function (t) { if (null === i) return; f.near = d.near = h.near = t.near, f.far = d.far = h.far = t.far, m === f.near && g === f.far || (i.updateRenderState({ depthNear: f.near, depthFar: f.far }), m = f.near, g = f.far); const e = t.parent, n = f.cameras; S(f, e); for (let i = 0; i < n.length; i++)S(n[i], e); t.matrixWorld.copy(f.matrixWorld), t.matrix.copy(f.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale); const r = t.children; for (let i = 0, s = r.length; i < s; i++)r[i].updateMatrixWorld(!0); 2 === n.length ? function (t, e, n) { _.setFromMatrixPosition(e.matrixWorld), w.setFromMatrixPosition(n.matrixWorld); const r = _.distanceTo(w), i = e.projectionMatrix.elements, s = n.projectionMatrix.elements, o = i[14] / (i[10] - 1), a = i[14] / (i[10] + 1), l = (i[9] + 1) / i[5], c = (i[9] - 1) / i[5], u = (i[8] - 1) / i[0], h = (s[8] + 1) / s[0], d = o * u, p = o * h, f = r / (-u + h), m = f * -u; e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert(); const g = o + f, v = a + f; t.projectionMatrix.makePerspective(d - m, p + (r - m), l * a / v * g, c * a / v * g, g, v) }(f, h, d) : f.projectionMatrix.copy(h.projectionMatrix) }, this.getCamera = function () { return f }; let x = null; const T = new EL; T.setAnimationLoop(function (t, e) { if (l = e.getViewerPose(o), null !== l) { const t = l.views, e = i.renderState.baseLayer; r.bindXRFramebuffer(e.framebuffer); let n = !1; t.length !== f.cameras.length && (f.cameras.length = 0, n = !0); for (let r = 0; r < t.length; r++) { const i = t[r], s = e.getViewport(i), o = p[r]; o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === r && f.matrix.copy(o.matrix), !0 === n && f.cameras.push(o) } } const n = i.inputSources; for (let r = 0; r < c.length; r++)c[r].update(n[r], e, o); x && x(t, e) }), this.setAnimationLoop = function (t) { x = t }, this.dispose = function () { } } } function BD(t) { function e(e, n) { e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap); const r = t.get(n).envMap; if (r) { e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture && r._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio; const i = t.get(r).__maxMipLevel; void 0 !== i && (e.maxMipLevel.value = i) } let i, s; n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (i = n.clearcoatRoughnessMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix)) } function n(e, n) { e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity) } return { refreshFogUniforms: function (t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) }, refreshMaterialUniforms: function (t, r, i, s, o) { r.isMeshBasicMaterial ? e(t, r) : r.isMeshLambertMaterial ? (e(t, r), function (t, e) { e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(t, r)) : r.isMeshToonMaterial ? (e(t, r), function (t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, r)) : r.isMeshPhongMaterial ? (e(t, r), function (t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, r)) : r.isMeshStandardMaterial ? (e(t, r), r.isMeshPhysicalMaterial ? function (t, e, r) { n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate()), t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), e.transmission > 0 && (t.transmissionSamplerMap.value = r.texture, t.transmissionSamplerSize.value.set(r.width, r.height)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor) }(t, r, o) : n(t, r)) : r.isMeshMatcapMaterial ? (e(t, r), function (t, e) { e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, r)) : r.isMeshDepthMaterial ? (e(t, r), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, r)) : r.isMeshDistanceMaterial ? (e(t, r), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, r)) : r.isMeshNormalMaterial ? (e(t, r), function (t, e) { e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, r)) : r.isLineBasicMaterial ? (function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, r), r.isLineDashedMaterial && function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, r)) : r.isPointsMaterial ? function (t, e, n, r) { let i; t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? i = e.map : e.alphaMap && (i = e.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix)) }(t, r, i, s) : r.isSpriteMaterial ? function (t, e) { let n; t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)) }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1) } } } function HD(t) { const e = void 0 !== (t = t || {}).canvas ? t.canvas : function () { const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return t.style.display = "block", t }(), n = void 0 !== t.context ? t.context : null, r = void 0 !== t.alpha && t.alpha, i = void 0 === t.depth || t.depth, s = void 0 === t.stencil || t.stencil, o = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, c = void 0 !== t.powerPreference ? t.powerPreference : "default", u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat; let h = null, d = null; const p = [], f = []; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = AC, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1; const m = this; let g = !1, v = 0, y = 0, b = null, _ = -1, w = null; const S = new $C, x = new $C; let T = null, E = e.width, M = e.height, A = 1, C = null, P = null; const R = new $C(0, 0, E, M), L = new $C(0, 0, E, M); let k = !1; const D = [], I = new TL; let O = !1, F = !1, N = null; const B = new IP, H = new rP, U = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function G() { return null === b ? A : 1 } let V, z, j, J, X, W, q, Z, K, Y, Q, $, tt, et, nt, rt, it, st, ot, at, lt, ct, ut = n; function ht(t, n) { for (let r = 0; r < t.length; r++) { const i = e.getContext(t[r], n); if (null !== i) return i } return null } try { const t = { alpha: r, depth: i, stencil: s, antialias: o, premultipliedAlpha: a, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: u }; if (e.addEventListener("webglcontextlost", ft, !1), e.addEventListener("webglcontextrestored", mt, !1), null === ut) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === m.isWebGL1Renderer && e.shift(), ut = ht(e, t), null === ut) throw ht(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === ut.getShaderPrecisionFormat && (ut.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (At) { throw console.error("THREE.WebGLRenderer: " + At.message), At } function dt() { V = new NL(ut), z = new IL(ut, V, t), V.init(z), lt = new kD(ut, V, z), j = new RD(ut, V, z), D[0] = 1029, J = new UL(ut), X = new gD, W = new LD(ut, V, j, X, z, lt, J), q = new FL(m), Z = new ML(ut, z), ct = new kL(ut, V, Z, z), K = new BL(ut, Z, J, ct), Y = new jL(ut, K, Z, J), st = new zL(ut), nt = new OL(X), Q = new mD(m, q, V, z, ct, nt), $ = new BD(X), tt = new _D(X), et = new MD(V, z), it = new LL(m, q, j, Y, a), rt = new PD(m, Y, z), ot = new DL(ut, V, J, z), at = new HL(ut, V, J, z), J.programs = Q.programs, m.capabilities = z, m.extensions = V, m.properties = X, m.renderLists = tt, m.shadowMap = rt, m.state = j, m.info = J } dt(); const pt = new ND(m, ut); function ft(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0 } function mt() { console.log("THREE.WebGLRenderer: Context Restored."), g = !1; const t = J.autoReset, e = rt.enabled, n = rt.autoUpdate, r = rt.needsUpdate, i = rt.type; dt(), J.autoReset = t, rt.enabled = e, rt.autoUpdate = n, rt.needsUpdate = r, rt.type = i } function gt(t) { const e = t.target; e.removeEventListener("dispose", gt), function (t) { (function (t) { const e = X.get(t).programs; void 0 !== e && e.forEach(function (t) { Q.releaseProgram(t) }) })(t), X.remove(t) }(e) } this.xr = pt, this.getContext = function () { return ut }, this.getContextAttributes = function () { return ut.getContextAttributes() }, this.forceContextLoss = function () { const t = V.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { const t = V.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return A }, this.setPixelRatio = function (t) { void 0 !== t && (A = t, this.setSize(E, M, !1)) }, this.getSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new XC), t.set(E, M) }, this.setSize = function (t, n, r) { pt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = t, M = n, e.width = Math.floor(t * A), e.height = Math.floor(n * A), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n)) }, this.getDrawingBufferSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new XC), t.set(E * A, M * A).floor() }, this.setDrawingBufferSize = function (t, n, r) { E = t, M = n, A = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n) }, this.getCurrentViewport = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new $C), t.copy(S) }, this.getViewport = function (t) { return t.copy(R) }, this.setViewport = function (t, e, n, r) { t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, n, r), j.viewport(S.copy(R).multiplyScalar(A).floor()) }, this.getScissor = function (t) { return t.copy(L) }, this.setScissor = function (t, e, n, r) { t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, n, r), j.scissor(x.copy(L).multiplyScalar(A).floor()) }, this.getScissorTest = function () { return k }, this.setScissorTest = function (t) { j.setScissorTest(k = t) }, this.setOpaqueSort = function (t) { C = t }, this.setTransparentSort = function (t) { P = t }, this.getClearColor = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), t = new PR), t.copy(it.getClearColor()) }, this.setClearColor = function () { it.setClearColor.apply(it, arguments) }, this.getClearAlpha = function () { return it.getClearAlpha() }, this.setClearAlpha = function () { it.setClearAlpha.apply(it, arguments) }, this.clear = function (t, e, n) { let r = 0; (void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === n || n) && (r |= 1024), ut.clear(r) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", ft, !1), e.removeEventListener("webglcontextrestored", mt, !1), tt.dispose(), et.dispose(), X.dispose(), q.dispose(), Y.dispose(), ct.dispose(), pt.dispose(), pt.removeEventListener("sessionstart", yt), pt.removeEventListener("sessionend", bt), N && (N.dispose(), N = null), _t.stop() }, this.renderBufferImmediate = function (t, e) { ct.initAttributes(); const n = X.get(t); t.hasPositions && !n.position && (n.position = ut.createBuffer()), t.hasNormals && !n.normal && (n.normal = ut.createBuffer()), t.hasUvs && !n.uv && (n.uv = ut.createBuffer()), t.hasColors && !n.color && (n.color = ut.createBuffer()); const r = e.getAttributes(); t.hasPositions && (ut.bindBuffer(34962, n.position), ut.bufferData(34962, t.positionArray, 35048), ct.enableAttribute(r.position), ut.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ut.bindBuffer(34962, n.normal), ut.bufferData(34962, t.normalArray, 35048), ct.enableAttribute(r.normal), ut.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ut.bindBuffer(34962, n.uv), ut.bufferData(34962, t.uvArray, 35048), ct.enableAttribute(r.uv), ut.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ut.bindBuffer(34962, n.color), ut.bufferData(34962, t.colorArray, 35048), ct.enableAttribute(r.color), ut.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), ct.disableUnusedAttributes(), ut.drawArrays(4, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, n, r, i, s) { null === e && (e = U); const o = i.isMesh && i.matrixWorld.determinant() < 0, a = Mt(t, e, r, i); j.setMaterial(r, o); let l = n.index; const c = n.attributes.position; if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return; let u, h = 1; !0 === r.wireframe && (l = K.getWireframeAttribute(n), h = 2), (r.morphTargets || r.morphNormals) && st.update(i, n, r, a), ct.setup(i, r, a, n, l); let d = ot; null !== l && (u = Z.get(l), d = at, d.setIndex(u)); const p = null !== l ? l.count : c.count, f = n.drawRange.start * h, m = n.drawRange.count * h, g = null !== s ? s.start * h : 0, v = null !== s ? s.count * h : 1 / 0, y = Math.max(f, g), b = Math.min(p, f + m, g + v) - 1, _ = Math.max(0, b - y + 1); if (0 !== _) { if (i.isMesh) !0 === r.wireframe ? (j.setLineWidth(r.wireframeLinewidth * G()), d.setMode(1)) : d.setMode(4); else if (i.isLine) { let t = r.linewidth; void 0 === t && (t = 1), j.setLineWidth(t * G()), d.setMode(i.isLineSegments ? 1 : i.isLineLoop ? 2 : 3) } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4); if (i.isInstancedMesh) d.renderInstances(y, _, i.count); else if (n.isInstancedBufferGeometry) { const t = Math.min(n.instanceCount, n._maxInstanceCount); d.renderInstances(y, _, t) } else d.render(y, _) } }, this.compile = function (t, e) { d = et.get(t), d.init(), t.traverseVisible(function (t) { t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t)) }), d.setupLights(), t.traverse(function (e) { const n = e.material; if (n) if (Array.isArray(n)) for (let r = 0; r < n.length; r++)Tt(n[r], t, e); else Tt(n, t, e) }) }; let vt = null; function yt() { _t.stop() } function bt() { _t.start() } const _t = new EL; function wt(t, e, n, r) { if (!1 === t.visible) return; if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(e); else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || I.intersectsSprite(t)) { r && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B); const e = Y.update(t), i = t.material; i.visible && h.push(t, e, i, n, H.z, null) } } else if (t.isImmediateRenderObject) r && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B), h.push(t, null, t.material, n, H.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== J.render.frame && (t.skeleton.update(), t.skeleton.frame = J.render.frame), !t.frustumCulled || I.intersectsObject(t))) { r && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B); const e = Y.update(t), i = t.material; if (Array.isArray(i)) { const r = e.groups; for (let s = 0, o = r.length; s < o; s++) { const o = r[s], a = i[o.materialIndex]; a && a.visible && h.push(t, e, a, n, H.z, o) } } else i.visible && h.push(t, e, i, n, H.z, null) } const i = t.children; for (let s = 0, o = i.length; s < o; s++)wt(i[s], e, n, r) } function St(t, e, n) { const r = !0 === e.isScene ? e.overrideMaterial : null; for (let i = 0, s = t.length; i < s; i++) { const s = t[i], o = s.object, a = s.geometry, l = null === r ? s.material : r, c = s.group; if (n.isArrayCamera) { const t = n.cameras; for (let n = 0, r = t.length; n < r; n++) { const r = t[n]; o.layers.test(r.layers) && (j.viewport(S.copy(r.viewport)), d.setupLightsView(r), xt(o, e, r, a, l, c)) } } else xt(o, e, n, a, l, c) } } function xt(t, e, n, r, i, s) { if (t.onBeforeRender(m, e, n, r, i, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) { const r = Mt(n, e, i, t); j.setMaterial(i), ct.reset(), function (t, e) { t.render(function (t) { m.renderBufferImmediate(t, e) }) }(t, r) } else m.renderBufferDirect(n, e, r, i, t, s); t.onAfterRender(m, e, n, r, i, s) } function Tt(t, e, n) { !0 !== e.isScene && (e = U); const r = X.get(t), i = d.state.lights, s = i.state.version, o = Q.getParameters(t, i.state, d.state.shadowsArray, e, n), a = Q.getProgramCacheKey(o); let l = r.programs; r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = q.get(t.envMap || r.environment), void 0 === l && (t.addEventListener("dispose", gt), l = new Map, r.programs = l); let c = l.get(a); if (void 0 !== c) { if (r.currentProgram === c && r.lightsStateVersion === s) return Et(t, o), c } else o.uniforms = Q.getUniforms(t), t.onBuild(o, m), t.onBeforeCompile(o, m), c = Q.acquireProgram(o, a), l.set(a, c), r.uniforms = o.uniforms; const u = r.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = nt.uniform), Et(t, o), r.needsLights = function (t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), r.lightsStateVersion = s, r.needsLights && (u.ambientLightColor.value = i.state.ambient, u.lightProbe.value = i.state.probe, u.directionalLights.value = i.state.directional, u.directionalLightShadows.value = i.state.directionalShadow, u.spotLights.value = i.state.spot, u.spotLightShadows.value = i.state.spotShadow, u.rectAreaLights.value = i.state.rectArea, u.ltc_1.value = i.state.rectAreaLTC1, u.ltc_2.value = i.state.rectAreaLTC2, u.pointLights.value = i.state.point, u.pointLightShadows.value = i.state.pointShadow, u.hemisphereLights.value = i.state.hemi, u.directionalShadowMap.value = i.state.directionalShadowMap, u.directionalShadowMatrix.value = i.state.directionalShadowMatrix, u.spotShadowMap.value = i.state.spotShadowMap, u.spotShadowMatrix.value = i.state.spotShadowMatrix, u.pointShadowMap.value = i.state.pointShadowMap, u.pointShadowMatrix.value = i.state.pointShadowMatrix); const h = c.getUniforms(), p = qk.seqWithValue(h.seq, u); return r.currentProgram = c, r.uniformsList = p, c } function Et(t, e) { const n = X.get(t); n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas } function Mt(t, e, n, r) { !0 !== e.isScene && (e = U), W.resetTextureUnits(); const i = e.fog, s = null === b ? m.outputEncoding : b.texture.encoding, o = q.get(n.envMap || (n.isMeshStandardMaterial ? e.environment : null)), a = !0 === n.vertexColors && r.geometry && r.geometry.attributes.color && 4 === r.geometry.attributes.color.itemSize, l = X.get(n), c = d.state.lights; !0 !== O || !0 !== F && t === w || nt.setState(n, t, t === w && n.id === _); let u = !1; n.version === l.__version ? l.needsLights && l.lightsStateVersion !== c.state.version || l.outputEncoding !== s || r.isInstancedMesh && !1 === l.instancing ? u = !0 : r.isInstancedMesh || !0 !== l.instancing ? r.isSkinnedMesh && !1 === l.skinning ? u = !0 : r.isSkinnedMesh || !0 !== l.skinning ? l.envMap !== o || n.fog && l.fog !== i ? u = !0 : void 0 === l.numClippingPlanes || l.numClippingPlanes === nt.numPlanes && l.numIntersection === nt.numIntersection ? l.vertexAlphas !== a && (u = !0) : u = !0 : u = !0 : u = !0 : (u = !0, l.__version = n.version); let h = l.currentProgram; !0 === u && (h = Tt(n, e, r)); let p = !1, f = !1, g = !1; const v = h.getUniforms(), y = l.uniforms; if (j.useProgram(h.program) && (p = !0, f = !0, g = !0), n.id !== _ && (_ = n.id, f = !0), p || w !== t) { if (v.setValue(ut, "projectionMatrix", t.projectionMatrix), z.logarithmicDepthBuffer && v.setValue(ut, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), w !== t && (w = t, f = !0, g = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) { const e = v.map.cameraPosition; void 0 !== e && e.setValue(ut, H.setFromMatrixPosition(t.matrixWorld)) } (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && v.setValue(ut, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || r.isSkinnedMesh) && v.setValue(ut, "viewMatrix", t.matrixWorldInverse) } if (r.isSkinnedMesh) { v.setOptional(ut, r, "bindMatrix"), v.setOptional(ut, r, "bindMatrixInverse"); const t = r.skeleton; t && (z.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), v.setValue(ut, "boneTexture", t.boneTexture, W), v.setValue(ut, "boneTextureSize", t.boneTextureSize)) : v.setOptional(ut, t, "boneMatrices")) } var S, x; return (f || l.receiveShadow !== r.receiveShadow) && (l.receiveShadow = r.receiveShadow, v.setValue(ut, "receiveShadow", r.receiveShadow)), f && (v.setValue(ut, "toneMappingExposure", m.toneMappingExposure), l.needsLights && ((S = y).ambientLightColor.needsUpdate = x = g, S.lightProbe.needsUpdate = x, S.directionalLights.needsUpdate = x, S.directionalLightShadows.needsUpdate = x, S.pointLights.needsUpdate = x, S.pointLightShadows.needsUpdate = x, S.spotLights.needsUpdate = x, S.spotLightShadows.needsUpdate = x, S.rectAreaLights.needsUpdate = x, S.hemisphereLights.needsUpdate = x), i && n.fog && $.refreshFogUniforms(y, i), $.refreshMaterialUniforms(y, n, A, M, N), qk.upload(ut, l.uniformsList, y, W)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (qk.upload(ut, l.uniformsList, y, W), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && v.setValue(ut, "center", r.center), v.setValue(ut, "modelViewMatrix", r.modelViewMatrix), v.setValue(ut, "normalMatrix", r.normalMatrix), v.setValue(ut, "modelMatrix", r.matrixWorld), h } _t.setAnimationLoop(function (t) { vt && vt(t) }), "undefined" != typeof window && _t.setContext(window), this.setAnimationLoop = function (t) { vt = t, pt.setAnimationLoop(t), null === t ? _t.stop() : _t.start() }, pt.addEventListener("sessionstart", yt), pt.addEventListener("sessionend", bt), this.render = function (t, e) { if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === g) return; !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === pt.enabled && !0 === pt.isPresenting && (!0 === pt.cameraAutoUpdate && pt.updateCamera(e), e = pt.getCamera()), !0 === t.isScene && t.onBeforeRender(m, t, e, b), d = et.get(t, f.length), d.init(), f.push(d), B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), I.setFromProjectionMatrix(B), F = this.localClippingEnabled, O = nt.init(this.clippingPlanes, F, e), h = tt.get(t, p.length), h.init(), p.push(h), wt(t, e, 0, m.sortObjects), h.finish(), !0 === m.sortObjects && h.sort(C, P), !0 === O && nt.beginShadows(), rt.render(d.state.shadowsArray, t, e), d.setupLights(), d.setupLightsView(e), !0 === O && nt.endShadows(), !0 === this.info.autoReset && this.info.reset(), it.render(h, t); const n = h.opaque, r = h.transmissive, i = h.transparent; n.length > 0 && St(n, t, e), r.length > 0 && function (t, e, n, r) { null === N && (N = new tP(1024, 1024, { generateMipmaps: !0, minFilter: uC, magFilter: oC, wrapS: iC, wrapT: iC })); const i = m.getRenderTarget(); m.setRenderTarget(N), m.clear(), St(t, n, r), W.updateRenderTargetMipmap(N), m.setRenderTarget(i), St(e, n, r) }(n, r, t, e), i.length > 0 && St(i, t, e), null !== b && (W.updateRenderTargetMipmap(b), W.updateMultisampleRenderTarget(b)), !0 === t.isScene && t.onAfterRender(m, t, e), j.buffers.depth.setTest(!0), j.buffers.depth.setMask(!0), j.buffers.color.setMask(!0), j.setPolygonOffset(!1), ct.resetDefaultState(), _ = -1, w = null, f.pop(), d = f.length > 0 ? f[f.length - 1] : null, p.pop(), h = p.length > 0 ? p[p.length - 1] : null }, this.getActiveCubeFace = function () { return v }, this.getActiveMipmapLevel = function () { return y }, this.getRenderTarget = function () { return b }, this.setRenderTarget = function (t, e = 0, n = 0) { b = t, v = e, y = n, t && void 0 === X.get(t).__webglFramebuffer && W.setupRenderTarget(t); let r = null, i = !1, s = !1; if (t) { const n = t.texture; (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0); const o = X.get(t).__webglFramebuffer; t.isWebGLCubeRenderTarget ? (r = o[e], i = !0) : r = t.isWebGLMultisampleRenderTarget ? X.get(t).__webglMultisampledFramebuffer : o, S.copy(t.viewport), x.copy(t.scissor), T = t.scissorTest } else S.copy(R).multiplyScalar(A).floor(), x.copy(L).multiplyScalar(A).floor(), T = k; if (j.bindFramebuffer(36160, r) && z.drawBuffers) { let e = !1; if (t) if (t.isWebGLMultipleRenderTargets) { const n = t.texture; if (D.length !== n.length || 36064 !== D[0]) { for (let t = 0, e = n.length; t < e; t++)D[t] = 36064 + t; D.length = n.length, e = !0 } } else 1 === D.length && 36064 === D[0] || (D[0] = 36064, D.length = 1, e = !0); else 1 === D.length && 1029 === D[0] || (D[0] = 1029, D.length = 1, e = !0); e && (z.isWebGL2 ? ut.drawBuffers(D) : V.get("WEBGL_draw_buffers").drawBuffersWEBGL(D)) } if (j.viewport(S), j.scissor(x), j.setScissorTest(T), i) { const r = X.get(t.texture); ut.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n) } else if (s) { const r = X.get(t.texture); ut.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, e || 0) } }, this.readRenderTargetPixels = function (t, e, n, r, i, s, o) { if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let a = X.get(t).__webglFramebuffer; if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) { j.bindFramebuffer(36160, a); try { const o = t.texture, a = o.format, l = o.type; if (a !== yC && lt.convert(a) !== ut.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); const c = l === mC && (V.has("EXT_color_buffer_half_float") || z.isWebGL2 && V.has("EXT_color_buffer_float")); if (!(l === hC || lt.convert(l) === ut.getParameter(35738) || l === fC && (z.isWebGL2 || V.has("OES_texture_float") || V.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === ut.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && ut.readPixels(e, n, r, i, lt.convert(a), lt.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { const t = null !== b ? X.get(b).__webglFramebuffer : null; j.bindFramebuffer(36160, t) } } }, this.copyFramebufferToTexture = function (t, e, n = 0) { const r = Math.pow(2, -n), i = Math.floor(e.image.width * r), s = Math.floor(e.image.height * r); let o = lt.convert(e.format); z.isWebGL2 && (6407 === o && (o = 32849), 6408 === o && (o = 32856)), W.setTexture2D(e, 0), ut.copyTexImage2D(3553, n, o, t.x, t.y, i, s, 0), j.unbindTexture() }, this.copyTextureToTexture = function (t, e, n, r = 0) { const i = e.image.width, s = e.image.height, o = lt.convert(n.format), a = lt.convert(n.type); W.setTexture2D(n, 0), ut.pixelStorei(37440, n.flipY), ut.pixelStorei(37441, n.premultiplyAlpha), ut.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ut.texSubImage2D(3553, r, t.x, t.y, i, s, o, a, e.image.data) : e.isCompressedTexture ? ut.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : ut.texSubImage2D(3553, r, t.x, t.y, o, a, e.image), 0 === r && n.generateMipmaps && ut.generateMipmap(3553), j.unbindTexture() }, this.copyTextureToTexture3D = function (t, e, n, r, i = 0) { if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); const { width: s, height: o, data: a } = n.image, l = lt.convert(r.format), c = lt.convert(r.type); let u; if (r.isDataTexture3D) W.setTexture3D(r, 0), u = 32879; else { if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); W.setTexture2DArray(r, 0), u = 35866 } ut.pixelStorei(37440, r.flipY), ut.pixelStorei(37441, r.premultiplyAlpha), ut.pixelStorei(3317, r.unpackAlignment); const h = ut.getParameter(3314), d = ut.getParameter(32878), p = ut.getParameter(3316), f = ut.getParameter(3315), g = ut.getParameter(32877); ut.pixelStorei(3314, s), ut.pixelStorei(32878, o), ut.pixelStorei(3316, t.min.x), ut.pixelStorei(3315, t.min.y), ut.pixelStorei(32877, t.min.z), ut.texSubImage3D(u, i, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, l, c, a), ut.pixelStorei(3314, h), ut.pixelStorei(32878, d), ut.pixelStorei(3316, p), ut.pixelStorei(3315, f), ut.pixelStorei(32877, g), 0 === i && r.generateMipmaps && ut.generateMipmap(u), j.unbindTexture() }, this.initTexture = function (t) { W.setTexture2D(t, 0), j.unbindTexture() }, this.resetState = function () { v = 0, y = 0, b = null, j.reset(), ct.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } (class extends HD { }).prototype.isWebGL1Renderer = !0; class UD { constructor(t, e = 25e-5) { this.name = "", this.color = new PR(t), this.density = e } clone() { return new UD(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } UD.prototype.isFogExp2 = !0; class GD { constructor(t, e = 1, n = 1e3) { this.name = "", this.color = new PR(t), this.near = e, this.far = n } clone() { return new GD(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } GD.prototype.isFog = !0; class VD extends sR { constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(t, e) { return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this } toJSON(t) { const e = super.toJSON(t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e } } VD.prototype.isScene = !0; class zD { constructor(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = RC, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = BC() } onUploadCallback() { } set needsUpdate(t) { !0 === t && this.version++ } setUsage(t) { return this.usage = t, this } copy(t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this } copyAt(t, e, n) { t *= this.stride, n *= e.stride; for (let r = 0, i = this.stride; r < i; r++)this.array[t + r] = e.array[n + r]; return this } set(t, e = 0) { return this.array.set(t, e), this } clone(t) { void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = BC()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(e, this.stride); return n.setUsage(this.usage), n } onUpload(t) { return this.onUploadCallback = t, this } toJSON(t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = BC()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } zD.prototype.isInterleavedBuffer = !0; const jD = new rP; class JD { constructor(t, e, n, r) { this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(t) { this.data.needsUpdate = t } applyMatrix4(t) { for (let e = 0, n = this.data.count; e < n; e++)jD.x = this.getX(e), jD.y = this.getY(e), jD.z = this.getZ(e), jD.applyMatrix4(t), this.setXYZ(e, jD.x, jD.y, jD.z); return this } applyNormalMatrix(t) { for (let e = 0, n = this.count; e < n; e++)jD.x = this.getX(e), jD.y = this.getY(e), jD.z = this.getZ(e), jD.applyNormalMatrix(t), this.setXYZ(e, jD.x, jD.y, jD.z); return this } transformDirection(t) { for (let e = 0, n = this.count; e < n; e++)jD.x = this.getX(e), jD.y = this.getY(e), jD.z = this.getZ(e), jD.transformDirection(t), this.setXYZ(e, jD.x, jD.y, jD.z); return this } setX(t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this } setY(t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this } setZ(t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this } setW(t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this } getX(t) { return this.data.array[t * this.data.stride + this.offset] } getY(t) { return this.data.array[t * this.data.stride + this.offset + 1] } getZ(t) { return this.data.array[t * this.data.stride + this.offset + 2] } getW(t) { return this.data.array[t * this.data.stride + this.offset + 3] } setXY(t, e, n) { return this.data.array[(t = t * this.data.stride + this.offset) + 0] = e, this.data.array[t + 1] = n, this } setXYZ(t, e, n, r) { return this.data.array[(t = t * this.data.stride + this.offset) + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this } setXYZW(t, e, n, r, i) { return this.data.array[(t = t * this.data.stride + this.offset) + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this } clone(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return new DR(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new JD(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } JD.prototype.isInterleavedBufferAttribute = !0; class XD extends SR { constructor(t) { super(), this.type = "SpriteMaterial", this.color = new PR(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this } } let WD; XD.prototype.isSpriteMaterial = !0; const qD = new rP, ZD = new rP, KD = new rP, YD = new XC, QD = new XC, $D = new IP, tI = new rP, eI = new rP, nI = new rP, rI = new XC, iI = new XC, sI = new XC; function oI(t, e, n, r, i, s) { YD.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== i ? (QD.x = s * YD.x - i * YD.y, QD.y = i * YD.x + s * YD.y) : QD.copy(YD), t.copy(e), t.x += QD.x, t.y += QD.y, t.applyMatrix4($D) } (class extends sR { constructor(t) { if (super(), this.type = "Sprite", void 0 === WD) { WD = new JR; const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), e = new zD(t, 5); WD.setIndex([0, 1, 2, 0, 2, 3]), WD.setAttribute("position", new JD(e, 3, 0, !1)), WD.setAttribute("uv", new JD(e, 2, 3, !1)) } this.geometry = WD, this.material = void 0 !== t ? t : new XD, this.center = new XC(.5, .5) } raycast(t, e) { null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ZD.setFromMatrixScale(this.matrixWorld), $D.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), KD.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && ZD.multiplyScalar(-KD.z); const n = this.material.rotation; let r, i; 0 !== n && (i = Math.cos(n), r = Math.sin(n)); const s = this.center; oI(tI.set(-.5, -.5, 0), KD, s, ZD, r, i), oI(eI.set(.5, -.5, 0), KD, s, ZD, r, i), oI(nI.set(.5, .5, 0), KD, s, ZD, r, i), rI.set(0, 0), iI.set(1, 0), sI.set(1, 1); let o = t.ray.intersectTriangle(tI, eI, nI, !1, qD); if (null === o && (oI(eI.set(-.5, .5, 0), KD, s, ZD, r, i), iI.set(0, 1), o = t.ray.intersectTriangle(tI, nI, eI, !1, qD), null === o)) return; const a = t.ray.origin.distanceTo(qD); a < t.near || a > t.far || e.push({ distance: a, point: qD.clone(), uv: _R.getUV(qD, tI, eI, nI, rI, iI, sI, new XC), face: null, object: this }) } copy(t) { return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this } }).prototype.isSprite = !0; const aI = new rP, lI = new $C, cI = new $C, uI = new rP, hI = new IP; class dI extends cL { constructor(t, e) { super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new IP, this.bindMatrixInverse = new IP } copy(t) { return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this } bind(t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const t = new $C, e = this.geometry.attributes.skinWeight; for (let n = 0, r = e.count; n < r; n++) { t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n); const r = 1 / t.manhattanLength(); r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w) } } updateMatrixWorld(t) { super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(t, e) { const n = this.skeleton, r = this.geometry; lI.fromBufferAttribute(r.attributes.skinIndex, t), cI.fromBufferAttribute(r.attributes.skinWeight, t), aI.fromBufferAttribute(r.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0); for (let i = 0; i < 4; i++) { const t = cI.getComponent(i); if (0 !== t) { const r = lI.getComponent(i); hI.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(uI.copy(aI).applyMatrix4(hI), t) } } return e.applyMatrix4(this.bindMatrixInverse) } } dI.prototype.isSkinnedMesh = !0; class pI extends sR { constructor() { super(), this.type = "Bone" } } pI.prototype.isBone = !0; class fI extends YC { constructor(t, e, n, r, i, s, o, a, l, c, u, h) { super(null, s, o, a, l, c, r, i, u, h), this.image = { data: t || null, width: e || 1, height: n || 1 }, this.magFilter = void 0 !== l ? l : oC, this.minFilter = void 0 !== c ? c : oC, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } fI.prototype.isDataTexture = !0; const mI = new IP, gI = new IP; class vI { constructor(t = [], e = []) { this.uuid = BC(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { const t = this.bones, e = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses(); else if (t.length !== e.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++)this.boneInverses.push(new IP) } } calculateInverses() { this.boneInverses.length = 0; for (let t = 0, e = this.bones.length; t < e; t++) { const e = new IP; this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e) } } pose() { for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && e.matrixWorld.copy(this.boneInverses[t]).invert() } for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) } } update() { const t = this.bones, e = this.boneInverses, n = this.boneMatrices, r = this.boneTexture; for (let i = 0, s = t.length; i < s; i++)mI.multiplyMatrices(t[i] ? t[i].matrixWorld : gI, e[i]), mI.toArray(n, 16 * i); null !== r && (r.needsUpdate = !0) } clone() { return new vI(this.bones, this.boneInverses) } computeBoneTexture() { let t = Math.sqrt(4 * this.bones.length); t = zC(t), t = Math.max(t, 4); const e = new Float32Array(t * t * 4); e.set(this.boneMatrices); const n = new fI(e, t, t, yC, fC); return this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this } getBoneByName(t) { for (let e = 0, n = this.bones.length; e < n; e++) { const n = this.bones[e]; if (n.name === t) return n } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(t, e) { this.uuid = t.uuid; for (let n = 0, r = t.bones.length; n < r; n++) { const r = t.bones[n]; let i = e[r]; void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new pI), this.bones.push(i), this.boneInverses.push((new IP).fromArray(t.boneInverses[n])) } return this.init(), this } toJSON() { const t = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; t.uuid = this.uuid; const e = this.bones, n = this.boneInverses; for (let r = 0, i = e.length; r < i; r++)t.bones.push(e[r].uuid), t.boneInverses.push(n[r].toArray()); return t } } const yI = new IP, bI = new IP, _I = [], wI = new cL; (class extends cL { constructor(t, e, n) { super(t, e), this.instanceMatrix = new DR(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 } copy(t) { return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this } getColorAt(t, e) { e.fromArray(this.instanceColor.array, 3 * t) } getMatrixAt(t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) } raycast(t, e) { const n = this.matrixWorld, r = this.count; if (wI.geometry = this.geometry, wI.material = this.material, void 0 !== wI.material) for (let i = 0; i < r; i++) { this.getMatrixAt(i, yI), bI.multiplyMatrices(n, yI), wI.matrixWorld = bI, wI.raycast(t, _I); for (let t = 0, n = _I.length; t < n; t++) { const n = _I[t]; n.instanceId = i, n.object = this, e.push(n) } _I.length = 0 } } setColorAt(t, e) { null === this.instanceColor && (this.instanceColor = new DR(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t) } setMatrixAt(t, e) { e.toArray(this.instanceMatrix.array, 16 * t) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } }).prototype.isInstancedMesh = !0; class SI extends SR { constructor(t) { super(), this.type = "LineBasicMaterial", this.color = new PR(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this } } SI.prototype.isLineBasicMaterial = !0; const xI = new rP, TI = new rP, EI = new IP, MI = new DP, AI = new EP; class CI extends sR { constructor(t = new JR, e = new SI) { super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets() } copy(t) { return super.copy(t), this.material = t.material, this.geometry = t.geometry, this } computeLineDistances() { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, n = [0]; for (let t = 1, r = e.count; t < r; t++)xI.fromBufferAttribute(e, t - 1), TI.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += xI.distanceTo(TI); t.setAttribute("lineDistance", new FR(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } raycast(t, e) { const n = this.geometry, r = this.matrixWorld, i = t.params.Line.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), AI.copy(n.boundingSphere), AI.applyMatrix4(r), AI.radius += i, !1 === t.ray.intersectsSphere(AI)) return; EI.copy(r).invert(), MI.copy(t.ray).applyMatrix4(EI); const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o, l = new rP, c = new rP, u = new rP, h = new rP, d = this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { const r = n.index, i = n.attributes.position; if (null !== r) for (let n = Math.max(0, s.start), o = Math.min(r.count, s.start + s.count) - 1; n < o; n += d) { const s = r.getX(n), o = r.getX(n + 1); if (l.fromBufferAttribute(i, s), c.fromBufferAttribute(i, o), MI.distanceSqToSegment(l, c, h, u) > a) continue; h.applyMatrix4(this.matrixWorld); const d = t.ray.origin.distanceTo(h); d < t.near || d > t.far || e.push({ distance: d, point: u.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } else for (let n = Math.max(0, s.start), o = Math.min(i.count, s.start + s.count) - 1; n < o; n += d) { if (l.fromBufferAttribute(i, n), c.fromBufferAttribute(i, n + 1), MI.distanceSqToSegment(l, c, h, u) > a) continue; h.applyMatrix4(this.matrixWorld); const r = t.ray.origin.distanceTo(h); r < t.near || r > t.far || e.push({ distance: r, point: u.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } updateMorphTargets() { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } CI.prototype.isLine = !0; const PI = new rP, RI = new rP; class LI extends CI { constructor(t, e) { super(t, e), this.type = "LineSegments" } computeLineDistances() { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, n = []; for (let t = 0, r = e.count; t < r; t += 2)PI.fromBufferAttribute(e, t), RI.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + PI.distanceTo(RI); t.setAttribute("lineDistance", new FR(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } } LI.prototype.isLineSegments = !0; class kI extends CI { constructor(t, e) { super(t, e), this.type = "LineLoop" } } kI.prototype.isLineLoop = !0; class DI extends SR { constructor(t) { super(), this.type = "PointsMaterial", this.color = new PR(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this } } DI.prototype.isPointsMaterial = !0; const II = new IP, OI = new DP, FI = new EP, NI = new rP; class BI extends sR { constructor(t = new JR, e = new DI) { super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets() } copy(t) { return super.copy(t), this.material = t.material, this.geometry = t.geometry, this } raycast(t, e) { const n = this.geometry, r = this.matrixWorld, i = t.params.Points.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), FI.copy(n.boundingSphere), FI.applyMatrix4(r), FI.radius += i, !1 === t.ray.intersectsSphere(FI)) return; II.copy(r).invert(), OI.copy(t.ray).applyMatrix4(II); const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), a = o * o; if (n.isBufferGeometry) { const i = n.index, o = n.attributes.position; if (null !== i) for (let n = Math.max(0, s.start), l = Math.min(i.count, s.start + s.count); n < l; n++) { const s = i.getX(n); NI.fromBufferAttribute(o, s), HI(NI, s, a, r, t, e, this) } else for (let n = Math.max(0, s.start), l = Math.min(o.count, s.start + s.count); n < l; n++)NI.fromBufferAttribute(o, n), HI(NI, n, a, r, t, e, this) } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } updateMorphTargets() { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } function HI(t, e, n, r, i, s, o) { const a = OI.distanceSqToPoint(t); if (a < n) { const n = new rP; OI.closestPointToPoint(t, n), n.applyMatrix4(r); const l = i.ray.origin.distanceTo(n); if (l < i.near || l > i.far) return; s.push({ distance: l, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: o }) } } BI.prototype.isPoints = !0, class extends YC { constructor(t, e, n, r, i, s, o, a, l) { super(t, e, n, r, i, s, o, a, l), this.format = void 0 !== o ? o : vC, this.minFilter = void 0 !== s ? s : cC, this.magFilter = void 0 !== i ? i : cC, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() { c.needsUpdate = !0, t.requestVideoFrameCallback(e) }) } clone() { return new this.constructor(this.image).copy(this) } update() { const t = this.image; 0 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }.prototype.isVideoTexture = !0, class extends YC { constructor(t, e, n, r, i, s, o, a, l, c, u, h) { super(null, s, o, a, l, c, r, i, u, h), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } }.prototype.isCompressedTexture = !0; class UI extends YC { constructor(t, e, n, r, i, s, o, a, l) { super(t, e, n, r, i, s, o, a, l), this.needsUpdate = !0 } } UI.prototype.isCanvasTexture = !0; class GI extends YC { constructor(t, e, n, r, i, s, o, a, l, c) { if ((c = void 0 !== c ? c : bC) !== bC && c !== _C) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && c === bC && (n = dC), void 0 === n && c === _C && (n = gC), super(null, r, i, s, o, a, c, n, l), this.image = { width: t, height: e }, this.magFilter = void 0 !== o ? o : oC, this.minFilter = void 0 !== a ? a : oC, this.flipY = !1, this.generateMipmaps = !1 } } function VI(t, e, n, r, i) { let s, o; if (i === function (t, e, n, r) { let i = 0; for (let s = e, o = n - r; s < n; s += r)i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s; return i }(t, e, n, r) > 0) for (s = e; s < n; s += r)o = cO(s, t[s], t[s + 1], o); else for (s = n - r; s >= e; s -= r)o = cO(s, t[s], t[s + 1], o); return o && rO(o, o.next) && (uO(o), o = o.next), o } function zI(t, e) { if (!t) return t; e || (e = t); let n, r = t; do { if (n = !1, r.steiner || !rO(r, r.next) && 0 !== nO(r.prev, r, r.next)) r = r.next; else { if (uO(r), r = e = r.prev, r === r.next) break; n = !0 } } while (n || r !== e); return e } function jI(t, e, n, r, i, s, o) { if (!t) return; !o && s && function (t, e, n, r) { let i = t; do { null === i.z && (i.z = QI(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== t); i.prevZ.nextZ = null, i.prevZ = null, function (t) { let e, n, r, i, s, o, a, l, c = 1; do { for (n = t, t = null, s = null, o = 0; n;) { for (o++, r = n, a = 0, e = 0; e < c && (a++, r = r.nextZ, r); e++); for (l = c; a > 0 || l > 0 && r;)0 !== a && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i; n = r } s.nextZ = null, c *= 2 } while (o > 1) }(i) }(t, r, i, s); let a, l, c = t; for (; t.prev !== t.next;)if (a = t.prev, l = t.next, s ? XI(t, r, i, s) : JI(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), uO(t), t = l.next, c = l.next; else if ((t = l) === c) { o ? 1 === o ? jI(t = WI(zI(t), e, n), e, n, r, i, s, 2) : 2 === o && qI(t, e, n, r, i, s) : jI(zI(t), e, n, r, i, s, 1); break } } function JI(t) { const e = t.prev, n = t, r = t.next; if (nO(e, n, r) >= 0) return !1; let i = t.next.next; for (; i !== t.prev;) { if (tO(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && nO(i.prev, i, i.next) >= 0) return !1; i = i.next } return !0 } function XI(t, e, n, r) { const i = t.prev, s = t, o = t.next; if (nO(i, s, o) >= 0) return !1; const a = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x, l = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y, c = QI(i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x, i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y, e, n, r), u = QI(a, l, e, n, r); let h = t.prevZ, d = t.nextZ; for (; h && h.z >= c && d && d.z <= u;) { if (h !== t.prev && h !== t.next && tO(i.x, i.y, s.x, s.y, o.x, o.y, h.x, h.y) && nO(h.prev, h, h.next) >= 0) return !1; if (h = h.prevZ, d !== t.prev && d !== t.next && tO(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && nO(d.prev, d, d.next) >= 0) return !1; d = d.nextZ } for (; h && h.z >= c;) { if (h !== t.prev && h !== t.next && tO(i.x, i.y, s.x, s.y, o.x, o.y, h.x, h.y) && nO(h.prev, h, h.next) >= 0) return !1; h = h.prevZ } for (; d && d.z <= u;) { if (d !== t.prev && d !== t.next && tO(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && nO(d.prev, d, d.next) >= 0) return !1; d = d.nextZ } return !0 } function WI(t, e, n) { let r = t; do { const i = r.prev, s = r.next.next; !rO(i, s) && iO(i, r, r.next, s) && aO(i, s) && aO(s, i) && (e.push(i.i / n), e.push(r.i / n), e.push(s.i / n), uO(r), uO(r.next), r = t = s), r = r.next } while (r !== t); return zI(r) } function qI(t, e, n, r, i, s) { let o = t; do { let t = o.next.next; for (; t !== o.prev;) { if (o.i !== t.i && eO(o, t)) { let a = lO(o, t); return o = zI(o, o.next), a = zI(a, a.next), jI(o, e, n, r, i, s), void jI(a, e, n, r, i, s) } t = t.next } o = o.next } while (o !== t) } function ZI(t, e) { return t.x - e.x } function KI(t, e) { if (e = function (t, e) { let n = e; const r = t.x, i = t.y; let s, o = -1 / 0; do { if (i <= n.y && i >= n.next.y && n.next.y !== n.y) { const t = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (t <= r && t > o) { if (o = t, t === r) { if (i === n.y) return n; if (i === n.next.y) return n.next } s = n.x < n.next.x ? n : n.next } } n = n.next } while (n !== e); if (!s) return null; if (r === o) return s; const a = s, l = s.x, c = s.y; let u, h = 1 / 0; n = s; do { r >= n.x && n.x >= l && r !== n.x && tO(i < c ? r : o, i, l, c, i < c ? o : r, i, n.x, n.y) && (u = Math.abs(i - n.y) / (r - n.x), aO(n, t) && (u < h || u === h && (n.x > s.x || n.x === s.x && YI(s, n))) && (s = n, h = u)), n = n.next } while (n !== a); return s }(t, e)) { const n = lO(e, t); zI(e, e.next), zI(n, n.next) } } function YI(t, e) { return nO(t.prev, t, e.prev) < 0 && nO(e.next, t, t.next) < 0 } function QI(t, e, n, r, i) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function $I(t) { let e = t, n = t; do { (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next } while (e !== t); return n } function tO(t, e, n, r, i, s, o, a) { return (i - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (r - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (i - o) * (r - a) >= 0 } function eO(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { let n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && iO(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 }(t, e) && (aO(t, e) && aO(e, t) && function (t, e) { let n = t, r = !1; const i = (t.x + e.x) / 2, s = (t.y + e.y) / 2; do { n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== t); return r }(t, e) && (nO(t.prev, t, e.prev) || nO(t, e.prev, e)) || rO(t, e) && nO(t.prev, t, t.next) > 0 && nO(e.prev, e, e.next) > 0) } function nO(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function rO(t, e) { return t.x === e.x && t.y === e.y } function iO(t, e, n, r) { const i = oO(nO(t, e, n)), s = oO(nO(t, e, r)), o = oO(nO(n, r, t)), a = oO(nO(n, r, e)); return i !== s && o !== a || !(0 !== i || !sO(t, n, e)) || !(0 !== s || !sO(t, r, e)) || !(0 !== o || !sO(n, t, r)) || !(0 !== a || !sO(n, e, r)) } function sO(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) } function oO(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function aO(t, e) { return nO(t.prev, t, t.next) < 0 ? nO(t, e, t.next) >= 0 && nO(t, t.prev, e) >= 0 : nO(t, e, t.prev) < 0 || nO(t, t.next, e) < 0 } function lO(t, e) { const n = new hO(t.i, t.x, t.y), r = new hO(e.i, e.x, e.y), i = t.next, s = e.prev; return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r } function cO(t, e, n, r) { const i = new hO(t, e, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function uO(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function hO(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } GI.prototype.isDepthTexture = !0, new rP, new rP, new rP, new _R; class dO { static area(t) { const e = t.length; let n = 0; for (let r = e - 1, i = 0; i < e; r = i++)n += t[r].x * t[i].y - t[i].x * t[r].y; return .5 * n } static isClockWise(t) { return dO.area(t) < 0 } static triangulateShape(t, e) { const n = [], r = [], i = []; pO(t), fO(n, t); let s = t.length; e.forEach(pO); for (let a = 0; a < e.length; a++)r.push(s), s += e[a].length, fO(n, e[a]); const o = function (t, e, n) { n = n || 2; const r = e && e.length, i = r ? e[0] * n : t.length; let s = VI(t, 0, i, n, !0); const o = []; if (!s || s.next === s.prev) return o; let a, l, c, u, h, d, p; if (r && (s = function (t, e, n, r) { const i = []; let s, o, a, l, c; for (s = 0, o = e.length; s < o; s++)a = e[s] * r, l = s < o - 1 ? e[s + 1] * r : t.length, c = VI(t, a, l, r, !1), c === c.next && (c.steiner = !0), i.push($I(c)); for (i.sort(ZI), s = 0; s < i.length; s++)KI(i[s], n), n = zI(n, n.next); return n }(t, e, s, n)), t.length > 80 * n) { a = c = t[0], l = u = t[1]; for (let e = n; e < i; e += n)h = t[e], d = t[e + 1], h < a && (a = h), d < l && (l = d), h > c && (c = h), d > u && (u = d); p = Math.max(c - a, u - l), p = 0 !== p ? 1 / p : 0 } return jI(s, o, n, a, l, p), o }(n, r); for (let a = 0; a < o.length; a += 3)i.push(o.slice(a, a + 3)); return i } } function pO(t) { const e = t.length; e > 2 && t[e - 1].equals(t[0]) && t.pop() } function fO(t, e) { for (let n = 0; n < e.length; n++)t.push(e[n].x), t.push(e[n].y) } class mO extends JR { constructor(t, e) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t]; const n = this, r = [], i = []; for (let o = 0, a = t.length; o < a; o++)s(t[o]); function s(t) { const s = [], o = void 0 !== e.curveSegments ? e.curveSegments : 12, a = void 0 !== e.steps ? e.steps : 1; let l = void 0 !== e.depth ? e.depth : 100, c = void 0 === e.bevelEnabled || e.bevelEnabled, u = void 0 !== e.bevelThickness ? e.bevelThickness : 6, h = void 0 !== e.bevelSize ? e.bevelSize : u - 2, d = void 0 !== e.bevelOffset ? e.bevelOffset : 0, p = void 0 !== e.bevelSegments ? e.bevelSegments : 3; const f = e.extrudePath, m = void 0 !== e.UVGenerator ? e.UVGenerator : gO; void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount); let g, v, y, b, _, w = !1; f && (g = f.getSpacedPoints(a), w = !0, c = !1, v = f.computeFrenetFrames(a, !1), y = new rP, b = new rP, _ = new rP), c || (p = 0, u = 0, h = 0, d = 0); const S = t.extractPoints(o); let x = S.shape; const T = S.holes; if (!dO.isClockWise(x)) { x = x.reverse(); for (let t = 0, e = T.length; t < e; t++) { const e = T[t]; dO.isClockWise(e) && (T[t] = e.reverse()) } } const E = dO.triangulateShape(x, T), M = x; for (let e = 0, n = T.length; e < n; e++)x = x.concat(T[e]); function A(t, e, n) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t) } const C = x.length, P = E.length; function R(t, e, n) { let r, i, s; const o = t.x - e.x, a = t.y - e.y, l = n.x - t.x, c = n.y - t.y, u = o * o + a * a; if (Math.abs(o * c - a * l) > Number.EPSILON) { const h = Math.sqrt(u), d = Math.sqrt(l * l + c * c), p = e.x - a / h, f = e.y + o / h, m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (o * c - a * l); r = p + o * m - t.x, i = f + a * m - t.y; const g = r * r + i * i; if (g <= 2) return new XC(r, i); s = Math.sqrt(g / 2) } else { let t = !1; o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (r = -a, i = o, s = Math.sqrt(u)) : (r = o, i = a, s = Math.sqrt(u / 2)) } return new XC(r / s, i / s) } const L = []; for (let e = 0, n = M.length, r = n - 1, i = e + 1; e < n; e++, r++, i++)r === n && (r = 0), i === n && (i = 0), L[e] = R(M[e], M[r], M[i]); const k = []; let D, I = L.concat(); for (let e = 0, n = T.length; e < n; e++) { const t = T[e]; D = []; for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++, r++, i++)r === n && (r = 0), i === n && (i = 0), D[e] = R(t[e], t[r], t[i]); k.push(D), I = I.concat(D) } for (let e = 0; e < p; e++) { const t = e / p, n = u * Math.cos(t * Math.PI / 2), r = h * Math.sin(t * Math.PI / 2) + d; for (let e = 0, i = M.length; e < i; e++) { const t = A(M[e], L[e], r); N(t.x, t.y, -n) } for (let e = 0, i = T.length; e < i; e++) { const t = T[e]; D = k[e]; for (let e = 0, i = t.length; e < i; e++) { const i = A(t[e], D[e], r); N(i.x, i.y, -n) } } } const O = h + d; for (let e = 0; e < C; e++) { const t = c ? A(x[e], I[e], O) : x[e]; w ? (b.copy(v.normals[0]).multiplyScalar(t.x), y.copy(v.binormals[0]).multiplyScalar(t.y), _.copy(g[0]).add(b).add(y), N(_.x, _.y, _.z)) : N(t.x, t.y, 0) } for (let e = 1; e <= a; e++)for (let t = 0; t < C; t++) { const n = c ? A(x[t], I[t], O) : x[t]; w ? (b.copy(v.normals[e]).multiplyScalar(n.x), y.copy(v.binormals[e]).multiplyScalar(n.y), _.copy(g[e]).add(b).add(y), N(_.x, _.y, _.z)) : N(n.x, n.y, l / a * e) } for (let e = p - 1; e >= 0; e--) { const t = e / p, n = u * Math.cos(t * Math.PI / 2), r = h * Math.sin(t * Math.PI / 2) + d; for (let e = 0, i = M.length; e < i; e++) { const t = A(M[e], L[e], r); N(t.x, t.y, l + n) } for (let e = 0, i = T.length; e < i; e++) { const t = T[e]; D = k[e]; for (let e = 0, i = t.length; e < i; e++) { const i = A(t[e], D[e], r); w ? N(i.x, i.y + g[a - 1].y, g[a - 1].x + n) : N(i.x, i.y, l + n) } } } function F(t, e) { let n = t.length; for (; --n >= 0;) { const r = n; let i = n - 1; i < 0 && (i = t.length - 1); for (let t = 0, n = a + 2 * p; t < n; t++) { const n = C * t, s = C * (t + 1); H(e + r + n, e + i + n, e + i + s, e + r + s) } } } function N(t, e, n) { s.push(t), s.push(e), s.push(n) } function B(t, e, i) { U(t), U(e), U(i); const s = r.length / 3, o = m.generateTopUV(n, r, s - 3, s - 2, s - 1); G(o[0]), G(o[1]), G(o[2]) } function H(t, e, i, s) { U(t), U(e), U(s), U(e), U(i), U(s); const o = r.length / 3, a = m.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1); G(a[0]), G(a[1]), G(a[3]), G(a[1]), G(a[2]), G(a[3]) } function U(t) { r.push(s[3 * t + 0]), r.push(s[3 * t + 1]), r.push(s[3 * t + 2]) } function G(t) { i.push(t.x), i.push(t.y) } !function () { const t = r.length / 3; if (c) { let t = 0, e = C * t; for (let n = 0; n < P; n++) { const t = E[n]; B(t[2] + e, t[1] + e, t[0] + e) } t = a + 2 * p, e = C * t; for (let n = 0; n < P; n++) { const t = E[n]; B(t[0] + e, t[1] + e, t[2] + e) } } else { for (let t = 0; t < P; t++) { const e = E[t]; B(e[2], e[1], e[0]) } for (let t = 0; t < P; t++) { const e = E[t]; B(e[0] + C * a, e[1] + C * a, e[2] + C * a) } } n.addGroup(t, r.length / 3 - t, 0) }(), function () { const t = r.length / 3; let e = 0; F(M, e), e += M.length; for (let n = 0, r = T.length; n < r; n++) { const t = T[n]; F(t, e), e += t.length } n.addGroup(t, r.length / 3 - t, 1) }() } this.setAttribute("position", new FR(r, 3)), this.setAttribute("uv", new FR(i, 2)), this.computeVertexNormals() } toJSON() { const t = super.toJSON(); return function (t, e, n) { if (n.shapes = [], Array.isArray(t)) for (let r = 0, i = t.length; r < i; r++)n.shapes.push(t[r].uuid); else n.shapes.push(t.uuid); return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n }(this.parameters.shapes, this.parameters.options, t) } } const gO = { generateTopUV: function (t, e, n, r, i) { const s = e[3 * r], o = e[3 * r + 1], a = e[3 * i], l = e[3 * i + 1]; return [new XC(e[3 * n], e[3 * n + 1]), new XC(s, o), new XC(a, l)] }, generateSideWallUV: function (t, e, n, r, i, s) { const o = e[3 * n], a = e[3 * n + 1], l = e[3 * n + 2], c = e[3 * r], u = e[3 * r + 1], h = e[3 * r + 2], d = e[3 * i], p = e[3 * i + 1], f = e[3 * i + 2], m = e[3 * s], g = e[3 * s + 1], v = e[3 * s + 2]; return Math.abs(a - u) < Math.abs(o - c) ? [new XC(o, 1 - l), new XC(c, 1 - h), new XC(d, 1 - f), new XC(m, 1 - v)] : [new XC(a, 1 - l), new XC(u, 1 - h), new XC(p, 1 - f), new XC(g, 1 - v)] } }; class vO extends JR { constructor(t, e = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: t, curveSegments: e }; const n = [], r = [], i = [], s = []; let o = 0, a = 0; if (!1 === Array.isArray(t)) l(t); else for (let c = 0; c < t.length; c++)l(t[c]), this.addGroup(o, a, c), o += a, a = 0; function l(t) { const o = r.length / 3, l = t.extractPoints(e); let c = l.shape; const u = l.holes; !1 === dO.isClockWise(c) && (c = c.reverse()); for (let e = 0, n = u.length; e < n; e++) { const t = u[e]; !0 === dO.isClockWise(t) && (u[e] = t.reverse()) } const h = dO.triangulateShape(c, u); for (let e = 0, n = u.length; e < n; e++)c = c.concat(u[e]); for (let e = 0, n = c.length; e < n; e++) { const t = c[e]; r.push(t.x, t.y, 0), i.push(0, 0, 1), s.push(t.x, t.y) } for (let e = 0, r = h.length; e < r; e++) { const t = h[e]; n.push(t[0] + o, t[1] + o, t[2] + o), a += 3 } } this.setIndex(n), this.setAttribute("position", new FR(r, 3)), this.setAttribute("normal", new FR(i, 3)), this.setAttribute("uv", new FR(s, 2)) } toJSON() { const t = super.toJSON(); return function (t, e) { if (e.shapes = [], Array.isArray(t)) for (let n = 0, r = t.length; n < r; n++)e.shapes.push(t[n].uuid); else e.shapes.push(t.uuid); return e }(this.parameters.shapes, t) } } class yO extends JR { constructor(t = 1, e = 8, n = 6, r = 0, i = 2 * Math.PI, s = 0, o = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: r, phiLength: i, thetaStart: s, thetaLength: o }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n)); const a = Math.min(s + o, Math.PI); let l = 0; const c = [], u = new rP, h = new rP, d = [], p = [], f = [], m = []; for (let g = 0; g <= n; g++) { const d = [], v = g / n; let y = 0; 0 == g && 0 == s ? y = .5 / e : g == n && a == Math.PI && (y = -.5 / e); for (let n = 0; n <= e; n++) { const a = n / e; u.x = -t * Math.cos(r + a * i) * Math.sin(s + v * o), u.y = t * Math.cos(s + v * o), u.z = t * Math.sin(r + a * i) * Math.sin(s + v * o), p.push(u.x, u.y, u.z), h.copy(u).normalize(), f.push(h.x, h.y, h.z), m.push(a + y, 1 - v), d.push(l++) } c.push(d) } for (let g = 0; g < n; g++)for (let t = 0; t < e; t++) { const e = c[g][t + 1], r = c[g][t], i = c[g + 1][t], o = c[g + 1][t + 1]; (0 !== g || s > 0) && d.push(e, r, o), (g !== n - 1 || a < Math.PI) && d.push(r, i, o) } this.setIndex(d), this.setAttribute("position", new FR(p, 3)), this.setAttribute("normal", new FR(f, 3)), this.setAttribute("uv", new FR(m, 2)) } } (class extends SR { constructor(t) { super(), this.type = "ShadowMaterial", this.color = new PR(0), this.transparent = !0, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this } }).prototype.isShadowMaterial = !0, class extends mL { constructor(t) { super(t), this.type = "RawShaderMaterial" } }.prototype.isRawShaderMaterial = !0; class bO extends SR { constructor(t) { super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new PR(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new PR(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new XC(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(t) } copy(t) { return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this } } bO.prototype.isMeshStandardMaterial = !0; class _O extends bO { constructor(t) { super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new XC(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function () { return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity) }, set: function (t) { this.reflectivity = HC(2.5 * (t - 1) / (t + 1), 0, 1) } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new PR(1, 1, 1), this.setValues(t) } copy(t) { return super.copy(t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, this.sheen = t.sheen ? (this.sheen || new PR).copy(t.sheen) : null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this } } _O.prototype.isMeshPhysicalMaterial = !0; class wO extends SR { constructor(t) { super(), this.type = "MeshPhongMaterial", this.color = new PR(16777215), this.specular = new PR(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new PR(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new XC(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this } } wO.prototype.isMeshPhongMaterial = !0, class extends SR { constructor(t) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new PR(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new PR(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new XC(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this } }.prototype.isMeshToonMaterial = !0, class extends SR { constructor(t) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new XC(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t) } copy(t) { return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this } }.prototype.isMeshNormalMaterial = !0; class SO extends SR { constructor(t) { super(), this.type = "MeshLambertMaterial", this.color = new PR(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new PR(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } copy(t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this } } SO.prototype.isMeshLambertMaterial = !0, class extends SR { constructor(t) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new PR(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new XC(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t) } copy(t) { return super.copy(t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this } }.prototype.isMeshMatcapMaterial = !0, class extends SI { constructor(t) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) } copy(t) { return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this } }.prototype.isLineDashedMaterial = !0; const xO = { arraySlice: function (t, e, n) { return xO.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) }, convertArray: function (t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (t) { const e = t.length, n = new Array(e); for (let r = 0; r !== e; ++r)n[r] = r; return n.sort(function (e, n) { return t[e] - t[n] }), n }, sortedArray: function (t, e, n) { const r = t.length, i = new t.constructor(r); for (let s = 0, o = 0; o !== r; ++s) { const r = n[s] * e; for (let n = 0; n !== e; ++n)i[o++] = t[r + n] } return i }, flattenJSON: function (t, e, n, r) { let i = 1, s = t[0]; for (; void 0 !== s && void 0 === s[r];)s = t[i++]; if (void 0 === s) return; let o = s[r]; if (void 0 !== o) if (Array.isArray(o)) do { o = s[r], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[i++] } while (void 0 !== s); else if (void 0 !== o.toArray) do { o = s[r], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[i++] } while (void 0 !== s); else do { o = s[r], void 0 !== o && (e.push(s.time), n.push(o)), s = t[i++] } while (void 0 !== s) }, subclip: function (t, e, n, r, i = 30) { const s = t.clone(); s.name = e; const o = []; for (let l = 0; l < s.tracks.length; ++l) { const t = s.tracks[l], e = t.getValueSize(), a = [], c = []; for (let s = 0; s < t.times.length; ++s) { const o = t.times[s] * i; if (!(o < n || o >= r)) { a.push(t.times[s]); for (let n = 0; n < e; ++n)c.push(t.values[s * e + n]) } } 0 !== a.length && (t.times = xO.convertArray(a, t.times.constructor), t.values = xO.convertArray(c, t.values.constructor), o.push(t)) } s.tracks = o; let a = 1 / 0; for (let l = 0; l < s.tracks.length; ++l)a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]); for (let l = 0; l < s.tracks.length; ++l)s.tracks[l].shift(-1 * a); return s.resetDuration(), s }, makeClipAdditive: function (t, e = 0, n = t, r = 30) { r <= 0 && (r = 30); const i = n.tracks.length, s = e / r; for (let o = 0; o < i; ++o) { const e = n.tracks[o], r = e.ValueTypeName; if ("bool" === r || "string" === r) continue; const i = t.tracks.find(function (t) { return t.name === e.name && t.ValueTypeName === r }); if (void 0 === i) continue; let a = 0; const l = e.getValueSize(); e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3); let c = 0; const u = i.getValueSize(); i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3); const h = e.times.length - 1; let d; if (s <= e.times[0]) d = xO.arraySlice(e.values, a, l - a); else if (s >= e.times[h]) { const t = h * l + a; d = xO.arraySlice(e.values, t, t + l - a) } else { const t = e.createInterpolant(), n = a, r = l - a; t.evaluate(s), d = xO.arraySlice(t.resultBuffer, n, r) } "quaternion" === r && (new nP).fromArray(d).normalize().conjugate().toArray(d); const p = i.times.length; for (let t = 0; t < p; ++t) { const e = t * u + c; if ("quaternion" === r) nP.multiplyQuaternionsFlat(i.values, e, d, 0, i.values, e); else { const t = u - 2 * c; for (let n = 0; n < t; ++n)i.values[e + n] -= d[n] } } } return t.blendMode = 2501, t } }; class TO { constructor(t, e, n, r) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(t) { const e = this.parameterPositions; let n = this._cachedIndex, r = e[n], i = e[n - 1]; t: { e: { let s; n: { r: if (!(t < r)) { for (let s = n + 2; ;) { if (void 0 === r) { if (t < i) break r; return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i) } if (n === s) break; if (i = r, r = e[++n], t < r) break e } s = e.length; break n } if (t >= i) break t; { const o = e[1]; t < o && (n = 2, i = o); for (let s = n - 2; ;) { if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r); if (n === s) break; if (r = i, i = e[--n - 1], t >= i) break e } s = n, n = 0 } } for (; n < s;) { const r = n + s >>> 1; t < e[r] ? s = r : n = r + 1 } if (r = e[n], i = e[n - 1], void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r); if (void 0 === r) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, t) } this._cachedIndex = n, this.intervalChanged_(n, i, r) } return this.interpolate_(n, i, t, r) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(t) { const e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r; for (let s = 0; s !== r; ++s)e[s] = n[i + s]; return e } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } TO.prototype.beforeStart_ = TO.prototype.copySampleValue_, TO.prototype.afterEnd_ = TO.prototype.copySampleValue_; class EO extends TO { constructor(t, e, n, r) { super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: TC, endingEnd: TC } } intervalChanged_(t, e, n) { const r = this.parameterPositions; let i = t - 2, s = t + 1, o = r[i], a = r[s]; if (void 0 === o) switch (this.getSettings_().endingStart) { case EC: i = t, o = 2 * e - n; break; case MC: i = r.length - 2, o = e + r[i] - r[i + 1]; break; default: i = t, o = n }if (void 0 === a) switch (this.getSettings_().endingEnd) { case EC: s = t, a = 2 * n - e; break; case MC: s = 1, a = n + r[1] - r[0]; break; default: s = t - 1, a = e }const l = .5 * (n - e), c = this.valueSize; this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = i * c, this._offsetNext = s * c } interpolate_(t, e, n, r) { const i = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = t * o, l = a - o, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - e) / (r - e), f = p * p, m = f * p, g = -h * m + 2 * h * f - h * p, v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, b = d * m - d * f; for (let _ = 0; _ !== o; ++_)i[_] = g * s[c + _] + v * s[l + _] + y * s[a + _] + b * s[u + _]; return i } } class MO extends TO { constructor(t, e, n, r) { super(t, e, n, r) } interpolate_(t, e, n, r) { const i = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = t * o, l = a - o, c = (n - e) / (r - e), u = 1 - c; for (let h = 0; h !== o; ++h)i[h] = s[l + h] * u + s[a + h] * c; return i } } class AO extends TO { constructor(t, e, n, r) { super(t, e, n, r) } interpolate_(t) { return this.copySampleValue_(t - 1) } } class CO { constructor(t, e, n, r) { if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = xO.convertArray(e, this.TimeBufferType), this.values = xO.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(t) { const e = t.constructor; let n; if (e.toJSON !== this.toJSON) n = e.toJSON(t); else { n = { name: t.name, times: xO.convertArray(t.times, Array), values: xO.convertArray(t.values, Array) }; const e = t.getInterpolation(); e !== t.DefaultInterpolation && (n.interpolation = e) } return n.type = t.ValueTypeName, n } InterpolantFactoryMethodDiscrete(t) { return new AO(this.times, this.values, this.getValueSize(), t) } InterpolantFactoryMethodLinear(t) { return new MO(this.times, this.values, this.getValueSize(), t) } InterpolantFactoryMethodSmooth(t) { return new EO(this.times, this.values, this.getValueSize(), t) } setInterpolation(t) { let e; switch (t) { case wC: e = this.InterpolantFactoryMethodDiscrete; break; case SC: e = this.InterpolantFactoryMethodLinear; break; case xC: e = this.InterpolantFactoryMethodSmooth }if (void 0 === e) { const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(e); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", e), this } return this.createInterpolant = e, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return wC; case this.InterpolantFactoryMethodLinear: return SC; case this.InterpolantFactoryMethodSmooth: return xC } } getValueSize() { return this.values.length / this.times.length } shift(t) { if (0 !== t) { const e = this.times; for (let n = 0, r = e.length; n !== r; ++n)e[n] += t } return this } scale(t) { if (1 !== t) { const e = this.times; for (let n = 0, r = e.length; n !== r; ++n)e[n] *= t } return this } trim(t, e) { const n = this.times, r = n.length; let i = 0, s = r - 1; for (; i !== r && n[i] < t;)++i; for (; -1 !== s && n[s] > e;)--s; if (++s, 0 !== i || s !== r) { i >= s && (s = Math.max(s, 1), i = s - 1); const t = this.getValueSize(); this.times = xO.arraySlice(n, i, s), this.values = xO.arraySlice(this.values, i * t, s * t) } return this } validate() { let t = !0; const e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); const n = this.times, r = this.values, i = n.length; 0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); let s = null; for (let o = 0; o !== i; o++) { const e = n[o]; if ("number" == typeof e && isNaN(e)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, e), t = !1; break } if (null !== s && s > e) { console.error("THREE.KeyframeTrack: Out of order keys.", this, o, e, s), t = !1; break } s = e } if (void 0 !== r && xO.isTypedArray(r)) for (let o = 0, a = r.length; o !== a; ++o) { const e = r[o]; if (isNaN(e)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, e), t = !1; break } } return t } optimize() { const t = xO.arraySlice(this.times), e = xO.arraySlice(this.values), n = this.getValueSize(), r = this.getInterpolation() === xC, i = t.length - 1; let s = 1; for (let o = 1; o < i; ++o) { let i = !1; const a = t[o]; if (a !== t[o + 1] && (1 !== o || a !== t[0])) if (r) i = !0; else { const t = o * n, r = t - n, s = t + n; for (let o = 0; o !== n; ++o) { const n = e[t + o]; if (n !== e[r + o] || n !== e[s + o]) { i = !0; break } } } if (i) { if (o !== s) { t[s] = t[o]; const r = o * n, i = s * n; for (let t = 0; t !== n; ++t)e[i + t] = e[r + t] } ++s } } if (i > 0) { t[s] = t[i]; for (let t = i * n, r = s * n, o = 0; o !== n; ++o)e[r + o] = e[t + o]; ++s } return s !== t.length ? (this.times = xO.arraySlice(t, 0, s), this.values = xO.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this } clone() { const t = xO.arraySlice(this.times, 0), e = xO.arraySlice(this.values, 0), n = new (0, this.constructor)(this.name, t, e); return n.createInterpolant = this.createInterpolant, n } } CO.prototype.TimeBufferType = Float32Array, CO.prototype.ValueBufferType = Float32Array, CO.prototype.DefaultInterpolation = SC; class PO extends CO { } PO.prototype.ValueTypeName = "bool", PO.prototype.ValueBufferType = Array, PO.prototype.DefaultInterpolation = wC, PO.prototype.InterpolantFactoryMethodLinear = void 0, PO.prototype.InterpolantFactoryMethodSmooth = void 0; class RO extends CO { } RO.prototype.ValueTypeName = "color"; class LO extends CO { } LO.prototype.ValueTypeName = "number"; class kO extends TO { constructor(t, e, n, r) { super(t, e, n, r) } interpolate_(t, e, n, r) { const i = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = (n - e) / (r - e); let l = t * o; for (let c = l + o; l !== c; l += 4)nP.slerpFlat(i, 0, s, l - o, s, l, a); return i } } class DO extends CO { InterpolantFactoryMethodLinear(t) { return new kO(this.times, this.values, this.getValueSize(), t) } } DO.prototype.ValueTypeName = "quaternion", DO.prototype.DefaultInterpolation = SC, DO.prototype.InterpolantFactoryMethodSmooth = void 0; class IO extends CO { } IO.prototype.ValueTypeName = "string", IO.prototype.ValueBufferType = Array, IO.prototype.DefaultInterpolation = wC, IO.prototype.InterpolantFactoryMethodLinear = void 0, IO.prototype.InterpolantFactoryMethodSmooth = void 0; class OO extends CO { } OO.prototype.ValueTypeName = "vector"; class FO { constructor(t, e = -1, n, r = 2500) { this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = BC(), this.duration < 0 && this.resetDuration() } static parse(t) { const e = [], n = t.tracks, r = 1 / (t.fps || 1); for (let s = 0, o = n.length; s !== o; ++s)e.push(NO(n[s]).scale(r)); const i = new this(t.name, t.duration, e, t.blendMode); return i.uuid = t.uuid, i } static toJSON(t) { const e = [], n = t.tracks, r = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }; for (let i = 0, s = n.length; i !== s; ++i)e.push(CO.toJSON(n[i])); return r } static CreateFromMorphTargetSequence(t, e, n, r) { const i = e.length, s = []; for (let o = 0; o < i; o++) { let t = [], a = []; t.push((o + i - 1) % i, o, (o + 1) % i), a.push(0, 1, 0); const l = xO.getKeyframeOrder(t); t = xO.sortedArray(t, 1, l), a = xO.sortedArray(a, 1, l), r || 0 !== t[0] || (t.push(i), a.push(a[0])), s.push(new LO(".morphTargetInfluences[" + e[o].name + "]", t, a).scale(1 / n)) } return new this(t, -1, s) } static findByName(t, e) { let n = t; if (!Array.isArray(t)) { const e = t; n = e.geometry && e.geometry.animations || e.animations } for (let r = 0; r < n.length; r++)if (n[r].name === e) return n[r]; return null } static CreateClipsFromMorphTargetSequences(t, e, n) { const r = {}, i = /^([\w-]*?)([\d]+)$/; for (let o = 0, a = t.length; o < a; o++) { const e = t[o], n = e.name.match(i); if (n && n.length > 1) { const t = n[1]; let i = r[t]; i || (r[t] = i = []), i.push(e) } } const s = []; for (const o in r) s.push(this.CreateFromMorphTargetSequence(o, r[o], e, n)); return s } static parseAnimation(t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (t, e, n, r, i) { if (0 !== n.length) { const s = [], o = []; xO.flattenJSON(n, s, o, r), 0 !== s.length && i.push(new t(e, s, o)) } }, r = [], i = t.name || "default", s = t.fps || 30, o = t.blendMode; let a = t.length || -1; const l = t.hierarchy || []; for (let c = 0; c < l.length; c++) { const t = l[c].keys; if (t && 0 !== t.length) if (t[0].morphTargets) { const e = {}; let n; for (n = 0; n < t.length; n++)if (t[n].morphTargets) for (let r = 0; r < t[n].morphTargets.length; r++)e[t[n].morphTargets[r]] = -1; for (const i in e) { const e = [], s = []; for (let r = 0; r !== t[n].morphTargets.length; ++r) { const r = t[n]; e.push(r.time), s.push(r.morphTarget === i ? 1 : 0) } r.push(new LO(".morphTargetInfluence[" + i + "]", e, s)) } a = e.length * (s || 1) } else { const i = ".bones[" + e[c].name + "]"; n(OO, i + ".position", t, "pos", r), n(DO, i + ".quaternion", t, "rot", r), n(OO, i + ".scale", t, "scl", r) } } return 0 === r.length ? null : new this(i, a, r, o) } resetDuration() { let t = 0; for (let e = 0, n = this.tracks.length; e !== n; ++e) { const n = this.tracks[e]; t = Math.max(t, n.times[n.times.length - 1]) } return this.duration = t, this } trim() { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this } validate() { let t = !0; for (let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t } optimize() { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this } clone() { const t = []; for (let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new this.constructor(this.name, this.duration, t, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function NO(t) { if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = function (t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return LO; case "vector": case "vector2": case "vector3": case "vector4": return OO; case "color": return RO; case "quaternion": return DO; case "bool": case "boolean": return PO; case "string": return IO }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t) }(t.type); if (void 0 === t.times) { const e = [], n = []; xO.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n } return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) } const BO = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }, HO = new class { constructor(t, e, n) { const r = this; let i, s = !1, o = 0, a = 0; const l = []; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) { a++, !1 === s && void 0 !== r.onStart && r.onStart(t, o, a), s = !0 }, this.itemEnd = function (t) { o++, void 0 !== r.onProgress && r.onProgress(t, o, a), o === a && (s = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function (t) { void 0 !== r.onError && r.onError(t) }, this.resolveURL = function (t) { return i ? i(t) : t }, this.setURLModifier = function (t) { return i = t, this }, this.addHandler = function (t, e) { return l.push(t, e), this }, this.removeHandler = function (t) { const e = l.indexOf(t); return -1 !== e && l.splice(e, 2), this }, this.getHandler = function (t) { for (let e = 0, n = l.length; e < n; e += 2) { const n = l[e], r = l[e + 1]; if (n.global && (n.lastIndex = 0), n.test(t)) return r } return null } } }; class UO { constructor(t) { this.manager = void 0 !== t ? t : HO, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(t, e) { const n = this; return new Promise(function (r, i) { n.load(t, r, e, i) }) } parse() { } setCrossOrigin(t) { return this.crossOrigin = t, this } setWithCredentials(t) { return this.withCredentials = t, this } setPath(t) { return this.path = t, this } setResourcePath(t) { return this.resourcePath = t, this } setRequestHeader(t) { return this.requestHeader = t, this } } const GO = {}; class VO extends UO { constructor(t) { super(t) } load(t, e, n, r) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const i = this, s = BO.get(t); if (void 0 !== s) return i.manager.itemStart(t), setTimeout(function () { e && e(s), i.manager.itemEnd(t) }, 0), s; if (void 0 !== GO[t]) return void GO[t].push({ onLoad: e, onProgress: n, onError: r }); const o = t.match(/^data:(.*?)(;base64)?,(.*)$/); let a; if (o) { const n = o[1], s = !!o[2]; let a = o[3]; a = decodeURIComponent(a), s && (a = atob(a)); try { let r; const s = (this.responseType || "").toLowerCase(); switch (s) { case "arraybuffer": case "blob": const t = new Uint8Array(a.length); for (let n = 0; n < a.length; n++)t[n] = a.charCodeAt(n); r = "blob" === s ? new Blob([t.buffer], { type: n }) : t.buffer; break; case "document": const e = new DOMParser; r = e.parseFromString(a, n); break; case "json": r = JSON.parse(a); break; default: r = a }setTimeout(function () { e && e(r), i.manager.itemEnd(t) }, 0) } catch (l) { setTimeout(function () { r && r(l), i.manager.itemError(t), i.manager.itemEnd(t) }, 0) } } else { GO[t] = [], GO[t].push({ onLoad: e, onProgress: n, onError: r }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", function (e) { const n = this.response, r = GO[t]; if (delete GO[t], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), BO.add(t, n); for (let t = 0, e = r.length; t < e; t++) { const e = r[t]; e.onLoad && e.onLoad(n) } i.manager.itemEnd(t) } else { for (let t = 0, n = r.length; t < n; t++) { const n = r[t]; n.onError && n.onError(e) } i.manager.itemError(t), i.manager.itemEnd(t) } }, !1), a.addEventListener("progress", function (e) { const n = GO[t]; for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; r.onProgress && r.onProgress(e) } }, !1), a.addEventListener("error", function (e) { const n = GO[t]; delete GO[t]; for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; r.onError && r.onError(e) } i.manager.itemError(t), i.manager.itemEnd(t) }, !1), a.addEventListener("abort", function (e) { const n = GO[t]; delete GO[t]; for (let t = 0, r = n.length; t < r; t++) { const r = n[t]; r.onError && r.onError(e) } i.manager.itemError(t), i.manager.itemEnd(t) }, !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]); a.send(null) } return i.manager.itemStart(t), a } setResponseType(t) { return this.responseType = t, this } setMimeType(t) { return this.mimeType = t, this } } class zO extends UO { constructor(t) { super(t) } load(t, e, n, r) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const i = this, s = BO.get(t); if (void 0 !== s) return i.manager.itemStart(t), setTimeout(function () { e && e(s), i.manager.itemEnd(t) }, 0), s; const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function a() { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), BO.add(t, this), e && e(this), i.manager.itemEnd(t) } function l(e) { o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t) } return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o } } class jO extends UO { constructor(t) { super(t) } load(t, e, n, r) { const i = new _L, s = new zO(this.manager); s.setCrossOrigin(this.crossOrigin), s.setPath(this.path); let o = 0; function a(n) { s.load(t[n], function (t) { i.images[n] = t, o++, 6 === o && (i.needsUpdate = !0, e && e(i)) }, void 0, r) } for (let l = 0; l < t.length; ++l)a(l); return i } } class JO extends UO { constructor(t) { super(t) } load(t, e, n, r) { const i = new YC, s = new zO(this.manager); return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, function (n) { i.image = n; const r = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/); i.format = r ? vC : yC, i.needsUpdate = !0, void 0 !== e && e(i) }, n, r), i } } class XO { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(t, e) { const n = this.getUtoTmapping(t); return this.getPoint(n, e) } getPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return e } getSpacedPoints(t = 5) { const e = []; for (let n = 0; n <= t; n++)e.push(this.getPointAt(n / t)); return e } getLength() { const t = this.getLengths(); return t[t.length - 1] } getLengths(t = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const e = []; let n, r = this.getPoint(0), i = 0; e.push(0); for (let s = 1; s <= t; s++)n = this.getPoint(s / t), i += n.distanceTo(r), e.push(i), r = n; return this.cacheArcLengths = e, e } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(t, e) { const n = this.getLengths(); let r = 0; const i = n.length; let s; s = e || t * n[i - 1]; let o, a = 0, l = i - 1; for (; a <= l;)if (r = Math.floor(a + (l - a) / 2), o = n[r] - s, o < 0) a = r + 1; else { if (!(o > 0)) { l = r; break } l = r - 1 } if (r = l, n[r] === s) return r / (i - 1); const c = n[r]; return (r + (s - c) / (n[r + 1] - c)) / (i - 1) } getTangent(t, e) { const n = 1e-4; let r = t - n, i = t + n; r < 0 && (r = 0), i > 1 && (i = 1); const s = this.getPoint(r), o = this.getPoint(i), a = e || (s.isVector2 ? new XC : new rP); return a.copy(o).sub(s).normalize(), a } getTangentAt(t, e) { const n = this.getUtoTmapping(t); return this.getTangent(n, e) } computeFrenetFrames(t, e) { const n = new rP, r = [], i = [], s = [], o = new rP, a = new IP; for (let d = 0; d <= t; d++)r[d] = this.getTangentAt(d / t, new rP), r[d].normalize(); i[0] = new rP, s[0] = new rP; let l = Number.MAX_VALUE; const c = Math.abs(r[0].x), u = Math.abs(r[0].y), h = Math.abs(r[0].z); c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), s[0].crossVectors(r[0], i[0]); for (let d = 1; d <= t; d++) { if (i[d] = i[d - 1].clone(), s[d] = s[d - 1].clone(), o.crossVectors(r[d - 1], r[d]), o.length() > Number.EPSILON) { o.normalize(); const t = Math.acos(HC(r[d - 1].dot(r[d]), -1, 1)); i[d].applyMatrix4(a.makeRotationAxis(o, t)) } s[d].crossVectors(r[d], i[d]) } if (!0 === e) { let e = Math.acos(HC(i[0].dot(i[t]), -1, 1)); e /= t, r[0].dot(o.crossVectors(i[0], i[t])) > 0 && (e = -e); for (let n = 1; n <= t; n++)i[n].applyMatrix4(a.makeRotationAxis(r[n], e * n)), s[n].crossVectors(r[n], i[n]) } return { tangents: r, normals: i, binormals: s } } clone() { return (new this.constructor).copy(this) } copy(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } toJSON() { const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t } fromJSON(t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } } class WO extends XO { constructor(t = 0, e = 0, n = 1, r = 1, i = 0, s = 2 * Math.PI, o = !1, a = 0) { super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a } getPoint(t, e) { const n = e || new XC, r = 2 * Math.PI; let i = this.aEndAngle - this.aStartAngle; const s = Math.abs(i) < Number.EPSILON; for (; i < 0;)i += r; for (; i > r;)i -= r; i < Number.EPSILON && (i = s ? 0 : r), !0 !== this.aClockwise || s || (i === r ? i = -r : i -= r); const o = this.aStartAngle + t * i; let a = this.aX + this.xRadius * Math.cos(o), l = this.aY + this.yRadius * Math.sin(o); if (0 !== this.aRotation) { const t = Math.cos(this.aRotation), e = Math.sin(this.aRotation), n = a - this.aX, r = l - this.aY; a = n * t - r * e + this.aX, l = n * e + r * t + this.aY } return n.set(a, l) } copy(t) { return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this } toJSON() { const t = super.toJSON(); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t } fromJSON(t) { return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this } } WO.prototype.isEllipseCurve = !0; class qO extends WO { constructor(t, e, n, r, i, s) { super(t, e, n, n, r, i, s), this.type = "ArcCurve" } } function ZO() { let t = 0, e = 0, n = 0, r = 0; function i(i, s, o, a) { t = i, e = o, n = -3 * i + 3 * s - 2 * o - a, r = 2 * i - 2 * s + o + a } return { initCatmullRom: function (t, e, n, r, s) { i(e, n, s * (n - t), s * (r - e)) }, initNonuniformCatmullRom: function (t, e, n, r, s, o, a) { let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o, c = (n - e) / o - (r - e) / (o + a) + (r - n) / a; l *= o, c *= o, i(e, n, l, c) }, calc: function (i) { const s = i * i; return t + e * i + n * s + r * (s * i) } } } qO.prototype.isArcCurve = !0; const KO = new rP, YO = new ZO, QO = new ZO, $O = new ZO; class tF extends XO { constructor(t = [], e = !1, n = "centripetal", r = .5) { super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r } getPoint(t, e = new rP) { const n = e, r = this.points, i = r.length, s = (i - (this.closed ? 0 : 1)) * t; let o, a, l = Math.floor(s), c = s - l; this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2, c = 1), this.closed || l > 0 ? o = r[(l - 1) % i] : (KO.subVectors(r[0], r[1]).add(r[0]), o = KO); const u = r[l % i], h = r[(l + 1) % i]; if (this.closed || l + 2 < i ? a = r[(l + 2) % i] : (KO.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), a = KO), "centripetal" === this.curveType || "chordal" === this.curveType) { const t = "chordal" === this.curveType ? .5 : .25; let e = Math.pow(o.distanceToSquared(u), t), n = Math.pow(u.distanceToSquared(h), t), r = Math.pow(h.distanceToSquared(a), t); n < 1e-4 && (n = 1), e < 1e-4 && (e = n), r < 1e-4 && (r = n), YO.initNonuniformCatmullRom(o.x, u.x, h.x, a.x, e, n, r), QO.initNonuniformCatmullRom(o.y, u.y, h.y, a.y, e, n, r), $O.initNonuniformCatmullRom(o.z, u.z, h.z, a.z, e, n, r) } else "catmullrom" === this.curveType && (YO.initCatmullRom(o.x, u.x, h.x, a.x, this.tension), QO.initCatmullRom(o.y, u.y, h.y, a.y, this.tension), $O.initCatmullRom(o.z, u.z, h.z, a.z, this.tension)); return n.set(YO.calc(c), QO.calc(c), $O.calc(c)), n } copy(t) { super.copy(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++)this.points.push(t.points[e].clone()); return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this } toJSON() { const t = super.toJSON(); t.points = []; for (let e = 0, n = this.points.length; e < n; e++)t.points.push(this.points[e].toArray()); return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t } fromJSON(t) { super.fromJSON(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push((new rP).fromArray(n)) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this } } function eF(t, e, n, r, i) { const s = .5 * (r - e), o = .5 * (i - n), a = t * t; return (2 * n - 2 * r + s + o) * (t * a) + (-3 * n + 3 * r - 2 * s - o) * a + s * t + n } function nF(t, e, n, r) { return function (t, e) { const n = 1 - t; return n * n * e }(t, e) + function (t, e) { return 2 * (1 - t) * t * e }(t, n) + function (t, e) { return t * t * e }(t, r) } function rF(t, e, n, r, i) { return function (t, e) { const n = 1 - t; return n * n * n * e }(t, e) + function (t, e) { const n = 1 - t; return 3 * n * n * t * e }(t, n) + function (t, e) { return 3 * (1 - t) * t * t * e }(t, r) + function (t, e) { return t * t * t * e }(t, i) } tF.prototype.isCatmullRomCurve3 = !0; class iF extends XO { constructor(t = new XC, e = new XC, n = new XC, r = new XC) { super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r } getPoint(t, e = new XC) { const n = e, r = this.v0, i = this.v1, s = this.v2, o = this.v3; return n.set(rF(t, r.x, i.x, s.x, o.x), rF(t, r.y, i.y, s.y, o.y)), n } copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this } toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t } fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this } } iF.prototype.isCubicBezierCurve = !0; class sF extends XO { constructor(t = new rP, e = new rP, n = new rP, r = new rP) { super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r } getPoint(t, e = new rP) { const n = e, r = this.v0, i = this.v1, s = this.v2, o = this.v3; return n.set(rF(t, r.x, i.x, s.x, o.x), rF(t, r.y, i.y, s.y, o.y), rF(t, r.z, i.z, s.z, o.z)), n } copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this } toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t } fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this } } sF.prototype.isCubicBezierCurve3 = !0; class oF extends XO { constructor(t = new XC, e = new XC) { super(), this.type = "LineCurve", this.v1 = t, this.v2 = e } getPoint(t, e = new XC) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n } getPointAt(t, e) { return this.getPoint(t, e) } getTangent(t, e) { const n = e || new XC; return n.copy(this.v2).sub(this.v1).normalize(), n } copy(t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this } toJSON() { const t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t } fromJSON(t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this } } oF.prototype.isLineCurve = !0; class aF extends XO { constructor(t = new XC, e = new XC, n = new XC) { super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n } getPoint(t, e = new XC) { const n = e, r = this.v0, i = this.v1, s = this.v2; return n.set(nF(t, r.x, i.x, s.x), nF(t, r.y, i.y, s.y)), n } copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this } toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t } fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this } } aF.prototype.isQuadraticBezierCurve = !0; class lF extends XO { constructor(t = new rP, e = new rP, n = new rP) { super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n } getPoint(t, e = new rP) { const n = e, r = this.v0, i = this.v1, s = this.v2; return n.set(nF(t, r.x, i.x, s.x), nF(t, r.y, i.y, s.y), nF(t, r.z, i.z, s.z)), n } copy(t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this } toJSON() { const t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t } fromJSON(t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this } } lF.prototype.isQuadraticBezierCurve3 = !0; class cF extends XO { constructor(t = []) { super(), this.type = "SplineCurve", this.points = t } getPoint(t, e = new XC) { const n = e, r = this.points, i = (r.length - 1) * t, s = Math.floor(i), o = i - s, a = r[0 === s ? s : s - 1], l = r[s], c = r[s > r.length - 2 ? r.length - 1 : s + 1], u = r[s > r.length - 3 ? r.length - 1 : s + 2]; return n.set(eF(o, a.x, l.x, c.x, u.x), eF(o, a.y, l.y, c.y, u.y)), n } copy(t) { super.copy(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++)this.points.push(t.points[e].clone()); return this } toJSON() { const t = super.toJSON(); t.points = []; for (let e = 0, n = this.points.length; e < n; e++)t.points.push(this.points[e].toArray()); return t } fromJSON(t) { super.fromJSON(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push((new XC).fromArray(n)) } return this } } cF.prototype.isSplineCurve = !0; var uF = Object.freeze({ __proto__: null, ArcCurve: qO, CatmullRomCurve3: tF, CubicBezierCurve: iF, CubicBezierCurve3: sF, EllipseCurve: WO, LineCurve: oF, LineCurve3: class extends XO { constructor(t = new rP, e = new rP) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e } getPoint(t, e = new rP) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n } getPointAt(t, e) { return this.getPoint(t, e) } copy(t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this } toJSON() { const t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t } fromJSON(t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this } }, QuadraticBezierCurve: aF, QuadraticBezierCurve3: lF, SplineCurve: cF }); class hF extends XO { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(t) { this.curves.push(t) } closePath() { const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new oF(e, t)) } getPoint(t) { const e = t * this.getLength(), n = this.getCurveLengths(); let r = 0; for (; r < n.length;) { if (n[r] >= e) { const t = n[r] - e, i = this.curves[r], s = i.getLength(); return i.getPointAt(0 === s ? 0 : 1 - t / s) } r++ } return null } getLength() { const t = this.getCurveLengths(); return t[t.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const t = []; let e = 0; for (let n = 0, r = this.curves.length; n < r; n++)e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t, t } getSpacedPoints(t = 40) { const e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e } getPoints(t = 12) { const e = []; let n; for (let r = 0, i = this.curves; r < i.length; r++) { const s = i[r], o = s.getPoints(s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t); for (let t = 0; t < o.length; t++) { const r = o[t]; n && n.equals(r) || (e.push(r), n = r) } } return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e } copy(t) { super.copy(t), this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++)this.curves.push(t.curves[e].clone()); return this.autoClose = t.autoClose, this } toJSON() { const t = super.toJSON(); t.autoClose = this.autoClose, t.curves = []; for (let e = 0, n = this.curves.length; e < n; e++)t.curves.push(this.curves[e].toJSON()); return t } fromJSON(t) { super.fromJSON(t), this.autoClose = t.autoClose, this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++) { const n = t.curves[e]; this.curves.push((new uF[n.type]).fromJSON(n)) } return this } } class dF extends hF { constructor(t) { super(), this.type = "Path", this.currentPoint = new XC, t && this.setFromPoints(t) } setFromPoints(t) { this.moveTo(t[0].x, t[0].y); for (let e = 1, n = t.length; e < n; e++)this.lineTo(t[e].x, t[e].y); return this } moveTo(t, e) { return this.currentPoint.set(t, e), this } lineTo(t, e) { const n = new oF(this.currentPoint.clone(), new XC(t, e)); return this.curves.push(n), this.currentPoint.set(t, e), this } quadraticCurveTo(t, e, n, r) { const i = new aF(this.currentPoint.clone(), new XC(t, e), new XC(n, r)); return this.curves.push(i), this.currentPoint.set(n, r), this } bezierCurveTo(t, e, n, r, i, s) { const o = new iF(this.currentPoint.clone(), new XC(t, e), new XC(n, r), new XC(i, s)); return this.curves.push(o), this.currentPoint.set(i, s), this } splineThru(t) { const e = [this.currentPoint.clone()].concat(t), n = new cF(e); return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this } arc(t, e, n, r, i, s) { return this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, n, r, i, s), this } absarc(t, e, n, r, i, s) { return this.absellipse(t, e, n, n, r, i, s), this } ellipse(t, e, n, r, i, s, o, a) { return this.absellipse(t + this.currentPoint.x, e + this.currentPoint.y, n, r, i, s, o, a), this } absellipse(t, e, n, r, i, s, o, a) { const l = new WO(t, e, n, r, i, s, o, a); if (this.curves.length > 0) { const t = l.getPoint(0); t.equals(this.currentPoint) || this.lineTo(t.x, t.y) } this.curves.push(l); const c = l.getPoint(1); return this.currentPoint.copy(c), this } copy(t) { return super.copy(t), this.currentPoint.copy(t.currentPoint), this } toJSON() { const t = super.toJSON(); return t.currentPoint = this.currentPoint.toArray(), t } fromJSON(t) { return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this } } class pF extends dF { constructor(t) { super(t), this.uuid = BC(), this.type = "Shape", this.holes = [] } getPointsHoles(t) { const e = []; for (let n = 0, r = this.holes.length; n < r; n++)e[n] = this.holes[n].getPoints(t); return e } extractPoints(t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } } copy(t) { super.copy(t), this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++)this.holes.push(t.holes[e].clone()); return this } toJSON() { const t = super.toJSON(); t.uuid = this.uuid, t.holes = []; for (let e = 0, n = this.holes.length; e < n; e++)t.holes.push(this.holes[e].toJSON()); return t } fromJSON(t) { super.fromJSON(t), this.uuid = t.uuid, this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++) { const n = t.holes[e]; this.holes.push((new dF).fromJSON(n)) } return this } } class fF extends sR { constructor(t, e = 1) { super(), this.type = "Light", this.color = new PR(t), this.intensity = e } dispose() { } copy(t) { return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this } toJSON(t) { const e = super.toJSON(t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e } } fF.prototype.isLight = !0, class extends fF { constructor(t, e, n) { super(t, n), this.type = "HemisphereLight", this.position.copy(sR.DefaultUp), this.updateMatrix(), this.groundColor = new PR(e) } copy(t) { return fF.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }.prototype.isHemisphereLight = !0; const mF = new IP, gF = new rP, vF = new rP; class yF { constructor(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new XC(512, 512), this.map = null, this.mapPass = null, this.matrix = new IP, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new TL, this._frameExtents = new XC(1, 1), this._viewportCount = 1, this._viewports = [new $C(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(t) { const e = this.camera, n = this.matrix; gF.setFromMatrixPosition(t.matrixWorld), e.position.copy(gF), vF.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(vF), e.updateMatrixWorld(), mF.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(mF), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse) } getViewport(t) { return this._viewports[t] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } } class bF extends yF { constructor() { super(new vL(50, 1, .5, 500)), this.focus = 1 } updateMatrices(t) { const e = this.camera, n = 2 * NC * t.angle * this.focus, r = this.mapSize.width / this.mapSize.height, i = t.distance || e.far; n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), super.updateMatrices(t) } copy(t) { return super.copy(t), this.focus = t.focus, this } } bF.prototype.isSpotLightShadow = !0; class _F extends fF { constructor(t, e, n = 0, r = Math.PI / 3, i = 0, s = 1) { super(t, e), this.type = "SpotLight", this.position.copy(sR.DefaultUp), this.updateMatrix(), this.target = new sR, this.distance = n, this.angle = r, this.penumbra = i, this.decay = s, this.shadow = new bF } get power() { return this.intensity * Math.PI } set power(t) { this.intensity = t / Math.PI } dispose() { this.shadow.dispose() } copy(t) { return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } } _F.prototype.isSpotLight = !0; const wF = new IP, SF = new rP, xF = new rP; class TF extends yF { constructor() { super(new vL(90, 1, .5, 500)), this._frameExtents = new XC(4, 2), this._viewportCount = 6, this._viewports = [new $C(2, 1, 1, 1), new $C(0, 1, 1, 1), new $C(3, 1, 1, 1), new $C(1, 1, 1, 1), new $C(3, 0, 1, 1), new $C(1, 0, 1, 1)], this._cubeDirections = [new rP(1, 0, 0), new rP(-1, 0, 0), new rP(0, 0, 1), new rP(0, 0, -1), new rP(0, 1, 0), new rP(0, -1, 0)], this._cubeUps = [new rP(0, 1, 0), new rP(0, 1, 0), new rP(0, 1, 0), new rP(0, 1, 0), new rP(0, 0, 1), new rP(0, 0, -1)] } updateMatrices(t, e = 0) { const n = this.camera, r = this.matrix, i = t.distance || n.far; i !== n.far && (n.far = i, n.updateProjectionMatrix()), SF.setFromMatrixPosition(t.matrixWorld), n.position.copy(SF), xF.copy(n.position), xF.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(xF), n.updateMatrixWorld(), r.makeTranslation(-SF.x, -SF.y, -SF.z), wF.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(wF) } } TF.prototype.isPointLightShadow = !0; class EF extends fF { constructor(t, e, n = 0, r = 1) { super(t, e), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new TF } get power() { return 4 * this.intensity * Math.PI } set power(t) { this.intensity = t / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(t) { return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } } EF.prototype.isPointLight = !0; class MF extends gL { constructor(t = -1, e = 1, n = 1, r = -1, i = .1, s = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = i, this.far = s, this.updateProjectionMatrix() } copy(t, e) { return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this } setViewOffset(t, e, n, r, i, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let i = n - t, s = n + t, o = r + e, a = r - e; if (null !== this.view && this.view.enabled) { const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom; i += t * this.view.offsetX, s = i + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height } this.projectionMatrix.makeOrthographic(i, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(t) { const e = super.toJSON(t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } } MF.prototype.isOrthographicCamera = !0; class AF extends yF { constructor() { super(new MF(-5, 5, 5, -5, .5, 500)) } } AF.prototype.isDirectionalLightShadow = !0; class CF extends fF { constructor(t, e) { super(t, e), this.type = "DirectionalLight", this.position.copy(sR.DefaultUp), this.updateMatrix(), this.target = new sR, this.shadow = new AF } dispose() { this.shadow.dispose() } copy(t) { return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } } CF.prototype.isDirectionalLight = !0; class PF extends fF { constructor(t, e) { super(t, e), this.type = "AmbientLight" } } PF.prototype.isAmbientLight = !0, class extends fF { constructor(t, e, n = 10, r = 10) { super(t, e), this.type = "RectAreaLight", this.width = n, this.height = r } copy(t) { return super.copy(t), this.width = t.width, this.height = t.height, this } toJSON(t) { const e = super.toJSON(t); return e.object.width = this.width, e.object.height = this.height, e } }.prototype.isRectAreaLight = !0; class RF { constructor() { this.coefficients = []; for (let t = 0; t < 9; t++)this.coefficients.push(new rP) } set(t) { for (let e = 0; e < 9; e++)this.coefficients[e].copy(t[e]); return this } zero() { for (let t = 0; t < 9; t++)this.coefficients[t].set(0, 0, 0); return this } getAt(t, e) { const n = t.x, r = t.y, i = t.z, s = this.coefficients; return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * r), e.addScaledVector(s[2], .488603 * i), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * r * 1.092548), e.addScaledVector(s[5], r * i * 1.092548), e.addScaledVector(s[6], .315392 * (3 * i * i - 1)), e.addScaledVector(s[7], n * i * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - r * r)), e } getIrradianceAt(t, e) { const n = t.x, r = t.y, i = t.z, s = this.coefficients; return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * r), e.addScaledVector(s[2], 1.023328 * i), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * r), e.addScaledVector(s[5], .858086 * r * i), e.addScaledVector(s[6], .743125 * i * i - .247708), e.addScaledVector(s[7], .858086 * n * i), e.addScaledVector(s[8], .429043 * (n * n - r * r)), e } add(t) { for (let e = 0; e < 9; e++)this.coefficients[e].add(t.coefficients[e]); return this } addScaledSH(t, e) { for (let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(t.coefficients[n], e); return this } scale(t) { for (let e = 0; e < 9; e++)this.coefficients[e].multiplyScalar(t); return this } lerp(t, e) { for (let n = 0; n < 9; n++)this.coefficients[n].lerp(t.coefficients[n], e); return this } equals(t) { for (let e = 0; e < 9; e++)if (!this.coefficients[e].equals(t.coefficients[e])) return !1; return !0 } copy(t) { return this.set(t.coefficients) } clone() { return (new this.constructor).copy(this) } fromArray(t, e = 0) { const n = this.coefficients; for (let r = 0; r < 9; r++)n[r].fromArray(t, e + 3 * r); return this } toArray(t = [], e = 0) { const n = this.coefficients; for (let r = 0; r < 9; r++)n[r].toArray(t, e + 3 * r); return t } static getBasisAt(t, e) { const n = t.x, r = t.y, i = t.z; e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * i, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = .546274 * (n * n - r * r) } } RF.prototype.isSphericalHarmonics3 = !0; class LF extends fF { constructor(t = new RF, e = 1) { super(void 0, e), this.sh = t } copy(t) { return super.copy(t), this.sh.copy(t.sh), this } fromJSON(t) { return this.intensity = t.intensity, this.sh.fromArray(t.sh), this } toJSON(t) { const e = super.toJSON(t); return e.object.sh = this.sh.toArray(), e } } LF.prototype.isLightProbe = !0; class kF { static decodeText(t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); let e = ""; for (let r = 0, i = t.length; r < i; r++)e += String.fromCharCode(t[r]); try { return decodeURIComponent(escape(e)) } catch (n) { return e } } static extractUrlBase(t) { const e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) } } (class extends JR { constructor() { super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(t) { return super.copy(t), this.instanceCount = t.instanceCount, this } clone() { return (new this.constructor).copy(this) } toJSON() { const t = super.toJSON(this); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t } }).prototype.isInstancedBufferGeometry = !0, class extends DR { constructor(t, e, n, r) { "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = r || 1 } copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this } toJSON() { const t = super.toJSON(); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t } }.prototype.isInstancedBufferAttribute = !0; class DF extends UO { constructor(t) { super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(t) { return this.options = t, this } load(t, e, n, r) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const i = this, s = BO.get(t); if (void 0 !== s) return i.manager.itemStart(t), setTimeout(function () { e && e(s), i.manager.itemEnd(t) }, 0), s; const o = {}; o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then(function (t) { return t.blob() }).then(function (t) { return createImageBitmap(t, Object.assign(i.options, { colorSpaceConversion: "none" })) }).then(function (n) { BO.add(t, n), e && e(n), i.manager.itemEnd(t) }).catch(function (e) { r && r(e), i.manager.itemError(t), i.manager.itemEnd(t) }), i.manager.itemStart(t) } } let IF; DF.prototype.isImageBitmapLoader = !0; class OF extends UO { constructor(t) { super(t) } load(t, e, n, r) { const i = this, s = new VO(this.manager); s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, function (n) { try { const t = n.slice(0); (void 0 === IF && (IF = new (window.AudioContext || window.webkitAudioContext)), IF).decodeAudioData(t, function (t) { e(t) }) } catch (s) { r ? r(s) : console.error(s), i.manager.itemError(t) } }, n, r) } } (class extends LF { constructor(t, e, n = 1) { super(void 0, n); const r = (new PR).set(t), i = (new PR).set(e), s = new rP(r.r, r.g, r.b), o = new rP(i.r, i.g, i.b), a = Math.sqrt(Math.PI), l = a * Math.sqrt(.75); this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l) } }).prototype.isHemisphereLightProbe = !0, class extends LF { constructor(t, e = 1) { super(void 0, e); const n = (new PR).set(t); this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } }.prototype.isAmbientLightProbe = !0; class FF { constructor(t, e, n) { let r, i, s; switch (this.binding = t, this.valueSize = n, e) { case "quaternion": r = this._slerp, i = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": r = this._select, i = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: r = this._lerp, i = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(t, e) { const n = this.buffer, r = this.valueSize, i = t * r + r; let s = this.cumulativeWeight; if (0 === s) { for (let t = 0; t !== r; ++t)n[i + t] = n[t]; s = e } else s += e, this._mixBufferRegion(n, i, 0, e / s, r); this.cumulativeWeight = s } accumulateAdditive(t) { const e = this.buffer, n = this.valueSize, r = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t } apply(t) { const e = this.valueSize, n = this.buffer, r = t * e + e, i = this.cumulativeWeight, s = this.cumulativeWeightAdditive, o = this.binding; this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1 && this._mixBufferRegion(n, r, e * this._origIndex, 1 - i, e), s > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e); for (let a = e, l = e + e; a !== l; ++a)if (n[a] !== n[a + e]) { o.setValue(n, r); break } } saveOriginalState() { const t = this.buffer, e = this.valueSize, n = e * this._origIndex; this.binding.getValue(t, n); for (let r = e, i = n; r !== i; ++r)t[r] = t[n + r % e]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { this.binding.setValue(this.buffer, 3 * this.valueSize) } _setAdditiveIdentityNumeric() { const t = this._addIndex * this.valueSize, e = t + this.valueSize; for (let n = t; n < e; n++)this.buffer[n] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[e + n] = this.buffer[t + n] } _select(t, e, n, r, i) { if (r >= .5) for (let s = 0; s !== i; ++s)t[e + s] = t[n + s] } _slerp(t, e, n, r) { nP.slerpFlat(t, e, t, e, t, n, r) } _slerpAdditive(t, e, n, r, i) { const s = this._workIndex * i; nP.multiplyQuaternionsFlat(t, s, t, e, t, n), nP.slerpFlat(t, e, t, e, t, s, r) } _lerp(t, e, n, r, i) { const s = 1 - r; for (let o = 0; o !== i; ++o) { const i = e + o; t[i] = t[i] * s + t[n + o] * r } } _lerpAdditive(t, e, n, r, i) { for (let s = 0; s !== i; ++s) { const i = e + s; t[i] = t[i] + t[n + s] * r } } } const NF = new RegExp("[\\[\\]\\.:\\/]", "g"), BF = "[^\\[\\]\\.:\\/]", HF = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", UF = /((?:WC+[\/:])*)/.source.replace("WC", BF), GF = /(WCOD+)?/.source.replace("WCOD", HF), VF = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", BF), zF = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", BF), jF = new RegExp("^" + UF + GF + VF + zF + "$"), JF = ["material", "materials", "bones"]; class XF { constructor(t, e, n) { const r = n || WF.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, r) } getValue(t, e) { this.bind(); const n = this._bindings[this._targetGroup.nCachedObjects_]; void 0 !== n && n.getValue(t, e) } setValue(t, e) { const n = this._bindings; for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)n[r].setValue(t, e) } bind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind() } unbind() { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind() } } let WF = (() => { class t { constructor(e, n, r) { this.path = n, this.parsedPath = r || t.parseTrackName(n), this.node = t.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, n, r) { return e && e.isAnimationObjectGroup ? new t.Composite(e, n, r) : new t(e, n, r) } static sanitizeNodeName(t) { return t.replace(/\s/g, "_").replace(NF, "") } static parseTrackName(t) { const e = jF.exec(t); if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t); const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, r = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== r && -1 !== r) { const t = n.nodeName.substring(r + 1); -1 !== JF.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return n } static findNode(t, e) { if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { const n = t.skeleton.getBoneByName(e); if (void 0 !== n) return n } if (t.children) { const n = function (t) { for (let r = 0; r < t.length; r++) { const i = t[r]; if (i.name === e || i.uuid === e) return i; const s = n(i.children); if (s) return s } return null }, r = n(t.children); if (r) return r } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(t, e) { t[e] = this.node[this.propertyName] } _getValue_array(t, e) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)t[e++] = n[r] } _getValue_arrayElement(t, e) { t[e] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(t, e) { this.resolvedProperty.toArray(t, e) } _setValue_direct(t, e) { this.targetObject[this.propertyName] = t[e] } _setValue_direct_setNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(t, e) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = t[e++] } _setValue_array_setNeedsUpdate(t, e) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = t[e++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(t, e) { const n = this.resolvedProperty; for (let r = 0, i = n.length; r !== i; ++r)n[r] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(t, e) { this.resolvedProperty[this.propertyIndex] = t[e] } _setValue_arrayElement_setNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(t, e) { this.resolvedProperty.fromArray(t, e) } _setValue_fromArray_setNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(t, e) { this.bind(), this.getValue(t, e) } _setValue_unbound(t, e) { this.bind(), this.setValue(t, e) } bind() { let e = this.node; const n = this.parsedPath, r = n.objectName, i = n.propertyName; let s = n.propertyIndex; if (e || (e = t.findNode(this.rootNode, n.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (r) { let t = n.objectIndex; switch (r) { case "materials": if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); e = e.material.materials; break; case "bones": if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); e = e.skeleton.bones; for (let n = 0; n < e.length; n++)if (e[n].name === t) { t = n; break } break; default: if (void 0 === e[r]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); e = e[r] }if (void 0 !== t) { if (void 0 === e[t]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); e = e[t] } } const o = e[i]; if (void 0 === o) return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n.nodeName + "." + i + " but it wasn't found.", e); let a = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate); let l = this.BindingType.Direct; if (void 0 !== s) { if ("morphTargetInfluences" === i) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== e.morphTargetDictionary[s] && (s = e.morphTargetDictionary[s]) } l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s } else void 0 !== o.fromArray && void 0 !== o.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i; this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } return t.Composite = XF, t })(); WF.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, WF.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, WF.prototype.GetterByBindingType = [WF.prototype._getValue_direct, WF.prototype._getValue_array, WF.prototype._getValue_arrayElement, WF.prototype._getValue_toArray], WF.prototype.SetterByBindingTypeAndVersioning = [[WF.prototype._setValue_direct, WF.prototype._setValue_direct_setNeedsUpdate, WF.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [WF.prototype._setValue_array, WF.prototype._setValue_array_setNeedsUpdate, WF.prototype._setValue_array_setMatrixWorldNeedsUpdate], [WF.prototype._setValue_arrayElement, WF.prototype._setValue_arrayElement_setNeedsUpdate, WF.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [WF.prototype._setValue_fromArray, WF.prototype._setValue_fromArray_setNeedsUpdate, WF.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class qF { constructor(t, e, n = null, r = e.blendMode) { this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r; const i = e.tracks, s = i.length, o = new Array(s), a = { endingStart: TC, endingEnd: TC }; for (let l = 0; l !== s; ++l) { const t = i[l].createInterpolant(null); o[l] = t, t.settings = a } this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(t) { return this._startTime = t, this } setLoop(t, e) { return this.loop = t, this.repetitions = e, this } setEffectiveWeight(t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(t) { return this._scheduleFading(t, 0, 1) } fadeOut(t) { return this._scheduleFading(t, 1, 0) } crossFadeFrom(t, e, n) { if (t.fadeOut(e), this.fadeIn(e), n) { const n = this._clip.duration, r = t._clip.duration, i = n / r; t.warp(1, r / n, e), this.warp(i, 1, e) } return this } crossFadeTo(t, e, n) { return t.crossFadeFrom(this, e, n) } stopFading() { const t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this } setEffectiveTimeScale(t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(t) { return this.timeScale = this._clip.duration / t, this.stopWarping() } syncWith(t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() } halt(t) { return this.warp(this._effectiveTimeScale, 0, t) } warp(t, e, n) { const r = this._mixer, i = r.time, s = this.timeScale; let o = this._timeScaleInterpolant; null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o); const a = o.parameterPositions, l = o.sampleValues; return a[0] = i, a[1] = i + n, l[0] = t / s, l[1] = e / s, this } stopWarping() { const t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(t, e, n, r) { if (!this.enabled) return void this._updateWeight(t); const i = this._startTime; if (null !== i) { const r = (t - i) * n; if (r < 0 || 0 === n) return; this._startTime = null, e = n * r } e *= this._updateTimeScale(t); const s = this._updateTime(e), o = this._updateWeight(t); if (o > 0) { const t = this._interpolants, e = this._propertyBindings; switch (this.blendMode) { case 2501: for (let n = 0, r = t.length; n !== r; ++n)t[n].evaluate(s), e[n].accumulateAdditive(o); break; case 2500: default: for (let n = 0, i = t.length; n !== i; ++n)t[n].evaluate(s), e[n].accumulate(r, o) } } } _updateWeight(t) { let e = 0; if (this.enabled) { e = this.weight; const n = this._weightInterpolant; if (null !== n) { const r = n.evaluate(t)[0]; e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1)) } } return this._effectiveWeight = e, e } _updateTimeScale(t) { let e = 0; if (!this.paused) { e = this.timeScale; const n = this._timeScaleInterpolant; null !== n && (e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)) } return this._effectiveTimeScale = e, e } _updateTime(t) { const e = this._clip.duration, n = this.loop; let r = this.time + t, i = this._loopCount; const s = 2202 === n; if (0 === t) return -1 === i ? r : s && 1 == (1 & i) ? e - r : r; if (2200 === n) { -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1)); t: { if (r >= e) r = e; else { if (!(r < 0)) { this.time = r; break t } r = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 }) } } else { if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), r >= e || r < 0) { const n = Math.floor(r / e); r -= e * n, i += Math.abs(n); const o = this.repetitions - i; if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 }); else { if (1 === o) { const e = t < 0; this._setEndings(e, !e, s) } else this._setEndings(!1, !1, s); this._loopCount = i, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n }) } } else this.time = r; if (s && 1 == (1 & i)) return e - r } return r } _setEndings(t, e, n) { const r = this._interpolantSettings; n ? (r.endingStart = EC, r.endingEnd = EC) : (r.endingStart = t ? this.zeroSlopeAtStart ? EC : TC : MC, r.endingEnd = e ? this.zeroSlopeAtEnd ? EC : TC : MC) } _scheduleFading(t, e, n) { const r = this._mixer, i = r.time; let s = this._weightInterpolant; null === s && (s = r._lendControlInterpolant(), this._weightInterpolant = s); const o = s.parameterPositions, a = s.sampleValues; return o[0] = i, a[0] = e, o[1] = i + t, a[1] = n, this } } class ZF extends DC { constructor(t) { super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(t, e) { const n = t._localRoot || this._root, r = t._clip.tracks, i = r.length, s = t._propertyBindings, o = t._interpolants, a = n.uuid, l = this._bindingsByRootAndName; let c = l[a]; void 0 === c && (c = {}, l[a] = c); for (let u = 0; u !== i; ++u) { const t = r[u], i = t.name; let l = c[i]; if (void 0 !== l) s[u] = l; else { if (l = s[u], void 0 !== l) { null === l._cacheIndex && (++l.referenceCount, this._addInactiveBinding(l, a, i)); continue } l = new FF(WF.create(n, i, e && e._propertyBindings[u].binding.parsedPath), t.ValueTypeName, t.getValueSize()), ++l.referenceCount, this._addInactiveBinding(l, a, i), s[u] = l } o[u].resultBuffer = l.buffer } } _activateAction(t) { if (!this._isActiveAction(t)) { if (null === t._cacheIndex) { const e = (t._localRoot || this._root).uuid, n = t._clip.uuid, r = this._actionsByClip[n]; this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e) } const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState()) } this._lendAction(t) } } _deactivateAction(t) { if (this._isActiveAction(t)) { const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n)) } this._takeBackAction(t) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const t = this; this.stats = { actions: { get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: { get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: { get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } } } _isActiveAction(t) { const e = t._cacheIndex; return null !== e && e < this._nActiveActions } _addInactiveAction(t, e, n) { const r = this._actions, i = this._actionsByClip; let s = i[e]; if (void 0 === s) s = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, i[e] = s; else { const e = s.knownActions; t._byClipCacheIndex = e.length, e.push(t) } t._cacheIndex = r.length, r.push(t), s.actionByRoot[n] = t } _removeInactiveAction(t) { const e = this._actions, n = e[e.length - 1], r = t._cacheIndex; n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null; const i = t._clip.uuid, s = this._actionsByClip, o = s[i], a = o.knownActions, l = a[a.length - 1], c = t._byClipCacheIndex; l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete s[i], this._removeInactiveBindingsForAction(t) } _removeInactiveBindingsForAction(t) { const e = t._propertyBindings; for (let n = 0, r = e.length; n !== r; ++n) { const t = e[n]; 0 == --t.referenceCount && this._removeInactiveBinding(t) } } _lendAction(t) { const e = this._actions, n = t._cacheIndex, r = this._nActiveActions++, i = e[r]; t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i } _takeBackAction(t) { const e = this._actions, n = t._cacheIndex, r = --this._nActiveActions, i = e[r]; t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i } _addInactiveBinding(t, e, n) { const r = this._bindingsByRootAndName, i = this._bindings; let s = r[e]; void 0 === s && (s = {}, r[e] = s), s[n] = t, t._cacheIndex = i.length, i.push(t) } _removeInactiveBinding(t) { const e = this._bindings, n = t.binding, r = n.rootNode.uuid, i = n.path, s = this._bindingsByRootAndName, o = s[r], a = e[e.length - 1], l = t._cacheIndex; a._cacheIndex = l, e[l] = a, e.pop(), delete o[i], 0 === Object.keys(o).length && delete s[r] } _lendBinding(t) { const e = this._bindings, n = t._cacheIndex, r = this._nActiveBindings++, i = e[r]; t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i } _takeBackBinding(t) { const e = this._bindings, n = t._cacheIndex, r = --this._nActiveBindings, i = e[r]; t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i } _lendControlInterpolant() { const t = this._controlInterpolants, e = this._nActiveControlInterpolants++; let n = t[e]; return void 0 === n && (n = new MO(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n } _takeBackControlInterpolant(t) { const e = this._controlInterpolants, n = t.__cacheIndex, r = --this._nActiveControlInterpolants, i = e[r]; t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i } clipAction(t, e, n) { const r = e || this._root, i = r.uuid; let s = "string" == typeof t ? FO.findByName(r, t) : t; const o = null !== s ? s.uuid : t, a = this._actionsByClip[o]; let l = null; if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== a) { const t = a.actionByRoot[i]; if (void 0 !== t && t.blendMode === n) return t; l = a.knownActions[0], null === s && (s = l._clip) } if (null === s) return null; const c = new qF(this, s, e, n); return this._bindAction(c, l), this._addInactiveAction(c, o, i), c } existingAction(t, e) { const n = e || this._root, r = n.uuid, i = "string" == typeof t ? FO.findByName(n, t) : t, s = this._actionsByClip[i ? i.uuid : t]; return void 0 !== s && s.actionByRoot[r] || null } stopAllAction() { const t = this._actions; for (let e = this._nActiveActions - 1; e >= 0; --e)t[e].stop(); return this } update(t) { const e = this._actions, n = this._nActiveActions, r = this.time += t *= this.timeScale, i = Math.sign(t), s = this._accuIndex ^= 1; for (let l = 0; l !== n; ++l)e[l]._update(r, t, i, s); const o = this._bindings, a = this._nActiveBindings; for (let l = 0; l !== a; ++l)o[l].apply(s); return this } setTime(t) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(t) } getRoot() { return this._root } uncacheClip(t) { const e = this._actions, n = t.uuid, r = this._actionsByClip, i = r[n]; if (void 0 !== i) { const t = i.knownActions; for (let n = 0, r = t.length; n !== r; ++n) { const r = t[n]; this._deactivateAction(r); const i = r._cacheIndex, s = e[e.length - 1]; r._cacheIndex = null, r._byClipCacheIndex = null, s._cacheIndex = i, e[i] = s, e.pop(), this._removeInactiveBindingsForAction(r) } delete r[n] } } uncacheRoot(t) { const e = t.uuid, n = this._actionsByClip; for (const i in n) { const t = n[i].actionByRoot[e]; void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t)) } const r = this._bindingsByRootAndName[e]; if (void 0 !== r) for (const i in r) { const t = r[i]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(t, e) { const n = this.existingAction(t, e); null !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } } ZF.prototype._controlInterpolantsResultBuffer = new Float32Array(1); class KF { constructor(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t } clone() { return new KF(void 0 === this.value.clone ? this.value : this.value.clone()) } } (class extends zD { constructor(t, e, n = 1) { super(t, e), this.meshPerAttribute = n || 1 } copy(t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this } clone(t) { const e = super.clone(t); return e.meshPerAttribute = this.meshPerAttribute, e } toJSON(t) { const e = super.toJSON(t); return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e } }).prototype.isInstancedInterleavedBuffer = !0; class YF { constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.phi = e, this.theta = n, this } set(t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this } copy(t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this } makeSafe() { const t = 1e-6; return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this } setFromVector3(t) { return this.setFromCartesianCoords(t.x, t.y, t.z) } setFromCartesianCoords(t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(HC(e / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } } const QF = new XC; class $F { constructor(t = new XC(1 / 0, 1 / 0), e = new XC(-1 / 0, -1 / 0)) { this.min = t, this.max = e } set(t, e) { return this.min.copy(t), this.max.copy(e), this } setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this } setFromCenterAndSize(t, e) { const n = QF.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(t) { return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new XC), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(t) { return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new XC), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) } expandByPoint(t) { return this.min.min(t), this.max.max(t), this } expandByVector(t) { return this.min.sub(t), this.max.add(t), this } expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this } containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) } containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y } getParameter(t, e) { return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new XC), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) } clampPoint(t, e) { return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new XC), e.copy(t).clamp(this.min, this.max) } distanceToPoint(t) { return QF.copy(t).clamp(this.min, this.max).sub(t).length() } intersect(t) { return this.min.max(t.min), this.max.min(t.max), this } union(t) { return this.min.min(t.min), this.max.max(t.max), this } translate(t) { return this.min.add(t), this.max.add(t), this } equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) } } $F.prototype.isBox2 = !0, class extends sR { constructor(t) { super(), this.material = t, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } }.prototype.isImmediateRenderObject = !0; const tN = new rP, eN = new IP, nN = new IP; function rN(t) { const e = []; t && t.isBone && e.push(t); for (let n = 0; n < t.children.length; n++)e.push.apply(e, rN(t.children[n])); return e } class iN extends cL { constructor(t, e, n) { super(new yO(e, 4, 2), new RR({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const sN = new Float32Array(1); new Int32Array(sN.buffer), Math.pow(2, 8); const oN = new RR({ side: 1, depthWrite: !1, depthTest: !1 }); new cL(new hL, oN), Math.sqrt(5), XO.create = function (t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(XO.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, dF.prototype.fromPoints = function (t) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) }, class extends LI { constructor(t = 10, e = 10, n = 4473924, r = 8947848) { n = new PR(n), r = new PR(r); const i = e / 2, s = t / e, o = t / 2, a = [], l = []; for (let u = 0, h = 0, d = -o; u <= e; u++, d += s) { a.push(-o, 0, d, o, 0, d), a.push(d, 0, -o, d, 0, o); const t = u === i ? n : r; t.toArray(l, h), h += 3, t.toArray(l, h), h += 3, t.toArray(l, h), h += 3, t.toArray(l, h), h += 3 } const c = new JR; c.setAttribute("position", new FR(a, 3)), c.setAttribute("color", new FR(l, 3)), super(c, new SI({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } }.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, class extends LI { constructor(t) { const e = rN(t), n = new JR, r = [], i = [], s = new PR(0, 0, 1), o = new PR(0, 1, 0); for (let a = 0; a < e.length; a++) { const t = e[a]; t.parent && t.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(s.r, s.g, s.b), i.push(o.r, o.g, o.b)) } n.setAttribute("position", new FR(r, 3)), n.setAttribute("color", new FR(i, 3)), super(n, new SI({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(t) { const e = this.bones, n = this.geometry, r = n.getAttribute("position"); nN.copy(this.root.matrixWorld).invert(); for (let i = 0, s = 0; i < e.length; i++) { const t = e[i]; t.parent && t.parent.isBone && (eN.multiplyMatrices(nN, t.matrixWorld), tN.setFromMatrixPosition(eN), r.setXYZ(s, tN.x, tN.y, tN.z), eN.multiplyMatrices(nN, t.parent.matrixWorld), tN.setFromMatrixPosition(eN), r.setXYZ(s + 1, tN.x, tN.y, tN.z), s += 2) } n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t) } }.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, UO.prototype.extractUrlBase = function (t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), kF.extractUrlBase(t) }, UO.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, $F.prototype.center = function (t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, $F.prototype.empty = function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, $F.prototype.isIntersectionBox = function (t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, $F.prototype.size = function (t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) }, oP.prototype.center = function (t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, oP.prototype.empty = function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, oP.prototype.isIntersectionBox = function (t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, oP.prototype.isIntersectionSphere = function (t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, oP.prototype.size = function (t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) }, EP.prototype.empty = function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, TL.prototype.setFromMatrix = function (t) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t) }, WC.prototype.flattenToArrayOffset = function (t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, WC.prototype.multiplyVector3 = function (t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, WC.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, WC.prototype.applyToBufferAttribute = function (t) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, WC.prototype.applyToVector3Array = function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, WC.prototype.getInverse = function (t) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() }, IP.prototype.extractPosition = function (t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, IP.prototype.flattenToArrayOffset = function (t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, IP.prototype.getPosition = function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new rP).setFromMatrixColumn(this, 3) }, IP.prototype.setRotationFromQuaternion = function (t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, IP.prototype.multiplyToArray = function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, IP.prototype.multiplyVector3 = function (t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, IP.prototype.multiplyVector4 = function (t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, IP.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, IP.prototype.rotateAxis = function (t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, IP.prototype.crossVector = function (t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, IP.prototype.translate = function () { console.error("THREE.Matrix4: .translate() has been removed.") }, IP.prototype.rotateX = function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, IP.prototype.rotateY = function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, IP.prototype.rotateZ = function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, IP.prototype.rotateByAxis = function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, IP.prototype.applyToBufferAttribute = function (t) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, IP.prototype.applyToVector3Array = function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, IP.prototype.makeFrustum = function (t, e, n, r, i, s) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, s) }, IP.prototype.getInverse = function (t) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() }, cR.prototype.isIntersectionLine = function (t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, nP.prototype.multiplyVector3 = function (t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, nP.prototype.inverse = function () { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, DP.prototype.isIntersectionBox = function (t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, DP.prototype.isIntersectionPlane = function (t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, DP.prototype.isIntersectionSphere = function (t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, _R.prototype.area = function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, _R.prototype.barycoordFromPoint = function (t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, _R.prototype.midpoint = function (t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, _R.prototypenormal = function (t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, _R.prototype.plane = function (t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) }, _R.barycoordFromPoint = function (t, e, n, r, i) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), _R.getBarycoord(t, e, n, r, i) }, _R.normal = function (t, e, n, r) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), _R.getNormal(t, e, n, r) }, pF.prototype.extractAllPoints = function (t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, pF.prototype.extrude = function (t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new mO(this, t) }, pF.prototype.makeGeometry = function (t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new vO(this, t) }, XC.prototype.fromAttribute = function (t, e, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, XC.prototype.distanceToManhattan = function (t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, XC.prototype.lengthManhattan = function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, rP.prototype.setEulerFromRotationMatrix = function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, rP.prototype.setEulerFromQuaternion = function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, rP.prototype.getPositionFromMatrix = function (t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, rP.prototype.getScaleFromMatrix = function (t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, rP.prototype.getColumnFromMatrix = function (t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, rP.prototype.applyProjection = function (t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, rP.prototype.fromAttribute = function (t, e, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, rP.prototype.distanceToManhattan = function (t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, rP.prototype.lengthManhattan = function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, $C.prototype.fromAttribute = function (t, e, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, $C.prototype.lengthManhattan = function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, sR.prototype.getChildByName = function (t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, sR.prototype.renderDepth = function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, sR.prototype.translate = function (t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, sR.prototype.getWorldRotation = function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, sR.prototype.applyMatrix = function (t) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) }, Object.defineProperties(sR.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), cL.prototype.setDrawMode = function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(cL.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), dI.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, vL.prototype.setLens = function (t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(fF.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function (t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function (t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function (t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function (t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function (t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function (t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function (t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(DR.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === LC }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(LC) } } }), DR.prototype.setDynamic = function (t) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? LC : RC), this }, DR.prototype.copyIndicesArray = function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, DR.prototype.setArray = function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, JR.prototype.addIndex = function (t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, JR.prototype.addAttribute = function (t, e) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new DR(arguments[1], arguments[2]))) }, JR.prototype.addDrawCall = function (t, e, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, JR.prototype.clearDrawCalls = function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, JR.prototype.computeOffsets = function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, JR.prototype.removeAttribute = function (t) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t) }, JR.prototype.applyMatrix = function (t) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) }, Object.defineProperties(JR.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), zD.prototype.setDynamic = function (t) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? LC : RC), this }, zD.prototype.setArray = function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, mO.prototype.getArrays = function () { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, mO.prototype.addShapeList = function () { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, mO.prototype.addShape = function () { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, VD.prototype.dispose = function () { console.error("THREE.Scene: .dispose() has been removed.") }, KF.prototype.onUpdate = function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this }, Object.defineProperties(SR.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new PR } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (t) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t } } }), Object.defineProperties(mL.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), HD.prototype.clearTarget = function (t, e, n, r) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r) }, HD.prototype.animate = function (t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, HD.prototype.getCurrentRenderTarget = function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, HD.prototype.getMaxAnisotropy = function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, HD.prototype.getPrecision = function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, HD.prototype.resetGLState = function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, HD.prototype.supportsFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, HD.prototype.supportsHalfFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, HD.prototype.supportsStandardDerivatives = function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, HD.prototype.supportsCompressedTextureS3TC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, HD.prototype.supportsCompressedTexturePVRTC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, HD.prototype.supportsBlendMinMax = function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, HD.prototype.supportsVertexTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, HD.prototype.supportsInstancedArrays = function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, HD.prototype.enableScissorTest = function (t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, HD.prototype.initMaterial = function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, HD.prototype.addPrePlugin = function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, HD.prototype.addPostPlugin = function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, HD.prototype.updateShadowMap = function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, HD.prototype.setFaceCulling = function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, HD.prototype.allocTextureUnit = function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, HD.prototype.setTexture = function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, HD.prototype.setTexture2D = function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, HD.prototype.setTextureCube = function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, HD.prototype.getActiveMipMapLevel = function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(HD.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (t) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? CC : AC } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(PD.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(tP.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), class extends sR { constructor(t) { super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this } setMediaElementSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this } setMediaStreamSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this } setBuffer(t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this } play(t = 0) { if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing."); if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control."); this._startedAt = this.context.currentTime + t; const e = this.context.createBufferSource(); return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } stop() { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].connect(this.filters[t]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].disconnect(this.filters[t]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(t) { return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this } setDetune(t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(t) { return this.setFilters(t ? [t] : []) } setPlaybackRate(t) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(t) { if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } setLoopStart(t) { return this.loopStart = t, this } setLoopEnd(t) { return this.loopEnd = t, this } getVolume() { return this.gain.gain.value } setVolume(t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this } }.prototype.load = function (t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const e = this; return (new OF).load(t, function (t) { e.setBuffer(t) }), this }, bL.prototype.updateCubeMap = function (t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }, bL.prototype.clear = function (t, e, n, r) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r) }, ZC.crossOrigin = void 0, ZC.loadTexture = function (t, e, n, r) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const i = new JO; i.setCrossOrigin(this.crossOrigin); const s = i.load(t, n, void 0, r); return e && (s.mapping = e), s }, ZC.loadTextureCube = function (t, e, n, r) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const i = new jO; i.setCrossOrigin(this.crossOrigin); const s = i.load(t, n, void 0, r); return e && (s.mapping = e), s }, ZC.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, ZC.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "129" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "129"); const aN = { type: "change" }, lN = { type: "start" }, cN = { type: "end" }; class uN extends DC { constructor(t, e) { super(), void 0 === e && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t, this.domElement = e, this.enabled = !0, this.target = new rP, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, this.touches = { ONE: 0, TWO: 2 }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () { return o.phi }, this.getAzimuthalAngle = function () { return o.theta }, this.listenToKeyEvents = function (t) { t.addEventListener("keydown", U), this._domElementKeyEvents = t }, this.saveState = function () { n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom }, this.reset = function () { n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(aN), n.update(), i = r.NONE }, this.update = function () { const e = new rP, h = (new nP).setFromUnitVectors(t.up, new rP(0, 1, 0)), d = h.clone().invert(), p = new rP, f = new nP, m = 2 * Math.PI; return function () { const t = n.object.position; e.copy(t).sub(n.target), e.applyQuaternion(h), o.setFromVector3(e), n.autoRotate && i === r.NONE && w(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (o.theta += a.theta * n.dampingFactor, o.phi += a.phi * n.dampingFactor) : (o.theta += a.theta, o.phi += a.phi); let g = n.minAzimuthAngle, v = n.maxAzimuthAngle; return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += m : g > Math.PI && (g -= m), v < -Math.PI ? v += m : v > Math.PI && (v -= m), o.theta = g <= v ? Math.max(g, Math.min(v, o.theta)) : o.theta > (g + v) / 2 ? Math.max(g, o.theta) : Math.min(v, o.theta)), o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)), o.makeSafe(), o.radius *= l, o.radius = Math.max(n.minDistance, Math.min(n.maxDistance, o.radius)), !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c), e.setFromSpherical(o), e.applyQuaternion(d), t.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (a.theta *= 1 - n.dampingFactor, a.phi *= 1 - n.dampingFactor, c.multiplyScalar(1 - n.dampingFactor)) : (a.set(0, 0, 0), c.set(0, 0, 0)), l = 1, !!(u || p.distanceToSquared(n.object.position) > s || 8 * (1 - f.dot(n.object.quaternion)) > s) && (n.dispatchEvent(aN), p.copy(n.object.position), f.copy(n.object.quaternion), u = !1, !0) } }(), this.dispose = function () { n.domElement.removeEventListener("contextmenu", j), n.domElement.removeEventListener("pointerdown", F), n.domElement.removeEventListener("wheel", H), n.domElement.removeEventListener("touchstart", G), n.domElement.removeEventListener("touchend", z), n.domElement.removeEventListener("touchmove", V), n.domElement.ownerDocument.removeEventListener("pointermove", N), n.domElement.ownerDocument.removeEventListener("pointerup", B), null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", U) }; const n = this, r = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let i = r.NONE; const s = 1e-6, o = new YF, a = new YF; let l = 1; const c = new rP; let u = !1; const h = new XC, d = new XC, p = new XC, f = new XC, m = new XC, g = new XC, v = new XC, y = new XC, b = new XC; function _() { return Math.pow(.95, n.zoomSpeed) } function w(t) { a.theta -= t } function S(t) { a.phi -= t } const x = function () { const t = new rP; return function (e, n) { t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), c.add(t) } }(), T = function () { const t = new rP; return function (e, r) { !0 === n.screenSpacePanning ? t.setFromMatrixColumn(r, 1) : (t.setFromMatrixColumn(r, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), c.add(t) } }(), E = function () { const t = new rP; return function (e, r) { const i = n.domElement; if (n.object.isPerspectiveCamera) { t.copy(n.object.position).sub(n.target); let s = t.length(); s *= Math.tan(n.object.fov / 2 * Math.PI / 180), x(2 * e * s / i.clientHeight, n.object.matrix), T(2 * r * s / i.clientHeight, n.object.matrix) } else n.object.isOrthographicCamera ? (x(e * (n.object.right - n.object.left) / n.object.zoom / i.clientWidth, n.object.matrix), T(r * (n.object.top - n.object.bottom) / n.object.zoom / i.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1) } }(); function M(t) { n.object.isPerspectiveCamera ? l /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)), n.object.updateProjectionMatrix(), u = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function A(t) { n.object.isPerspectiveCamera ? l *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)), n.object.updateProjectionMatrix(), u = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1) } function C(t) { h.set(t.clientX, t.clientY) } function P(t) { f.set(t.clientX, t.clientY) } function R(t) { 1 == t.touches.length ? h.set(t.touches[0].pageX, t.touches[0].pageY) : h.set(.5 * (t.touches[0].pageX + t.touches[1].pageX), .5 * (t.touches[0].pageY + t.touches[1].pageY)) } function L(t) { 1 == t.touches.length ? f.set(t.touches[0].pageX, t.touches[0].pageY) : f.set(.5 * (t.touches[0].pageX + t.touches[1].pageX), .5 * (t.touches[0].pageY + t.touches[1].pageY)) } function k(t) { const e = t.touches[0].pageX - t.touches[1].pageX, n = t.touches[0].pageY - t.touches[1].pageY, r = Math.sqrt(e * e + n * n); v.set(0, r) } function D(t) { 1 == t.touches.length ? d.set(t.touches[0].pageX, t.touches[0].pageY) : d.set(.5 * (t.touches[0].pageX + t.touches[1].pageX), .5 * (t.touches[0].pageY + t.touches[1].pageY)), p.subVectors(d, h).multiplyScalar(n.rotateSpeed); const e = n.domElement; w(2 * Math.PI * p.x / e.clientHeight), S(2 * Math.PI * p.y / e.clientHeight), h.copy(d) } function I(t) { 1 == t.touches.length ? m.set(t.touches[0].pageX, t.touches[0].pageY) : m.set(.5 * (t.touches[0].pageX + t.touches[1].pageX), .5 * (t.touches[0].pageY + t.touches[1].pageY)), g.subVectors(m, f).multiplyScalar(n.panSpeed), E(g.x, g.y), f.copy(m) } function O(t) { const e = t.touches[0].pageX - t.touches[1].pageX, r = t.touches[0].pageY - t.touches[1].pageY, i = Math.sqrt(e * e + r * r); y.set(0, i), b.set(0, Math.pow(y.y / v.y, n.zoomSpeed)), M(b.y), v.copy(y) } function F(t) { if (!1 !== n.enabled) switch (t.pointerType) { case "mouse": case "pen": !function (t) { let e; switch (t.preventDefault(), n.domElement.focus ? n.domElement.focus() : window.focus(), t.button) { case 0: e = n.mouseButtons.LEFT; break; case 1: e = n.mouseButtons.MIDDLE; break; case 2: e = n.mouseButtons.RIGHT; break; default: e = -1 }switch (e) { case 1: if (!1 === n.enableZoom) return; !function (t) { v.set(t.clientX, t.clientY) }(t), i = r.DOLLY; break; case 0: if (t.ctrlKey || t.metaKey || t.shiftKey) { if (!1 === n.enablePan) return; P(t), i = r.PAN } else { if (!1 === n.enableRotate) return; C(t), i = r.ROTATE } break; case 2: if (t.ctrlKey || t.metaKey || t.shiftKey) { if (!1 === n.enableRotate) return; C(t), i = r.ROTATE } else { if (!1 === n.enablePan) return; P(t), i = r.PAN } break; default: i = r.NONE }i !== r.NONE && (n.domElement.ownerDocument.addEventListener("pointermove", N), n.domElement.ownerDocument.addEventListener("pointerup", B), n.dispatchEvent(lN)) }(t) } } function N(t) { if (!1 !== n.enabled) switch (t.pointerType) { case "mouse": case "pen": !function (t) { if (!1 !== n.enabled) switch (t.preventDefault(), i) { case r.ROTATE: if (!1 === n.enableRotate) return; !function (t) { d.set(t.clientX, t.clientY), p.subVectors(d, h).multiplyScalar(n.rotateSpeed); const e = n.domElement; w(2 * Math.PI * p.x / e.clientHeight), S(2 * Math.PI * p.y / e.clientHeight), h.copy(d), n.update() }(t); break; case r.DOLLY: if (!1 === n.enableZoom) return; !function (t) { y.set(t.clientX, t.clientY), b.subVectors(y, v), b.y > 0 ? M(_()) : b.y < 0 && A(_()), v.copy(y), n.update() }(t); break; case r.PAN: if (!1 === n.enablePan) return; !function (t) { m.set(t.clientX, t.clientY), g.subVectors(m, f).multiplyScalar(n.panSpeed), E(g.x, g.y), f.copy(m), n.update() }(t) } }(t) } } function B(t) { switch (t.pointerType) { case "mouse": case "pen": n.domElement.ownerDocument.removeEventListener("pointermove", N), n.domElement.ownerDocument.removeEventListener("pointerup", B), !1 !== n.enabled && (n.dispatchEvent(cN), i = r.NONE) } } function H(t) { !1 === n.enabled || !1 === n.enableZoom || i !== r.NONE && i !== r.ROTATE || (t.preventDefault(), n.dispatchEvent(lN), function (t) { t.deltaY < 0 ? A(_()) : t.deltaY > 0 && M(_()), n.update() }(t), n.dispatchEvent(cN)) } function U(t) { !1 !== n.enabled && !1 !== n.enablePan && function (t) { let e = !1; switch (t.code) { case n.keys.UP: E(0, n.keyPanSpeed), e = !0; break; case n.keys.BOTTOM: E(0, -n.keyPanSpeed), e = !0; break; case n.keys.LEFT: E(n.keyPanSpeed, 0), e = !0; break; case n.keys.RIGHT: E(-n.keyPanSpeed, 0), e = !0 }e && (t.preventDefault(), n.update()) }(t) } function G(t) { if (!1 !== n.enabled) { switch (t.preventDefault(), t.touches.length) { case 1: switch (n.touches.ONE) { case 0: if (!1 === n.enableRotate) return; R(t), i = r.TOUCH_ROTATE; break; case 1: if (!1 === n.enablePan) return; L(t), i = r.TOUCH_PAN; break; default: i = r.NONE }break; case 2: switch (n.touches.TWO) { case 2: if (!1 === n.enableZoom && !1 === n.enablePan) return; !function (t) { n.enableZoom && k(t), n.enablePan && L(t) }(t), i = r.TOUCH_DOLLY_PAN; break; case 3: if (!1 === n.enableZoom && !1 === n.enableRotate) return; !function (t) { n.enableZoom && k(t), n.enableRotate && R(t) }(t), i = r.TOUCH_DOLLY_ROTATE; break; default: i = r.NONE }break; default: i = r.NONE }i !== r.NONE && n.dispatchEvent(lN) } } function V(t) { if (!1 !== n.enabled) switch (t.preventDefault(), i) { case r.TOUCH_ROTATE: if (!1 === n.enableRotate) return; D(t), n.update(); break; case r.TOUCH_PAN: if (!1 === n.enablePan) return; I(t), n.update(); break; case r.TOUCH_DOLLY_PAN: if (!1 === n.enableZoom && !1 === n.enablePan) return; !function (t) { n.enableZoom && O(t), n.enablePan && I(t) }(t), n.update(); break; case r.TOUCH_DOLLY_ROTATE: if (!1 === n.enableZoom && !1 === n.enableRotate) return; !function (t) { n.enableZoom && O(t), n.enableRotate && D(t) }(t), n.update(); break; default: i = r.NONE } } function z(t) { !1 !== n.enabled && (n.dispatchEvent(cN), i = r.NONE) } function j(t) { !1 !== n.enabled && t.preventDefault() } n.domElement.addEventListener("contextmenu", j), n.domElement.addEventListener("pointerdown", F), n.domElement.addEventListener("wheel", H, { passive: !1 }), n.domElement.addEventListener("touchstart", G, { passive: !1 }), n.domElement.addEventListener("touchend", z), n.domElement.addEventListener("touchmove", V, { passive: !1 }), this.update() } } var hN = {}, dN = function (t) { return URL.createObjectURL(new Blob([t], { type: "text/javascript" })) }, pN = function (t) { return new Worker(t) }; try { URL.revokeObjectURL(dN("")) } catch (Iz) { dN = function (t) { return "data:application/javascript;charset=UTF-8," + encodeURI(t) }, pN = function (t) { return new Worker(t, { type: "module" }) } } var fN = Uint8Array, mN = Uint16Array, gN = Uint32Array, vN = new fN([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), yN = new fN([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), bN = new fN([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), _N = function (t, e) { for (var n = new mN(31), r = 0; r < 31; ++r)n[r] = e += 1 << t[r - 1]; var i = new gN(n[30]); for (r = 1; r < 30; ++r)for (var s = n[r]; s < n[r + 1]; ++s)i[s] = s - n[r] << 5 | r; return [n, i] }, wN = _N(vN, 2), SN = wN[0], xN = wN[1]; SN[28] = 258, xN[258] = 28; for (var TN = _N(yN, 0), EN = TN[0], MN = TN[1], AN = new mN(32768), CN = 0; CN < 32768; ++CN) { var PN = (43690 & CN) >>> 1 | (21845 & CN) << 1; AN[CN] = ((65280 & (PN = (61680 & (PN = (52428 & PN) >>> 2 | (13107 & PN) << 2)) >>> 4 | (3855 & PN) << 4)) >>> 8 | (255 & PN) << 8) >>> 1 } var RN = function (t, e, n) { for (var r = t.length, i = 0, s = new mN(e); i < r; ++i)++s[t[i] - 1]; var o, a = new mN(e); for (i = 0; i < e; ++i)a[i] = a[i - 1] + s[i - 1] << 1; if (n) { o = new mN(1 << e); var l = 15 - e; for (i = 0; i < r; ++i)if (t[i]) for (var c = i << 4 | t[i], u = e - t[i], h = a[t[i] - 1]++ << u, d = h | (1 << u) - 1; h <= d; ++h)o[AN[h] >>> l] = c } else for (o = new mN(r), i = 0; i < r; ++i)t[i] && (o[i] = AN[a[t[i] - 1]++] >>> 15 - t[i]); return o }, LN = new fN(288); for (CN = 0; CN < 144; ++CN)LN[CN] = 8; for (CN = 144; CN < 256; ++CN)LN[CN] = 9; for (CN = 256; CN < 280; ++CN)LN[CN] = 7; for (CN = 280; CN < 288; ++CN)LN[CN] = 8; var kN = new fN(32); for (CN = 0; CN < 32; ++CN)kN[CN] = 5; var DN = RN(LN, 9, 0), IN = RN(LN, 9, 1), ON = RN(kN, 5, 0), FN = RN(kN, 5, 1), NN = function (t) { for (var e = t[0], n = 1; n < t.length; ++n)t[n] > e && (e = t[n]); return e }, BN = function (t, e, n) { var r = e / 8 | 0; return (t[r] | t[r + 1] << 8) >> (7 & e) & n }, HN = function (t, e) { var n = e / 8 | 0; return (t[n] | t[n + 1] << 8 | t[n + 2] << 16) >> (7 & e) }, UN = function (t) { return (t / 8 | 0) + (7 & t && 1) }, GN = function (t, e, n) { (null == e || e < 0) && (e = 0), (null == n || n > t.length) && (n = t.length); var r = new (t instanceof mN ? mN : t instanceof gN ? gN : fN)(n - e); return r.set(t.subarray(e, n)), r }, VN = function (t, e, n) { var r = t.length; if (!r || n && !n.l && r < 5) return e || new fN(0); var i = !e || n, s = !n || n.i; n || (n = {}), e || (e = new fN(3 * r)); var o = function (t) { var n = e.length; if (t > n) { var r = new fN(Math.max(2 * n, t)); r.set(e), e = r } }, a = n.f || 0, l = n.p || 0, c = n.b || 0, u = n.l, h = n.d, d = n.m, p = n.n, f = 8 * r; do { if (!u) { n.f = a = BN(t, l, 1); var m = BN(t, l + 1, 3); if (l += 3, !m) { var g = t[(A = UN(l) + 4) - 4] | t[A - 3] << 8, v = A + g; if (v > r) { if (s) throw "unexpected EOF"; break } i && o(c + g), e.set(t.subarray(A, v), c), n.b = c += g, n.p = l = 8 * v; continue } if (1 == m) u = IN, h = FN, d = 9, p = 5; else { if (2 != m) throw "invalid block type"; var y = BN(t, l, 31) + 257, b = BN(t, l + 10, 15) + 4, _ = y + BN(t, l + 5, 31) + 1; l += 14; for (var w = new fN(_), S = new fN(19), x = 0; x < b; ++x)S[bN[x]] = BN(t, l + 3 * x, 7); l += 3 * b; var T = NN(S), E = (1 << T) - 1, M = RN(S, T, 1); for (x = 0; x < _;) { var A, C = M[BN(t, l, E)]; if (l += 15 & C, (A = C >>> 4) < 16) w[x++] = A; else { var P = 0, R = 0; for (16 == A ? (R = 3 + BN(t, l, 3), l += 2, P = w[x - 1]) : 17 == A ? (R = 3 + BN(t, l, 7), l += 3) : 18 == A && (R = 11 + BN(t, l, 127), l += 7); R--;)w[x++] = P } } var L = w.subarray(0, y), k = w.subarray(y); d = NN(L), p = NN(k), u = RN(L, d, 1), h = RN(k, p, 1) } if (l > f) { if (s) throw "unexpected EOF"; break } } i && o(c + 131072); for (var D = (1 << d) - 1, I = (1 << p) - 1, O = l; ; O = l) { var F = (P = u[HN(t, l) & D]) >>> 4; if ((l += 15 & P) > f) { if (s) throw "unexpected EOF"; break } if (!P) throw "invalid length/literal"; if (F < 256) e[c++] = F; else { if (256 == F) { O = l, u = null; break } var N = F - 254; F > 264 && (N = BN(t, l, (1 << (U = vN[x = F - 257])) - 1) + SN[x], l += U); var B = h[HN(t, l) & I], H = B >>> 4; if (!B) throw "invalid distance"; if (l += 15 & B, k = EN[H], H > 3) { var U = yN[H]; k += HN(t, l) & (1 << U) - 1, l += U } if (l > f) { if (s) throw "unexpected EOF"; break } i && o(c + 131072); for (var G = c + N; c < G; c += 4)e[c] = e[c - k], e[c + 1] = e[c + 1 - k], e[c + 2] = e[c + 2 - k], e[c + 3] = e[c + 3 - k]; c = G } } n.l = u, n.p = O, n.b = c, u && (a = 1, n.m = d, n.d = h, n.n = p) } while (!a); return c == e.length ? e : GN(e, 0, c) }, zN = function (t, e, n) { var r = e / 8 | 0; t[r] |= n <<= 7 & e, t[r + 1] |= n >>> 8 }, jN = function (t, e, n) { var r = e / 8 | 0; t[r] |= n <<= 7 & e, t[r + 1] |= n >>> 8, t[r + 2] |= n >>> 16 }, JN = function (t, e) { for (var n = [], r = 0; r < t.length; ++r)t[r] && n.push({ s: r, f: t[r] }); var i = n.length, s = n.slice(); if (!i) return [QN, 0]; if (1 == i) { var o = new fN(n[0].s + 1); return o[n[0].s] = 1, [o, 1] } n.sort(function (t, e) { return t.f - e.f }), n.push({ s: -1, f: 25001 }); var a = n[0], l = n[1], c = 0, u = 1, h = 2; for (n[0] = { s: -1, f: a.f + l.f, l: a, r: l }; u != i - 1;)a = n[n[c].f < n[h].f ? c++ : h++], l = n[c != u && n[c].f < n[h].f ? c++ : h++], n[u++] = { s: -1, f: a.f + l.f, l: a, r: l }; var d = s[0].s; for (r = 1; r < i; ++r)s[r].s > d && (d = s[r].s); var p = new mN(d + 1), f = XN(n[u - 1], p, 0); if (f > e) { r = 0; var m = 0, g = f - e, v = 1 << g; for (s.sort(function (t, e) { return p[e.s] - p[t.s] || t.f - e.f }); r < i; ++r) { var y = s[r].s; if (!(p[y] > e)) break; m += v - (1 << f - p[y]), p[y] = e } for (m >>>= g; m > 0;) { var b = s[r].s; p[b] < e ? m -= 1 << e - p[b]++ - 1 : ++r } for (; r >= 0 && m; --r) { var _ = s[r].s; p[_] == e && (--p[_], ++m) } f = e } return [new fN(p), f] }, XN = function (t, e, n) { return -1 == t.s ? Math.max(XN(t.l, e, n + 1), XN(t.r, e, n + 1)) : e[t.s] = n }, WN = function (t) { for (var e = t.length; e && !t[--e];); for (var n = new mN(++e), r = 0, i = t[0], s = 1, o = function (t) { n[r++] = t }, a = 1; a <= e; ++a)if (t[a] == i && a != e) ++s; else { if (!i && s > 2) { for (; s > 138; s -= 138)o(32754); s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0) } else if (s > 3) { for (o(i), --s; s > 6; s -= 6)o(8304); s > 2 && (o(s - 3 << 5 | 8208), s = 0) } for (; s--;)o(i); s = 1, i = t[a] } return [n.subarray(0, r), e] }, qN = function (t, e) { for (var n = 0, r = 0; r < e.length; ++r)n += t[r] * e[r]; return n }, ZN = function (t, e, n) { var r = n.length, i = UN(e + 2); t[i] = 255 & r, t[i + 1] = r >>> 8, t[i + 2] = 255 ^ t[i], t[i + 3] = 255 ^ t[i + 1]; for (var s = 0; s < r; ++s)t[i + s + 4] = n[s]; return 8 * (i + 4 + r) }, KN = function (t, e, n, r, i, s, o, a, l, c, u) { zN(e, u++, n), ++i[256]; for (var h = JN(i, 15), d = h[0], p = h[1], f = JN(s, 15), m = f[0], g = f[1], v = WN(d), y = v[0], b = v[1], _ = WN(m), w = _[0], S = _[1], x = new mN(19), T = 0; T < y.length; ++T)x[31 & y[T]]++; for (T = 0; T < w.length; ++T)x[31 & w[T]]++; for (var E = JN(x, 7), M = E[0], A = E[1], C = 19; C > 4 && !M[bN[C - 1]]; --C); var P, R, L, k, D = c + 5 << 3, I = qN(i, LN) + qN(s, kN) + o, O = qN(i, d) + qN(s, m) + o + 14 + 3 * C + qN(x, M) + (2 * x[16] + 3 * x[17] + 7 * x[18]); if (D <= I && D <= O) return ZN(e, u, t.subarray(l, l + c)); if (zN(e, u, 1 + (O < I)), u += 2, O < I) { P = RN(d, p, 0), R = d, L = RN(m, g, 0), k = m; var F = RN(M, A, 0); for (zN(e, u, b - 257), zN(e, u + 5, S - 1), zN(e, u + 10, C - 4), u += 14, T = 0; T < C; ++T)zN(e, u + 3 * T, M[bN[T]]); u += 3 * C; for (var N = [y, w], B = 0; B < 2; ++B) { var H = N[B]; for (T = 0; T < H.length; ++T)zN(e, u, F[U = 31 & H[T]]), u += M[U], U > 15 && (zN(e, u, H[T] >>> 5 & 127), u += H[T] >>> 12) } } else P = DN, R = LN, L = ON, k = kN; for (T = 0; T < a; ++T)if (r[T] > 255) { var U; jN(e, u, P[257 + (U = r[T] >>> 18 & 31)]), u += R[U + 257], U > 7 && (zN(e, u, r[T] >>> 23 & 31), u += vN[U]); var G = 31 & r[T]; jN(e, u, L[G]), u += k[G], G > 3 && (jN(e, u, r[T] >>> 5 & 8191), u += yN[G]) } else jN(e, u, P[r[T]]), u += R[r[T]]; return jN(e, u, P[256]), u + R[256] }, YN = new gN([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), QN = new fN(0), $N = function (t, e, n, r, i, s) { var o = t.length, a = new fN(r + o + 5 * (1 + Math.ceil(o / 7e3)) + i), l = a.subarray(r, a.length - i), c = 0; if (!e || o < 8) for (var u = 0; u <= o; u += 65535) { var h = u + 65535; h < o ? c = ZN(l, c, t.subarray(u, h)) : (l[u] = s, c = ZN(l, c, t.subarray(u, o))) } else { for (var d = YN[e - 1], p = d >>> 13, f = 8191 & d, m = (1 << n) - 1, g = new mN(32768), v = new mN(m + 1), y = Math.ceil(n / 3), b = 2 * y, _ = function (e) { return (t[e] ^ t[e + 1] << y ^ t[e + 2] << b) & m }, w = new gN(25e3), S = new mN(288), x = new mN(32), T = 0, E = 0, M = (u = 0, 0), A = 0, C = 0; u < o; ++u) { var P = _(u), R = 32767 & u, L = v[P]; if (g[R] = L, v[P] = R, A <= u) { var k = o - u; if ((T > 7e3 || M > 24576) && k > 423) { c = KN(t, l, 0, w, S, x, E, M, C, u - C, c), M = T = E = 0, C = u; for (var D = 0; D < 286; ++D)S[D] = 0; for (D = 0; D < 30; ++D)x[D] = 0 } var I = 2, O = 0, F = f, N = R - L & 32767; if (k > 2 && P == _(u - N)) for (var B = Math.min(p, k) - 1, H = Math.min(32767, u), U = Math.min(258, k); N <= H && --F && R != L;) { if (t[u + I] == t[u + I - N]) { for (var G = 0; G < U && t[u + G] == t[u + G - N]; ++G); if (G > I) { if (I = G, O = N, G > B) break; var V = Math.min(N, G - 2), z = 0; for (D = 0; D < V; ++D) { var j = u - N + D + 32768 & 32767, J = j - g[j] + 32768 & 32767; J > z && (z = J, L = j) } } } N += (R = L) - (L = g[R]) + 32768 & 32767 } if (O) { w[M++] = 268435456 | xN[I] << 18 | MN[O]; var X = 31 & xN[I], W = 31 & MN[O]; E += vN[X] + yN[W], ++S[257 + X], ++x[W], A = u + I, ++T } else w[M++] = t[u], ++S[t[u]] } } c = KN(t, l, s, w, S, x, E, M, C, u - C, c), !s && 7 & c && (c = ZN(l, c + 1, QN)) } return GN(a, 0, r + UN(c) + i) }, tB = function () { for (var t = new gN(256), e = 0; e < 256; ++e) { for (var n = e, r = 9; --r;)n = (1 & n && 3988292384) ^ n >>> 1; t[e] = n } return t }(), eB = function () { var t = -1; return { p: function (e) { for (var n = t, r = 0; r < e.length; ++r)n = tB[255 & n ^ e[r]] ^ n >>> 8; t = n }, d: function () { return ~t } } }, nB = function () { var t = 1, e = 0; return { p: function (n) { for (var r = t, i = e, s = n.length, o = 0; o != s;) { for (var a = Math.min(o + 2655, s); o < a; ++o)i += r += n[o]; r = (65535 & r) + 15 * (r >> 16), i = (65535 & i) + 15 * (i >> 16) } t = r, e = i }, d: function () { return (255 & (t %= 65521)) << 24 | t >>> 8 << 16 | (255 & (e %= 65521)) << 8 | e >>> 8 } } }, rB = function (t, e, n, r, i) { return $N(t, null == e.level ? 6 : e.level, null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem, n, r, !i) }, iB = function (t, e) { var n = {}; for (var r in t) n[r] = t[r]; for (var r in e) n[r] = e[r]; return n }, sB = function (t, e, n) { for (var r = t(), i = t.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < r.length; ++o) { var a = r[o], l = s[o]; if ("function" == typeof a) { e += ";" + l + "="; var c = a.toString(); if (a.prototype) if (-1 != c.indexOf("[native code]")) { var u = c.indexOf(" ", 8) + 1; e += c.slice(u, c.indexOf("(", u)) } else for (var h in e += c, a.prototype) e += ";" + l + ".prototype." + h + "=" + a.prototype[h].toString(); else e += c } else n[l] = a } return [e, n] }, oB = [], aB = function (t, e, n, r) { var i; if (!oB[n]) { for (var s = "", o = {}, a = t.length - 1, l = 0; l < a; ++l)s = (i = sB(t[l], s, o))[0], o = i[1]; oB[n] = sB(t[a], s, o) } var c = iB({}, oB[n][1]); return function (t, e, n, r, i) { var s = pN(hN[e] || (hN[e] = dN(t))); return s.onerror = function (t) { return i(t.error, null) }, s.onmessage = function (t) { return i(null, t.data) }, s.postMessage(n, r), s }(oB[n][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + e.toString() + "}", n, c, function (t) { var e = []; for (var n in t) (t[n] instanceof fN || t[n] instanceof mN || t[n] instanceof gN) && e.push((t[n] = new t[n].constructor(t[n])).buffer); return e }(c), r) }, lB = function () { return [fN, mN, gN, vN, yN, bN, SN, EN, IN, FN, AN, RN, NN, BN, HN, UN, GN, VN, NB, fB, mB] }, cB = function () { return [fN, mN, gN, vN, yN, bN, xN, MN, DN, LN, ON, kN, AN, YN, QN, RN, zN, jN, JN, XN, WN, qN, ZN, KN, UN, GN, $N, rB, DB, fB] }, uB = function () { return [xB, MB, SB, eB, tB] }, hB = function () { return [TB, EB] }, dB = function () { return [AB, SB, nB] }, pB = function () { return [CB] }, fB = function (t) { return postMessage(t, [t.buffer]) }, mB = function (t) { return t && t.size && new fN(t.size) }, gB = function (t, e, n, r, i, s) { var o = aB(n, r, i, function (t, e) { o.terminate(), s(t, e) }); return o.postMessage([t, e], e.consume ? [t.buffer] : []), function () { o.terminate() } }, vB = function (t) { return t.ondata = function (t, e) { return postMessage([t, e], [t.buffer]) }, function (e) { return t.push(e.data[0], e.data[1]) } }, yB = function (t, e, n, r, i) { var s, o = aB(t, r, i, function (t, n) { t ? (o.terminate(), e.ondata.call(e, t)) : (n[1] && o.terminate(), e.ondata.call(e, t, n[0], n[1])) }); o.postMessage(n), e.push = function (t, n) { if (s) throw "stream finished"; if (!e.ondata) throw "no stream handler"; o.postMessage([t, s = n], [t.buffer]) }, e.terminate = function () { o.terminate() } }, bB = function (t, e) { return t[e] | t[e + 1] << 8 }, _B = function (t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0 }, wB = function (t, e) { return _B(t, e) + 4294967296 * _B(t, e + 4) }, SB = function (t, e, n) { for (; n; ++e)t[e] = n, n >>>= 8 }, xB = function (t, e) { var n = e.filename; if (t[0] = 31, t[1] = 139, t[2] = 8, t[8] = e.level < 2 ? 4 : 9 == e.level ? 2 : 0, t[9] = 3, 0 != e.mtime && SB(t, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)), n) { t[3] = 8; for (var r = 0; r <= n.length; ++r)t[r + 10] = n.charCodeAt(r) } }, TB = function (t) { if (31 != t[0] || 139 != t[1] || 8 != t[2]) throw "invalid gzip data"; var e = t[3], n = 10; 4 & e && (n += t[10] | 2 + (t[11] << 8)); for (var r = (e >> 3 & 1) + (e >> 4 & 1); r > 0; r -= !t[n++]); return n + (2 & e) }, EB = function (t) { var e = t.length; return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0 }, MB = function (t) { return 10 + (t.filename && t.filename.length + 1 || 0) }, AB = function (t, e) { var n = e.level, r = 0 == n ? 0 : n < 6 ? 1 : 9 == n ? 3 : 2; t[0] = 120, t[1] = r << 6 | (r ? 32 - 2 * r : 1) }, CB = function (t) { if (8 != (15 & t[0]) || t[0] >>> 4 > 7 || (t[0] << 8 | t[1]) % 31) throw "invalid zlib data"; if (32 & t[1]) throw "invalid zlib data: preset dictionaries not supported" }; function PB(t, e) { return e || "function" != typeof t || (e = t, t = {}), this.ondata = e, t } var RB = function () { function t(t, e) { e || "function" != typeof t || (e = t, t = {}), this.ondata = e, this.o = t || {} } return t.prototype.p = function (t, e) { this.ondata(rB(t, this.o, 0, 0, !e), e) }, t.prototype.push = function (t, e) { if (this.d) throw "stream finished"; if (!this.ondata) throw "no stream handler"; this.d = e, this.p(t, e || !1) }, t }(), LB = function () { return function (t, e) { yB([cB, function () { return [vB, RB] }], this, PB.call(this, t, e), function (t) { var e = new RB(t.data); onmessage = vB(e) }, 6) } }(); function kB(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return gB(t, e, [cB], function (t) { return fB(DB(t.data[0], t.data[1])) }, 0, n) } function DB(t, e) { return rB(t, e || {}, 0, 0) } var IB = function () { function t(t) { this.s = {}, this.p = new fN(0), this.ondata = t } return t.prototype.e = function (t) { if (this.d) throw "stream finished"; if (!this.ondata) throw "no stream handler"; var e = this.p.length, n = new fN(e + t.length); n.set(this.p), n.set(t, e), this.p = n }, t.prototype.c = function (t) { this.d = this.s.i = t || !1; var e = this.s.b, n = VN(this.p, this.o, this.s); this.ondata(GN(n, e, this.s.b), this.d), this.o = GN(n, this.s.b - 32768), this.s.b = this.o.length, this.p = GN(this.p, this.s.p / 8 | 0), this.s.p &= 7 }, t.prototype.push = function (t, e) { this.e(t), this.c(e) }, t }(), OB = function () { return function (t) { this.ondata = t, yB([lB, function () { return [vB, IB] }], this, 0, function () { var t = new IB; onmessage = vB(t) }, 7) } }(); function FB(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return gB(t, e, [lB], function (t) { return fB(NB(t.data[0], mB(t.data[1]))) }, 1, n) } function NB(t, e) { return VN(t, e) } var BB = function () { function t(t, e) { this.c = eB(), this.l = 0, this.v = 1, RB.call(this, t, e) } return t.prototype.push = function (t, e) { RB.prototype.push.call(this, t, e) }, t.prototype.p = function (t, e) { this.c.p(t), this.l += t.length; var n = rB(t, this.o, this.v && MB(this.o), e && 8, !e); this.v && (xB(n, this.o), this.v = 0), e && (SB(n, n.length - 8, this.c.d()), SB(n, n.length - 4, this.l)), this.ondata(n, e) }, t }(), HB = function () { return function (t, e) { yB([cB, uB, function () { return [vB, RB, BB] }], this, PB.call(this, t, e), function (t) { var e = new BB(t.data); onmessage = vB(e) }, 8) } }(); function UB(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return gB(t, e, [cB, uB, function () { return [GB] }], function (t) { return fB(GB(t.data[0], t.data[1])) }, 2, n) } function GB(t, e) { e || (e = {}); var n = eB(), r = t.length; n.p(t); var i = rB(t, e, MB(e), 8), s = i.length; return xB(i, e), SB(i, s - 8, n.d()), SB(i, s - 4, r), i } var VB = function () { function t(t) { this.v = 1, IB.call(this, t) } return t.prototype.push = function (t, e) { if (IB.prototype.e.call(this, t), this.v) { var n = this.p.length > 3 ? TB(this.p) : 4; if (n >= this.p.length && !e) return; this.p = this.p.subarray(n), this.v = 0 } if (e) { if (this.p.length < 8) throw "invalid gzip stream"; this.p = this.p.subarray(0, -8) } IB.prototype.c.call(this, e) }, t }(), zB = function () { return function (t) { this.ondata = t, yB([lB, hB, function () { return [vB, IB, VB] }], this, 0, function () { var t = new VB; onmessage = vB(t) }, 9) } }(); function jB(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return gB(t, e, [lB, hB, function () { return [JB] }], function (t) { return fB(JB(t.data[0])) }, 3, n) } function JB(t, e) { return VN(t.subarray(TB(t), -8), e || new fN(EB(t))) } var XB = function () { function t(t, e) { this.c = nB(), this.v = 1, RB.call(this, t, e) } return t.prototype.push = function (t, e) { RB.prototype.push.call(this, t, e) }, t.prototype.p = function (t, e) { this.c.p(t); var n = rB(t, this.o, this.v && 2, e && 4, !e); this.v && (AB(n, this.o), this.v = 0), e && SB(n, n.length - 4, this.c.d()), this.ondata(n, e) }, t }(), WB = function () { return function (t, e) { yB([cB, dB, function () { return [vB, RB, XB] }], this, PB.call(this, t, e), function (t) { var e = new XB(t.data); onmessage = vB(e) }, 10) } }(); function qB(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return gB(t, e, [cB, dB, function () { return [ZB] }], function (t) { return fB(ZB(t.data[0], t.data[1])) }, 4, n) } function ZB(t, e) { e || (e = {}); var n = nB(); n.p(t); var r = rB(t, e, 2, 4); return AB(r, e), SB(r, r.length - 4, n.d()), r } var KB = function () { function t(t) { this.v = 1, IB.call(this, t) } return t.prototype.push = function (t, e) { if (IB.prototype.e.call(this, t), this.v) { if (this.p.length < 2 && !e) return; this.p = this.p.subarray(2), this.v = 0 } if (e) { if (this.p.length < 4) throw "invalid zlib stream"; this.p = this.p.subarray(0, -4) } IB.prototype.c.call(this, e) }, t }(), YB = function () { return function (t) { this.ondata = t, yB([lB, pB, function () { return [vB, IB, KB] }], this, 0, function () { var t = new KB; onmessage = vB(t) }, 11) } }(); function QB(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return gB(t, e, [lB, pB, function () { return [$B] }], function (t) { return fB($B(t.data[0], mB(t.data[1]))) }, 5, n) } function $B(t, e) { return VN((CB(t), t.subarray(2, -4)), e) } var tH = function () { function t(t) { this.G = VB, this.I = IB, this.Z = KB, this.ondata = t } return t.prototype.push = function (t, e) { if (!this.ondata) throw "no stream handler"; if (this.s) this.s.push(t, e); else { if (this.p && this.p.length) { var n = new fN(this.p.length + t.length); n.set(this.p), n.set(t, this.p.length) } else this.p = t; if (this.p.length > 2) { var r = this, i = function () { r.ondata.apply(r, arguments) }; this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(i) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(i) : new this.Z(i), this.s.push(this.p, e), this.p = null } } }, t }(), eH = function () { function t(t) { this.G = zB, this.I = OB, this.Z = YB, this.ondata = t } return t.prototype.push = function (t, e) { tH.prototype.push.call(this, t, e) }, t }(); function nH(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; return 31 == t[0] && 139 == t[1] && 8 == t[2] ? jB(t, e, n) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? FB(t, e, n) : QB(t, e, n) } function rH(t, e) { return 31 == t[0] && 139 == t[1] && 8 == t[2] ? JB(t, e) : 8 != (15 & t[0]) || t[0] >> 4 > 7 || (t[0] << 8 | t[1]) % 31 ? NB(t, e) : $B(t, e) } var iH = function (t, e, n, r) { for (var i in t) { var s = t[i], o = e + i; s instanceof fN ? n[o] = [s, r] : Array.isArray(s) ? n[o] = [s[0], iB(r, s[1])] : iH(s, o + "/", n, r) } }, sH = "undefined" != typeof TextEncoder && new TextEncoder, oH = "undefined" != typeof TextDecoder && new TextDecoder, aH = 0; try { oH.decode(QN, { stream: !0 }), aH = 1 } catch (Iz) { } var lH = function (t) { for (var e = "", n = 0; ;) { var r = t[n++], i = (r > 127) + (r > 223) + (r > 239); if (n + i > t.length) return [e, GN(t, n - 1)]; i ? 3 == i ? (r = ((15 & r) << 18 | (63 & t[n++]) << 12 | (63 & t[n++]) << 6 | 63 & t[n++]) - 65536, e += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : e += String.fromCharCode(1 & i ? (31 & r) << 6 | 63 & t[n++] : (15 & r) << 12 | (63 & t[n++]) << 6 | 63 & t[n++]) : e += String.fromCharCode(r) } }, cH = function () { function t(t) { this.ondata = t, aH ? this.t = new TextDecoder : this.p = QN } return t.prototype.push = function (t, e) { if (!this.ondata) throw "no callback"; if (e = !!e, this.t) { if (this.ondata(this.t.decode(t, { stream: !0 }), e), e) { if (this.t.decode().length) throw "invalid utf-8 data"; this.t = null } } else { if (!this.p) throw "stream finished"; var n = new fN(this.p.length + t.length); n.set(this.p), n.set(t, this.p.length); var r = lH(n), i = r[0], s = r[1]; if (e) { if (s.length) throw "invalid utf-8 data"; this.p = null } else this.p = s; this.ondata(i, e) } }, t }(), uH = function () { function t(t) { this.ondata = t } return t.prototype.push = function (t, e) { if (!this.ondata) throw "no callback"; if (this.d) throw "stream finished"; this.ondata(hH(t), this.d = e || !1) }, t }(); function hH(t, e) { if (e) { for (var n = new fN(t.length), r = 0; r < t.length; ++r)n[r] = t.charCodeAt(r); return n } if (sH) return sH.encode(t); var i = t.length, s = new fN(t.length + (t.length >> 1)), o = 0, a = function (t) { s[o++] = t }; for (r = 0; r < i; ++r) { if (o + 5 > s.length) { var l = new fN(o + 8 + (i - r << 1)); l.set(s), s = l } var c = t.charCodeAt(r); c < 128 || e ? a(c) : c < 2048 ? (a(192 | c >> 6), a(128 | 63 & c)) : c > 55295 && c < 57344 ? (a(240 | (c = 65536 + (1047552 & c) | 1023 & t.charCodeAt(++r)) >> 18), a(128 | c >> 12 & 63), a(128 | c >> 6 & 63), a(128 | 63 & c)) : (a(224 | c >> 12), a(128 | c >> 6 & 63), a(128 | 63 & c)) } return GN(s, 0, o) } function dH(t, e) { if (e) { for (var n = "", r = 0; r < t.length; r += 16384)n += String.fromCharCode.apply(null, t.subarray(r, r + 16384)); return n } if (oH) return oH.decode(t); var i = lH(t); if (i[1].length) throw "invalid utf-8 data"; return i[0] } var pH = function (t) { return 1 == t ? 3 : t < 6 ? 2 : 9 == t ? 1 : 0 }, fH = function (t, e) { return e + 30 + bB(t, e + 26) + bB(t, e + 28) }, mH = function (t, e, n) { var r = bB(t, e + 28), i = dH(t.subarray(e + 46, e + 46 + r), !(2048 & bB(t, e + 8))), s = e + 46 + r, o = _B(t, e + 20), a = n && 4294967295 == o ? gH(t, s) : [o, _B(t, e + 24), _B(t, e + 42)], l = a[0], c = a[1], u = a[2]; return [bB(t, e + 10), l, c, i, s + bB(t, e + 30) + bB(t, e + 32), u] }, gH = function (t, e) { for (; 1 != bB(t, e); e += 4 + bB(t, e + 2)); return [wB(t, e + 12), wB(t, e + 4), wB(t, e + 20)] }, vH = function (t) { var e = 0; if (t) for (var n in t) { var r = t[n].length; if (r > 65535) throw "extra field too long"; e += r + 4 } return e }, yH = function (t, e, n, r, i, s, o, a) { var l = r.length, c = n.extra, u = a && a.length, h = vH(c); SB(t, e, null != o ? 33639248 : 67324752), e += 4, null != o && (t[e++] = 20, t[e++] = n.os), t[e] = 20, e += 2, t[e++] = n.flag << 1 | (null == s && 8), t[e++] = i && 8, t[e++] = 255 & n.compression, t[e++] = n.compression >> 8; var d = new Date(null == n.mtime ? Date.now() : n.mtime), p = d.getFullYear() - 1980; if (p < 0 || p > 119) throw "date not in range 1980-2099"; if (SB(t, e, p << 25 | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1), e += 4, null != s && (SB(t, e, n.crc), SB(t, e + 4, s), SB(t, e + 8, n.size)), SB(t, e + 12, l), SB(t, e + 14, h), e += 16, null != o && (SB(t, e, u), SB(t, e + 6, n.attrs), SB(t, e + 10, o), e += 14), t.set(r, e), e += l, h) for (var f in c) { var m = c[f], g = m.length; SB(t, e, +f), SB(t, e + 2, g), t.set(m, e + 4), e += 4 + g } return u && (t.set(a, e), e += u), e }, bH = function (t, e, n, r, i) { SB(t, e, 101010256), SB(t, e + 8, n), SB(t, e + 10, n), SB(t, e + 12, r), SB(t, e + 16, i) }, _H = function () { function t(t) { this.filename = t, this.c = eB(), this.size = 0, this.compression = 0 } return t.prototype.process = function (t, e) { this.ondata(null, t, e) }, t.prototype.push = function (t, e) { if (!this.ondata) throw "no callback - add to ZIP archive before pushing"; this.c.p(t), this.size += t.length, e && (this.crc = this.c.d()), this.process(t, e || !1) }, t }(), wH = function () { function t(t, e) { var n = this; e || (e = {}), _H.call(this, t), this.d = new RB(e, function (t, e) { n.ondata(null, t, e) }), this.compression = 8, this.flag = pH(e.level) } return t.prototype.process = function (t, e) { try { this.d.push(t, e) } catch (Iz) { this.ondata(Iz, null, e) } }, t.prototype.push = function (t, e) { _H.prototype.push.call(this, t, e) }, t }(), SH = function () { function t(t, e) { var n = this; e || (e = {}), _H.call(this, t), this.d = new LB(e, function (t, e, r) { n.ondata(t, e, r) }), this.compression = 8, this.flag = pH(e.level), this.terminate = this.d.terminate } return t.prototype.process = function (t, e) { this.d.push(t, e) }, t.prototype.push = function (t, e) { _H.prototype.push.call(this, t, e) }, t }(), xH = function () { function t(t) { this.ondata = t, this.u = [], this.d = 1 } return t.prototype.add = function (t) { var e = this; if (2 & this.d) throw "stream finished"; var n = hH(t.filename), r = n.length, i = t.comment, s = i && hH(i), o = r != t.filename.length || s && i.length != s.length, a = r + vH(t.extra) + 30; if (r > 65535) throw "filename too long"; var l = new fN(a); yH(l, 0, t, n, o); var c = [l], u = function () { for (var t = 0, n = c; t < n.length; t++)e.ondata(null, n[t], !1); c = [] }, h = this.d; this.d = 0; var d = this.u.length, p = iB(t, { f: n, u: o, o: s, t: function () { t.terminate && t.terminate() }, r: function () { if (u(), h) { var t = e.u[d + 1]; t ? t.r() : e.d = 1 } h = 1 } }), f = 0; t.ondata = function (n, r, i) { if (n) e.ondata(n, r, i), e.terminate(); else if (f += r.length, c.push(r), i) { var s = new fN(16); SB(s, 0, 134695760), SB(s, 4, t.crc), SB(s, 8, f), SB(s, 12, t.size), c.push(s), p.c = f, p.b = a + f + 16, p.crc = t.crc, p.size = t.size, h && p.r(), h = 1 } else h && u() }, this.u.push(p) }, t.prototype.end = function () { var t = this; if (2 & this.d) { if (1 & this.d) throw "stream finishing"; throw "stream finished" } this.d ? this.e() : this.u.push({ r: function () { 1 & t.d && (t.u.splice(-1, 1), t.e()) }, t: function () { } }), this.d = 3 }, t.prototype.e = function () { for (var t = 0, e = 0, n = 0, r = 0, i = this.u; r < i.length; r++)n += 46 + (l = i[r]).f.length + vH(l.extra) + (l.o ? l.o.length : 0); for (var s = new fN(n + 22), o = 0, a = this.u; o < a.length; o++) { var l; yH(s, t, l = a[o], l.f, l.u, l.c, e, l.o), t += 46 + l.f.length + vH(l.extra) + (l.o ? l.o.length : 0), e += l.b } bH(s, t, this.u.length, n, e), this.ondata(null, s, !0), this.d = 2 }, t.prototype.terminate = function () { for (var t = 0, e = this.u; t < e.length; t++)e[t].t(); this.d = 2 }, t }(); function TH(t, e, n) { if (n || (n = e, e = {}), "function" != typeof n) throw "no callback"; var r = {}; iH(t, "", r, e); var i = Object.keys(r), s = i.length, o = 0, a = 0, l = s, c = new Array(s), u = [], h = function () { for (var t = 0; t < u.length; ++t)u[t]() }, d = function () { var t = new fN(a + 22), e = o, r = a - o; a = 0; for (var i = 0; i < l; ++i) { var s = c[i]; try { var u = s.c.length; yH(t, a, s, s.f, s.u, u); var h = 30 + s.f.length + vH(s.extra), d = a + h; t.set(s.c, d), yH(t, o, s, s.f, s.u, u, a, s.m), o += 16 + h + (s.m ? s.m.length : 0), a = d + u } catch (Iz) { return n(Iz, null) } } bH(t, o, c.length, r, e), n(null, t) }; s || d(); for (var p = function (t) { var e = i[t], l = r[e], p = l[0], f = l[1], m = eB(), g = p.length; m.p(p); var v = hH(e), y = v.length, b = f.comment, _ = b && hH(b), w = _ && _.length, S = vH(f.extra), x = 0 == f.level ? 0 : 8, T = function (r, i) { if (r) h(), n(r, null); else { var l = i.length; c[t] = iB(f, { size: g, crc: m.d(), c: i, f: v, m: _, u: y != e.length || _ && b.length != w, compression: x }), o += 30 + y + S + l, a += 76 + 2 * (y + S) + (w || 0) + l, --s || d() } }; if (y > 65535 && T("filename too long", null), x) if (g < 16e4) try { T(null, DB(p, f)) } catch (Iz) { T(Iz, null) } else u.push(kB(p, f, T)); else T(null, p) }, f = 0; f < l; ++f)p(f); return h } function EH(t, e) { e || (e = {}); var n = {}, r = []; iH(t, "", n, e); var i = 0, s = 0; for (var o in n) { var a = n[o], l = a[0], c = a[1], u = 0 == c.level ? 0 : 8, h = (x = hH(o)).length, d = c.comment, p = d && hH(d), f = p && p.length, m = vH(c.extra); if (h > 65535) throw "filename too long"; var g = u ? DB(l, c) : l, v = g.length, y = eB(); y.p(l), r.push(iB(c, { size: l.length, crc: y.d(), c: g, f: x, m: p, u: h != o.length || p && d.length != f, o: i, compression: u })), i += 30 + h + m + v, s += 76 + 2 * (h + m) + (f || 0) + v } for (var b = new fN(s + 22), _ = i, w = s - i, S = 0; S < r.length; ++S) { var x; yH(b, (x = r[S]).o, x, x.f, x.u, x.c.length); var T = 30 + x.f.length + vH(x.extra); b.set(x.c, x.o + T), yH(b, i, x, x.f, x.u, x.c.length, x.o, x.m), i += 16 + T + (x.m ? x.m.length : 0) } return bH(b, i, r.length, w, _), b } var MH = function () { function t() { } return t.prototype.push = function (t, e) { this.ondata(null, t, e) }, t.compression = 0, t }(), AH = function () { function t() { var t = this; this.i = new IB(function (e, n) { t.ondata(null, e, n) }) } return t.prototype.push = function (t, e) { try { this.i.push(t, e) } catch (Iz) { this.ondata(Iz, t, e) } }, t.compression = 8, t }(), CH = function () { function t(t, e) { var n = this; e < 32e4 ? this.i = new IB(function (t, e) { n.ondata(null, t, e) }) : (this.i = new OB(function (t, e, r) { n.ondata(t, e, r) }), this.terminate = this.i.terminate) } return t.prototype.push = function (t, e) { this.i.terminate && (t = GN(t, 0)), this.i.push(t, e) }, t.compression = 8, t }(), PH = function () { function t(t) { this.onfile = t, this.k = [], this.o = { 0: MH }, this.p = QN } return t.prototype.push = function (t, e) { var n = this; if (!this.onfile) throw "no callback"; if (!this.p) throw "stream finished"; if (this.c > 0) { var r = Math.min(this.c, t.length), i = t.subarray(0, r); if (this.c -= r, this.d ? this.d.push(i, !this.c) : this.k[0].push(i), (t = t.subarray(r)).length) return this.push(t, e) } else { var s = 0, o = 0, a = void 0, l = void 0; this.p.length ? t.length ? ((l = new fN(this.p.length + t.length)).set(this.p), l.set(t, this.p.length)) : l = this.p : l = t; for (var c = l.length, u = this.c, h = u && this.d, d = function () { var t, e = _B(l, o); if (67324752 == e) { s = 1, a = o, p.d = null, p.c = 0; var r = bB(l, o + 6), i = bB(l, o + 8), h = 2048 & r, d = 8 & r, f = bB(l, o + 26), m = bB(l, o + 28); if (c > o + 30 + f + m) { var g = []; p.k.unshift(g), s = 2; var v, y = _B(l, o + 18), b = _B(l, o + 22), _ = dH(l.subarray(o + 30, o += 30 + f), !h); 4294967295 == y ? (t = d ? [-2] : gH(l, o), y = t[0], b = t[1]) : d && (y = -1), o += m, p.c = y; var w = { name: _, compression: i, start: function () { if (!w.ondata) throw "no callback"; if (y) { var t = n.o[i]; if (!t) throw "unknown compression type " + i; (v = y < 0 ? new t(_) : new t(_, y, b)).ondata = function (t, e, n) { w.ondata(t, e, n) }; for (var e = 0, r = g; e < r.length; e++)v.push(r[e], !1); n.k[0] == g && n.c ? n.d = v : v.push(QN, !0) } else w.ondata(null, QN, !0) }, terminate: function () { v && v.terminate && v.terminate() } }; y >= 0 && (w.size = y, w.originalSize = b), p.onfile(w) } return "break" } if (u) { if (134695760 == e) return a = o += 12 + (-2 == u && 8), s = 3, p.c = 0, "break"; if (33639248 == e) return a = o -= 4, s = 3, p.c = 0, "break" } }, p = this; o < c - 4 && "break" !== d(); ++o); if (this.p = QN, u < 0) { var f = l.subarray(0, s ? a - 12 - (-2 == u && 8) - (134695760 == _B(l, a - 16) && 4) : o); h ? h.push(f, !!s) : this.k[+(2 == s)].push(f) } if (2 & s) return this.push(l.subarray(o), e); this.p = l.subarray(o) } if (e) { if (this.c) throw "invalid zip file"; this.p = null } }, t.prototype.register = function (t) { this.o[t.compression] = t }, t }(); function RH(t, e) { if ("function" != typeof e) throw "no callback"; for (var n = [], r = function () { for (var t = 0; t < n.length; ++t)n[t]() }, i = {}, s = t.length - 22; 101010256 != _B(t, s); --s)if (!s || t.length - s > 65558) return void e("invalid zip file", null); var o = bB(t, s + 8); o || e(null, {}); var a = o, l = _B(t, s + 16), c = 4294967295 == l; if (c) { if (s = _B(t, s - 12), 101075792 != _B(t, s)) return void e("invalid zip file", null); a = o = _B(t, s + 32), l = _B(t, s + 48) } for (var u = function (a) { var u = mH(t, l, c), h = u[0], d = u[1], p = u[2], f = u[3], m = u[4], g = fH(t, u[5]); l = m; var v = function (t, n) { t ? (r(), e(t, null)) : (i[f] = n, --o || e(null, i)) }; if (h) if (8 == h) { var y = t.subarray(g, g + d); if (d < 32e4) try { v(null, NB(y, new fN(p))) } catch (s) { v(s, null) } else n.push(FB(y, { size: p }, v)) } else v("unknown compression type " + h, null); else v(null, GN(t, g, g + d)) }, h = 0; h < a; ++h)u(); return r } function LH(t) { for (var e = {}, n = t.length - 22; 101010256 != _B(t, n); --n)if (!n || t.length - n > 65558) throw "invalid zip file"; var r = bB(t, n + 8); if (!r) return {}; var i = _B(t, n + 16), s = 4294967295 == i; if (s) { if (n = _B(t, n - 12), 101075792 != _B(t, n)) throw "invalid zip file"; r = _B(t, n + 32), i = _B(t, n + 48) } for (var o = 0; o < r; ++o) { var a = mH(t, i, s), l = a[0], c = a[1], u = a[2], h = a[3], d = a[4], p = fH(t, a[5]); if (i = d, l) { if (8 != l) throw "unknown compression type " + l; e[h] = NB(t.subarray(p, p + c), new fN(u)) } else e[h] = GN(t, p, p + c) } return e } class kH { static findSpan(t, e, n) { const r = n.length - t - 1; if (e >= n[r]) return r - 1; if (e <= n[t]) return t; let i = t, s = r, o = Math.floor((i + s) / 2); for (; e < n[o] || e >= n[o + 1];)e < n[o] ? s = o : i = o, o = Math.floor((i + s) / 2); return o } static calcBasisFunctions(t, e, n, r) { const i = [], s = [], o = []; i[0] = 1; for (let a = 1; a <= n; ++a) { s[a] = e - r[t + 1 - a], o[a] = r[t + a] - e; let n = 0; for (let t = 0; t < a; ++t) { const e = o[t + 1], r = s[a - t], l = i[t] / (e + r); i[t] = n + e * l, n = r * l } i[a] = n } return i } static calcBSplinePoint(t, e, n, r) { const i = this.findSpan(t, r, e), s = this.calcBasisFunctions(i, r, t, e), o = new $C(0, 0, 0, 0); for (let a = 0; a <= t; ++a) { const e = n[i - t + a], r = s[a], l = e.w * r; o.x += e.x * l, o.y += e.y * l, o.z += e.z * l, o.w += e.w * r } return o } static calcBasisFunctionDerivatives(t, e, n, r, i) { const s = []; for (let h = 0; h <= n; ++h)s[h] = 0; const o = []; for (let h = 0; h <= r; ++h)o[h] = s.slice(0); const a = []; for (let h = 0; h <= n; ++h)a[h] = s.slice(0); a[0][0] = 1; const l = s.slice(0), c = s.slice(0); for (let h = 1; h <= n; ++h) { l[h] = e - i[t + 1 - h], c[h] = i[t + h] - e; let n = 0; for (let t = 0; t < h; ++t) { const e = c[t + 1], r = l[h - t]; a[h][t] = e + r; const i = a[t][h - 1] / a[h][t]; a[t][h] = n + e * i, n = r * i } a[h][h] = n } for (let h = 0; h <= n; ++h)o[0][h] = a[h][n]; for (let h = 0; h <= n; ++h) { let t = 0, e = 1; const i = []; for (let r = 0; r <= n; ++r)i[r] = s.slice(0); i[0][0] = 1; for (let s = 1; s <= r; ++s) { let r = 0; const l = h - s, c = n - s; h >= s && (i[e][0] = i[t][0] / a[c + 1][l], r = i[e][0] * a[l][c]); const u = h - 1 <= c ? s - 1 : n - h; for (let n = l >= -1 ? 1 : -l; n <= u; ++n)i[e][n] = (i[t][n] - i[t][n - 1]) / a[c + 1][l + n], r += i[e][n] * a[l + n][c]; h <= c && (i[e][s] = -i[t][s - 1] / a[c + 1][h], r += i[e][s] * a[h][c]), o[s][h] = r; const d = t; t = e, e = d } } let u = n; for (let h = 1; h <= r; ++h) { for (let t = 0; t <= n; ++t)o[h][t] *= u; u *= n - h } return o } static calcBSplineDerivatives(t, e, n, r, i) { const s = i < t ? i : t, o = [], a = this.findSpan(t, r, e), l = this.calcBasisFunctionDerivatives(a, r, t, s, e), c = []; for (let u = 0; u < n.length; ++u) { const t = n[u].clone(), e = t.w; t.x *= e, t.y *= e, t.z *= e, c[u] = t } for (let u = 0; u <= s; ++u) { const e = c[a - t].clone().multiplyScalar(l[u][0]); for (let n = 1; n <= t; ++n)e.add(c[a - t + n].clone().multiplyScalar(l[u][n])); o[u] = e } for (let u = s + 1; u <= i + 1; ++u)o[u] = new $C(0, 0, 0); return o } static calcKoverI(t, e) { let n = 1; for (let i = 2; i <= t; ++i)n *= i; let r = 1; for (let i = 2; i <= e; ++i)r *= i; for (let i = 2; i <= t - e; ++i)r *= i; return n / r } static calcRationalCurveDerivatives(t) { const e = t.length, n = [], r = []; for (let s = 0; s < e; ++s) { const e = t[s]; n[s] = new rP(e.x, e.y, e.z), r[s] = e.w } const i = []; for (let s = 0; s < e; ++s) { const t = n[s].clone(); for (let e = 1; e <= s; ++e)t.sub(i[s - e].clone().multiplyScalar(this.calcKoverI(s, e) * r[e])); i[s] = t.divideScalar(r[0]) } return i } static calcNURBSDerivatives(t, e, n, r, i) { const s = this.calcBSplineDerivatives(t, e, n, r, i); return this.calcRationalCurveDerivatives(s) } static calcSurfacePoint(t, e, n, r, i, s, o, a) { const l = this.findSpan(t, s, n), c = this.findSpan(e, o, r), u = this.calcBasisFunctions(l, s, t, n), h = this.calcBasisFunctions(c, o, e, r), d = []; for (let f = 0; f <= e; ++f) { d[f] = new $C(0, 0, 0, 0); for (let n = 0; n <= t; ++n) { const r = i[l - t + n][c - e + f].clone(), s = r.w; r.x *= s, r.y *= s, r.z *= s, d[f].add(r.multiplyScalar(u[n])) } } const p = new $C(0, 0, 0, 0); for (let f = 0; f <= e; ++f)p.add(d[f].multiplyScalar(h[f])); p.divideScalar(p.w), a.set(p.x, p.y, p.z) } } class DH extends XO { constructor(t, e, n, r, i) { super(), this.degree = t, this.knots = e, this.controlPoints = [], this.startKnot = r || 0, this.endKnot = i || this.knots.length - 1; for (let s = 0; s < n.length; ++s) { const t = n[s]; this.controlPoints[s] = new $C(t.x, t.y, t.z, t.w) } } getPoint(t, e = new rP) { const n = e, r = kH.calcBSplinePoint(this.degree, this.knots, this.controlPoints, this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot])); return 1 !== r.w && r.divideScalar(r.w), n.set(r.x, r.y, r.z) } getTangent(t, e = new rP) { const n = e, r = kH.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]), 1); return n.copy(r[1]).normalize(), n } } let IH, OH, FH; class NH extends UO { constructor(t) { super(t) } load(t, e, n, r) { const i = this, s = "" === i.path ? kF.extractUrlBase(t) : i.path, o = new VO(this.manager); o.setPath(i.path), o.setResponseType("arraybuffer"), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(t, function (n) { try { e(i.parse(n, s)) } catch (Iz) { r ? r(Iz) : console.error(Iz), i.manager.itemError(t) } }, n, r) } parse(t, e) { if (function (t) { const e = "Kaydara FBX Binary  \0"; return t.byteLength >= e.length && e === tU(t, 0, e.length) }(t)) IH = (new VH).parse(t); else { const e = tU(t); if (!function (t) { const e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"]; let n = 0; function r(e) { const r = t[e - 1]; return t = t.slice(n + e), n++, r } for (let i = 0; i < e.length; ++i)if (r(1) === e[i]) return !1; return !0 }(e)) throw new Error("THREE.FBXLoader: Unknown format."); if (JH(e) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + JH(e)); IH = (new GH).parse(e) } const n = new JO(this.manager).setPath(this.resourcePath || e).setCrossOrigin(this.crossOrigin); return new BH(n, this.manager).parse(IH) } } class BH { constructor(t, e) { this.textureLoader = t, this.manager = e } parse() { OH = this.parseConnections(); const t = this.parseImages(), e = this.parseTextures(t), n = this.parseMaterials(e), r = this.parseDeformers(), i = (new HH).parse(r); return this.parseScene(r, i, n), FH } parseConnections() { const t = new Map; return "Connections" in IH && IH.Connections.connections.forEach(function (e) { const n = e[0], r = e[1], i = e[2]; t.has(n) || t.set(n, { parents: [], children: [] }); const s = { ID: r, relationship: i }; t.get(n).parents.push(s), t.has(r) || t.set(r, { parents: [], children: [] }); const o = { ID: n, relationship: i }; t.get(r).children.push(o) }), t } parseImages() { const t = {}, e = {}; if ("Video" in IH.Objects) { const n = IH.Objects.Video; for (const r in n) { const i = n[r]; if (t[parseInt(r)] = i.RelativeFilename || i.Filename, "Content" in i) { const t = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, s = "string" == typeof i.Content && "" !== i.Content; if (t || s) { const t = this.parseImage(n[r]); e[i.RelativeFilename || i.Filename] = t } } } } for (const n in t) { const r = t[n]; t[n] = void 0 !== e[r] ? e[r] : t[n].split("\\").pop() } return t } parseImage(t) { const e = t.Content, n = t.RelativeFilename || t.Filename, r = n.slice(n.lastIndexOf(".") + 1).toLowerCase(); let i; switch (r) { case "bmp": i = "image/bmp"; break; case "jpg": case "jpeg": i = "image/jpeg"; break; case "png": i = "image/png"; break; case "tif": i = "image/tiff"; break; case "tga": null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n), i = "image/tga"; break; default: return void console.warn('FBXLoader: Image type "' + r + '" is not supported.') }if ("string" == typeof e) return "data:" + i + ";base64," + e; { const t = new Uint8Array(e); return window.URL.createObjectURL(new Blob([t], { type: i })) } } parseTextures(t) { const e = new Map; if ("Texture" in IH.Objects) { const n = IH.Objects.Texture; for (const r in n) { const i = this.parseTexture(n[r], t); e.set(parseInt(r), i) } } return e } parseTexture(t, e) { const n = this.loadTexture(t, e); n.ID = t.id, n.name = t.attrName; const r = t.WrapModeU, i = t.WrapModeV, s = void 0 !== i ? i.value : 0; if (n.wrapS = 0 === (void 0 !== r ? r.value : 0) ? rC : iC, n.wrapT = 0 === s ? rC : iC, "Scaling" in t) { const e = t.Scaling.value; n.repeat.x = e[0], n.repeat.y = e[1] } return n } loadTexture(t, e) { let n; const r = this.textureLoader.path, i = OH.get(t.id).children; let s; void 0 !== i && i.length > 0 && void 0 !== e[i[0].ID] && (n = e[i[0].ID], 0 !== n.indexOf("blob:") && 0 !== n.indexOf("data:") || this.textureLoader.setPath(void 0)); const o = t.FileName.slice(-3).toLowerCase(); if ("tga" === o) { const e = this.manager.getHandler(".tga"); null === e ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", t.RelativeFilename), s = new YC) : (e.setPath(this.textureLoader.path), s = e.load(n)) } else "psd" === o ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", t.RelativeFilename), s = new YC) : s = this.textureLoader.load(n); return this.textureLoader.setPath(r), s } parseMaterials(t) { const e = new Map; if ("Material" in IH.Objects) { const n = IH.Objects.Material; for (const r in n) { const i = this.parseMaterial(n[r], t); null !== i && e.set(parseInt(r), i) } } return e } parseMaterial(t, e) { const n = t.id, r = t.attrName; let i = t.ShadingModel; if ("object" == typeof i && (i = i.value), !OH.has(n)) return null; const s = this.parseParameters(t, e, n); let o; switch (i.toLowerCase()) { case "phong": o = new wO; break; case "lambert": o = new SO; break; default: console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), o = new wO }return o.setValues(s), o.name = r, o } parseParameters(t, e, n) { const r = {}; t.BumpFactor && (r.bumpScale = t.BumpFactor.value), t.Diffuse ? r.color = (new PR).fromArray(t.Diffuse.value) : !t.DiffuseColor || "Color" !== t.DiffuseColor.type && "ColorRGB" !== t.DiffuseColor.type || (r.color = (new PR).fromArray(t.DiffuseColor.value)), t.DisplacementFactor && (r.displacementScale = t.DisplacementFactor.value), t.Emissive ? r.emissive = (new PR).fromArray(t.Emissive.value) : !t.EmissiveColor || "Color" !== t.EmissiveColor.type && "ColorRGB" !== t.EmissiveColor.type || (r.emissive = (new PR).fromArray(t.EmissiveColor.value)), t.EmissiveFactor && (r.emissiveIntensity = parseFloat(t.EmissiveFactor.value)), t.Opacity && (r.opacity = parseFloat(t.Opacity.value)), r.opacity < 1 && (r.transparent = !0), t.ReflectionFactor && (r.reflectivity = t.ReflectionFactor.value), t.Shininess && (r.shininess = t.Shininess.value), t.Specular ? r.specular = (new PR).fromArray(t.Specular.value) : t.SpecularColor && "Color" === t.SpecularColor.type && (r.specular = (new PR).fromArray(t.SpecularColor.value)); const i = this; return OH.get(n).children.forEach(function (t) { const n = t.relationship; switch (n) { case "Bump": r.bumpMap = i.getTexture(e, t.ID); break; case "Maya|TEX_ao_map": r.aoMap = i.getTexture(e, t.ID); break; case "DiffuseColor": case "Maya|TEX_color_map": r.map = i.getTexture(e, t.ID), r.map.encoding = CC; break; case "DisplacementColor": r.displacementMap = i.getTexture(e, t.ID); break; case "EmissiveColor": r.emissiveMap = i.getTexture(e, t.ID), r.emissiveMap.encoding = CC; break; case "NormalMap": case "Maya|TEX_normal_map": r.normalMap = i.getTexture(e, t.ID); break; case "ReflectionColor": r.envMap = i.getTexture(e, t.ID), r.envMap.mapping = 303, r.envMap.encoding = CC; break; case "SpecularColor": r.specularMap = i.getTexture(e, t.ID), r.specularMap.encoding = CC; break; case "TransparentColor": case "TransparencyFactor": r.alphaMap = i.getTexture(e, t.ID), r.transparent = !0; break; case "AmbientColor": case "ShininessExponent": case "SpecularFactor": case "VectorDisplacementColor": default: console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n) } }), r } getTexture(t, e) { return "LayeredTexture" in IH.Objects && e in IH.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), e = OH.get(e).children[0].ID), t.get(e) } parseDeformers() { const t = {}, e = {}; if ("Deformer" in IH.Objects) { const n = IH.Objects.Deformer; for (const r in n) { const i = n[r], s = OH.get(parseInt(r)); if ("Skin" === i.attrType) { const e = this.parseSkeleton(s, n); e.ID = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), e.geometryID = s.parents[0].ID, t[r] = e } else if ("BlendShape" === i.attrType) { const t = { id: r }; t.rawTargets = this.parseMorphTargets(s, n), t.id = r, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), e[r] = t } } } return { skeletons: t, morphTargets: e } } parseSkeleton(t, e) { const n = []; return t.children.forEach(function (t) { const r = e[t.ID]; if ("Cluster" !== r.attrType) return; const i = { ID: t.ID, indices: [], weights: [], transformLink: (new IP).fromArray(r.TransformLink.a) }; "Indexes" in r && (i.indices = r.Indexes.a, i.weights = r.Weights.a), n.push(i) }), { rawBones: n, bones: [] } } parseMorphTargets(t, e) { const n = []; for (let r = 0; r < t.children.length; r++) { const i = t.children[r], s = e[i.ID], o = { name: s.attrName, initialWeight: s.DeformPercent, id: s.id, fullWeights: s.FullWeights.a }; if ("BlendShapeChannel" !== s.attrType) return; o.geoID = OH.get(parseInt(i.ID)).children.filter(function (t) { return void 0 === t.relationship })[0].ID, n.push(o) } return n } parseScene(t, e, n) { FH = new ID; const r = this.parseModels(t.skeletons, e, n), i = IH.Objects.Model, s = this; r.forEach(function (t) { s.setLookAtProperties(t, i[t.ID]), OH.get(t.ID).parents.forEach(function (e) { const n = r.get(e.ID); void 0 !== n && n.add(t) }), null === t.parent && FH.add(t) }), this.bindSkeleton(t.skeletons, e, r), this.createAmbientLight(), this.setupMorphMaterials(), FH.traverse(function (t) { if (t.userData.transformData) { t.parent && (t.userData.transformData.parentMatrix = t.parent.matrix, t.userData.transformData.parentMatrixWorld = t.parent.matrixWorld); const e = YH(t.userData.transformData); t.applyMatrix4(e), t.updateWorldMatrix() } }); const o = (new UH).parse(); 1 === FH.children.length && FH.children[0].isGroup && (FH.children[0].animations = o, FH = FH.children[0]), FH.animations = o } parseModels(t, e, n) { const r = new Map, i = IH.Objects.Model; for (const s in i) { const o = parseInt(s), a = i[s], l = OH.get(o); let c = this.buildSkeleton(l, t, o, a.attrName); if (!c) { switch (a.attrType) { case "Camera": c = this.createCamera(l); break; case "Light": c = this.createLight(l); break; case "Mesh": c = this.createMesh(l, e, n); break; case "NurbsCurve": c = this.createCurve(l, e); break; case "LimbNode": case "Root": c = new pI; break; case "Null": default: c = new ID }c.name = a.attrName ? WF.sanitizeNodeName(a.attrName) : "", c.ID = o } this.getTransformData(c, a), r.set(o, c) } return r } buildSkeleton(t, e, n, r) { let i = null; return t.parents.forEach(function (t) { for (const s in e) { const o = e[s]; o.rawBones.forEach(function (e, s) { if (e.ID === t.ID) { const t = i; i = new pI, i.matrixWorld.copy(e.transformLink), i.name = r ? WF.sanitizeNodeName(r) : "", i.ID = n, o.bones[s] = i, null !== t && i.add(t) } }) } }), i } createCamera(t) { let e, n; if (t.children.forEach(function (t) { const e = IH.Objects.NodeAttribute[t.ID]; void 0 !== e && (n = e) }), void 0 === n) e = new sR; else { let t = 0; void 0 !== n.CameraProjectionType && 1 === n.CameraProjectionType.value && (t = 1); let r = 1; void 0 !== n.NearPlane && (r = n.NearPlane.value / 1e3); let i = 1e3; void 0 !== n.FarPlane && (i = n.FarPlane.value / 1e3); let s = window.innerWidth, o = window.innerHeight; void 0 !== n.AspectWidth && void 0 !== n.AspectHeight && (s = n.AspectWidth.value, o = n.AspectHeight.value); const a = s / o; let l = 45; void 0 !== n.FieldOfView && (l = n.FieldOfView.value); const c = n.FocalLength ? n.FocalLength.value : null; switch (t) { case 0: e = new vL(l, a, r, i), null !== c && e.setFocalLength(c); break; case 1: e = new MF(-s / 2, s / 2, o / 2, -o / 2, r, i); break; default: console.warn("THREE.FBXLoader: Unknown camera type " + t + "."), e = new sR } } return e } createLight(t) { let e, n; if (t.children.forEach(function (t) { const e = IH.Objects.NodeAttribute[t.ID]; void 0 !== e && (n = e) }), void 0 === n) e = new sR; else { let t; t = void 0 === n.LightType ? 0 : n.LightType.value; let r = 16777215; void 0 !== n.Color && (r = (new PR).fromArray(n.Color.value)); let i = void 0 === n.Intensity ? 1 : n.Intensity.value / 100; void 0 !== n.CastLightOnObject && 0 === n.CastLightOnObject.value && (i = 0); let s = 0; void 0 !== n.FarAttenuationEnd && (s = void 0 !== n.EnableFarAttenuation && 0 === n.EnableFarAttenuation.value ? 0 : n.FarAttenuationEnd.value); const o = 1; switch (t) { case 0: e = new EF(r, i, s, o); break; case 1: e = new CF(r, i); break; case 2: let t = Math.PI / 3; void 0 !== n.InnerAngle && (t = JC.degToRad(n.InnerAngle.value)); let a = 0; void 0 !== n.OuterAngle && (a = JC.degToRad(n.OuterAngle.value), a = Math.max(a, 1)), e = new _F(r, i, s, t, a, o); break; default: console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), e = new EF(r, i) }void 0 !== n.CastShadows && 1 === n.CastShadows.value && (e.castShadow = !0) } return e } createMesh(t, e, n) { let r, i = null, s = null; const o = []; return t.children.forEach(function (t) { e.has(t.ID) && (i = e.get(t.ID)), n.has(t.ID) && o.push(n.get(t.ID)) }), o.length > 1 ? s = o : o.length > 0 ? s = o[0] : (s = new wO({ color: 13421772 }), o.push(s)), "color" in i.attributes && o.forEach(function (t) { t.vertexColors = !0 }), i.FBX_Deformer ? (r = new dI(i, s), r.normalizeSkinWeights()) : r = new cL(i, s), r } createCurve(t, e) { const n = t.children.reduce(function (t, n) { return e.has(n.ID) && (t = e.get(n.ID)), t }, null), r = new SI({ color: 3342591, linewidth: 1 }); return new CI(n, r) } getTransformData(t, e) { const n = {}; "InheritType" in e && (n.inheritType = parseInt(e.InheritType.value)), n.eulerOrder = "RotationOrder" in e ? QH(e.RotationOrder.value) : "ZYX", "Lcl_Translation" in e && (n.translation = e.Lcl_Translation.value), "PreRotation" in e && (n.preRotation = e.PreRotation.value), "Lcl_Rotation" in e && (n.rotation = e.Lcl_Rotation.value), "PostRotation" in e && (n.postRotation = e.PostRotation.value), "Lcl_Scaling" in e && (n.scale = e.Lcl_Scaling.value), "ScalingOffset" in e && (n.scalingOffset = e.ScalingOffset.value), "ScalingPivot" in e && (n.scalingPivot = e.ScalingPivot.value), "RotationOffset" in e && (n.rotationOffset = e.RotationOffset.value), "RotationPivot" in e && (n.rotationPivot = e.RotationPivot.value), t.userData.transformData = n } setLookAtProperties(t, e) { "LookAtProperty" in e && OH.get(t.ID).children.forEach(function (e) { if ("LookAtProperty" === e.relationship) { const n = IH.Objects.Model[e.ID]; if ("Lcl_Translation" in n) { const e = n.Lcl_Translation.value; void 0 !== t.target ? (t.target.position.fromArray(e), FH.add(t.target)) : t.lookAt((new rP).fromArray(e)) } } }) } bindSkeleton(t, e, n) { const r = this.parsePoseNodes(); for (const i in t) { const s = t[i]; OH.get(parseInt(s.ID)).parents.forEach(function (t) { e.has(t.ID) && OH.get(t.ID).parents.forEach(function (t) { n.has(t.ID) && n.get(t.ID).bind(new vI(s.bones), r[t.ID]) }) }) } } parsePoseNodes() { const t = {}; if ("Pose" in IH.Objects) { const e = IH.Objects.Pose; for (const n in e) if ("BindPose" === e[n].attrType) { const r = e[n].PoseNode; Array.isArray(r) ? r.forEach(function (e) { t[e.Node] = (new IP).fromArray(e.Matrix.a) }) : t[r.Node] = (new IP).fromArray(r.Matrix.a) } } return t } createAmbientLight() { if ("GlobalSettings" in IH && "AmbientColor" in IH.GlobalSettings) { const t = IH.GlobalSettings.AmbientColor.value, e = t[0], n = t[1], r = t[2]; if (0 !== e || 0 !== n || 0 !== r) { const t = new PR(e, n, r); FH.add(new PF(t, 1)) } } } setupMorphMaterials() { const t = this; FH.traverse(function (e) { e.isMesh && e.geometry.morphAttributes.position && e.geometry.morphAttributes.position.length && (Array.isArray(e.material) ? e.material.forEach(function (n, r) { t.setupMorphMaterial(e, n, r) }) : t.setupMorphMaterial(e, e.material)) }) } setupMorphMaterial(t, e, n) { const r = t.uuid, i = e.uuid; let s = !1; if (FH.traverse(function (t) { t.isMesh && (Array.isArray(t.material) ? t.material.forEach(function (e) { e.uuid === i && t.uuid !== r && (s = !0) }) : t.material.uuid === i && t.uuid !== r && (s = !0)) }), !0 === s) { const r = e.clone(); r.morphTargets = !0, void 0 === n ? t.material = r : t.material[n] = r } else e.morphTargets = !0 } } class HH { parse(t) { const e = new Map; if ("Geometry" in IH.Objects) { const n = IH.Objects.Geometry; for (const r in n) { const i = OH.get(parseInt(r)), s = this.parseGeometry(i, n[r], t); e.set(parseInt(r), s) } } return e } parseGeometry(t, e, n) { switch (e.attrType) { case "Mesh": return this.parseMeshGeometry(t, e, n); case "NurbsCurve": return this.parseNurbsGeometry(e) } } parseMeshGeometry(t, e, n) { const r = n.skeletons, i = [], s = t.parents.map(function (t) { return IH.Objects.Model[t.ID] }); if (0 === s.length) return; const o = t.children.reduce(function (t, e) { return void 0 !== r[e.ID] && (t = r[e.ID]), t }, null); t.children.forEach(function (t) { void 0 !== n.morphTargets[t.ID] && i.push(n.morphTargets[t.ID]) }); const a = s[0], l = {}; "RotationOrder" in a && (l.eulerOrder = QH(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value); const c = YH(l); return this.genGeometry(e, o, i, c) } genGeometry(t, e, n, r) { const i = new JR; t.attrName && (i.name = t.attrName); const s = this.parseGeoNode(t, e), o = this.genBuffers(s), a = new FR(o.vertex, 3); if (a.applyMatrix4(r), i.setAttribute("position", a), o.colors.length > 0 && i.setAttribute("color", new FR(o.colors, 3)), e && (i.setAttribute("skinIndex", new IR(o.weightsIndices, 4)), i.setAttribute("skinWeight", new FR(o.vertexWeights, 4)), i.FBX_Deformer = e), o.normal.length > 0) { const t = (new WC).getNormalMatrix(r), e = new FR(o.normal, 3); e.applyNormalMatrix(t), i.setAttribute("normal", e) } if (o.uvs.forEach(function (t, e) { let n = "uv" + (e + 1).toString(); 0 === e && (n = "uv"), i.setAttribute(n, new FR(o.uvs[e], 2)) }), s.material && "AllSame" !== s.material.mappingType) { let t = o.materialIndex[0], e = 0; if (o.materialIndex.forEach(function (n, r) { n !== t && (i.addGroup(e, r - e, t), t = n, e = r) }), i.groups.length > 0) { const e = i.groups[i.groups.length - 1], n = e.start + e.count; n !== o.materialIndex.length && i.addGroup(n, o.materialIndex.length - n, t) } 0 === i.groups.length && i.addGroup(0, o.materialIndex.length, o.materialIndex[0]) } return this.addMorphTargets(i, t, n, r), i } parseGeoNode(t, e) { const n = {}; if (n.vertexPositions = void 0 !== t.Vertices ? t.Vertices.a : [], n.vertexIndices = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], t.LayerElementColor && (n.color = this.parseVertexColors(t.LayerElementColor[0])), t.LayerElementMaterial && (n.material = this.parseMaterialIndices(t.LayerElementMaterial[0])), t.LayerElementNormal && (n.normal = this.parseNormals(t.LayerElementNormal[0])), t.LayerElementUV) { n.uv = []; let e = 0; for (; t.LayerElementUV[e];)t.LayerElementUV[e].UV && n.uv.push(this.parseUVs(t.LayerElementUV[e])), e++ } return n.weightTable = {}, null !== e && (n.skeleton = e, e.rawBones.forEach(function (t, e) { t.indices.forEach(function (r, i) { void 0 === n.weightTable[r] && (n.weightTable[r] = []), n.weightTable[r].push({ id: e, weight: t.weights[i] }) }) })), n } genBuffers(t) { const e = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] }; let n = 0, r = 0, i = !1, s = [], o = [], a = [], l = [], c = [], u = []; const h = this; return t.vertexIndices.forEach(function (d, p) { let f, m = !1; d < 0 && (d ^= -1, m = !0); let g = [], v = []; if (s.push(3 * d, 3 * d + 1, 3 * d + 2), t.color) { const e = qH(p, n, d, t.color); a.push(e[0], e[1], e[2]) } if (t.skeleton) { if (void 0 !== t.weightTable[d] && t.weightTable[d].forEach(function (t) { v.push(t.weight), g.push(t.id) }), v.length > 4) { i || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), i = !0); const t = [0, 0, 0, 0], e = [0, 0, 0, 0]; v.forEach(function (n, r) { let i = n, s = g[r]; e.forEach(function (e, n, r) { if (i > e) { r[n] = i, i = e; const o = t[n]; t[n] = s, s = o } }) }), g = t, v = e } for (; v.length < 4;)v.push(0), g.push(0); for (let t = 0; t < 4; ++t)c.push(v[t]), u.push(g[t]) } if (t.normal) { const e = qH(p, n, d, t.normal); o.push(e[0], e[1], e[2]) } t.material && "AllSame" !== t.material.mappingType && (f = qH(p, n, d, t.material)[0]), t.uv && t.uv.forEach(function (t, e) { const r = qH(p, n, d, t); void 0 === l[e] && (l[e] = []), l[e].push(r[0]), l[e].push(r[1]) }), r++, m && (h.genFace(e, t, s, f, o, a, l, c, u, r), n++, r = 0, s = [], o = [], a = [], l = [], c = [], u = []) }), e } genFace(t, e, n, r, i, s, o, a, l, c) { for (let u = 2; u < c; u++)t.vertex.push(e.vertexPositions[n[0]]), t.vertex.push(e.vertexPositions[n[1]]), t.vertex.push(e.vertexPositions[n[2]]), t.vertex.push(e.vertexPositions[n[3 * (u - 1)]]), t.vertex.push(e.vertexPositions[n[3 * (u - 1) + 1]]), t.vertex.push(e.vertexPositions[n[3 * (u - 1) + 2]]), t.vertex.push(e.vertexPositions[n[3 * u]]), t.vertex.push(e.vertexPositions[n[3 * u + 1]]), t.vertex.push(e.vertexPositions[n[3 * u + 2]]), e.skeleton && (t.vertexWeights.push(a[0]), t.vertexWeights.push(a[1]), t.vertexWeights.push(a[2]), t.vertexWeights.push(a[3]), t.vertexWeights.push(a[4 * (u - 1)]), t.vertexWeights.push(a[4 * (u - 1) + 1]), t.vertexWeights.push(a[4 * (u - 1) + 2]), t.vertexWeights.push(a[4 * (u - 1) + 3]), t.vertexWeights.push(a[4 * u]), t.vertexWeights.push(a[4 * u + 1]), t.vertexWeights.push(a[4 * u + 2]), t.vertexWeights.push(a[4 * u + 3]), t.weightsIndices.push(l[0]), t.weightsIndices.push(l[1]), t.weightsIndices.push(l[2]), t.weightsIndices.push(l[3]), t.weightsIndices.push(l[4 * (u - 1)]), t.weightsIndices.push(l[4 * (u - 1) + 1]), t.weightsIndices.push(l[4 * (u - 1) + 2]), t.weightsIndices.push(l[4 * (u - 1) + 3]), t.weightsIndices.push(l[4 * u]), t.weightsIndices.push(l[4 * u + 1]), t.weightsIndices.push(l[4 * u + 2]), t.weightsIndices.push(l[4 * u + 3])), e.color && (t.colors.push(s[0]), t.colors.push(s[1]), t.colors.push(s[2]), t.colors.push(s[3 * (u - 1)]), t.colors.push(s[3 * (u - 1) + 1]), t.colors.push(s[3 * (u - 1) + 2]), t.colors.push(s[3 * u]), t.colors.push(s[3 * u + 1]), t.colors.push(s[3 * u + 2])), e.material && "AllSame" !== e.material.mappingType && (t.materialIndex.push(r), t.materialIndex.push(r), t.materialIndex.push(r)), e.normal && (t.normal.push(i[0]), t.normal.push(i[1]), t.normal.push(i[2]), t.normal.push(i[3 * (u - 1)]), t.normal.push(i[3 * (u - 1) + 1]), t.normal.push(i[3 * (u - 1) + 2]), t.normal.push(i[3 * u]), t.normal.push(i[3 * u + 1]), t.normal.push(i[3 * u + 2])), e.uv && e.uv.forEach(function (e, n) { void 0 === t.uvs[n] && (t.uvs[n] = []), t.uvs[n].push(o[n][0]), t.uvs[n].push(o[n][1]), t.uvs[n].push(o[n][2 * (u - 1)]), t.uvs[n].push(o[n][2 * (u - 1) + 1]), t.uvs[n].push(o[n][2 * u]), t.uvs[n].push(o[n][2 * u + 1]) }) } addMorphTargets(t, e, n, r) { if (0 === n.length) return; t.morphTargetsRelative = !0, t.morphAttributes.position = []; const i = this; n.forEach(function (n) { n.rawTargets.forEach(function (n) { const s = IH.Objects.Geometry[n.geoID]; void 0 !== s && i.genMorphGeometry(t, e, s, r, n.name) }) }) } genMorphGeometry(t, e, n, r, i) { const s = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], o = void 0 !== n.Vertices ? n.Vertices.a : [], a = void 0 !== n.Indexes ? n.Indexes.a : [], l = new Float32Array(3 * t.attributes.position.count); for (let h = 0; h < a.length; h++) { const t = 3 * a[h]; l[t] = o[3 * h], l[t + 1] = o[3 * h + 1], l[t + 2] = o[3 * h + 2] } const c = this.genBuffers({ vertexIndices: s, vertexPositions: l }), u = new FR(c.vertex, 3); u.name = i || n.attrName, u.applyMatrix4(r), t.morphAttributes.position.push(u) } parseNormals(t) { const e = t.ReferenceInformationType; let n = []; return "IndexToDirect" === e && ("NormalIndex" in t ? n = t.NormalIndex.a : "NormalsIndex" in t && (n = t.NormalsIndex.a)), { dataSize: 3, buffer: t.Normals.a, indices: n, mappingType: t.MappingInformationType, referenceType: e } } parseUVs(t) { const e = t.ReferenceInformationType; let n = []; return "IndexToDirect" === e && (n = t.UVIndex.a), { dataSize: 2, buffer: t.UV.a, indices: n, mappingType: t.MappingInformationType, referenceType: e } } parseVertexColors(t) { const e = t.ReferenceInformationType; let n = []; return "IndexToDirect" === e && (n = t.ColorIndex.a), { dataSize: 4, buffer: t.Colors.a, indices: n, mappingType: t.MappingInformationType, referenceType: e } } parseMaterialIndices(t) { const e = t.MappingInformationType, n = t.ReferenceInformationType; if ("NoMappingInformation" === e) return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: n }; const r = t.Materials.a, i = []; for (let s = 0; s < r.length; ++s)i.push(s); return { dataSize: 1, buffer: r, indices: i, mappingType: e, referenceType: n } } parseNurbsGeometry(t) { if (void 0 === DH) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new JR; const e = parseInt(t.Order); if (isNaN(e)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", t.Order, t.id), new JR; const n = e - 1, r = t.KnotVector.a, i = [], s = t.Points.a; for (let h = 0, d = s.length; h < d; h += 4)i.push((new $C).fromArray(s, h)); let o, a; if ("Closed" === t.Form) i.push(i[0]); else if ("Periodic" === t.Form) { o = n, a = r.length - 1 - o; for (let t = 0; t < n; ++t)i.push(i[t]) } const l = new DH(n, r, i, o, a).getPoints(7 * i.length), c = new Float32Array(3 * l.length); l.forEach(function (t, e) { t.toArray(c, 3 * e) }); const u = new JR; return u.setAttribute("position", new DR(c, 3)), u } } class UH { parse() { const t = [], e = this.parseClips(); if (void 0 !== e) for (const n in e) { const r = this.addClip(e[n]); t.push(r) } return t } parseClips() { if (void 0 === IH.Objects.AnimationCurve) return; const t = this.parseAnimationCurveNodes(); this.parseAnimationCurves(t); const e = this.parseAnimationLayers(t); return this.parseAnimStacks(e) } parseAnimationCurveNodes() { const t = IH.Objects.AnimationCurveNode, e = new Map; for (const n in t) { const r = t[n]; if (null !== r.attrName.match(/S|R|T|DeformPercent/)) { const t = { id: r.id, attr: r.attrName, curves: {} }; e.set(t.id, t) } } return e } parseAnimationCurves(t) { const e = IH.Objects.AnimationCurve; for (const n in e) { const r = { id: e[n].id, times: e[n].KeyTime.a.map(XH), values: e[n].KeyValueFloat.a }, i = OH.get(r.id); if (void 0 !== i) { const e = i.parents[0].ID, n = i.parents[0].relationship; n.match(/X/) ? t.get(e).curves.x = r : n.match(/Y/) ? t.get(e).curves.y = r : n.match(/Z/) ? t.get(e).curves.z = r : n.match(/d|DeformPercent/) && t.has(e) && (t.get(e).curves.morph = r) } } } parseAnimationLayers(t) { const e = IH.Objects.AnimationLayer, n = new Map; for (const r in e) { const e = [], i = OH.get(parseInt(r)); void 0 !== i && (i.children.forEach(function (n, r) { if (t.has(n.ID)) { const i = t.get(n.ID); if (void 0 !== i.curves.x || void 0 !== i.curves.y || void 0 !== i.curves.z) { if (void 0 === e[r]) { const t = OH.get(n.ID).parents.filter(function (t) { return void 0 !== t.relationship })[0].ID; if (void 0 !== t) { const i = IH.Objects.Model[t.toString()]; if (void 0 === i) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", n); const s = { modelName: i.attrName ? WF.sanitizeNodeName(i.attrName) : "", ID: i.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] }; FH.traverse(function (t) { t.ID === i.id && (s.transform = t.matrix, t.userData.transformData && (s.eulerOrder = t.userData.transformData.eulerOrder)) }), s.transform || (s.transform = new IP), "PreRotation" in i && (s.preRotation = i.PreRotation.value), "PostRotation" in i && (s.postRotation = i.PostRotation.value), e[r] = s } } e[r] && (e[r][i.attr] = i) } else if (void 0 !== i.curves.morph) { if (void 0 === e[r]) { const t = OH.get(n.ID).parents.filter(function (t) { return void 0 !== t.relationship })[0].ID, i = OH.get(t).parents[0].ID, s = OH.get(i).parents[0].ID, o = OH.get(s).parents[0].ID, a = IH.Objects.Model[o], l = { modelName: a.attrName ? WF.sanitizeNodeName(a.attrName) : "", morphName: IH.Objects.Deformer[t].attrName }; e[r] = l } e[r][i.attr] = i } } }), n.set(parseInt(r), e)) } return n } parseAnimStacks(t) { const e = IH.Objects.AnimationStack, n = {}; for (const r in e) { const i = OH.get(parseInt(r)).children; i.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."); const s = t.get(i[0].ID); n[r] = { name: e[r].attrName, layer: s } } return n } addClip(t) { let e = []; const n = this; return t.layer.forEach(function (t) { e = e.concat(n.generateTracks(t)) }), new FO(t.name, -1, e) } generateTracks(t) { const e = []; let n = new rP, r = new nP, i = new rP; if (t.transform && t.transform.decompose(n, r, i), n = n.toArray(), r = (new jP).setFromQuaternion(r, t.eulerOrder).toArray(), i = i.toArray(), void 0 !== t.T && Object.keys(t.T.curves).length > 0) { const r = this.generateVectorTrack(t.modelName, t.T.curves, n, "position"); void 0 !== r && e.push(r) } if (void 0 !== t.R && Object.keys(t.R.curves).length > 0) { const n = this.generateRotationTrack(t.modelName, t.R.curves, r, t.preRotation, t.postRotation, t.eulerOrder); void 0 !== n && e.push(n) } if (void 0 !== t.S && Object.keys(t.S.curves).length > 0) { const n = this.generateVectorTrack(t.modelName, t.S.curves, i, "scale"); void 0 !== n && e.push(n) } if (void 0 !== t.DeformPercent) { const n = this.generateMorphTrack(t); void 0 !== n && e.push(n) } return e } generateVectorTrack(t, e, n, r) { const i = this.getTimesForAllAxes(e), s = this.getKeyframeTrackValues(i, e, n); return new OO(t + "." + r, i, s) } generateRotationTrack(t, e, n, r, i, s) { void 0 !== e.x && (this.interpolateRotations(e.x), e.x.values = e.x.values.map(JC.degToRad)), void 0 !== e.y && (this.interpolateRotations(e.y), e.y.values = e.y.values.map(JC.degToRad)), void 0 !== e.z && (this.interpolateRotations(e.z), e.z.values = e.z.values.map(JC.degToRad)); const o = this.getTimesForAllAxes(e), a = this.getKeyframeTrackValues(o, e, n); void 0 !== r && ((r = r.map(JC.degToRad)).push(s), r = (new jP).fromArray(r), r = (new nP).setFromEuler(r)), void 0 !== i && ((i = i.map(JC.degToRad)).push(s), i = (new jP).fromArray(i), i = (new nP).setFromEuler(i).invert()); const l = new nP, c = new jP, u = []; for (let h = 0; h < a.length; h += 3)c.set(a[h], a[h + 1], a[h + 2], s), l.setFromEuler(c), void 0 !== r && l.premultiply(r), void 0 !== i && l.multiply(i), l.toArray(u, h / 3 * 4); return new DO(t + ".quaternion", o, u) } generateMorphTrack(t) { const e = t.DeformPercent.curves.morph, n = e.values.map(function (t) { return t / 100 }), r = FH.getObjectByName(t.modelName).morphTargetDictionary[t.morphName]; return new LO(t.modelName + ".morphTargetInfluences[" + r + "]", e.times, n) } getTimesForAllAxes(t) { let e = []; if (void 0 !== t.x && (e = e.concat(t.x.times)), void 0 !== t.y && (e = e.concat(t.y.times)), void 0 !== t.z && (e = e.concat(t.z.times)), e = e.sort(function (t, e) { return t - e }), e.length > 1) { let t = 1, n = e[0]; for (let r = 1; r < e.length; r++) { const i = e[r]; i !== n && (e[t] = i, n = i, t++) } e = e.slice(0, t) } return e } getKeyframeTrackValues(t, e, n) { const r = n, i = []; let s = -1, o = -1, a = -1; return t.forEach(function (t) { if (e.x && (s = e.x.times.indexOf(t)), e.y && (o = e.y.times.indexOf(t)), e.z && (a = e.z.times.indexOf(t)), -1 !== s) { const t = e.x.values[s]; i.push(t), r[0] = t } else i.push(r[0]); if (-1 !== o) { const t = e.y.values[o]; i.push(t), r[1] = t } else i.push(r[1]); if (-1 !== a) { const t = e.z.values[a]; i.push(t), r[2] = t } else i.push(r[2]) }), i } interpolateRotations(t) { for (let e = 1; e < t.values.length; e++) { const n = t.values[e - 1], r = t.values[e] - n, i = Math.abs(r); if (i >= 180) { const s = i / 180, o = r / s; let a = n + o; const l = t.times[e - 1], c = (t.times[e] - l) / s; let u = l + c; const h = [], d = []; for (; u < t.times[e];)h.push(u), u += c, d.push(a), a += o; t.times = eU(t.times, e, h), t.values = eU(t.values, e, d) } } } } class GH { getPrevNode() { return this.nodeStack[this.currentIndent - 2] } getCurrentNode() { return this.nodeStack[this.currentIndent - 1] } getCurrentProp() { return this.currentProp } pushStack(t) { this.nodeStack.push(t), this.currentIndent += 1 } popStack() { this.nodeStack.pop(), this.currentIndent -= 1 } setCurrentProp(t, e) { this.currentProp = t, this.currentPropName = e } parse(t) { this.currentIndent = 0, this.allNodes = new jH, this.nodeStack = [], this.currentProp = [], this.currentPropName = ""; const e = this, n = t.split(/[\r\n]+/); return n.forEach(function (t, r) { const i = t.match(/^[\s\t]*;/), s = t.match(/^[\s\t]*$/); if (i || s) return; const o = t.match("^\\t{" + e.currentIndent + "}(\\w+):(.*){", ""), a = t.match("^\\t{" + e.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), l = t.match("^\\t{" + (e.currentIndent - 1) + "}}"); o ? e.parseNodeBegin(t, o) : a ? e.parseNodeProperty(t, a, n[++r]) : l ? e.popStack() : t.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(t) }), this.allNodes } parseNodeBegin(t, e) { const n = e[1].trim().replace(/^"/, "").replace(/"$/, ""), r = e[2].split(",").map(function (t) { return t.trim().replace(/^"/, "").replace(/"$/, "") }), i = { name: n }, s = this.parseNodeAttr(r), o = this.getCurrentNode(); 0 === this.currentIndent ? this.allNodes.add(n, i) : n in o ? ("PoseNode" === n ? o.PoseNode.push(i) : void 0 !== o[n].id && (o[n] = {}, o[n][o[n].id] = o[n]), "" !== s.id && (o[n][s.id] = i)) : "number" == typeof s.id ? (o[n] = {}, o[n][s.id] = i) : "Properties70" !== n && (o[n] = "PoseNode" === n ? [i] : i), "number" == typeof s.id && (i.id = s.id), "" !== s.name && (i.attrName = s.name), "" !== s.type && (i.attrType = s.type), this.pushStack(i) } parseNodeAttr(t) { let e = t[0]; "" !== t[0] && (e = parseInt(t[0]), isNaN(e) && (e = t[0])); let n = "", r = ""; return t.length > 1 && (n = t[1].replace(/^(\w+)::/, ""), r = t[2]), { id: e, name: n, type: r } } parseNodeProperty(t, e, n) { let r = e[1].replace(/^"/, "").replace(/"$/, "").trim(), i = e[2].replace(/^"/, "").replace(/"$/, "").trim(); "Content" === r && "," === i && (i = n.replace(/"/g, "").replace(/,$/, "").trim()); const s = this.getCurrentNode(); if ("Properties70" !== s.name) { if ("C" === r) { const t = i.split(",").slice(1), e = parseInt(t[0]), n = parseInt(t[1]); let o = i.split(",").slice(3); o = o.map(function (t) { return t.trim().replace(/^"/, "") }), r = "connections", i = [e, n], function (t, e) { for (let n = 0, r = t.length, i = e.length; n < i; n++, r++)t[r] = e[n] }(i, o), void 0 === s[r] && (s[r] = []) } "Node" === r && (s.id = i), r in s && Array.isArray(s[r]) ? s[r].push(i) : "a" !== r ? s[r] = i : s.a = i, this.setCurrentProp(s, r), "a" === r && "," !== i.slice(-1) && (s.a = $H(i)) } else this.parseNodeSpecialProperty(t, r, i) } parseNodePropertyContinued(t) { const e = this.getCurrentNode(); e.a += t, "," !== t.slice(-1) && (e.a = $H(e.a)) } parseNodeSpecialProperty(t, e, n) { const r = n.split('",').map(function (t) { return t.trim().replace(/^\"/, "").replace(/\s/, "_") }), i = r[0], s = r[1], o = r[2], a = r[3]; let l = r[4]; switch (s) { case "int": case "enum": case "bool": case "ULongLong": case "double": case "Number": case "FieldOfView": l = parseFloat(l); break; case "Color": case "ColorRGB": case "Vector3D": case "Lcl_Translation": case "Lcl_Rotation": case "Lcl_Scaling": l = $H(l) }this.getPrevNode()[i] = { type: s, type2: o, flag: a, value: l }, this.setCurrentProp(this.getPrevNode(), i) } } class VH { parse(t) { const e = new zH(t); e.skip(23); const n = e.getUint32(); if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n); const r = new jH; for (; !this.endOfContent(e);) { const t = this.parseNode(e, n); null !== t && r.add(t.name, t) } return r } endOfContent(t) { return t.size() % 16 == 0 ? (t.getOffset() + 160 + 16 & -16) >= t.size() : t.getOffset() + 160 + 16 >= t.size() } parseNode(t, e) { const n = {}, r = e >= 7500 ? t.getUint64() : t.getUint32(), i = e >= 7500 ? t.getUint64() : t.getUint32(); e >= 7500 ? t.getUint64() : t.getUint32(); const s = t.getUint8(), o = t.getString(s); if (0 === r) return null; const a = []; for (let h = 0; h < i; h++)a.push(this.parseProperty(t)); const l = a.length > 0 ? a[0] : "", c = a.length > 1 ? a[1] : "", u = a.length > 2 ? a[2] : ""; for (n.singleProperty = 1 === i && t.getOffset() === r; r > t.getOffset();) { const r = this.parseNode(t, e); null !== r && this.parseSubNode(o, n, r) } return n.propertyList = a, "number" == typeof l && (n.id = l), "" !== c && (n.attrName = c), "" !== u && (n.attrType = u), "" !== o && (n.name = o), n } parseSubNode(t, e, n) { if (!0 === n.singleProperty) { const t = n.propertyList[0]; Array.isArray(t) ? (e[n.name] = n, n.a = t) : e[n.name] = t } else if ("Connections" === t && "C" === n.name) { const t = []; n.propertyList.forEach(function (e, n) { 0 !== n && t.push(e) }), void 0 === e.connections && (e.connections = []), e.connections.push(t) } else if ("Properties70" === n.name) Object.keys(n).forEach(function (t) { e[t] = n[t] }); else if ("Properties70" === t && "P" === n.name) { let t = n.propertyList[0], r = n.propertyList[1]; const i = n.propertyList[2], s = n.propertyList[3]; let o; 0 === t.indexOf("Lcl ") && (t = t.replace("Lcl ", "Lcl_")), 0 === r.indexOf("Lcl ") && (r = r.replace("Lcl ", "Lcl_")), o = "Color" === r || "ColorRGB" === r || "Vector" === r || "Vector3D" === r || 0 === r.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], e[t] = { type: r, type2: i, flag: s, value: o } } else void 0 === e[n.name] ? "number" == typeof n.id ? (e[n.name] = {}, e[n.name][n.id] = n) : e[n.name] = n : "PoseNode" === n.name ? (Array.isArray(e[n.name]) || (e[n.name] = [e[n.name]]), e[n.name].push(n)) : void 0 === e[n.name][n.id] && (e[n.name][n.id] = n) } parseProperty(t) { const e = t.getString(1); let n; switch (e) { case "C": return t.getBoolean(); case "D": return t.getFloat64(); case "F": return t.getFloat32(); case "I": return t.getInt32(); case "L": return t.getInt64(); case "R": return n = t.getUint32(), t.getArrayBuffer(n); case "S": return n = t.getUint32(), t.getString(n); case "Y": return t.getInt16(); case "b": case "c": case "d": case "f": case "i": case "l": const i = t.getUint32(), s = t.getUint32(), o = t.getUint32(); if (0 === s) switch (e) { case "b": case "c": return t.getBooleanArray(i); case "d": return t.getFloat64Array(i); case "f": return t.getFloat32Array(i); case "i": return t.getInt32Array(i); case "l": return t.getInt64Array(i) }void 0 === r && console.error("THREE.FBXLoader: External library fflate.min.js required."); const a = $B(new Uint8Array(t.getArrayBuffer(o))), l = new zH(a.buffer); switch (e) { case "b": case "c": return l.getBooleanArray(i); case "d": return l.getFloat64Array(i); case "f": return l.getFloat32Array(i); case "i": return l.getInt32Array(i); case "l": return l.getInt64Array(i) }default: throw new Error("THREE.FBXLoader: Unknown property type " + e) } } } class zH { constructor(t, e) { this.dv = new DataView(t), this.offset = 0, this.littleEndian = void 0 === e || e } getOffset() { return this.offset } size() { return this.dv.buffer.byteLength } skip(t) { this.offset += t } getBoolean() { return 1 == (1 & this.getUint8()) } getBooleanArray(t) { const e = []; for (let n = 0; n < t; n++)e.push(this.getBoolean()); return e } getUint8() { const t = this.dv.getUint8(this.offset); return this.offset += 1, t } getInt16() { const t = this.dv.getInt16(this.offset, this.littleEndian); return this.offset += 2, t } getInt32() { const t = this.dv.getInt32(this.offset, this.littleEndian); return this.offset += 4, t } getInt32Array(t) { const e = []; for (let n = 0; n < t; n++)e.push(this.getInt32()); return e } getUint32() { const t = this.dv.getUint32(this.offset, this.littleEndian); return this.offset += 4, t } getInt64() { let t, e; return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 2147483648 & e ? (e = 4294967295 & ~e, t = 4294967295 & ~t, 4294967295 === t && (e = e + 1 & 4294967295), t = t + 1 & 4294967295, -(4294967296 * e + t)) : 4294967296 * e + t } getInt64Array(t) { const e = []; for (let n = 0; n < t; n++)e.push(this.getInt64()); return e } getUint64() { let t, e; return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 4294967296 * e + t } getFloat32() { const t = this.dv.getFloat32(this.offset, this.littleEndian); return this.offset += 4, t } getFloat32Array(t) { const e = []; for (let n = 0; n < t; n++)e.push(this.getFloat32()); return e } getFloat64() { const t = this.dv.getFloat64(this.offset, this.littleEndian); return this.offset += 8, t } getFloat64Array(t) { const e = []; for (let n = 0; n < t; n++)e.push(this.getFloat64()); return e } getArrayBuffer(t) { const e = this.dv.buffer.slice(this.offset, this.offset + t); return this.offset += t, e } getString(t) { let e = []; for (let r = 0; r < t; r++)e[r] = this.getUint8(); const n = e.indexOf(0); return n >= 0 && (e = e.slice(0, n)), kF.decodeText(new Uint8Array(e)) } } class jH { add(t, e) { this[t] = e } } function JH(t) { const e = t.match(/FBXVersion: (\d+)/); if (e) return parseInt(e[1]); throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.") } function XH(t) { return t / 46186158e3 } const WH = []; function qH(t, e, n, r) { let i; switch (r.mappingType) { case "ByPolygonVertex": i = t; break; case "ByPolygon": i = e; break; case "ByVertice": i = n; break; case "AllSame": i = r.indices[0]; break; default: console.warn("THREE.FBXLoader: unknown attribute mapping type " + r.mappingType) }"IndexToDirect" === r.referenceType && (i = r.indices[i]); const s = i * r.dataSize; return function (t, e, n, r) { for (let i = n, s = 0; i < r; i++, s++)t[s] = e[i]; return t }(WH, r.buffer, s, s + r.dataSize) } const ZH = new jP, KH = new rP; function YH(t) { const e = new IP, n = new IP, r = new IP, i = new IP, s = new IP, o = new IP, a = new IP, l = new IP, c = new IP, u = new IP, h = new IP, d = new IP, p = t.inheritType ? t.inheritType : 0; if (t.translation && e.setPosition(KH.fromArray(t.translation)), t.preRotation) { const e = t.preRotation.map(JC.degToRad); e.push(t.eulerOrder), n.makeRotationFromEuler(ZH.fromArray(e)) } if (t.rotation) { const e = t.rotation.map(JC.degToRad); e.push(t.eulerOrder), r.makeRotationFromEuler(ZH.fromArray(e)) } if (t.postRotation) { const e = t.postRotation.map(JC.degToRad); e.push(t.eulerOrder), i.makeRotationFromEuler(ZH.fromArray(e)), i.invert() } t.scale && s.scale(KH.fromArray(t.scale)), t.scalingOffset && a.setPosition(KH.fromArray(t.scalingOffset)), t.scalingPivot && o.setPosition(KH.fromArray(t.scalingPivot)), t.rotationOffset && l.setPosition(KH.fromArray(t.rotationOffset)), t.rotationPivot && c.setPosition(KH.fromArray(t.rotationPivot)), t.parentMatrixWorld && (h.copy(t.parentMatrix), u.copy(t.parentMatrixWorld)); const f = (new IP).copy(n).multiply(r).multiply(i), m = new IP; m.extractRotation(u); const g = new IP; g.copyPosition(u); const v = new IP, y = (new IP).copy(g).invert().multiply(u); v.copy(m).invert().multiply(y); const b = s, _ = new IP; if (0 === p) _.copy(m).multiply(f).multiply(v).multiply(b); else if (1 === p) _.copy(m).multiply(v).multiply(f).multiply(b); else { const t = (new IP).scale((new rP).setFromMatrixScale(h)), e = (new IP).copy(t).invert(), n = (new IP).copy(v).multiply(e); _.copy(m).multiply(f).multiply(n).multiply(b) } const w = new IP; w.copy(c).invert(); const S = new IP; S.copy(o).invert(); let x = new IP; x.copy(e).multiply(l).multiply(c).multiply(n).multiply(r).multiply(i).multiply(w).multiply(a).multiply(o).multiply(s).multiply(S); const T = (new IP).copyPosition(x), E = (new IP).copy(u).multiply(T); return d.copyPosition(E), x = (new IP).copy(d).multiply(_), x.premultiply(u.invert()), x } function QH(t) { const e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"]; return 6 === (t = t || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[t] } function $H(t) { return t.split(",").map(function (t) { return parseFloat(t) }) } function tU(t, e, n) { return void 0 === e && (e = 0), void 0 === n && (n = t.byteLength), kF.decodeText(new Uint8Array(t, e, n)) } function eU(t, e, n) { return t.slice(0, e).concat(n).concat(t.slice(e)) } class nU extends UO { constructor(t) { super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (t) { return new aU(t) }), this.register(function (t) { return new cU(t) }), this.register(function (t) { return new uU(t) }), this.register(function (t) { return new lU(t) }), this.register(function (t) { return new sU(t) }), this.register(function (t) { return new hU(t) }) } load(t, e, n, r) { const i = this; let s; s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : kF.extractUrlBase(t), this.manager.itemStart(t); const o = function (e) { r ? r(e) : console.error(e), i.manager.itemError(t), i.manager.itemEnd(t) }, a = new VO(this.manager); a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function (n) { try { i.parse(n, s, function (n) { e(n), i.manager.itemEnd(t) }, o) } catch (Iz) { o(Iz) } }, n, o) } setDRACOLoader(t) { return this.dracoLoader = t, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(t) { return this.ktx2Loader = t, this } setMeshoptDecoder(t) { return this.meshoptDecoder = t, this } register(t) { return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this } unregister(t) { return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this } parse(t, e, n, r) { let i; const s = {}, o = {}; if ("string" == typeof t) i = t; else if (kF.decodeText(new Uint8Array(t, 0, 4)) === dU) { try { s[iU.KHR_BINARY_GLTF] = new pU(t) } catch (c) { return void (r && r(c)) } i = s[iU.KHR_BINARY_GLTF].content } else i = kF.decodeText(new Uint8Array(t)); const a = JSON.parse(i); if (void 0 === a.asset || a.asset.version[0] < 2) return void (r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."))); const l = new IU(a, { path: e || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let u = 0; u < this.pluginCallbacks.length; u++) { const t = this.pluginCallbacks[u](l); o[t.name] = t, s[t.name] = !0 } if (a.extensionsUsed) for (let u = 0; u < a.extensionsUsed.length; ++u) { const t = a.extensionsUsed[u], e = a.extensionsRequired || []; switch (t) { case iU.KHR_MATERIALS_UNLIT: s[t] = new oU; break; case iU.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: s[t] = new vU; break; case iU.KHR_DRACO_MESH_COMPRESSION: s[t] = new fU(a, this.dracoLoader); break; case iU.KHR_TEXTURE_TRANSFORM: s[t] = new mU; break; case iU.KHR_MESH_QUANTIZATION: s[t] = new yU; break; default: e.indexOf(t) >= 0 && void 0 === o[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".') } } l.setExtensions(s), l.setPlugins(o), l.parse(n, r) } } function rU() { let t = {}; return { get: function (e) { return t[e] }, add: function (e, n) { t[e] = n }, remove: function (e) { delete t[e] }, removeAll: function () { t = {} } } } const iU = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; class sU { constructor(t) { this.parser = t, this.name = iU.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const t = this.parser, e = this.parser.json.nodes || []; for (let n = 0, r = e.length; n < r; n++) { const r = e[n]; r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && t._addNodeRef(this.cache, r.extensions[this.name].light) } } _loadLight(t) { const e = this.parser, n = "light:" + t; let r = e.cache.get(n); if (r) return r; const i = e.json, s = ((i.extensions && i.extensions[this.name] || {}).lights || [])[t]; let o; const a = new PR(16777215); void 0 !== s.color && a.fromArray(s.color); const l = void 0 !== s.range ? s.range : 0; switch (s.type) { case "directional": o = new CF(a), o.target.position.set(0, 0, -1), o.add(o.target); break; case "point": o = new EF(a), o.distance = l; break; case "spot": o = new _F(a), o.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, o.angle = s.spot.outerConeAngle, o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type) }return o.position.set(0, 0, 0), o.decay = 2, void 0 !== s.intensity && (o.intensity = s.intensity), o.name = e.createUniqueName(s.name || "light_" + t), r = Promise.resolve(o), e.cache.add(n, r), r } createNodeAttachment(t) { const e = this, n = this.parser, r = n.json.nodes[t], i = (r.extensions && r.extensions[this.name] || {}).light; return void 0 === i ? null : this._loadLight(i).then(function (t) { return n._getNodeRef(e.cache, i, t) }) } } class oU { constructor() { this.name = iU.KHR_MATERIALS_UNLIT } getMaterialType() { return RR } extendParams(t, e, n) { const r = []; t.color = new PR(1, 1, 1), t.opacity = 1; const i = e.pbrMetallicRoughness; if (i) { if (Array.isArray(i.baseColorFactor)) { const e = i.baseColorFactor; t.color.fromArray(e), t.opacity = e[3] } void 0 !== i.baseColorTexture && r.push(n.assignTexture(t, "map", i.baseColorTexture)) } return Promise.all(r) } } class aU { constructor(t) { this.parser = t, this.name = iU.KHR_MATERIALS_CLEARCOAT } getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? _O : null } extendMaterialParams(t, e) { const n = this.parser, r = n.json.materials[t]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], s = r.extensions[this.name]; if (void 0 !== s.clearcoatFactor && (e.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && i.push(n.assignTexture(e, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (e.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && i.push(n.assignTexture(e, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (i.push(n.assignTexture(e, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) { const t = s.clearcoatNormalTexture.scale; e.clearcoatNormalScale = new XC(t, -t) } return Promise.all(i) } } class lU { constructor(t) { this.parser = t, this.name = iU.KHR_MATERIALS_TRANSMISSION } getMaterialType(t) { const e = this.parser.json.materials[t]; return e.extensions && e.extensions[this.name] ? _O : null } extendMaterialParams(t, e) { const n = this.parser, r = n.json.materials[t]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); const i = [], s = r.extensions[this.name]; return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && i.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)), Promise.all(i) } } class cU { constructor(t) { this.parser = t, this.name = iU.KHR_TEXTURE_BASISU } loadTexture(t) { const e = this.parser, n = e.json, r = n.textures[t]; if (!r.extensions || !r.extensions[this.name]) return null; const i = n.images[r.extensions[this.name].source], s = e.options.ktx2Loader; if (!s) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return e.loadTextureImage(t, i, s) } } class uU { constructor(t) { this.parser = t, this.name = iU.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(t) { const e = this.name, n = this.parser, r = n.json, i = r.textures[t]; if (!i.extensions || !i.extensions[e]) return null; const s = r.images[i.extensions[e].source]; let o = n.textureLoader; if (s.uri) { const t = n.options.manager.getHandler(s.uri); null !== t && (o = t) } return this.detectSupport().then(function (i) { if (i) return n.loadTextureImage(t, s, o); if (r.extensionsRequired && r.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(t) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (t) { const e = new Image; e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function () { t(1 === e.height) } })), this.isSupported } } class hU { constructor(t) { this.name = iU.EXT_MESHOPT_COMPRESSION, this.parser = t } loadBufferView(t) { const e = this.parser.json, n = e.bufferViews[t]; if (n.extensions && n.extensions[this.name]) { const t = n.extensions[this.name], r = this.parser.getDependency("buffer", t.buffer), i = this.parser.options.meshoptDecoder; if (!i || !i.supported) { if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return Promise.all([r, i.ready]).then(function (e) { const n = t.byteOffset || 0, r = t.byteLength || 0, s = t.count, o = t.byteStride, a = new ArrayBuffer(s * o), l = new Uint8Array(e[0], n, r); return i.decodeGltfBuffer(new Uint8Array(a), s, o, l, t.mode, t.filter), a }) } return null } } const dU = "glTF"; class pU { constructor(t) { this.name = iU.KHR_BINARY_GLTF, this.content = null, this.body = null; const e = new DataView(t, 0, 12); if (this.header = { magic: kF.decodeText(new Uint8Array(t.slice(0, 4))), version: e.getUint32(4, !0), length: e.getUint32(8, !0) }, this.header.magic !== dU) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - 12, r = new DataView(t, 12); let i = 0; for (; i < n;) { const e = r.getUint32(i, !0); i += 4; const n = r.getUint32(i, !0); if (i += 4, 1313821514 === n) { const n = new Uint8Array(t, 12 + i, e); this.content = kF.decodeText(n) } else if (5130562 === n) { const n = 12 + i; this.body = t.slice(n, n + e) } i += e } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class fU { constructor(t, e) { if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = iU.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload() } decodePrimitive(t, e) { const n = this.json, r = this.dracoLoader, i = t.extensions[this.name].bufferView, s = t.extensions[this.name].attributes, o = {}, a = {}, l = {}; for (const c in s) { const t = TU[c] || c.toLowerCase(); o[t] = s[c] } for (const c in t.attributes) { const e = TU[c] || c.toLowerCase(); if (void 0 !== s[c]) { const r = n.accessors[t.attributes[c]]; l[e] = _U[r.componentType], a[e] = !0 === r.normalized } } return e.getDependency("bufferView", i).then(function (t) { return new Promise(function (e) { r.decodeDracoFile(t, function (t) { for (const e in t.attributes) { const n = t.attributes[e], r = a[e]; void 0 !== r && (n.normalized = r) } e(t) }, o, l) }) }) } } class mU { constructor() { this.name = iU.KHR_TEXTURE_TRANSFORM } extendTexture(t, e) { return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t } } class gU extends bO { constructor(t) { super(), this.isGLTFSpecularGlossinessMaterial = !0; const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), i = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), o = { specular: { value: (new PR).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = o, this.onBeforeCompile = function (t) { for (const e in o) t.uniforms[e] = o[e]; t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", i).replace("#include <lights_physical_fragment>", s) }, Object.defineProperties(this, { specular: { get: function () { return o.specular.value }, set: function (t) { o.specular.value = t } }, specularMap: { get: function () { return o.specularMap.value }, set: function (t) { o.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return o.glossiness.value }, set: function (t) { o.glossiness.value = t } }, glossinessMap: { get: function () { return o.glossinessMap.value }, set: function (t) { o.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t) } copy(t) { return super.copy(t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this } } class vU { constructor() { this.name = iU.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] } getMaterialType() { return gU } extendParams(t, e, n) { const r = e.extensions[this.name]; t.color = new PR(1, 1, 1), t.opacity = 1; const i = []; if (Array.isArray(r.diffuseFactor)) { const e = r.diffuseFactor; t.color.fromArray(e), t.opacity = e[3] } if (void 0 !== r.diffuseTexture && i.push(n.assignTexture(t, "map", r.diffuseTexture)), t.emissive = new PR(0, 0, 0), t.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, t.specular = new PR(1, 1, 1), Array.isArray(r.specularFactor) && t.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) { const e = r.specularGlossinessTexture; i.push(n.assignTexture(t, "glossinessMap", e)), i.push(n.assignTexture(t, "specularMap", e)) } return Promise.all(i) } createMaterial(t) { const e = new gU(t); return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = 0, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e } } class yU { constructor() { this.name = iU.KHR_MESH_QUANTIZATION } } class bU extends TO { constructor(t, e, n, r) { super(t, e, n, r) } copySampleValue_(t) { const e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r * 3 + r; for (let s = 0; s !== r; s++)e[s] = n[i + s]; return e } } bU.prototype.beforeStart_ = bU.prototype.copySampleValue_, bU.prototype.afterEnd_ = bU.prototype.copySampleValue_, bU.prototype.interpolate_ = function (t, e, n, r) { const i = this.resultBuffer, s = this.sampleValues, o = this.valueSize, a = 2 * o, l = 3 * o, c = r - e, u = (n - e) / c, h = u * u, d = h * u, p = t * l, f = p - l, m = -2 * d + 3 * h, g = d - h, v = 1 - m, y = g - h + u; for (let b = 0; b !== o; b++)i[b] = v * s[f + b + o] + y * (s[f + b + a] * c) + m * s[p + b + o] + g * (s[p + b] * c); return i }; const _U = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, wU = { 9728: oC, 9729: cC, 9984: aC, 9985: 1007, 9986: lC, 9987: uC }, SU = { 33071: iC, 33648: sC, 10497: rC }, xU = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, TU = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, EU = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, MU = { CUBICSPLINE: void 0, LINEAR: SC, STEP: wC }; function AU(t, e) { return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t) } function CU(t, e, n) { for (const r in n.extensions) void 0 === t[r] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = n.extensions[r]) } function PU(t, e) { void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras)) } function RU(t, e) { if (t.updateMorphTargets(), void 0 !== e.weights) for (let n = 0, r = e.weights.length; n < r; n++)t.morphTargetInfluences[n] = e.weights[n]; if (e.extras && Array.isArray(e.extras.targetNames)) { const n = e.extras.targetNames; if (t.morphTargetInfluences.length === n.length) { t.morphTargetDictionary = {}; for (let e = 0, r = n.length; e < r; e++)t.morphTargetDictionary[n[e]] = e } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function LU(t) { const e = t.extensions && t.extensions[iU.KHR_DRACO_MESH_COMPRESSION]; let n; return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + kU(e.attributes) : t.indices + ":" + kU(t.attributes) + ":" + t.mode, n } function kU(t) { let e = ""; const n = Object.keys(t).sort(); for (let r = 0, i = n.length; r < i; r++)e += n[r] + ":" + t[n[r]] + ";"; return e } function DU(t) { switch (t) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } class IU { constructor(t = {}, e = {}) { this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new rU, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, this.textureLoader = "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? new DF(this.options.manager) : new JO(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new VO(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(t) { this.extensions = t } setPlugins(t) { this.plugins = t } parse(t, e) { const n = this, r = this.json, i = this.extensions; this.cache.removeAll(), this._invokeAll(function (t) { return t._markDefs && t._markDefs() }), Promise.all(this._invokeAll(function (t) { return t.beforeRoot && t.beforeRoot() })).then(function () { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) }).then(function (e) { const s = { scene: e[0][r.scene || 0], scenes: e[0], animations: e[1], cameras: e[2], asset: r.asset, parser: n, userData: {} }; CU(i, s, r), PU(s, r), Promise.all(n._invokeAll(function (t) { return t.afterRoot && t.afterRoot(s) })).then(function () { t(s) }) }).catch(e) } _markDefs() { const t = this.json.nodes || [], e = this.json.skins || [], n = this.json.meshes || []; for (let r = 0, i = e.length; r < i; r++) { const n = e[r].joints; for (let e = 0, r = n.length; e < r; e++)t[n[e]].isBone = !0 } for (let r = 0, i = t.length; r < i; r++) { const e = t[r]; void 0 !== e.mesh && (this._addNodeRef(this.meshCache, e.mesh), void 0 !== e.skin && (n[e.mesh].isSkinnedMesh = !0)), void 0 !== e.camera && this._addNodeRef(this.cameraCache, e.camera) } } _addNodeRef(t, e) { void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++) } _getNodeRef(t, e, n) { if (t.refs[e] <= 1) return n; const r = n.clone(); return r.name += "_instance_" + t.uses[e]++, r } _invokeOne(t) { const e = Object.values(this.plugins); e.push(this); for (let n = 0; n < e.length; n++) { const r = t(e[n]); if (r) return r } return null } _invokeAll(t) { const e = Object.values(this.plugins); e.unshift(this); const n = []; for (let r = 0; r < e.length; r++) { const i = t(e[r]); i && n.push(i) } return n } getDependency(t, e) { const n = t + ":" + e; let r = this.cache.get(n); if (!r) { switch (t) { case "scene": r = this.loadScene(e); break; case "node": r = this.loadNode(e); break; case "mesh": r = this._invokeOne(function (t) { return t.loadMesh && t.loadMesh(e) }); break; case "accessor": r = this.loadAccessor(e); break; case "bufferView": r = this._invokeOne(function (t) { return t.loadBufferView && t.loadBufferView(e) }); break; case "buffer": r = this.loadBuffer(e); break; case "material": r = this._invokeOne(function (t) { return t.loadMaterial && t.loadMaterial(e) }); break; case "texture": r = this._invokeOne(function (t) { return t.loadTexture && t.loadTexture(e) }); break; case "skin": r = this.loadSkin(e); break; case "animation": r = this.loadAnimation(e); break; case "camera": r = this.loadCamera(e); break; default: throw new Error("Unknown type: " + t) }this.cache.add(n, r) } return r } getDependencies(t) { let e = this.cache.get(t); if (!e) { const n = this; e = Promise.all((this.json[t + ("mesh" === t ? "es" : "s")] || []).map(function (e, r) { return n.getDependency(t, r) })), this.cache.add(t, e) } return e } loadBuffer(t) { const e = this.json.buffers[t], n = this.fileLoader; if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported."); if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[iU.KHR_BINARY_GLTF].body); const r = this.options; return new Promise(function (t, i) { n.load(AU(e.uri, r.path), t, void 0, function () { i(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".')) }) }) } loadBufferView(t) { const e = this.json.bufferViews[t]; return this.getDependency("buffer", e.buffer).then(function (t) { const n = e.byteOffset || 0; return t.slice(n, n + (e.byteLength || 0)) }) } loadAccessor(t) { const e = this, n = this.json, r = this.json.accessors[t]; if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null); const i = []; return i.push(void 0 !== r.bufferView ? this.getDependency("bufferView", r.bufferView) : null), void 0 !== r.sparse && (i.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(i).then(function (t) { const i = t[0], s = xU[r.type], o = _U[r.componentType], a = o.BYTES_PER_ELEMENT, l = r.byteOffset || 0, c = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0, u = !0 === r.normalized; let h, d; if (c && c !== a * s) { const t = Math.floor(l / c), n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + t + ":" + r.count; let p = e.cache.get(n); p || (h = new o(i, t * c, r.count * c / a), p = new zD(h, c / a), e.cache.add(n, p)), d = new JD(p, s, l % c / a, u) } else h = null === i ? new o(r.count * s) : new o(i, l, r.count * s), d = new DR(h, s, u); if (void 0 !== r.sparse) { const e = r.sparse.values.byteOffset || 0, n = new (0, _U[r.sparse.indices.componentType])(t[1], r.sparse.indices.byteOffset || 0, r.sparse.count * xU.SCALAR), a = new o(t[2], e, r.sparse.count * s); null !== i && (d = new DR(d.array.slice(), d.itemSize, d.normalized)); for (let t = 0, r = n.length; t < r; t++) { const e = n[t]; if (d.setX(e, a[t * s]), s >= 2 && d.setY(e, a[t * s + 1]), s >= 3 && d.setZ(e, a[t * s + 2]), s >= 4 && d.setW(e, a[t * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return d }) } loadTexture(t) { const e = this.json, n = e.images[e.textures[t].source]; let r = this.textureLoader; if (n.uri) { const t = this.options.manager.getHandler(n.uri); null !== t && (r = t) } return this.loadTextureImage(t, n, r) } loadTextureImage(t, e, n) { const r = this, i = this.json, s = this.options, o = i.textures[t], a = (e.uri || e.bufferView) + ":" + o.sampler; if (this.textureCache[a]) return this.textureCache[a]; const l = self.URL || self.webkitURL; let c = e.uri || "", u = !1, h = !0; const d = c.search(/\.jpe?g($|\?)/i) > 0 || 0 === c.search(/^data\:image\/jpeg/); if (("image/jpeg" === e.mimeType || d) && (h = !1), void 0 !== e.bufferView) c = r.getDependency("bufferView", e.bufferView).then(function (t) { if ("image/png" === e.mimeType) { const e = new DataView(t, 25, 1).getUint8(0, !1); h = 6 === e || 4 === e || 3 === e } u = !0; const n = new Blob([t], { type: e.mimeType }); return c = l.createObjectURL(n), c }); else if (void 0 === e.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView"); const p = Promise.resolve(c).then(function (t) { return new Promise(function (e, r) { let i = e; !0 === n.isImageBitmapLoader && (i = function (t) { e(new UI(t)) }), n.load(AU(t, s.path), i, void 0, r) }) }).then(function (e) { !0 === u && l.revokeObjectURL(c), e.flipY = !1, o.name && (e.name = o.name), h || (e.format = vC); const n = (i.samplers || {})[o.sampler] || {}; return e.magFilter = wU[n.magFilter] || cC, e.minFilter = wU[n.minFilter] || uC, e.wrapS = SU[n.wrapS] || rC, e.wrapT = SU[n.wrapT] || rC, r.associations.set(e, { type: "textures", index: t }), e }); return this.textureCache[a] = p, p } assignTexture(t, e, n) { const r = this; return this.getDependency("texture", n.index).then(function (i) { if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), r.extensions[iU.KHR_TEXTURE_TRANSFORM]) { const t = void 0 !== n.extensions ? n.extensions[iU.KHR_TEXTURE_TRANSFORM] : void 0; if (t) { const e = r.associations.get(i); i = r.extensions[iU.KHR_TEXTURE_TRANSFORM].extendTexture(i, t), r.associations.set(i, e) } } t[e] = i }) } assignFinalMaterial(t) { const e = t.geometry; let n = t.material; const r = void 0 !== e.attributes.tangent, i = void 0 !== e.attributes.color, s = void 0 === e.attributes.normal, o = Object.keys(e.morphAttributes).length > 0, a = o && void 0 !== e.morphAttributes.normal; if (t.isPoints) { const t = "PointsMaterial:" + n.uuid; let e = this.cache.get(t); e || (e = new DI, SR.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e } else if (t.isLine) { const t = "LineBasicMaterial:" + n.uuid; let e = this.cache.get(t); e || (e = new SI, SR.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)), n = e } if (r || i || s || o) { let t = "ClonedMaterial:" + n.uuid + ":"; n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"), r && (t += "vertex-tangents:"), i && (t += "vertex-colors:"), s && (t += "flat-shading:"), o && (t += "morph-targets:"), a && (t += "morph-normals:"); let e = this.cache.get(t); e || (e = n.clone(), i && (e.vertexColors = !0), s && (e.flatShading = !0), o && (e.morphTargets = !0), a && (e.morphNormals = !0), r && (e.vertexTangents = !0, e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e } n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n } getMaterialType() { return bO } loadMaterial(t) { const e = this, n = this.extensions, r = this.json.materials[t]; let i; const s = {}, o = r.extensions || {}, a = []; if (o[iU.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { const t = n[iU.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; i = t.getMaterialType(), a.push(t.extendParams(s, r, e)) } else if (o[iU.KHR_MATERIALS_UNLIT]) { const t = n[iU.KHR_MATERIALS_UNLIT]; i = t.getMaterialType(), a.push(t.extendParams(s, r, e)) } else { const n = r.pbrMetallicRoughness || {}; if (s.color = new PR(1, 1, 1), s.opacity = 1, Array.isArray(n.baseColorFactor)) { const t = n.baseColorFactor; s.color.fromArray(t), s.opacity = t[3] } void 0 !== n.baseColorTexture && a.push(e.assignTexture(s, "map", n.baseColorTexture)), s.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, s.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (a.push(e.assignTexture(s, "metalnessMap", n.metallicRoughnessTexture)), a.push(e.assignTexture(s, "roughnessMap", n.metallicRoughnessTexture))), i = this._invokeOne(function (e) { return e.getMaterialType && e.getMaterialType(t) }), a.push(Promise.all(this._invokeAll(function (e) { return e.extendMaterialParams && e.extendMaterialParams(t, s) }))) } !0 === r.doubleSided && (s.side = 2); const l = r.alphaMode || "OPAQUE"; return "BLEND" === l ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, "MASK" === l && (s.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && i !== RR && (a.push(e.assignTexture(s, "normalMap", r.normalTexture)), s.normalScale = new XC(1, -1), void 0 !== r.normalTexture.scale && s.normalScale.set(r.normalTexture.scale, -r.normalTexture.scale)), void 0 !== r.occlusionTexture && i !== RR && (a.push(e.assignTexture(s, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (s.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && i !== RR && (s.emissive = (new PR).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && i !== RR && a.push(e.assignTexture(s, "emissiveMap", r.emissiveTexture)), Promise.all(a).then(function () { let o; return o = i === gU ? n[iU.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new i(s), r.name && (o.name = r.name), o.map && (o.map.encoding = CC), o.emissiveMap && (o.emissiveMap.encoding = CC), PU(o, r), e.associations.set(o, { type: "materials", index: t }), r.extensions && CU(n, o, r), o }) } createUniqueName(t) { const e = WF.sanitizeNodeName(t || ""); let n = e; for (let r = 1; this.nodeNamesUsed[n]; ++r)n = e + "_" + r; return this.nodeNamesUsed[n] = !0, n } loadGeometries(t) { const e = this, n = this.extensions, r = this.primitiveCache; function i(t) { return n[iU.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then(function (n) { return FU(n, t, e) }) } const s = []; for (let o = 0, a = t.length; o < a; o++) { const n = t[o], a = LU(n), l = r[a]; if (l) s.push(l.promise); else { let t; t = n.extensions && n.extensions[iU.KHR_DRACO_MESH_COMPRESSION] ? i(n) : FU(new JR, n, e), r[a] = { primitive: n, promise: t }, s.push(t) } } return Promise.all(s) } loadMesh(t) { const e = this, n = this.extensions, r = this.json.meshes[t], i = r.primitives, s = []; for (let a = 0, l = i.length; a < l; a++) { const t = void 0 === i[a].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new bO({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: 0 })), o.DefaultMaterial) : this.getDependency("material", i[a].material); s.push(t) } var o; return s.push(e.loadGeometries(i)), Promise.all(s).then(function (s) { const o = s.slice(0, s.length - 1), a = s[s.length - 1], l = []; for (let u = 0, h = a.length; u < h; u++) { const s = a[u], c = i[u]; let h; const d = o[u]; if (4 === c.mode || 5 === c.mode || 6 === c.mode || void 0 === c.mode) h = !0 === r.isSkinnedMesh ? new dI(s, d) : new cL(s, d), !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), 5 === c.mode ? h.geometry = NU(h.geometry, 1) : 6 === c.mode && (h.geometry = NU(h.geometry, 2)); else if (1 === c.mode) h = new LI(s, d); else if (3 === c.mode) h = new CI(s, d); else if (2 === c.mode) h = new kI(s, d); else { if (0 !== c.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c.mode); h = new BI(s, d) } Object.keys(h.geometry.morphAttributes).length > 0 && RU(h, r), h.name = e.createUniqueName(r.name || "mesh_" + t), PU(h, r), c.extensions && CU(n, h, c), e.assignFinalMaterial(h), l.push(h) } if (1 === l.length) return l[0]; const c = new ID; for (let t = 0, e = l.length; t < e; t++)c.add(l[t]); return c }) } loadCamera(t) { let e; const n = this.json.cameras[t], r = n[n.type]; if (r) return "perspective" === n.type ? e = new vL(JC.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (e = new MF(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (e.name = this.createUniqueName(n.name)), PU(e, n), Promise.resolve(e); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(t) { const e = this.json.skins[t], n = { joints: e.joints }; return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then(function (t) { return n.inverseBindMatrices = t, n }) } loadAnimation(t) { const e = this.json.animations[t], n = [], r = [], i = [], s = [], o = []; for (let a = 0, l = e.channels.length; a < l; a++) { const t = e.channels[a], l = e.samplers[t.sampler], c = t.target, u = void 0 !== e.parameters ? e.parameters[l.input] : l.input, h = void 0 !== e.parameters ? e.parameters[l.output] : l.output; n.push(this.getDependency("node", void 0 !== c.node ? c.node : c.id)), r.push(this.getDependency("accessor", u)), i.push(this.getDependency("accessor", h)), s.push(l), o.push(c) } return Promise.all([Promise.all(n), Promise.all(r), Promise.all(i), Promise.all(s), Promise.all(o)]).then(function (n) { const r = n[0], i = n[1], s = n[2], o = n[3], a = n[4], l = []; for (let t = 0, e = r.length; t < e; t++) { const e = r[t], n = i[t], c = s[t], u = o[t], h = a[t]; if (void 0 === e) continue; let d; switch (e.updateMatrix(), e.matrixAutoUpdate = !0, EU[h.path]) { case EU.weights: d = LO; break; case EU.rotation: d = DO; break; case EU.position: case EU.scale: default: d = OO }const p = e.name ? e.name : e.uuid, f = void 0 !== u.interpolation ? MU[u.interpolation] : SC, m = []; EU[h.path] === EU.weights ? e.traverse(function (t) { !0 === t.isMesh && t.morphTargetInfluences && m.push(t.name ? t.name : t.uuid) }) : m.push(p); let g = c.array; if (c.normalized) { const t = DU(g.constructor), e = new Float32Array(g.length); for (let n = 0, r = g.length; n < r; n++)e[n] = g[n] * t; g = e } for (let t = 0, r = m.length; t < r; t++) { const e = new d(m[t] + "." + EU[h.path], n.array, g, f); "CUBICSPLINE" === u.interpolation && (e.createInterpolant = function (t) { return new bU(this.times, this.values, this.getValueSize() / 3, t) }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(e) } } return new FO(e.name ? e.name : "animation_" + t, void 0, l) }) } createNodeMesh(t) { const e = this, n = this.json.nodes[t]; return void 0 === n.mesh ? null : e.getDependency("mesh", n.mesh).then(function (t) { const r = e._getNodeRef(e.meshCache, n.mesh, t); return void 0 !== n.weights && r.traverse(function (t) { if (t.isMesh) for (let e = 0, r = n.weights.length; e < r; e++)t.morphTargetInfluences[e] = n.weights[e] }), r }) } loadNode(t) { const e = this.extensions, n = this, r = this.json.nodes[t], i = r.name ? n.createUniqueName(r.name) : ""; return function () { const e = [], i = n._invokeOne(function (e) { return e.createNodeMesh && e.createNodeMesh(t) }); return i && e.push(i), void 0 !== r.camera && e.push(n.getDependency("camera", r.camera).then(function (t) { return n._getNodeRef(n.cameraCache, r.camera, t) })), n._invokeAll(function (e) { return e.createNodeAttachment && e.createNodeAttachment(t) }).forEach(function (t) { e.push(t) }), Promise.all(e) }().then(function (s) { let o; if (o = !0 === r.isBone ? new pI : s.length > 1 ? new ID : 1 === s.length ? s[0] : new sR, o !== s[0]) for (let t = 0, e = s.length; t < e; t++)o.add(s[t]); if (r.name && (o.userData.name = r.name, o.name = i), PU(o, r), r.extensions && CU(e, o, r), void 0 !== r.matrix) { const t = new IP; t.fromArray(r.matrix), o.applyMatrix4(t) } else void 0 !== r.translation && o.position.fromArray(r.translation), void 0 !== r.rotation && o.quaternion.fromArray(r.rotation), void 0 !== r.scale && o.scale.fromArray(r.scale); return n.associations.set(o, { type: "nodes", index: t }), o }) } loadScene(t) { const e = this.json, n = this.extensions, r = this.json.scenes[t], i = this, s = new ID; r.name && (s.name = i.createUniqueName(r.name)), PU(s, r), r.extensions && CU(n, s, r); const o = r.nodes || [], a = []; for (let l = 0, c = o.length; l < c; l++)a.push(OU(o[l], s, e, i)); return Promise.all(a).then(function () { return s }) } } function OU(t, e, n, r) { const i = n.nodes[t]; return r.getDependency("node", t).then(function (t) { if (void 0 === i.skin) return t; let e; return r.getDependency("skin", i.skin).then(function (t) { e = t; const n = []; for (let i = 0, s = e.joints.length; i < s; i++)n.push(r.getDependency("node", e.joints[i])); return Promise.all(n) }).then(function (n) { return t.traverse(function (t) { if (!t.isMesh) return; const r = [], i = []; for (let s = 0, o = n.length; s < o; s++) { const t = n[s]; if (t) { r.push(t); const n = new IP; void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * s), i.push(n) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[s]) } t.bind(new vI(r, i), t.matrixWorld) }), t }) }).then(function (t) { e.add(t); const s = []; if (i.children) { const e = i.children; for (let i = 0, o = e.length; i < o; i++)s.push(OU(e[i], t, n, r)) } return Promise.all(s) }) } function FU(t, e, n) { const r = e.attributes, i = []; function s(e, r) { return n.getDependency("accessor", e).then(function (e) { t.setAttribute(r, e) }) } for (const o in r) { const e = TU[o] || o.toLowerCase(); e in t.attributes || i.push(s(r[o], e)) } if (void 0 !== e.indices && !t.index) { const r = n.getDependency("accessor", e.indices).then(function (e) { t.setIndex(e) }); i.push(r) } return PU(t, e), function (t, e, n) { const r = e.attributes, i = new oP; if (void 0 === r.POSITION) return; { const t = n.json.accessors[r.POSITION], e = t.min, s = t.max; if (void 0 === e || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); if (i.set(new rP(e[0], e[1], e[2]), new rP(s[0], s[1], s[2])), t.normalized) { const e = DU(_U[t.componentType]); i.min.multiplyScalar(e), i.max.multiplyScalar(e) } } const s = e.targets; if (void 0 !== s) { const t = new rP, e = new rP; for (let r = 0, i = s.length; r < i; r++) { const i = s[r]; if (void 0 !== i.POSITION) { const r = n.json.accessors[i.POSITION], s = r.min, o = r.max; if (void 0 !== s && void 0 !== o) { if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), r.normalized) { const t = DU(_U[r.componentType]); e.multiplyScalar(t) } t.max(e) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } i.expandByVector(t) } t.boundingBox = i; const o = new EP; i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, t.boundingSphere = o }(t, e, n), Promise.all(i).then(function () { return void 0 !== e.targets ? function (t, e, n) { let r = !1, i = !1; for (let a = 0, l = e.length; a < l; a++) { const t = e[a]; if (void 0 !== t.POSITION && (r = !0), void 0 !== t.NORMAL && (i = !0), r && i) break } if (!r && !i) return Promise.resolve(t); const s = [], o = []; for (let a = 0, l = e.length; a < l; a++) { const l = e[a]; if (r) { const e = void 0 !== l.POSITION ? n.getDependency("accessor", l.POSITION) : t.attributes.position; s.push(e) } if (i) { const e = void 0 !== l.NORMAL ? n.getDependency("accessor", l.NORMAL) : t.attributes.normal; o.push(e) } } return Promise.all([Promise.all(s), Promise.all(o)]).then(function (e) { const n = e[1]; return r && (t.morphAttributes.position = e[0]), i && (t.morphAttributes.normal = n), t.morphTargetsRelative = !0, t }) }(t, e.targets, n) : t }) } function NU(t, e) { let n = t.getIndex(); if (null === n) { const e = [], r = t.getAttribute("position"); if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t; for (let t = 0; t < r.count; t++)e.push(t); t.setIndex(e), n = t.getIndex() } const r = n.count - 2, i = []; if (2 === e) for (let o = 1; o <= r; o++)i.push(n.getX(0)), i.push(n.getX(o)), i.push(n.getX(o + 1)); else for (let o = 0; o < r; o++)o % 2 == 0 ? (i.push(n.getX(o)), i.push(n.getX(o + 1)), i.push(n.getX(o + 2))) : (i.push(n.getX(o + 2)), i.push(n.getX(o + 1)), i.push(n.getX(o))); i.length / 3 !== r && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = t.clone(); return s.setIndex(i), s } var BU = (new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]), class extends mL { constructor() { super({ type: "CopyMaterial", uniforms: { inputBuffer: new KF(null), opacity: new KF(1) }, fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n}", vertexShader: "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", blending: 0, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1 } }), HU = new gL, UU = null, GU = class { constructor(t = "Pass", e = new VD, n = HU) { this.name = t, this.scene = e, this.camera = n, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0 } get renderToScreen() { return !this.rtt } set renderToScreen(t) { if (this.rtt === t) { const e = this.getFullscreenMaterial(); null !== e && (e.needsUpdate = !0), this.rtt = !t } } getFullscreenMaterial() { return null !== this.screen ? this.screen.material : null } setFullscreenMaterial(t) { let e = this.screen; null !== e ? e.material = t : (e = new cL(function () { if (null === UU) { const t = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), e = new Float32Array([0, 0, 2, 0, 0, 2]); void 0 !== (UU = new JR).setAttribute ? (UU.setAttribute("position", new DR(t, 3)), UU.setAttribute("uv", new DR(e, 2))) : (UU.addAttribute("position", new DR(t, 3)), UU.addAttribute("uv", new DR(e, 2))) } return UU }(), t), e.frustumCulled = !1, null === this.scene && (this.scene = new VD), this.scene.add(e), this.screen = e) } getDepthTexture() { return null } setDepthTexture(t, e = 0) { } render(t, e, n, r, i) { throw new Error("Render method not implemented!") } setSize(t, e) { } initialize(t, e, n) { } dispose() { const t = this.getFullscreenMaterial(); null !== t && t.dispose(); for (const e of Object.keys(this)) { const t = this[e]; if (null !== t && "function" == typeof t.dispose) { if (t instanceof VD) continue; this[e].dispose() } } } }, VU = class extends GU { constructor() { super("ClearMaskPass", null, null), this.needsSwap = !1 } render(t, e, n, r, i) { const s = t.state.buffers.stencil; s.setLocked(!1), s.setTest(!1) } }, zU = new PR, jU = class extends GU { constructor(t = !0, e = !0, n = !1) { super("ClearPass", null, null), this.needsSwap = !1, this.color = t, this.depth = e, this.stencil = n, this.overrideClearColor = null, this.overrideClearAlpha = -1 } render(t, e, n, r, i) { const s = this.overrideClearColor, o = this.overrideClearAlpha, a = t.getClearAlpha(), l = null !== s, c = o >= 0; l ? (zU.copy(t.getClearColor(zU)), t.setClearColor(s, c ? o : a)) : c && t.setClearAlpha(o), t.setRenderTarget(this.renderToScreen ? null : e), t.clear(this.color, this.depth, this.stencil), l ? t.setClearColor(zU, a) : c && t.setClearAlpha(a) } }, JU = !1, XU = class { constructor(t = null) { this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(t), this.meshCount = 0, this.replaceMaterial = t => { if (t.isMesh) { let e; if (t.material.flatShading) switch (t.material.side) { case 2: e = this.materialsFlatShadedDoubleSide; break; case 1: e = this.materialsFlatShadedBackSide; break; default: e = this.materialsFlatShaded } else switch (t.material.side) { case 2: e = this.materialsDoubleSide; break; case 1: e = this.materialsBackSide; break; default: e = this.materials }this.originalMaterials.set(t, t.material), t.material = t.isSkinnedMesh ? e[2] : t.isInstancedMesh ? e[1] : e[0], ++this.meshCount } } } setMaterial(t) { if (this.disposeMaterials(), this.material = t, null !== t) { const e = this.materials = [t.clone(), t.clone(), t.clone()]; for (const n of e) n.uniforms = Object.assign({}, t.uniforms), n.side = 0; e[2].skinning = !0, this.materialsBackSide = e.map(e => { const n = e.clone(); return n.uniforms = Object.assign({}, t.uniforms), n.side = 1, n }), this.materialsDoubleSide = e.map(e => { const n = e.clone(); return n.uniforms = Object.assign({}, t.uniforms), n.side = 2, n }), this.materialsFlatShaded = e.map(e => { const n = e.clone(); return n.uniforms = Object.assign({}, t.uniforms), n.flatShading = !0, n }), this.materialsFlatShadedBackSide = e.map(e => { const n = e.clone(); return n.uniforms = Object.assign({}, t.uniforms), n.flatShading = !0, n.side = 1, n }), this.materialsFlatShadedDoubleSide = e.map(e => { const n = e.clone(); return n.uniforms = Object.assign({}, t.uniforms), n.flatShading = !0, n.side = 2, n }) } } render(t, e, n) { const r = t.shadowMap.enabled; if (t.shadowMap.enabled = !1, JU) { const r = this.originalMaterials; this.meshCount = 0, e.traverse(this.replaceMaterial), t.render(e, n); for (const t of r) t[0].material = t[1]; this.meshCount !== r.size && r.clear() } else { const r = e.overrideMaterial; e.overrideMaterial = this.material, t.render(e, n), e.overrideMaterial = r } t.shadowMap.enabled = r } disposeMaterials() { if (null !== this.material) { const t = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide); for (const e of t) e.dispose() } } dispose() { this.originalMaterials.clear(), this.disposeMaterials() } static get workaroundEnabled() { return JU } static set workaroundEnabled(t) { JU = t } }, WU = class extends GU { constructor(t, e, n = null) { super("RenderPass", t, e), this.needsSwap = !1, this.clearPass = new jU, this.overrideMaterialManager = null === n ? null : new XU(n) } get renderToScreen() { return super.renderToScreen } set renderToScreen(t) { super.renderToScreen = t, this.clearPass.renderToScreen = t } get overrideMaterial() { const t = this.overrideMaterialManager; return null !== t ? t.material : null } set overrideMaterial(t) { const e = this.overrideMaterialManager; null !== t ? null !== e ? e.setMaterial(t) : this.overrideMaterialManager = new XU(t) : null !== e && (e.dispose(), this.overrideMaterialManager = null) } get clear() { return this.clearPass.enabled } set clear(t) { this.clearPass.enabled = t } getClearPass() { return this.clearPass } render(t, e, n, r, i) { const s = this.scene, o = this.camera, a = s.background, l = this.renderToScreen ? null : e; this.clear && (null !== this.clearPass.overrideClearColor && (s.background = null), this.clearPass.render(t, e)), t.setRenderTarget(l), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(t, s, o) : t.render(s, o), s.background !== a && (s.background = a) } }; new Float32Array([255 / 256 / 256 ** 3, 255 / 256 / 65536, 255 / 256 / 256, 255 / 256]), new Map([[0, null], [1, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}"], [2, "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}"], [3, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}"], [4, "float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"], [5, "float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"], [6, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}"], [7, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}"], [8, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}"], [9, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}"], [10, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}"], [11, "float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"], [12, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}"], [13, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}"], [14, "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"], [15, "float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"], [16, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}"], [17, "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"], [18, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}"]]); var qU = class extends GU { constructor(t, e) { super("MaskPass", t, e), this.needsSwap = !1, this.clearPass = new jU(!1, !1, !0), this.inverse = !1 } get clear() { return this.clearPass.enabled } set clear(t) { this.clearPass.enabled = t } render(t, e, n, r, i) { const s = t.getContext(), o = t.state.buffers, a = this.scene, l = this.camera, c = this.clearPass, u = this.inverse ? 0 : 1, h = 1 - u; o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.stencil.setFunc(s.ALWAYS, u, 4294967295), o.stencil.setClear(h), o.stencil.setLocked(!0), this.clear && (this.renderToScreen ? c.render(t, null) : (c.render(t, e), c.render(t, n))), this.renderToScreen ? (t.setRenderTarget(null), t.render(a, l)) : (t.setRenderTarget(e), t.render(a, l), t.setRenderTarget(n), t.render(a, l)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(s.EQUAL, 1, 4294967295), o.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.stencil.setLocked(!0) } }, ZU = class extends GU { constructor(t, e = "inputBuffer") { super("ShaderPass"), this.setFullscreenMaterial(t), this.uniform = null, this.setInput(e) } setInput(t) { const e = this.getFullscreenMaterial(); if (this.uniform = null, null !== e) { const n = e.uniforms; void 0 !== n && void 0 !== n[t] && (this.uniform = n[t]) } } render(t, e, n, r, i) { null !== this.uniform && null !== e && (this.uniform.value = e.texture), t.setRenderTarget(this.renderToScreen ? null : n), t.render(this.scene, this.camera) } initialize(t, e, n) { void 0 !== n && n !== hC && (this.getFullscreenMaterial().defines.FRAMEBUFFER_PRECISION_HIGH = "1") } }; function KU(t, e, n) { return t + (e - t) * n } function YU(t, e, n, r) { const i = KU(t, e, .75), s = KU(n, r, .75); return KU(i, s, .875) } Set, new rP, new IP, new PR, Math, new rP, new rP, new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array(2), new Float32Array(2), new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]), new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125]), new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4]), new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3]), new Map([[YU(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])], [YU(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])], [YU(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])], [YU(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])], [YU(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])], [YU(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])], [YU(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])], [YU(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])], [YU(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])], [YU(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])], [YU(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])], [YU(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])], [YU(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])], [YU(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])], [YU(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])], [YU(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]]); var QU, $U = { Linear: { None: function (t) { return t } }, Quadratic: { In: function (t) { return t * t }, Out: function (t) { return t * (2 - t) }, InOut: function (t) { return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) } }, Cubic: { In: function (t) { return t * t * t }, Out: function (t) { return --t * t * t + 1 }, InOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) } }, Quartic: { In: function (t) { return t * t * t * t }, Out: function (t) { return 1 - --t * t * t * t }, InOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) } }, Quintic: { In: function (t) { return t * t * t * t * t }, Out: function (t) { return --t * t * t * t * t + 1 }, InOut: function (t) { return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) } }, Sinusoidal: { In: function (t) { return 1 - Math.cos(t * Math.PI / 2) }, Out: function (t) { return Math.sin(t * Math.PI / 2) }, InOut: function (t) { return .5 * (1 - Math.cos(Math.PI * t)) } }, Exponential: { In: function (t) { return 0 === t ? 0 : Math.pow(1024, t - 1) }, Out: function (t) { return 1 === t ? 1 : 1 - Math.pow(2, -10 * t) }, InOut: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1))) } }, Circular: { In: function (t) { return 1 - Math.sqrt(1 - t * t) }, Out: function (t) { return Math.sqrt(1 - --t * t) }, InOut: function (t) { return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) } }, Elastic: { In: function (t) { return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) }, Out: function (t) { return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1 }, InOut: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1 } }, Back: { In: function (t) { var e = 1.70158; return t * t * ((e + 1) * t - e) }, Out: function (t) { var e = 1.70158; return --t * t * ((e + 1) * t + e) + 1 }, InOut: function (t) { var e = 2.5949095; return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2) } }, Bounce: { In: function (t) { return 1 - $U.Bounce.Out(1 - t) }, Out: function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, InOut: function (t) { return t < .5 ? .5 * $U.Bounce.In(2 * t) : .5 * $U.Bounce.Out(2 * t - 1) + .5 } } }, tG = "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? function () { var t = process.hrtime(); return 1e3 * t[0] + t[1] / 1e6 } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now.bind(self.performance) : void 0 !== Date.now ? Date.now : function () { return (new Date).getTime() }, eG = function () { function t() { this._tweens = {}, this._tweensAddedDuringUpdate = {} } return t.prototype.getAll = function () { var t = this; return Object.keys(this._tweens).map(function (e) { return t._tweens[e] }) }, t.prototype.removeAll = function () { this._tweens = {} }, t.prototype.add = function (t) { this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t }, t.prototype.remove = function (t) { delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()] }, t.prototype.update = function (t, e) { void 0 === t && (t = tG()), void 0 === e && (e = !1); var n = Object.keys(this._tweens); if (0 === n.length) return !1; for (; n.length > 0;) { this._tweensAddedDuringUpdate = {}; for (var r = 0; r < n.length; r++) { var i = this._tweens[n[r]]; i && !1 === i.update(t, !e) && !e && delete this._tweens[n[r]] } n = Object.keys(this._tweensAddedDuringUpdate) } return !0 }, t }(), nG = { Linear: function (t, e) { var n = t.length - 1, r = n * e, i = Math.floor(r), s = nG.Utils.Linear; return e < 0 ? s(t[0], t[1], r) : e > 1 ? s(t[n], t[n - 1], n - r) : s(t[i], t[i + 1 > n ? n : i + 1], r - i) }, Bezier: function (t, e) { for (var n = 0, r = t.length - 1, i = Math.pow, s = nG.Utils.Bernstein, o = 0; o <= r; o++)n += i(1 - e, r - o) * i(e, o) * t[o] * s(r, o); return n }, CatmullRom: function (t, e) { var n = t.length - 1, r = n * e, i = Math.floor(r), s = nG.Utils.CatmullRom; return t[0] === t[n] ? (e < 0 && (i = Math.floor(r = n * (1 + e))), s(t[(i - 1 + n) % n], t[i], t[(i + 1) % n], t[(i + 2) % n], r - i)) : e < 0 ? t[0] - (s(t[0], t[0], t[1], t[1], -r) - t[0]) : e > 1 ? t[n] - (s(t[n], t[n], t[n - 1], t[n - 1], r - n) - t[n]) : s(t[i ? i - 1 : 0], t[i], t[n < i + 1 ? n : i + 1], t[n < i + 2 ? n : i + 2], r - i) }, Utils: { Linear: function (t, e, n) { return (e - t) * n + t }, Bernstein: function (t, e) { var n = nG.Utils.Factorial; return n(t) / n(e) / n(t - e) }, Factorial: (QU = [1], function (t) { var e = 1; if (QU[t]) return QU[t]; for (var n = t; n > 1; n--)e *= n; return QU[t] = e, e }), CatmullRom: function (t, e, n, r, i) { var s = .5 * (n - t), o = .5 * (r - e), a = i * i; return (2 * e - 2 * n + s + o) * (i * a) + (-3 * e + 3 * n - 2 * s - o) * a + s * i + e } } }, rG = function () { function t() { } return t.nextId = function () { return t._nextId++ }, t._nextId = 0, t }(), iG = new eG, sG = function () { function t(t, e) { void 0 === e && (e = iG), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = $U.Linear.None, this._interpolationFunction = nG.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = rG.nextId(), this._isChainStopped = !1, this._goToEnd = !1 } return t.prototype.getId = function () { return this._id }, t.prototype.isPlaying = function () { return this._isPlaying }, t.prototype.isPaused = function () { return this._isPaused }, t.prototype.to = function (t, e) { return this._valuesEnd = Object.create(t), void 0 !== e && (this._duration = e), this }, t.prototype.duration = function (t) { return this._duration = t, this }, t.prototype.start = function (t) { if (this._isPlaying) return this; if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) for (var e in this._reversed = !1, this._valuesStartRepeat) this._swapEndStartRepeatValues(e), this._valuesStart[e] = this._valuesStartRepeat[e]; return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = void 0 !== t ? "string" == typeof t ? tG() + parseFloat(t) : t : tG(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this }, t.prototype._setupProperties = function (t, e, n, r) { for (var i in n) { var s = t[i], o = Array.isArray(s), a = o ? "array" : typeof s, l = !o && Array.isArray(n[i]); if ("undefined" !== a && "function" !== a) { if (l) { var c = n[i]; if (0 === c.length) continue; c = c.map(this._handleRelativeValue.bind(this, s)), n[i] = [s].concat(c) } if ("object" !== a && !o || !s || l) void 0 === e[i] && (e[i] = s), o || (e[i] *= 1), r[i] = l ? n[i].slice().reverse() : e[i] || 0; else { for (var u in e[i] = o ? [] : {}, s) e[i][u] = s[u]; r[i] = o ? [] : {}, this._setupProperties(s, e[i], n[i], r[i]) } } } }, t.prototype.stop = function () { return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this }, t.prototype.end = function () { return this._goToEnd = !0, this.update(1 / 0), this }, t.prototype.pause = function (t) { return void 0 === t && (t = tG()), this._isPaused || !this._isPlaying || (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this)), this }, t.prototype.resume = function (t) { return void 0 === t && (t = tG()), this._isPaused && this._isPlaying ? (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this) : this }, t.prototype.stopChainedTweens = function () { for (var t = 0, e = this._chainedTweens.length; t < e; t++)this._chainedTweens[t].stop(); return this }, t.prototype.group = function (t) { return this._group = t, this }, t.prototype.delay = function (t) { return this._delayTime = t, this }, t.prototype.repeat = function (t) { return this._initialRepeat = t, this._repeat = t, this }, t.prototype.repeatDelay = function (t) { return this._repeatDelayTime = t, this }, t.prototype.yoyo = function (t) { return this._yoyo = t, this }, t.prototype.easing = function (t) { return this._easingFunction = t, this }, t.prototype.interpolation = function (t) { return this._interpolationFunction = t, this }, t.prototype.chain = function () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return this._chainedTweens = t, this }, t.prototype.onStart = function (t) { return this._onStartCallback = t, this }, t.prototype.onUpdate = function (t) { return this._onUpdateCallback = t, this }, t.prototype.onRepeat = function (t) { return this._onRepeatCallback = t, this }, t.prototype.onComplete = function (t) { return this._onCompleteCallback = t, this }, t.prototype.onStop = function (t) { return this._onStopCallback = t, this }, t.prototype.update = function (t, e) { if (void 0 === t && (t = tG()), void 0 === e && (e = !0), this._isPaused) return !0; var n, r; if (!this._goToEnd && !this._isPlaying) { if (t > this._startTime + this._duration) return !1; e && this.start(t) } if (this._goToEnd = !1, t < this._startTime) return !0; !1 === this._onStartCallbackFired && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), r = (t - this._startTime) / this._duration; var i = this._easingFunction(r = 0 === this._duration || r > 1 ? 1 : r); if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, i), this._onUpdateCallback && this._onUpdateCallback(this._object, r), 1 === r) { if (this._repeat > 0) { for (n in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) this._yoyo || "string" != typeof this._valuesEnd[n] || (this._valuesStartRepeat[n] = this._valuesStartRepeat[n] + parseFloat(this._valuesEnd[n])), this._yoyo && this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n]; return this._yoyo && (this._reversed = !this._reversed), this._startTime = void 0 !== this._repeatDelayTime ? t + this._repeatDelayTime : t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0 } this._onCompleteCallback && this._onCompleteCallback(this._object); for (var s = 0, o = this._chainedTweens.length; s < o; s++)this._chainedTweens[s].start(this._startTime + this._duration); return this._isPlaying = !1, !1 } return !0 }, t.prototype._updateProperties = function (t, e, n, r) { for (var i in n) if (void 0 !== e[i]) { var s = e[i] || 0, o = n[i], a = Array.isArray(t[i]), l = Array.isArray(o); !a && l ? t[i] = this._interpolationFunction(o, r) : "object" == typeof o && o ? this._updateProperties(t[i], s, o, r) : "number" == typeof (o = this._handleRelativeValue(s, o)) && (t[i] = s + (o - s) * r) } }, t.prototype._handleRelativeValue = function (t, e) { return "string" != typeof e ? e : "+" === e.charAt(0) || "-" === e.charAt(0) ? t + parseFloat(e) : parseFloat(e) }, t.prototype._swapEndStartRepeatValues = function (t) { var e = this._valuesStartRepeat[t], n = this._valuesEnd[t]; this._valuesStartRepeat[t] = "string" == typeof n ? this._valuesStartRepeat[t] + parseFloat(n) : this._valuesEnd[t], this._valuesEnd[t] = e }, t }(), oG = iG, aG = (oG.getAll.bind(oG), oG.removeAll.bind(oG), oG.add.bind(oG), oG.remove.bind(oG), oG.update.bind(oG)); class lG { constructor(t) { this.config = t, this.entities = [], this.lights = [], this.then = 0, this.parentElement = document.getElementById(t.canvasId), this.debugHTML = document.getElementById("debug"), this.scene = new VD, this.camera = new vL(t.cameraFOV, this.parentElement.offsetWidth / this.parentElement.offsetHeight, 1, 1e3); const { x: e, y: n, z: r } = t.cameraPosition; this.camera.position.set(e, n, r), this.renderer = new HD({ powerPreference: "high-performance", alpha: !0, antialias: !0, stencil: !0 }), this.renderer.setSize(this.parentElement.offsetWidth, this.parentElement.offsetHeight), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.toneMapping = 4, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = 2, this.parentElement.appendChild(this.renderer.domElement), this.composer = new class { constructor(t = null, { depthBuffer: e = !0, stencilBuffer: n = !1, alpha: r = !1, multisampling: i = 0, frameBufferType: s } = {}) { this.renderer = t, this.inputBuffer = null, this.outputBuffer = null, null !== this.renderer && (this.renderer.autoClear = !1, this.inputBuffer = this.createBuffer(e, n, s, i), this.outputBuffer = this.inputBuffer.clone()), this.copyPass = new ZU(new BU), this.alpha = r, this.depthTexture = null, this.passes = [], this.autoRenderToScreen = !0 } get multisampling() { return this.inputBuffer instanceof eP ? this.inputBuffer.samples : 0 } set multisampling(t) { const e = this.inputBuffer, n = this.multisampling; n > 0 && t > 0 ? (this.inputBuffer.samples = t, this.outputBuffer.samples = t) : n !== t && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, t), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone()) } getRenderer() { return this.renderer } replaceRenderer(t, e = !0) { const n = this.renderer; if (null !== n && n !== t) { const r = n.getSize(new XC), i = t.getSize(new XC), s = n.domElement.parentNode; this.renderer = t, this.renderer.autoClear = !1, r.equals(i) || this.setSize(), e && null !== s && (s.removeChild(n.domElement), s.appendChild(t.domElement)) } return n } createDepthTexture() { const t = this.depthTexture = new GI; return this.inputBuffer.depthTexture = t, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (t.format = _C, t.type = gC) : t.type = pC, t } deleteDepthTexture() { if (null !== this.depthTexture) { this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose(); for (const t of this.passes) t.setDepthTexture(null) } } createBuffer(t, e, n, r) { const i = this.renderer, s = i.getContext(), o = i.getDrawingBufferSize(new XC), a = { format: this.alpha || s.getContextAttributes().alpha || n !== hC ? yC : vC, minFilter: cC, magFilter: cC, stencilBuffer: e, depthBuffer: t, type: n }, l = r > 0 ? new eP(o.width, o.height, a) : new tP(o.width, o.height, a); return r > 0 && (l.samples = r), l.texture.name = "EffectComposer.Buffer", l.texture.generateMipmaps = !1, l } addPass(t, e) { const n = this.passes, r = this.renderer, i = r.getDrawingBufferSize(new XC), s = r.getContext().getContextAttributes().alpha, o = this.inputBuffer.texture.type; if (t.setSize(i.width, i.height), t.initialize(r, s, o), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), t.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== e ? n.splice(e, 0, t) : n.push(t), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), t.needsDepthTexture || null !== this.depthTexture) if (null === this.depthTexture) { const e = this.createDepthTexture(); for (t of n) t.setDepthTexture(e) } else t.setDepthTexture(this.depthTexture) } removePass(t) { const e = this.passes, n = e.indexOf(t); -1 !== n && e.splice(n, 1).length > 0 && (null !== this.depthTexture && (e.reduce((t, e) => t || e.needsDepthTexture, !1) || (t.getDepthTexture() === this.depthTexture && t.setDepthTexture(null), this.deleteDepthTexture())), this.autoRenderToScreen && n === e.length && (t.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0))) } removeAllPasses() { const t = this.passes; this.deleteDepthTexture(), t.length > 0 && (this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !1), this.passes = []) } render(t) { const e = this.renderer, n = this.copyPass; let r, i, s, o = this.inputBuffer, a = this.outputBuffer, l = !1; for (const c of this.passes) c.enabled && (c.render(e, o, a, t, l), c.needsSwap && (l && (n.renderToScreen = c.renderToScreen, r = e.getContext(), i = e.state.buffers.stencil, i.setFunc(r.NOTEQUAL, 1, 4294967295), n.render(e, o, a, t, l), i.setFunc(r.EQUAL, 1, 4294967295)), s = o, o = a, a = s), c instanceof qU ? l = !0 : c instanceof VU && (l = !1)) } setSize(t, e, n) { const r = this.renderer; if (void 0 === t || void 0 === e) { const n = r.getSize(new XC); t = n.width, e = n.height } else r.setSize(t, e, n); const i = r.getDrawingBufferSize(new XC); this.inputBuffer.setSize(i.width, i.height), this.outputBuffer.setSize(i.width, i.height); for (const s of this.passes) s.setSize(i.width, i.height) } reset() { this.dispose(), this.autoRenderToScreen = !0 } dispose() { for (const t of this.passes) t.dispose(); this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose() } }(this.renderer), this.composer.addPass(new WU(this.scene, this.camera)), this.controls = new uN(this.camera, this.renderer.domElement), this.controls.minDistance = 25, this.controls.maxDistance = 300, this.controls.target.set(0, 0, 0), this.controls.enabled = !0, this.controls.enableZoom = !0, this.controls.enablePan = !1, this.controls.autoRotateSpeed = 1, this.controls.update(), this.camera.zoom = t.cameraZoom, this.camera.updateProjectionMatrix(), window.addEventListener("resize", this.onWindowResize.bind(this), !1) } loadScene(t, e) { for (this.callback = e; this.scene.children.length > 0;)this.scene.remove(this.scene.children[0]); this.loadObjects(t.objectConfigs || []), this.createLights(t.lights), t.backgroundColor && (this.scene.background = new PR(t.backgroundColor)), t.fogColor && (this.scene.fog = new GD(t.fogColor, 250, 400)); const { x: n, y: r, z: i } = t.cameraPosition ? t.cameraPosition : this.config.cameraPosition; this.camera.position.set(n, r, i), this.controls.target.set(0, 0, 0), this.controls.autoRotate = t.autoRotate, this.controls.enabled = t.controls, this.camera.zoom = t.cameraZoom || this.config.cameraZoom, this.camera.fov = t.cameraFOV || this.config.cameraFOV, this.camera.updateProjectionMatrix(), this.controls.update() } toggleBackground(t) { this.entities[1].object.visible = t } zoom(t) { var e = this.camera.position, n = new rP(this.config.cameraPosition.x / t, this.config.cameraPosition.y / t, this.config.cameraPosition.z / t); new sG(e).to(n, 1e3).easing($U.Sinusoidal.InOut).onUpdate(() => { this.camera.position.set(e.x, e.y, e.z) }).start() } switchAnimation(t) { this.playAnimation(this.entities[0], t) } scrollRender(t) { let e = .001 * Date.now(); const n = e - this.then; this.then = e, this.composer.render(n), aG(), this.camera.updateProjectionMatrix(), this.controls.update(), this.entities.forEach(e => { e.animationMixer && e.currentClip && e.animationMixer.setTime(e.currentClip.duration * t) }) } loadObjects(t) { let e = 0; t.forEach((n, r) => { n.filePath.includes(".gltf") ? (new nU).load(n.filePath, i => { i.scene.traverse(t => { t instanceof cL && (t.material.metalness = 0) }); const s = this.processLoad(i.scene, n, i.animations); this.entities[r] = s, e++, e === t.length && this.loadComplete() }) : n.filePath.includes(".fbx") ? (new NH).load(n.filePath, i => { const s = this.processLoad(i, n, i.animations); this.entities[r] = s, e++, e === t.length && this.loadComplete() }) : console.error(`${n.filePath} is not a supported file type`) }) } loadComplete() { this.config.scrollControl ? (this.scrollRender(0), setTimeout(() => this.scrollRender(0), 1)) : this.render(Date.now()), this.callback() } processLoad(t, e, n) { this.scene.add(t), t.scale.set(e.scale, e.scale, e.scale), e.position && t.position.set(e.position.x, e.position.y, e.position.z), e.rotation && t.rotation.set(e.rotation.x, e.rotation.y, e.rotation.z), t.traverse(t => { t instanceof cL && (t.castShadow = e.castShadow, t.receiveShadow = e.receiveShadow) }); const r = { object: t, clips: [] }; if (e.animate) { const i = new ZF(t); r.clips = n, r.animationMixer = i, this.playAnimation(r, e.initialAnimation) } return r } createLights(t) { t.forEach(t => { var e, n, r, i, s, o; let a; if ("ambient" === t.type) a = new PF(t.color, t.intensity); else if ("directional" === t.type) a = new CF(t.color, t.intensity), a.castShadow = t.castShadow || !1, a.position.set((null === (e = t.position) || void 0 === e ? void 0 : e.x) || 1, (null === (n = t.position) || void 0 === n ? void 0 : n.y) || 1, (null === (r = t.position) || void 0 === r ? void 0 : r.z) || 1), a.shadow.camera.visible = !0, a.shadow.camera.far = 200, a.shadow.camera.near = 10, a.shadow.mapSize.width = 1024, a.shadow.mapSize.height = 1024, a.shadow.camera.bottom = -30, a.shadow.camera.top = 30, a.shadow.camera.left = -30, a.shadow.camera.right = 30; else if ("point" === t.type) { a = new EF(t.color, t.intensity, 100), a.castShadow = t.castShadow || !1, a.position.set((null === (i = t.position) || void 0 === i ? void 0 : i.x) || 1, (null === (s = t.position) || void 0 === s ? void 0 : s.y) || 1, (null === (o = t.position) || void 0 === o ? void 0 : o.z) || 1); const e = new iN(a, 1); this.scene.add(e) } this.scene.add(a), this.lights.push(a) }) } playAnimation(t, e) { var n, r; null === (n = t.animationMixer) || void 0 === n || n.stopAllAction(), t.currentClip = t.clips[e]; let i = t.currentClip ? null === (r = t.animationMixer) || void 0 === r ? void 0 : r.clipAction(t.currentClip) : null; i && i.play() } onWindowResize() { this.camera.aspect = this.parentElement.offsetWidth / this.parentElement.offsetHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(this.parentElement.offsetWidth, this.parentElement.offsetHeight) } render(t) { const e = (t *= .001) - this.then; this.then = t, this.composer.render(e), aG(), this.camera.updateProjectionMatrix(), this.controls.update(), requestAnimationFrame(this.render.bind(this)), this.entities.forEach(t => { t.animationMixer && !this.config.scrollControl && t.animationMixer.update(e) }), this.debugHTML && (this.debugHTML.innerHTML = `\n            <p>Scene polycount: ${this.renderer.info.render.triangles}</p>\n            <p>Active Drawcalls: ${this.renderer.info.render.calls}</p>\n            <p>Textures in Memory: ${this.renderer.info.memory.textures}</p>\n            <p>Geometries in Memory: ${this.renderer.info.memory.geometries}</p>\n            `) } } function cG(t, e) { if (1 & t) { const t = Go(); Fo(0, "button", 18), Jo("click", function () { const e = Oe(t).index; return Ko(2).playAnimation(e) }), ya(1), No() } if (2 & t) { const t = e.$implicit, n = e.index; aa("active", Ko(2).activeAnimation == n), ns(1), ba(t) } } function uG(t, e) { if (1 & t) { const t = Go(); Ho(0), Fo(1, "a", 7), Fo(2, "p"), ya(3, "Return home "), Bo(4, "img", 8), No(), No(), Fo(5, "div", 9), Fo(6, "p"), ya(7, "Control"), No(), Bo(8, "hr"), Fo(9, "img", 10), Jo("click", function () { return Oe(t), Ko().zoomIn() }), No(), Fo(10, "img", 11), Jo("click", function () { return Oe(t), Ko().zoomOut() }), No(), Bo(11, "hr", 12), Fo(12, "div", 13), Jo("click", function () { return Oe(t), Ko().toggleBackground() }), Bo(13, "div", 14), Fo(14, "p", 15), ya(15, "Background"), Bo(16, "br"), ya(17, "Toggle"), No(), No(), Bo(18, "hr", 12), Fo(19, "div", 16), Jo("click", function () { return Oe(t), Ko().toggleControls() }), Bo(20, "div", 14), Fo(21, "p", 15), ya(22, "Controls"), Bo(23, "br"), ya(24, "Toggle"), No(), No(), No(), Fo(25, "div", 17), Fo(26, "button", 18), Jo("click", function () { return Oe(t), Ko().loadRandomScene() }), ya(27, " Randomise "), Bo(28, "img", 19), No(), No(), Fo(29, "div", 20), Fo(30, "p"), ya(31, "Animate"), No(), Bo(32, "hr"), Lo(33, cG, 2, 3, "button", 21), No(), Uo() } if (2 & t) { const t = Ko(); ns(13), aa("active", t.backgroundActive), ns(7), aa("active", t.controlsActive), ns(13), Io("ngForOf", t.animations) } } function hG(t, e) { 1 & t && Bo(0, "div", 22) } let dG = (() => { class t { constructor(t) { this.http = t, this.hidecontrols = !1, this.debug = !1, this.scenes = [], this.loading = !0, this.animations = [], this.backgroundActive = !0, this.controlsActive = !0, this.activeAnimation = 0, this.activeScene = "", this.rendererConfig = { canvasId: "threejs-viewer", cameraPosition: { x: 150, y: 100, z: 150 }, cameraFOV: 25, cameraZoom: 1.5 } } ngOnInit() { this.renderer = new lG(this.rendererConfig), this.scenepath ? this.http.get(this.scenepath).pipe(Dg(t => { const e = this.modelpaths.split(","); t.objectConfigs.forEach((t, n) => t.filePath = e[n]), this.loadScene(t) })).subscribe() : console.error("Path to scene config was not provided"), this.scrollelementid && (this.rendererConfig.scrollControl = !0, document.addEventListener("scroll", t => this.scrollRender())) } playAnimation(t) { this.activeAnimation = t, this.renderer.switchAnimation(t) } zoomIn() { this.renderer.zoom(4) } zoomOut() { this.renderer.zoom(1) } toggleBackground() { this.backgroundActive = !this.backgroundActive, this.renderer.toggleBackground(this.backgroundActive) } toggleControls() { this.controlsActive = !this.controlsActive } loadScene(t) { this.loading = !0, this.renderer.loadScene(t, () => { var e, n; this.loading = !1, this.animations = (null === (e = t.objectConfigs[0]) || void 0 === e ? void 0 : e.animations) || [], this.activeAnimation = null === (n = t.objectConfigs[0]) || void 0 === n ? void 0 : n.initialAnimation, this.scrollelementid && this.scrollRender() }) } scrollRender() { var t; const e = null === (t = document.getElementById(this.scrollelementid)) || void 0 === t ? void 0 : t.getBoundingClientRect(); if (e) { const t = e.height - window.innerHeight, n = .97 * Math.abs(e.top / t); e.top <= 0 && e.bottom > window.innerHeight && this.renderer.scrollRender(n) } } } return t.\u0275fac = function (e) { return new (e || t)(Do(bM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-model-viewer"]], inputs: { modelpaths: "modelpaths", scenepath: "scenepath", hidecontrols: "hidecontrols", scrollelementid: "scrollelementid", debug: "debug" }, decls: 12, vars: 6, consts: [["id", "threejs-viewer", 1, "viewer", "bg-tan"], [4, "ngIf"], [1, "loading", "bg-tan"], [1, "dot"], [1, "dot", 2, "animation-delay", "100ms"], [1, "dot", 2, "animation-delay", "200ms"], ["id", "debug", 4, "ngIf"], ["href", "/", 1, "home", "panel", "control"], ["src", "assets/icons/home.svg"], [1, "panel", "controls"], ["src", "assets/icons/plus.svg", 1, "viewer-button", "control", 3, "click"], ["src", "assets/icons/minus.svg", 1, "viewer-button", "control", 3, "click"], [1, "control"], [1, "toggle-container", "control", 3, "click"], [1, "toggle"], [1, "toggle-label"], [1, "toggle-container", 3, "click"], [1, "scene-picker", "control"], [3, "click"], ["src", "assets/icons/randomise.svg"], [1, "panel", "animations", "control"], [3, "active", "click", 4, "ngFor", "ngForOf"], ["id", "debug"]], template: function (t, e) { 1 & t && (Fo(0, "div", 0), Lo(1, uG, 34, 5, "ng-container", 1), Fo(2, "div", 2), Fo(3, "h1"), ya(4, "Loading"), Fo(5, "span", 3), ya(6, "."), No(), Fo(7, "span", 4), ya(8, "."), No(), Fo(9, "span", 5), ya(10, "."), No(), No(), No(), No(), Lo(11, hG, 1, 0, "div", 6)), 2 & t && (aa("hide-controls", !e.controlsActive), ns(1), Io("ngIf", !e.hidecontrols), ns(1), aa("hide", !e.loading), ns(9), Io("ngIf", e.debug)) }, directives: [th, Qu], styles: ['.viewer{position:sticky;top:0;height:100vh;width:100%;font-family:Work Sans,Arial,sans-serif}.viewer.hide-controls .control{display:none}.viewer .viewer-button,.viewer button{cursor:pointer;transition:all .25s}.viewer .viewer-button:hover,.viewer button:hover{transform:scale(1.1)}.viewer .viewer-button:active,.viewer button:active{transform:scale(1)}.viewer button{border-radius:20px;background-color:#fff;color:#999;outline:none;-webkit-appearance:none;border:none;padding:10px 15px;font-weight:700;font-size:10px;text-transform:uppercase}.viewer button.active{background-color:#ff8000;color:#fff}.viewer hr{width:100%;border:none;border-top:1px solid #fff}.viewer .controls{height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;left:60px;top:0;bottom:0;margin:auto 0;flex-direction:column}.viewer .controls,.viewer .scene-picker{position:absolute;display:flex;justify-content:center;align-items:center}.viewer .scene-picker{width:100%;left:0;bottom:60px}.viewer .scene-picker button{display:flex;align-items:center;color:#ff8000}.viewer .scene-picker button img{margin-left:10px}.viewer .animations{height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;right:60px;bottom:0;margin:auto 0;align-items:stretch}.viewer .animations,.viewer .loading{position:absolute;top:0;display:flex;flex-direction:column;justify-content:center}.viewer .loading{left:0;z-index:2;width:100%;height:100%;align-items:center;opacity:1}.viewer .loading.hide{transition:all 1s;transition-delay:.5s;opacity:0;visibility:hidden}.viewer .loading img{width:200px}.viewer .loading h1{color:#ff8000;font-family:Arial,Helvetica,sans-serif;font-weight:700;text-transform:uppercase;font-size:2.5rem;font-weight:900}.viewer .loading .dot{display:inline-block;animation:bounce 1s ease-in-out infinite}.viewer canvas{cursor:grab}.viewer canvas:active{cursor:grabbing}.viewer .panel{border:1px solid #fff;padding:10px 15px;border-radius:20px;overflow:hidden;text-transform:uppercase;text-align:center;color:#fff;font-size:14px;font-weight:700;font-family:inherit}.viewer .panel>*{margin:10px 0;position:relative;z-index:1}.viewer .panel:before{content:" ";background-color:#0000001a;-webkit-backdrop-filter:blur(5px);backdrop-filter:blur(5px);position:absolute;top:0;left:0;width:100%;height:100%;z-index:0}.viewer .home{display:block;position:absolute;margin:0 auto;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;top:60px;left:0;right:0;border-radius:50px;cursor:pointer;text-decoration:none}.viewer .home p{margin:0;display:flex;align-items:center;font-size:10px;padding:0 10px}.viewer .home img{margin-left:10px;width:20px}.viewer .toggle-container{display:flex;flex-direction:column;align-items:center}.viewer .toggle-container .toggle{cursor:pointer;background:#ffffff4d;border-radius:20px;width:46px}.viewer .toggle-container .toggle:after{content:" ";display:block;background:#fff;border-radius:inherit;height:20px;width:20px;transform:translateX(26px);transition:all .25s}.viewer .toggle-container .toggle.active:after{transform:translateX(0);background-color:#ff8000}.viewer .toggle-container .toggle-label{font-size:10px;text-align:center;margin:10px 0 0;line-height:1.2em}#debug{position:absolute;top:15px;left:15px;background:#000;color:lime}@keyframes bounce{0%{transform:translateY(0)}20%{transform:translateY(-10px)}40%{transform:translateY(0)}to{transform:translateY(0)}}'], encapsulation: 2 }), t })(); function pG(t, e) { if (1 & t && (Fo(0, "div", 23), ya(1), Fo(2, "span", 21), ya(3), No(), No()), 2 & t) { const t = e.ngIf; ns(1), _a("", t.value, " "), ns(2), ba(t.trait_count) } } function fG(t, e) { if (1 & t && (Fo(0, "div", 19), Fo(1, "div", 20), ya(2), No(), Fo(3, "div", 10), ya(4), Fo(5, "span", 21), ya(6), No(), No(), Lo(7, pG, 4, 2, "div", 22), No()), 2 & t) { const t = e.$implicit, n = Ko(2).ngIf, r = Ko(); ns(2), ba(t.trait_type), ns(2), _a("", t.value, " "), ns(2), ba(t.trait_count), ns(1), Io("ngIf", r.getColor(t.trait_type, n.asset.traits)) } } function mG(t, e) { if (1 & t && (Fo(0, "div", 24), Bo(1, "img", 25), Fo(2, "p", 26), ya(3), No(), No()), 2 & t) { const t = e.ngIf; ns(1), Io("src", t.profile_img_url, si), ns(2), ba(null == t.user ? null : t.user.username) } } function gG(t, e) { if (1 & t && (Ho(0), Fo(1, "h3", 12), ya(2, "Trait"), No(), Lo(3, fG, 8, 4, "div", 13), Fo(4, "h3", 14), ya(5, "Download Files"), No(), Fo(6, "a", 15), Fo(7, "ga-button", 16), ya(8, "Download PNG"), No(), No(), Fo(9, "a", 17), Fo(10, "ga-button", 16), ya(11, "Download FBX"), No(), No(), Fo(12, "h3", 14), ya(13, "Owned By"), No(), Lo(14, mG, 4, 2, "div", 18), Uo()), 2 & t) { const t = Ko().ngIf, e = Ko(); ns(3), Io("ngForOf", e.filterOutColor(null == t.asset ? null : t.asset.traits)), ns(3), Io("href", t.metadata.image, si), ns(3), Io("href", t.metadata.model, si), ns(5), Io("ngIf", t.asset.owner) } } function vG(t, e) { if (1 & t) { const t = Go(); Fo(0, "div", 27), Bo(1, "ga-model-viewer", 28), Fo(2, "img", 29), Jo("click", function () { return Oe(t), Ko(2).toggleModel() }), No(), No() } if (2 & t) { const t = Ko().ngIf; ns(1), Io("modelpaths", t.metadata.model) } } function yG(t, e) { if (1 & t) { const t = Go(); Ho(0), Fo(1, "div", 5), Fo(2, "div", 6), Jo("click", function () { return Oe(t), Ko().toggleModel() }), Bo(3, "img", 7), Bo(4, "img", 8), No(), Fo(5, "div", 9), Fo(6, "h5", 10), ya(7), No(), Fo(8, "h2"), ya(9), No(), Lo(10, gG, 15, 4, "ng-container", 4), No(), No(), Lo(11, vG, 3, 1, "div", 11), Uo() } if (2 & t) { const t = e.ngIf, n = Ko(); ns(4), Io("src", t.metadata.image, si), ns(3), _a("#", t.index, ""), ns(2), ba((null == t.asset ? null : t.asset.name) || "Unknown"), ns(1), Io("ngIf", 0 != t.metadata.attributes.length), ns(1), Io("ngIf", n.modelVisible) } } let bG = (() => { class t { constructor(t, e, n, r, i, s) { this.blockchain = t, this.route = e, this.contentService = n, this.loadingService = r, this.opensea = i, this.gaService = s, this.index$ = this.route.params.pipe(xM("index")), this.slug$ = this.route.params.pipe(xM("slug")), this.drop$ = this.slug$.pipe(V(t => this.contentService.getDrop(t))), this.metadata$ = this.drop$.pipe(TM(this.index$), V(([t, e]) => this.blockchain.getVoxMetadata(t.address, bE.O$.from(e)))), this.asset$ = this.drop$.pipe(TM(this.index$), V(([t, e]) => this.opensea.getAsset(t.address, parseInt(e))), yg(() => id([]))), this.$data = this.loadingService.watch(this.metadata$, this.drop$, this.asset$, this.index$).pipe(P(([t, e, n, r]) => ({ metadata: t, drop: e, asset: n, index: r }))), this.modelVisible = !1 } toggleModel() { this.modelVisible = !this.modelVisible, this.modelVisible && this.gaService.eventEmitter("Detail Component", "View Model") } filterOutColor(t) { if (t) return t.filter(t => 0 == t.trait_type.includes("Color")) } getColor(t, e) { if (e && t) return e.filter(e => `${t} Color` == e.trait_type)[0] } } return t.\u0275fac = function (e) { return new (e || t)(Do(zE), Do(Xv), Do(ZE), Do(vM), Do(_M), Do(gM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-detail"]], decls: 7, vars: 3, consts: [[1, "border-b", "border-gray-light", "py-8", "px-12"], ["routerLink", "/profile/collection", 1, "flex"], ["src", "assets/small-arrow.svg", 1, "mr-2"], [1, "h5"], [4, "ngIf"], [1, "detail-wrapper", "flex", "flex-col", "lg:flex-row"], [1, "relative", "cursor-pointer", "model-image", "flex", "items-center", "bg-tan", 3, "click"], ["src", "assets/icons/icon-expand.svg", 1, "absolute", "right-8", "top-8"], [1, "w-full", 3, "src"], [1, "h-full", "bg-gray-lightest", "p-12", "flex-grow"], [1, "text-primary"], ["class", "viewer", 4, "ngIf"], [1, "mt-8", "mb-4"], ["class", "bg-white p-3 rounded-sm mb-2 max-w-screen-md flex", 4, "ngFor", "ngForOf"], [1, "mt-8"], ["target", "_blank", 1, "inline-block", "mt-4", "mr-4", 3, "href"], ["variant", "outline", "color", "primary"], ["target", "_blank", 1, "inline-block", "mt-4", 3, "href"], ["class", "flex items-center", 4, "ngIf"], [1, "bg-white", "p-3", "rounded-sm", "mb-2", "max-w-screen-md", "flex"], [1, "flex-grow"], [1, "trait-count"], ["class", "text-primary ml-8", 4, "ngIf"], [1, "text-primary", "ml-8"], [1, "flex", "items-center"], [1, "rounded-full", "h-8", 3, "src"], [1, "text-primary", "ml-4"], [1, "viewer"], ["scenepath", "assets/json/inspect-scene.json", "hidecontrols", "true", 3, "modelpaths"], ["src", "assets/icons/icon-close.svg", 1, "absolute", "right-8", "top-8", "cursor-pointer", "h-8", 3, "click"]], template: function (t, e) { 1 & t && (Fo(0, "div", 0), Fo(1, "a", 1), Bo(2, "img", 2), Fo(3, "span", 3), ya(4, " Back to My Collection"), No(), No(), No(), Lo(5, yG, 12, 5, "ng-container", 4), Zl(6, "async")), 2 & t && (ns(5), Io("ngIf", Kl(6, 1, e.$data))) }, directives: [gb, th, Qu, QE, dG], pipes: [hh], styles: [".image[_ngcontent-%COMP%]{background-repeat:no-repeat;background-size:contain;background-position:50%}.container[_ngcontent-%COMP%]{padding-top:1rem;padding-bottom:1rem}.viewer[_ngcontent-%COMP%]{position:fixed;top:0;left:0;height:100vh;width:100vw}.trait-count[_ngcontent-%COMP%]{display:inline-block;padding-left:.25rem;padding-right:.25rem;margin-left:.5rem;border-radius:.375rem;border-width:1px;border-color:#fee0c3;background-color:#fef1e5;font-size:.75rem;line-height:1.25em}@media (min-width:1024px){.model-image[_ngcontent-%COMP%]{max-width:40%}}"] }), t })(); function _G(t, e) { if (1 & t && (Fo(0, "div", 1), Fo(1, "h1"), ya(2), No(), Bo(3, "div", 2), No()), 2 & t) { const t = e.ngIf; ns(2), ba(t.title), ns(1), Io("innerHTML", t.content, ii) } } const wG = n(4585); let SG = (() => { class t { constructor(t, e) { this.contentService = t, this.loadingService = e, this.data$ = this.contentService.getTermsAndConditions(), this.loaded$ = this.loadingService.watch(this.data$).pipe(P(([t]) => { const e = wG({ blocks: t[0].content }); return { title: t[0].title, content: e } })) } } return t.\u0275fac = function (e) { return new (e || t)(Do(ZE), Do(vM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-terms-conditions"]], decls: 2, vars: 3, consts: [["class", "container terms-conditions", 4, "ngIf"], [1, "container", "terms-conditions"], [3, "innerHTML"]], template: function (t, e) { 1 & t && (Lo(0, _G, 4, 2, "div", 0), Zl(1, "async")), 2 & t && Io("ngIf", Kl(1, 1, e.loaded$)) }, directives: [th], pipes: [hh], styles: [""] }), t })(), xG = (() => { class t { constructor(t, e, n) { this.route = t, this.content = e, this.blockchain = n, this.slug$ = this.route.params.pipe(xM("slug")), this.drop$ = this.slug$.pipe(V(t => this.content.getDrop(t)), u_()), this.ethBalance$ = this.drop$.pipe(V(t => this.blockchain.getEthBalance(t.address))), this.linkBalance$ = this.drop$.pipe(V(t => this.blockchain.getLinkBalance(t.address))), this.contract$ = this.drop$.pipe(V(t => zE.getWritableVoxContract(t.address))) } ngOnInit() { } withdraw() { this.contract$.subscribe(t => t.withdraw()) } reveal() { this.contract$.subscribe(t => t.reveal()) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Xv), Do(ZE), Do(zE)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-admin"]], decls: 14, vars: 10, consts: [[1, "flex", "flex-col"], [1, "flex", "items-center", "py-16", "drop-image"], ["color", "primary", "variant", "outline", 3, "click"]], template: function (t, e) { 1 & t && (Fo(0, "div", 0), ya(1), Zl(2, "bigNumber"), Zl(3, "async"), Bo(4, "br"), ya(5), Zl(6, "bigNumber"), Zl(7, "async"), Bo(8, "br"), Fo(9, "div", 1), Fo(10, "ga-button", 2), Jo("click", function () { return e.withdraw() }), ya(11, " Withdraw "), No(), Fo(12, "ga-button", 2), Jo("click", function () { return e.reveal() }), ya(13, " REVEAL! "), No(), No(), No()), 2 & t && (ns(1), _a(" Contract ETH Balance ", Kl(2, 2, Kl(3, 4, e.ethBalance$)), ""), ns(4), _a(" Contract LINK Balance ", Kl(6, 6, Kl(7, 8, e.linkBalance$)), "")) }, directives: [QE], pipes: [AM, hh], styles: [""] }), t })(); function TG(t) { const { start: e, index: n, count: r, subscriber: i } = t; n >= r ? i.complete() : (i.next(e), i.closed || (t.index = n + 1, t.start = e + 1, this.schedule(t))) } function EG(t, e) { 1 & t && (Fo(0, "div", 10), Fo(1, "mat-icon"), ya(2, "done"), No(), ya(3, " Provenance verified "), No()) } function MG(t, e) { if (1 & t && (Fo(0, "div", 3), Fo(1, "p", 4), ya(2, " Calculated Provenance Hash "), No(), ya(3), Lo(4, EG, 4, 0, "div", 9), Zl(5, "async"), No()), 2 & t) { const t = e.ngIf, n = Ko(); ns(3), _a(" ", t, " "), ns(1), Io("ngIf", t === Kl(5, 2, n.provenanceHash$)) } } let AG = (() => { class t { constructor(t, e, n) { this.route = t, this.content = e, this.blockchain = n, this.downloaded = 0, this.log = "", this.slug$ = this.route.params.pipe(xM("slug")), this.drop$ = this.slug$.pipe(V(t => this.content.getDrop(t)), u_()), this.contract$ = this.drop$.pipe(P(t => zE.getReadOnlyVoxContract(t.address)), u_()), this.supply$ = this.contract$.pipe(V(t => t.maxSupply())), this.provenanceHash$ = this.contract$.pipe(V(t => t.PROVENANCE())), this.offset$ = this.contract$.pipe(V(t => t.offset())), this.provenance$ = ig([this.drop$, this.supply$, this.offset$, this.provenanceHash$]).pipe(V(([t, e, n, r]) => { this.addLog(`Reading from contract ${t.address}`); const i = +_E.formatUnits(e, 0), s = +_E.formatUnits(n, 0); return this.addLog(`Read supply of ${i}`), this.addLog(`Read provenance of ${r}`), this.addLog(`Read offset of ${s}`), function (t = 0, e, n) { return new w(r => { void 0 === e && (e = t, t = 0); let i = 0, s = t; if (n) return n.schedule(TG, 0, { index: i, count: e, start: t, subscriber: r }); for (; ;) { if (i++ >= e) { r.complete(); break } if (r.next(s++), r.closed) break } }) }(0, i).pipe(V(e => B(this.blockchain.getVoxMetadata(t.address, _E.parseUnits(e.toString(), 0))).pipe(Dg(() => this.downloaded++), Dg(t => this.addLog(`Downloaded ${t.uri} (${t.raw.byteLength} byte(s))`)), V(t => vE(this, void 0, void 0, function* () { return { tokenId: (e + s) % i, hash: zE.buf2hex(yield crypto.subtle.digest("SHA-256", t.raw)) } })), Dg(t => this.addLog(`Hashed ${t.tokenId} to ${t.hash}`)))), SA(), Dg(t => t.sort((t, e) => t.tokenId - e.tokenId)), V(t => vE(this, void 0, void 0, function* () { const e = t.map(t => t.hash).join(""); this.addLog(`Concatenated full provenance string ${e}`); const n = new TextEncoder, r = zE.buf2hex(yield crypto.subtle.digest("SHA-256", n.encode(e))); return this.addLog(`Hashed final proof ${r}`), r }))) })) } addLog(t) { this.log += t + "\n" } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t)(Do(Xv), Do(ZE), Do(zE)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-provenance"]], decls: 33, vars: 14, consts: [[1, "flex", "flex-col"], [1, "mat-elevation-z16", "flex-grow", "bg-gray-lightest"], [1, "bidding-control-container", "mt-8", "lg:mt-0"], [1, "md:col-span-2", "items-center"], [1, "h5"], [1, "font-mono"], [1, "blockquote", "text-primary"], [1, "overflow-scroll", "max-h-60"], ["class", "md:col-span-2 items-center", 4, "ngIf"], ["class", "flex items-center", 4, "ngIf"], [1, "flex", "items-center"]], template: function (t, e) { 1 & t && (Fo(0, "div", 0), Fo(1, "div", 1), Fo(2, "div", 2), Fo(3, "div", 3), Fo(4, "p", 4), ya(5, " Provenance Hash from Contract "), No(), Fo(6, "pre", 5), ya(7), Zl(8, "async"), No(), No(), Fo(9, "div"), Fo(10, "p", 4), ya(11, "Reveal offset"), No(), Fo(12, "p", 6), ya(13), Zl(14, "async"), No(), No(), Fo(15, "div"), Fo(16, "p", 4), ya(17, "Supply"), No(), Fo(18, "p", 6), ya(19), Zl(20, "async"), No(), No(), Fo(21, "div"), Fo(22, "p", 4), ya(23, "Metadata Downloaded"), No(), Fo(24, "p", 6), ya(25), No(), No(), Fo(26, "div"), Fo(27, "p", 4), ya(28, "Log"), No(), Fo(29, "pre", 7), ya(30), No(), No(), Lo(31, MG, 6, 4, "div", 8), Zl(32, "async"), No(), No(), No()), 2 & t && (ns(7), ba(Kl(8, 6, e.provenanceHash$)), ns(6), _a(" ", Kl(14, 8, e.offset$), " "), ns(6), _a(" ", Kl(20, 10, e.supply$), " "), ns(6), _a(" ", e.downloaded, " "), ns(5), ba(e.log), ns(1), Io("ngIf", Kl(32, 12, e.provenance$))) }, directives: [th, dE], pipes: [hh], styles: ["mat-icon[_ngcontent-%COMP%]{color:#2dcb48}"] }), t })(); function CG(t, e) { if (1 & t && (Fo(0, "div", 15), Fo(1, "span", 16), ya(2), No(), No()), 2 & t) { const t = e.$implicit; oa("background-color", t.value), ns(2), _a(" ", t.name, " ") } } function PG(t, e) { if (1 & t && (Fo(0, "div", 13), Fo(1, "p"), ya(2), No(), Fo(3, "div", 13), Lo(4, CG, 3, 3, "div", 14), No(), No()), 2 & t) { const t = e.$implicit; ns(2), wa("", t.trait_type, ": ", t.value, ""), ns(2), Io("ngForOf", t.colors) } } function RG(t, e) { if (1 & t) { const t = Go(); Ho(0), Fo(1, "ga-button", 5), Jo("click", function () { return Oe(t), Ko().nav(-1) }), ya(2, " \ud83d\udc48 "), No(), Fo(3, "ga-button", 5), Jo("click", function () { return Oe(t), Ko().nav(1) }), ya(4, " \ud83d\udc49 "), No(), Fo(5, "div", 6), Fo(6, "div", 7), Bo(7, "ga-model-viewer", 8), No(), Fo(8, "div", 9), Bo(9, "img", 10), No(), Fo(10, "div", 11), Fo(11, "h2"), ya(12), No(), Fo(13, "h5"), ya(14, "Attributes"), No(), Lo(15, PG, 5, 3, "div", 12), No(), No(), Uo() } if (2 & t) { const t = e.ngIf; ns(7), Io("modelpaths", t.model), ns(2), Io("src", t.image, si), ns(3), ba(t.metadata.name), ns(3), Io("ngForOf", t.metadata.attributes) } } let LG = (() => { class t { constructor(t, e, n, r, i) { this.route = t, this.loadingService = e, this.http = n, this.router = r, this.snackBar = i, this.index$ = this.route.params.pipe(xM("index")), this.slug$ = this.route.params.pipe(xM("slug")), this.metadata$ = this.index$.pipe(V(t => this.http.get("" + t).pipe(yg(() => (this.snackBar.error(`Error downloading metadata for ${t}`), Xd))))), this.model$ = this.index$.pipe(P(t => `${t}.fbx`)), this.image$ = this.index$.pipe(P(t => `${t}.png`)), this.$data = this.loadingService.watch(this.metadata$, this.model$, this.image$).pipe(P(([t, e, n]) => ({ metadata: t, model: e, image: n }))), this.modelVisible = !1 } nav(t) { this.index$.pipe(Lg()).subscribe(e => this.router.navigate(["/town-star/debug", +e + t])) } toggleModel() { this.modelVisible = !this.modelVisible } } return t.\u0275fac = function (e) { return new (e || t)(Do(Xv), Do(vM), Do(Ad), Do(fb), Do(iM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-debug"]], decls: 7, vars: 3, consts: [[1, "border-b", "border-gray-light", "py-8", "px-12"], ["routerLink", "/profile/collection", 1, "flex"], ["src", "assets/small-arrow.svg", 1, "mr-2"], [1, "h5"], [4, "ngIf"], ["color", "secondary", "variant", "outline", 1, "mr-4", 3, "click"], [1, "detail-wrapper", "flex", "flex-col", "lg:flex-row"], [1, "w-4/12"], ["scenepath", "assets/json/inspect-scene.json", "hidecontrols", "true", 3, "modelpaths"], [1, "w-3/12"], [2, "width", "350px", "height", "350px", 3, "src"], [1, "w-5/12", "h-full", "bg-gray-lightest", "pl-12", "flex-grow", "overflow-scroll"], ["class", "flex items-center", 4, "ngFor", "ngForOf"], [1, "flex", "items-center"], ["class", "px-2 ml-2", 3, "background-color", 4, "ngFor", "ngForOf"], [1, "px-2", "ml-2"], [2, "color", "#ddd"]], template: function (t, e) { 1 & t && (Fo(0, "div", 0), Fo(1, "a", 1), Bo(2, "img", 2), Fo(3, "span", 3), ya(4, " Back to My Collection"), No(), No(), No(), Lo(5, RG, 16, 4, "ng-container", 4), Zl(6, "async")), 2 & t && (ns(5), Io("ngIf", Kl(6, 1, e.$data))) }, directives: [gb, th, QE, dG, Qu], pipes: [hh], styles: [".image[_ngcontent-%COMP%]{background-repeat:no-repeat;background-size:contain;background-position:50%}.container[_ngcontent-%COMP%]{padding-top:1rem;padding-bottom:1rem}.attributes[_ngcontent-%COMP%]{display:grid;grid-template-columns:-webkit-max-content auto;grid-template-columns:max-content auto;grid-row-gap:1rem;grid-column-gap:2rem}.image-wrapper[_ngcontent-%COMP%]{position:relative;height:100vw;width:100vw}@media (min-width:1024px){.detail-wrapper[_ngcontent-%COMP%]{height:80vh}.image-wrapper[_ngcontent-%COMP%]{height:80vh;width:80vh}}.viewer[_ngcontent-%COMP%]{position:fixed;top:0;left:0;height:100vh;width:100vw}"] }), t })(); const kG = ["*", [["mat-card-footer"]]], DG = ["*", "mat-card-footer"]; let IG = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["mat-card-content"], ["", "mat-card-content", ""], ["", "matCardContent", ""]], hostAttrs: [1, "mat-card-content"] }), t })(), OG = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["", "mat-card-image", ""], ["", "matCardImage", ""]], hostAttrs: [1, "mat-card-image"] }), t })(), FG = (() => { class t { constructor(t) { this._animationMode = t } } return t.\u0275fac = function (e) { return new (e || t)(Do(qm, 8)) }, t.\u0275cmp = Jt({ type: t, selectors: [["mat-card"]], hostAttrs: [1, "mat-card", "mat-focus-indicator"], hostVars: 2, hostBindings: function (t, e) { 2 & t && aa("_mat-animation-noopable", "NoopAnimations" === e._animationMode) }, exportAs: ["matCard"], ngContentSelectors: DG, decls: 2, vars: 0, template: function (t, e) { 1 & t && (Qo(kG), $o(0), $o(1, 1)) }, styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions:not(.mat-card-actions-align-end) .mat-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-raised-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-actions-align-end .mat-button:last-child,.mat-card-actions-align-end .mat-raised-button:last-child,.mat-card-actions-align-end .mat-stroked-button:last-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"], encapsulation: 2, changeDetection: 0 }), t })(); const NG = function (t, e) { return ["/", t, e] }; function BG(t, e) { if (1 & t && (Ho(0), Fo(1, "mat-card"), Bo(2, "img", 1), Zl(3, "async"), Fo(4, "mat-card-content", 2), Fo(5, "div", 3), Fo(6, "h5", 4), ya(7), No(), Fo(8, "h2", 5), ya(9), No(), Fo(10, "ga-button", 6), Zl(11, "bigNumber"), ya(12, " View VOX "), No(), No(), No(), No(), Uo()), 2 & t) { const t = e.ngIf, s = Ko(); ns(2), Io("src", Kl(3, 6, s.image$), si)("alt", t.name), ns(5), _a("#", null != t.id ? t.id : "????", ""), ns(2), _a(" ", t.name, " "), ns(1), Io("disabled", null == t.id)("routerLink", (11, n = NG, r = s.slug, i = Yl(11, 8, s.nft, 0), ql(De(), ze(), 11, n, r, i, undefined))) } var n, r, i } let HG = (() => { class t { constructor(t) { this.blockchain = t } ngOnInit() { this.metadata$ = cg(() => this.blockchain.getVoxMetadata(this.address, this.nft)), this.image$ = this.metadata$.pipe(P(t => t.uri)) } } return t.\u0275fac = function (e) { return new (e || t)(Do(zE)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-nft-card"]], inputs: { address: "address", slug: "slug", nft: "nft" }, decls: 2, vars: 3, consts: [[4, "ngIf"], ["mat-card-image", "", 1, "object-cover", 3, "src", "alt"], [1, "h-34"], [1, "text-center"], [1, "text-primary"], [1, "blockquote", "mb-4"], ["color", "primary", 3, "disabled", "routerLink"]], template: function (t, e) { 1 & t && (Lo(0, BG, 13, 14, "ng-container", 0), Zl(1, "async")), 2 & t && Io("ngIf", Kl(1, 1, e.metadata$)) }, directives: [th, FG, OG, IG, QE, mb], pipes: [hh, AM], styles: [""] }), t })(); function UG(t, e) { if (1 & t && Bo(0, "ga-nft-card", 5), 2 & t) { const t = e.$implicit; Io("address", t.address)("slug", t.slug)("nft", t.token) } } function GG(t, e) { 1 & t && (Fo(0, "div", 6), Fo(1, "h3"), ya(2, "Nothing in collection"), No(), No()) } function VG(t, e) { if (1 & t && (Ho(0), Fo(1, "div", 1), Fo(2, "div", 2), Lo(3, UG, 1, 3, "ga-nft-card", 3), No(), Lo(4, GG, 3, 0, "div", 4), No(), Uo()), 2 & t) { const t = e.ngIf; ns(3), Io("ngForOf", t.nfts), ns(1), Io("ngIf", 0 === t.nfts.length) } } let zG = (() => { class t { constructor(t, e, n) { this.content = t, this.blockchain = e, this.loadingService = n, this.icon = "assets/icons/icon-empty-collection.svg", this.nfts$ = this.content.getContracts().pipe(V(t => t), V(t => B(this.blockchain.getVoxByOwner(t.address)).pipe(V(t => t), P(e => Object.assign({ token: e }, t)))), SA()), this.data$ = this.loadingService.watch(this.nfts$).pipe(P(([t]) => ({ nfts: t }))) } } return t.\u0275fac = function (e) { return new (e || t)(Do(ZE), Do(zE), Do(vM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-my-collection"]], decls: 2, vars: 3, consts: [[4, "ngIf"], [1, "collection-wrapper", "flex-grow", "py-12", "min-h-screen-3/4"], [1, "section", "grid", "gala-grid-md"], [3, "address", "slug", "nft", 4, "ngFor", "ngForOf"], ["class", "text-center", 4, "ngIf"], [3, "address", "slug", "nft"], [1, "text-center"]], template: function (t, e) { 1 & t && (Lo(0, VG, 5, 2, "ng-container", 0), Zl(1, "async")), 2 & t && Io("ngIf", Kl(1, 1, e.data$)) }, directives: [th, Qu, HG], pipes: [hh], styles: [".selection-border[_ngcontent-%COMP%]{border:1px solid var(--light-color)}"] }), t })(); const jG = ["*"], JG = ["tabListContainer"], XG = ["tabList"], WG = ["nextPaginator"], qG = ["previousPaginator"], ZG = ["mat-tab-nav-bar", ""], KG = new Kn("MatInkBarPositioner", { providedIn: "root", factory: function () { return t => ({ left: t ? (t.offsetLeft || 0) + "px" : "0", width: t ? (t.offsetWidth || 0) + "px" : "0" }) } }); let YG = (() => { class t { constructor(t, e, n, r) { this._elementRef = t, this._ngZone = e, this._inkBarPositioner = n, this._animationMode = r } alignToElement(t) { this.show(), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => this._setStyles(t)) }) : this._setStyles(t) } show() { this._elementRef.nativeElement.style.visibility = "visible" } hide() { this._elementRef.nativeElement.style.visibility = "hidden" } _setStyles(t) { const e = this._inkBarPositioner(t), n = this._elementRef.nativeElement; n.style.left = e.left, n.style.width = e.width } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(Vc), Do(KG), Do(qm, 8)) }, t.\u0275dir = Yt({ type: t, selectors: [["mat-ink-bar"]], hostAttrs: [1, "mat-ink-bar"], hostVars: 2, hostBindings: function (t, e) { 2 & t && aa("_mat-animation-noopable", "NoopAnimations" === e._animationMode) } }), t })(); const QG = __({ passive: !0 }); let $G = (() => { class t { constructor(t, e, n, r, i, s, o) { this._elementRef = t, this._changeDetectorRef = e, this._viewportRuler = n, this._dir = r, this._ngZone = i, this._platform = s, this._animationMode = o, this._scrollDistance = 0, this._selectedIndexChanged = !1, this._destroyed = new M, this._showPaginationControls = !1, this._disableScrollAfter = !0, this._disableScrollBefore = !0, this._stopScrolling = new M, this.disablePagination = !1, this._selectedIndex = 0, this.selectFocusedIndex = new ec, this.indexFocused = new ec, i.runOutsideAngular(() => { zb(t.nativeElement, "mouseleave").pipe(a_(this._destroyed)).subscribe(() => { this._stopInterval() }) }) } get selectedIndex() { return this._selectedIndex } set selectedIndex(t) { t = Hb(t), this._selectedIndex != t && (this._selectedIndexChanged = !0, this._selectedIndex = t, this._keyManager && this._keyManager.updateActiveItem(t)) } ngAfterViewInit() { zb(this._previousPaginator.nativeElement, "touchstart", QG).pipe(a_(this._destroyed)).subscribe(() => { this._handlePaginatorPress("before") }), zb(this._nextPaginator.nativeElement, "touchstart", QG).pipe(a_(this._destroyed)).subscribe(() => { this._handlePaginatorPress("after") }) } ngAfterContentInit() { const t = this._dir ? this._dir.change : id("ltr"), e = this._viewportRuler.change(150), n = () => { this.updatePagination(), this._alignInkBarToSelectedTab() }; this._keyManager = new Pw(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap(), this._keyManager.updateActiveItem(this._selectedIndex), "undefined" != typeof requestAnimationFrame ? requestAnimationFrame(n) : n(), W(t, e, this._items.changes).pipe(a_(this._destroyed)).subscribe(() => { this._ngZone.run(() => Promise.resolve().then(n)), this._keyManager.withHorizontalOrientation(this._getLayoutDirection()) }), this._keyManager.change.pipe(a_(this._destroyed)).subscribe(t => { this.indexFocused.emit(t), this._setTabFocus(t) }) } ngAfterContentChecked() { this._tabLabelCount != this._items.length && (this.updatePagination(), this._tabLabelCount = this._items.length, this._changeDetectorRef.markForCheck()), this._selectedIndexChanged && (this._scrollToLabel(this._selectedIndex), this._checkScrollingControls(), this._alignInkBarToSelectedTab(), this._selectedIndexChanged = !1, this._changeDetectorRef.markForCheck()), this._scrollDistanceChanged && (this._updateTabScrollPosition(), this._scrollDistanceChanged = !1, this._changeDetectorRef.markForCheck()) } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete(), this._stopScrolling.complete() } _handleKeydown(t) { if (!H_(t)) switch (t.keyCode) { case 13: case 32: this.focusIndex !== this.selectedIndex && (this.selectFocusedIndex.emit(this.focusIndex), this._itemSelected(t)); break; default: this._keyManager.onKeydown(t) } } _onContentChanges() { const t = this._elementRef.nativeElement.textContent; t !== this._currentTextContent && (this._currentTextContent = t || "", this._ngZone.run(() => { this.updatePagination(), this._alignInkBarToSelectedTab(), this._changeDetectorRef.markForCheck() })) } updatePagination() { this._checkPaginationEnabled(), this._checkScrollingControls(), this._updateTabScrollPosition() } get focusIndex() { return this._keyManager ? this._keyManager.activeItemIndex : 0 } set focusIndex(t) { this._isValidIndex(t) && this.focusIndex !== t && this._keyManager && this._keyManager.setActiveItem(t) } _isValidIndex(t) { if (!this._items) return !0; const e = this._items ? this._items.toArray()[t] : null; return !!e && !e.disabled } _setTabFocus(t) { if (this._showPaginationControls && this._scrollToLabel(t), this._items && this._items.length) { this._items.toArray()[t].focus(); const e = this._tabListContainer.nativeElement, n = this._getLayoutDirection(); e.scrollLeft = "ltr" == n ? 0 : e.scrollWidth - e.offsetWidth } } _getLayoutDirection() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } _updateTabScrollPosition() { if (this.disablePagination) return; const t = this.scrollDistance, e = "ltr" === this._getLayoutDirection() ? -t : t; this._tabList.nativeElement.style.transform = `translateX(${Math.round(e)}px)`, (this._platform.TRIDENT || this._platform.EDGE) && (this._tabListContainer.nativeElement.scrollLeft = 0) } get scrollDistance() { return this._scrollDistance } set scrollDistance(t) { this._scrollTo(t) } _scrollHeader(t) { return this._scrollTo(this._scrollDistance + ("before" == t ? -1 : 1) * this._tabListContainer.nativeElement.offsetWidth / 3) } _handlePaginatorClick(t) { this._stopInterval(), this._scrollHeader(t) } _scrollToLabel(t) { if (this.disablePagination) return; const e = this._items ? this._items.toArray()[t] : null; if (!e) return; const n = this._tabListContainer.nativeElement.offsetWidth, { offsetLeft: r, offsetWidth: i } = e.elementRef.nativeElement; let s, o; "ltr" == this._getLayoutDirection() ? (s = r, o = s + i) : (o = this._tabList.nativeElement.offsetWidth - r, s = o - i); const a = this.scrollDistance, l = this.scrollDistance + n; s < a ? this.scrollDistance -= a - s + 60 : o > l && (this.scrollDistance += o - l + 60) } _checkPaginationEnabled() { if (this.disablePagination) this._showPaginationControls = !1; else { const t = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth; t || (this.scrollDistance = 0), t !== this._showPaginationControls && this._changeDetectorRef.markForCheck(), this._showPaginationControls = t } } _checkScrollingControls() { this.disablePagination ? this._disableScrollAfter = this._disableScrollBefore = !0 : (this._disableScrollBefore = 0 == this.scrollDistance, this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance(), this._changeDetectorRef.markForCheck()) } _getMaxScrollDistance() { return this._tabList.nativeElement.scrollWidth - this._tabListContainer.nativeElement.offsetWidth || 0 } _alignInkBarToSelectedTab() { const t = this._items && this._items.length ? this._items.toArray()[this.selectedIndex] : null, e = t ? t.elementRef.nativeElement : null; e ? this._inkBar.alignToElement(e) : this._inkBar.hide() } _stopInterval() { this._stopScrolling.next() } _handlePaginatorPress(t, e) { e && null != e.button && 0 !== e.button || (this._stopInterval(), i_(650, 100).pipe(a_(W(this._stopScrolling, this._destroyed))).subscribe(() => { const { maxScrollDistance: e, distance: n } = this._scrollHeader(t); (0 === n || n >= e) && this._stopInterval() })) } _scrollTo(t) { if (this.disablePagination) return { maxScrollDistance: 0, distance: 0 }; const e = this._getMaxScrollDistance(); return this._scrollDistance = Math.max(0, Math.min(e, t)), this._scrollDistanceChanged = !0, this._checkScrollingControls(), { maxScrollDistance: e, distance: this._scrollDistance } } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(bl), Do(C_), Do(T_, 8), Do(Vc), Do(p_), Do(qm, 8)) }, t.\u0275dir = Yt({ type: t, inputs: { disablePagination: "disablePagination" } }), t })(), tV = (() => { class t extends $G { constructor(t, e, n, r, i, s, o) { super(t, r, i, e, n, s, o), this._disableRipple = !1, this.color = "primary" } get backgroundColor() { return this._backgroundColor } set backgroundColor(t) { const e = this._elementRef.nativeElement.classList; e.remove(`mat-background-${this.backgroundColor}`), t && e.add(`mat-background-${t}`), this._backgroundColor = t } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = Bb(t) } _itemSelected() { } ngAfterContentInit() { this._items.changes.pipe(fg(null), a_(this._destroyed)).subscribe(() => { this.updateActiveLink() }), super.ngAfterContentInit() } updateActiveLink() { if (!this._items) return; const t = this._items.toArray(); for (let e = 0; e < t.length; e++)if (t[e].active) return this.selectedIndex = e, void this._changeDetectorRef.markForCheck(); this.selectedIndex = -1, this._inkBar.hide() } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(T_, 8), Do(Vc), Do(bl), Do(C_), Do(p_), Do(qm, 8)) }, t.\u0275dir = Yt({ type: t, inputs: { color: "color", backgroundColor: "backgroundColor", disableRipple: "disableRipple" }, features: [vo] }), t })(), eV = (() => { class t extends tV { constructor(t, e, n, r, i, s, o) { super(t, e, n, r, i, s, o) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(T_, 8), Do(Vc), Do(bl), Do(C_), Do(p_), Do(qm, 8)) }, t.\u0275cmp = Jt({ type: t, selectors: [["", "mat-tab-nav-bar", ""]], contentQueries: function (t, e, n) { if (1 & t && mc(n, iV, 5), 2 & t) { let t; pc(t = gc()) && (e._items = t) } }, viewQuery: function (t, e) { if (1 & t && (fc(YG, 7), fc(JG, 7), fc(XG, 7), fc(WG, 5), fc(qG, 5)), 2 & t) { let t; pc(t = gc()) && (e._inkBar = t.first), pc(t = gc()) && (e._tabListContainer = t.first), pc(t = gc()) && (e._tabList = t.first), pc(t = gc()) && (e._nextPaginator = t.first), pc(t = gc()) && (e._previousPaginator = t.first) } }, hostAttrs: [1, "mat-tab-nav-bar", "mat-tab-header"], hostVars: 10, hostBindings: function (t, e) { 2 & t && aa("mat-tab-header-pagination-controls-enabled", e._showPaginationControls)("mat-tab-header-rtl", "rtl" == e._getLayoutDirection())("mat-primary", "warn" !== e.color && "accent" !== e.color)("mat-accent", "accent" === e.color)("mat-warn", "warn" === e.color) }, inputs: { color: "color" }, exportAs: ["matTabNavBar", "matTabNav"], features: [vo], attrs: ZG, ngContentSelectors: jG, decls: 13, vars: 8, consts: [["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-before", "mat-elevation-z4", 3, "matRippleDisabled", "click", "mousedown", "touchend"], ["previousPaginator", ""], [1, "mat-tab-header-pagination-chevron"], [1, "mat-tab-link-container", 3, "keydown"], ["tabListContainer", ""], [1, "mat-tab-list", 3, "cdkObserveContent"], ["tabList", ""], [1, "mat-tab-links"], ["aria-hidden", "true", "mat-ripple", "", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-after", "mat-elevation-z4", 3, "matRippleDisabled", "mousedown", "click", "touchend"], ["nextPaginator", ""]], template: function (t, e) { 1 & t && (Qo(), Fo(0, "div", 0, 1), Jo("click", function () { return e._handlePaginatorClick("before") })("mousedown", function (t) { return e._handlePaginatorPress("before", t) })("touchend", function () { return e._stopInterval() }), Bo(2, "div", 2), No(), Fo(3, "div", 3, 4), Jo("keydown", function (t) { return e._handleKeydown(t) }), Fo(5, "div", 5, 6), Jo("cdkObserveContent", function () { return e._onContentChanges() }), Fo(7, "div", 7), $o(8), No(), Bo(9, "mat-ink-bar"), No(), No(), Fo(10, "div", 8, 9), Jo("mousedown", function (t) { return e._handlePaginatorPress("after", t) })("click", function () { return e._handlePaginatorClick("after") })("touchend", function () { return e._stopInterval() }), Bo(12, "div", 2), No()), 2 & t && (aa("mat-tab-header-pagination-disabled", e._disableScrollBefore), Io("matRippleDisabled", e._disableScrollBefore || e.disableRipple), ns(5), aa("_mat-animation-noopable", "NoopAnimations" === e._animationMode), ns(5), aa("mat-tab-header-pagination-disabled", e._disableScrollAfter), Io("matRippleDisabled", e._disableScrollAfter || e.disableRipple)) }, directives: [gS, Aw, YG], styles: ['.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:"";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center]>.mat-tab-link-container .mat-tab-links{justify-content:center}[mat-align-tabs=end]>.mat-tab-link-container .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\n'], encapsulation: 2 }), t })(); const nV = oS(sS(rS(class { }))); let rV = (() => { class t extends nV { constructor(t, e, n, r, i, s) { super(), this._tabNavBar = t, this.elementRef = e, this._focusMonitor = i, this._isActive = !1, this.rippleConfig = n || {}, this.tabIndex = parseInt(r) || 0, "NoopAnimations" === s && (this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 }) } get active() { return this._isActive } set active(t) { Bb(t) !== this._isActive && (this._isActive = t, this._tabNavBar.updateActiveLink()) } get rippleDisabled() { return this.disabled || this.disableRipple || this._tabNavBar.disableRipple || !!this.rippleConfig.disabled } focus() { this.elementRef.nativeElement.focus() } ngAfterViewInit() { this._focusMonitor.monitor(this.elementRef) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this.elementRef) } _handleFocus() { this._tabNavBar.focusIndex = this._tabNavBar._items.toArray().indexOf(this) } } return t.\u0275fac = function (e) { return new (e || t)(Do(tV), Do(Wa), Do(mS, 8), Wn("tabindex"), Do(Ww), Do(qm, 8)) }, t.\u0275dir = Yt({ type: t, inputs: { active: "active" }, features: [vo] }), t })(), iV = (() => { class t extends rV { constructor(t, e, n, r, i, s, o, a) { super(t, e, i, s, o, a), this._tabLinkRipple = new fS(this, n, e, r), this._tabLinkRipple.setupTriggerEvents(e.nativeElement) } ngOnDestroy() { super.ngOnDestroy(), this._tabLinkRipple._removeTriggerEvents() } } return t.\u0275fac = function (e) { return new (e || t)(Do(eV), Do(Wa), Do(Vc), Do(p_), Do(mS, 8), Wn("tabindex"), Do(Ww), Do(qm, 8)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "mat-tab-link", ""], ["", "matTabLink", ""]], hostAttrs: [1, "mat-tab-link", "mat-focus-indicator"], hostVars: 7, hostBindings: function (t, e) { 1 & t && Jo("focus", function () { return e._handleFocus() }), 2 & t && (Ro("aria-current", e.active ? "page" : null)("aria-disabled", e.disabled)("tabIndex", e.tabIndex), aa("mat-tab-disabled", e.disabled)("mat-tab-label-active", e.active)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex" }, exportAs: ["matTabLink"], features: [vo] }), t })(), sV = (() => { class t { constructor() { this._vertical = !1, this._inset = !1 } get vertical() { return this._vertical } set vertical(t) { this._vertical = Bb(t) } get inset() { return this._inset } set inset(t) { this._inset = Bb(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = Jt({ type: t, selectors: [["mat-divider"]], hostAttrs: ["role", "separator", 1, "mat-divider"], hostVars: 7, hostBindings: function (t, e) { 2 & t && (Ro("aria-orientation", e.vertical ? "vertical" : "horizontal"), aa("mat-divider-vertical", e.vertical)("mat-divider-horizontal", !e.vertical)("mat-divider-inset", e.inset)) }, inputs: { vertical: "vertical", inset: "inset" }, decls: 0, vars: 0, template: function (t, e) { }, styles: [".mat-divider{display:block;margin:0;border-top-width:1px;border-top-style:solid}.mat-divider.mat-divider-vertical{border-top:0;border-right-width:1px;border-right-style:solid}.mat-divider.mat-divider-inset{margin-left:80px}[dir=rtl] .mat-divider.mat-divider-inset{margin-left:auto;margin-right:80px}\n"], encapsulation: 2, changeDetection: 0 }), t })(); const oV = [{ path: "", component: (() => { class t { constructor(e, n, r) { this.route = e, this.selfService = n, this.router = r, this.ProfileComponent = t, this.slug$ = this.route.params.pipe(xM("slug")) } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t)(Do(Xv), Do(jE), Do(fb)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-profile"]], decls: 10, vars: 1, consts: [[1, "profile-wrapper", "bg-gray-lightest"], [1, "container", "flex"], [1, "flex-grow"], ["mat-tab-nav-bar", ""], ["mat-tab-link", "", "routerLink", "collection", "routerLinkActive", "", 3, "active"], ["rla", "routerLinkActive"], [1, "container"]], template: function (t, e) { if (1 & t && (Fo(0, "div", 0), Fo(1, "div", 1), Fo(2, "div", 2), Fo(3, "nav", 3), Fo(4, "a", 4, 5), ya(6, " My Collection "), No(), No(), No(), No(), Bo(7, "mat-divider"), Fo(8, "div", 6), Bo(9, "router-outlet"), No(), No()), 2 & t) { const t = ko(5); ns(4), Io("active", t.isActive) } }, directives: [eV, gb, iV, yb, sV, bb], styles: ["body[_ngcontent-%COMP%]{--primary-color:#ff8000;--secondary-color:#404040;--warn-color:#fc0;--error-color:#da1414;--gray-color:#a7a7a7;--light-color:#e0e0e0}.mat-tab-link[_ngcontent-%COMP%]{font-size:1.125rem;line-height:1.75rem;padding-top:1.5rem;padding-bottom:1.5rem;height:auto}.mat-tab-label-active[_ngcontent-%COMP%]{opacity:1}.container[_ngcontent-%COMP%]{padding-top:0;padding-bottom:0}"] }), t })(), children: [{ path: "collection", component: zG }, { path: "**", redirectTo: "collection" }] }]; let aV = (() => { class t { constructor(t, e, n) { this.selfService = t, this.router = e, this.platformId = n } canActivate(t, e) { return gh(this.platformId) ? this.selfService.self$.pipe(P(t => !t || this.router.parseUrl("/"))) : id(!0) } } return t.\u0275fac = function (e) { return new (e || t)(fr(jE), fr(fb), fr(Ac)) }, t.\u0275prov = ft({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); var lV = n(7682); const cV = { UKNOWN: "Unknown" }, uV = { CHROME: "Chrome", FIREFOX: "Firefox", SAFARI: "Safari", OPERA: "Opera", IE: "IE", MS_EDGE: "MS-Edge", MS_EDGE_CHROMIUM: "MS-Edge-Chromium", FB_MESSANGER: "FB-Messanger", SAMSUNG: "Samsung", UCBROWSER: "UC-Browser", UNKNOWN: cV.UKNOWN }, hV = { HTC: /HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\bEVO\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel/, NEXUS_PHONE: /Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6/, DELL: /Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\b001DL\b|\b101DL\b|\bGS01\b/, MOTOROLA: new RegExp("Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|\n      A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|\n      MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|\n      ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|\n      WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|\n      XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|\n      XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052"), SAMSUNG: new RegExp("\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|\n      GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|\n      GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|\n      GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|\n      GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|\n      GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|\n      GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|\n      GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|\n      GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|\n      GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|\n      GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|\n      GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|\n      GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|\n      GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|\n      GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|\n      GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|\n      GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|\n      GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|\n      SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|\n      SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|\n      SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|\n      SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|\n      SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|\n      SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|\n      SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|\n      SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|\n      SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|\n      SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|\n      SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|\n      SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|\n      SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|\n      SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|\n      SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|\n      SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|\n      SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|\n      SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|\n      SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|\n      SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|\n      SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|\n      SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|\n      SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|\n      SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|\n      SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|\n      SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|\n      SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|\n      SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|\n      SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|\n      SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|\n      SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|\n      GT-N7105|SCH-I535|SM-N900A|SM-N900T|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|\n      GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|\n      GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|\n      SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|\n      SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|\n      SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F"), LG: new RegExp("\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|\n      LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|\n      C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|\n      LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|\n      VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|\n      MS323|M257)"), SONY: /SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533/, ASUS: /Asus.*Galaxy|PadFone.*Mobile/, NOKIA_LUMIA: /Lumia [0-9]{3,4}/, MICROMAX: /Micromax.*\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\b/, PALM: /PalmSource|Palm/, VERTU: /Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature/, PANTECH: new RegExp("PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|\n        IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|\n        IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|\n        CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|\n        P2000|P7040|P7000|C790"), FLY: /IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250/, WIKO: new RegExp("KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|\n        SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|\n        CINK KING|CINK PEAX|CINK SLIM|SUBLIM"), I_MOBILE: /i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)/, SIMVALLEY: /\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\b/, WOLFGANG: /AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q/, ALCATEL: /Alcatel|Mobile; rv:49.0|Mobile; ALCATEL 4052R; rv:48.0/, NINTENDO: /Nintendo (3DS|Switch)/, AMOI: /Amoi/, INQ: /INQ/, VITA: /\bVita\b/, BLACKBERRY: /\bBlackBerry\b|\bBB10\b|rim[0-9]+/, FIREFOX_OS: /\bFirefox-OS\b/, IPHONE: /\biPhone\b/, iPod: /\biPod\b/, ANDROID: /\bAndroid\b/, WINDOWS_PHONE: /\bWindows-Phone\b/, GENERIC_PHONE: new RegExp("Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|\n        up.link|vodafone|\\bwap\\b|nokia|Nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser") }, dV = { iPad: /iPad|iPad.*Mobile/, NexusTablet: /Android.*Nexus[\s]+(7|9|10)/, GoogleTablet: /Android.*Pixel C/, SamsungTablet: new RegExp("SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|\n        GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|\n        SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|\n        GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|\n        SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|\n        GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|\n        SHV-E230S|SHW-M180K|SHW-M180L|SM-T865|SM-T290|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|\n        SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|\n        GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T385M|SM-P585M|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|\n        SM-P601|SM-P605|SM-P615|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|\n        GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|\n        SM-T510|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|\n        SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T500|SM-T330|\n        SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|\n        SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|\n        SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|\n        SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|\n        SM-T719|SM-T813|SM-T819|SM-T580|SM-T590|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|\n        SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835|SM-P585Y"), Kindle: new RegExp("Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|\n        KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk/[0-9.]+ like Chrome        /[0-9.]+ (?!Mobile)"), SurfaceTablet: /Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)/, HPTablet: /HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10/, AsusTablet: new RegExp("^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|\n        TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|\n        Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|\n        ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|\n        ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b"), BlackBerryTablet: /PlayBook|RIM Tablet/, HTCtablet: /HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410/, MotorolaTablet: /xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617/, NookTablet: /Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2/, AcerTablet: new RegExp("Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|\n        W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\n        \\bA3-A20\\b|\\bA3-A30"), ToshibaTablet: /Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO/, LGTablet: /\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\b/, FujitsuTablet: /Android.*\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\b/, PrestigioTablet: new RegExp("PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|\n        PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|\n        PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|\n        PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|\n        PMT5887|PMT5001|PMT5002"), LenovoTablet: new RegExp("Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|\n        YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|\n        B8000|B8080)(-|)(FL|F|HV|H|)|TB-X606F|TB-X103F|TB-X304F|TB-X304L|TB-X704F|TB-8703F|Tab2A7-10F|TB2-X30L|TB-8504F"), DellTablet: /Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7/, YarvikTablet: new RegExp("Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|\n        TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|\n        TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|\n        TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|\n        TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b"), MedionTablet: /Android.*\bOYO\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB/, ArnovaTablet: /97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2/, IntensoTablet: /INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004/, IRUTablet: /M702pro/, MegafonTablet: /MegaFon V9|\bZTE V9\b|Android.*\bMT7A\b/, EbodaTablet: /E-Boda (Supreme|Impresspeed|Izzycomm|Essential)/, AllViewTablet: /Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)/, ArchosTablet: new RegExp("\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10|\n         Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b"), AinolTablet: /NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark/, NokiaLumiaTablet: /Lumia 2520/, SonyTablet: new RegExp("Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|\n        SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|\n        EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|\n        SGP612|SGP712"), PhilipsTablet: /\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\b/, CubeTablet: /Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT/, CobyTablet: new RegExp("MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|\n        MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010"), MIDTablet: new RegExp("M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|\n        MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|\n        MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10"), MSITablet: new RegExp("MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|\n        Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b"), SMiTTablet: /Android.*(\bMID\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)/, RockChipTablet: /Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A/, FlyTablet: /IQ310|Fly Vision/, bqTablet: new RegExp("Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|\n        Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))|Maxwell.*Lite|Maxwell.*Plus"), HuaweiTablet: new RegExp("MediaPad|MediaPad 7 Youth|MediaPad T3 10|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|\n        S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09|AGS-W09"), NecTablet: /\bN-06D|\bN-08D/, PantechTablet: /Pantech.*P4100/, BronchoTablet: /Broncho.*(N701|N708|N802|a710)/, VersusTablet: /TOUCHPAD.*[78910]|\bTOUCHTAB\b/, ZyncTablet: /z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900/, PositivoTablet: /TB07STA|TB10STA|TB07FTA|TB10FTA/, NabiTablet: /Android.*\bNabi/, KoboTablet: /Kobo Touch|\bK080\b|\bVox\b Build|\bArc\b Build/, DanewTablet: /DSlide.*\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\b/, TexetTablet: new RegExp("NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|\n        TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|\n        TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|\n        TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|\n        TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|\n        TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|\n        TB-436|TB-416|TB-146SE|TB-126SE"), PlaystationTablet: /Playstation.*(Portable|Vita)/, TrekstorTablet: /ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab/, PyleAudioTablet: /\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\b/, AdvanTablet: new RegExp("Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|\n        T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b"), DanyTechTablet: "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|\n        Genius TAB GII|Genius TAB GIII|Genius Tab S1", GalapadTablet: /Android.*\bG1\b(?!\))/, MicromaxTablet: /Funbook|Micromax.*\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\b/, KarbonnTablet: /Android.*\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\b/, AllFineTablet: /Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide/, PROSCANTablet: new RegExp("\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|\n        PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|\n        PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|\n        PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b"), YONESTablet: /BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026/, ChangJiaTablet: new RegExp("TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|\n        TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|\n        TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|\n        TPC10111|TPC10203|TPC10205|TPC10503"), GUTablet: /TX-A1301|TX-M9002|Q702|kf026/, PointOfViewTablet: new RegExp("TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|\n        TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|\n        TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|\n        TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10"), OvermaxTablet: new RegExp("OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|\n        MagicTab|Stream|TB-08|TB-09)|Qualcore 1027"), HCLTablet: /HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync/, DPSTablet: /DPS Dream 9|DPS Dual 7/, VistureTablet: /V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10/, CrestaTablet: /CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989/, MediatekTablet: /\bMT8125|MT8389|MT8135|MT8377\b/, ConcordeTablet: /Concorde([ ]+)?Tab|ConCorde ReadMan/, GoCleverTablet: new RegExp("GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|\n        TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|\n        GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|\n        TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|\n        TAB R104|TAB R83.3|TAB A1042"), ModecomTablet: new RegExp("FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|\n        FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|\n        FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003"), VoninoTablet: new RegExp("\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|\n        Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|\n        Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b"), ECSTablet: /V07OT2|TM105A|S10OT1|TR10CS1/, StorexTablet: /eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab/, VodafoneTablet: /SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497/, EssentielBTablet: /Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2/, RossMoorTablet: /RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711/, iMobileTablet: /i-mobile i-note/, TolinoTablet: /tolino tab [0-9.]+|tolino shine/, AudioSonicTablet: /\bC-22Q|T7-QC|T-17B|T-17P\b/, AMPETablet: /Android.* A78 /, SkkTablet: /Android.* (SKYPAD|PHOENIX|CYCLOPS)/, TecnoTablet: /TECNO P9|TECNO DP8D/, JXDTablet: new RegExp("Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|\n        S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|\n        P1000|P300|S18|S6600|S9100)\\b"), iJoyTablet: new RegExp("Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|\n        Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|\n        Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|\n        Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|\n        Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)"), FX2Tablet: /FX2 PAD7|FX2 PAD10/, XoroTablet: new RegExp("KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|\n        PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|\n        PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|\n        TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151"), ViewsonicTablet: /ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a/, VerizonTablet: /QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1/, OdysTablet: /LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\bXELIO\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10/, CaptivaTablet: /CAPTIVA PAD/, IconbitTablet: new RegExp("NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|\n        NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S"), TeclastTablet: new RegExp("T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\n        \\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\n        \\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\n        \\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\n        \\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\n        \\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\n        \\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\n        \\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\n        \\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi"), OndaTablet: new RegExp("\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|\n        V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|\n        V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|\n        Vi40)\\b[s]+|V10 \\b4G\\b"), JaytechTablet: /TPC-PA762/, BlaupunktTablet: /Endeavour 800NG|Endeavour 1010/, DigmaTablet: /\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\b/, EvolioTablet: /ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\bEvotab\b|\bNeura\b/, LavaTablet: /QPAD E704|\bIvoryS\b|E-TAB IVORY|\bE-TAB\b/, AocTablet: /MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712/, MpmanTablet: new RegExp("MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\n        \\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|\n        MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010"), CelkonTablet: /CT695|CT888|CT[\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\bCT-1\b/, WolderTablet: new RegExp("miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|\n        POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|\n        FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b"), MediacomTablet: "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA", MiTablet: /\bMI PAD\b|\bHM NOTE 1W\b/, NibiruTablet: /Nibiru M1|Nibiru Jupiter One/, NexoTablet: /NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI/, LeaderTablet: new RegExp("TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|\n        TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100"), UbislateTablet: /UbiSlate[\s]?7C/, PocketBookTablet: /Pocketbook/, KocasoTablet: /\b(TB-1207)\b/, HisenseTablet: /\b(F5281|E2371)\b/, Hudl: /Hudl HT7S3|Hudl 2/, TelstraTablet: /T-Hub2/, Honeywell: /RT10A/, GenericTablet: new RegExp("Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|\n        A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|\n        Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107") }, pV = { BLACKBERRY: "Blackberry", FIREFOX_OS: "Firefox-OS", CHROME_BOOK: "Chrome-Book", WINDOWS_PHONE: "Windows-Phone", VITA: "Vita", PS4: "PS4", MAC: "Macintosh", CHROMECAST: "Chromecast", APPLE_TV: "Apple-TV", GOOGLE_TV: "Google-TV", ANDROID: "Android", Tesla: "Tesla", iPad: "iPad", IPHONE: "iPhone", iPod: "iPod", UNKNOWN: cV.UKNOWN, HTC: "HTC", NEXUS_PHONE: "Nexus Phone", NexusTablet: "Nexus Tablet", DELL: "Dell", MOTOROLA: "Motorola", SAMSUNG: "Samsung", LG: "LG", SONY: "Sony", ASUS: "Asus", NOKIA_LUMIA: "Nokia Lumia", MICROMAX: "Micromax", PALM: "Palm", VERTU: "Vertu", PANTECH: "PANTECH", FLY: "Fly", WIKO: "WIKO", I_MOBILE: "i-mobile", SIMVALLEY: "Simvalley", WOLFGANG: "Wolfgang", ALCATEL: "Alcatel", HONEYWELL: "Honeywell", NINTENDO: "Nintendo", AMOI: "Amoi", INQ: "INQ", GENERIC_PHONE: "Generic Phone", MI_SE_9: "Mi SE 9" }, fV = [pV.PS4, pV.CHROME_BOOK, pV.MAC, pV.DELL, pV.ASUS, pV.UNKNOWN], mV = { WINDOWS: "Windows", MAC: "Mac", IOS: "iOS", ANDROID: "Android", LINUX: "Linux", UNIX: "Unix", FIREFOX_OS: "Firefox-OS", CHROME_OS: "Chrome-OS", WINDOWS_PHONE: "Windows-Phone", UNKNOWN: cV.UKNOWN }, gV = { WINDOWS_3_11: "windows-3-11", WINDOWS_95: "windows-95", WINDOWS_ME: "windows-me", WINDOWS_98: "windows-98", WINDOWS_CE: "windows-ce", WINDOWS_2000: "windows-2000", WINDOWS_XP: "windows-xp", WINDOWS_SERVER_2003: "windows-server-2003", WINDOWS_VISTA: "windows-vista", WINDOWS_7: "windows-7", WINDOWS_8_1: "windows-8-1", WINDOWS_8: "windows-8", WINDOWS_10: "windows-10", WINDOWS_PHONE_7_5: "windows-phone-7-5", WINDOWS_PHONE_8_1: "windows-phone-8-1", WINDOWS_PHONE_10: "windows-phone-10", WINDOWS_NT_4_0: "windows-nt-4-0", MACOSX_11_0: "mac-os-x-11-0", MACOSX_16: "mac-os-x-16", MACOSX_15: "mac-os-x-15", MACOSX_14: "mac-os-x-14", MACOSX_13: "mac-os-x-13", MACOSX_12: "mac-os-x-12", MACOSX_11: "mac-os-x-11", MACOSX_10: "mac-os-x-10", MACOSX_9: "mac-os-x-9", MACOSX_8: "mac-os-x-8", MACOSX_7: "mac-os-x-7", MACOSX_6: "mac-os-x-6", MACOSX_5: "mac-os-x-5", MACOSX_4: "mac-os-x-4", MACOSX_3: "mac-os-x-3", MACOSX_2: "mac-os-x-2", MACOSX: "mac-os-x", iOS: "iOS", ANDROID_9: "android-9", UNKNOWN: cV.UKNOWN.toLowerCase() }, vV = { WINDOWS: { and: [{ or: [/\bWindows|(Win\d\d)\b/, /\bWin 9x\b/] }, { not: /\bWindows Phone\b/ }] }, MAC: { and: [/\bMac OS\b/, { not: { or: [/\biPhone\b/, /\biPad\b/, /\biPod\b/, /\bWindows Phone\b/] } }] }, IOS: { and: [{ or: [/\biPad\b/, /\biPhone\b/, /\biPod\b/] }, { not: /\bWindows Phone\b/ }] }, ANDROID: { and: [/\bAndroid\b/, { not: /\bWindows Phone\b/ }] }, LINUX: /\bLinux\b/, UNIX: /\bUNIX\b/, FIREFOX_OS: { and: [/\bFirefox\b/, /Mobile\b/] }, CHROME_OS: /\bCrOS\b/, WINDOWS_PHONE: { or: [/\bIEMobile\b/, /\bWindows Phone\b/] }, PS4: /\bMozilla\/5.0 \(PlayStation 4\b/, VITA: /\bMozilla\/5.0 \(Play(S|s)tation Vita\b/ }, yV = Object.assign(Object.assign(Object.assign(Object.assign({}, hV), dV), vV), { FIREFOX_OS: { and: [/\bFirefox\b/, /\bMobile\b/] }, CHROME_BOOK: /\bCrOS\b/, PS4: /\bMozilla\/5.0 \(PlayStation 4\b/, CHROMECAST: /\bCrKey\b/, APPLE_TV: /^iTunes-AppleTV\/4.1$/, GOOGLE_TV: /\bGoogleTV\b/, Tesla: /Tesla\/([0-9]{4}.[0-9]{1,2}.?[0-9]{0,2}.?[0-9]{0,2})-(.{7})/, MI_SE_9: /\bXiaomi\b/, MAC: { and: [/\bMac OS\b/, { not: { or: [/\biPhone\b/, /\biPad\b/, /\biPod\b/, /\bWindows Phone\b/] } }] } }), bV = { WINDOWS_3_11: /Win16/, WINDOWS_95: /(Windows 95|Win95|Windows_95)/, WINDOWS_ME: /(Win 9x 4.90|Windows ME)/, WINDOWS_98: /(Windows 98|Win98)/, WINDOWS_CE: /Windows CE/, WINDOWS_2000: /(Windows NT 5.0|Windows 2000)/, WINDOWS_XP: /(Windows NT 5.1|Windows XP)/, WINDOWS_SERVER_2003: /Windows NT 5.2/, WINDOWS_VISTA: /Windows NT 6.0/, WINDOWS_7: /(Windows 7|Windows NT 6.1)/, WINDOWS_8_1: /(Windows 8.1|Windows NT 6.3)/, WINDOWS_8: /(Windows 8|Windows NT 6.2)/, WINDOWS_10: /(Windows NT 10.0)/, WINDOWS_PHONE_7_5: /(Windows Phone OS 7.5)/, WINDOWS_PHONE_8_1: /(Windows Phone 8.1)/, WINDOWS_PHONE_10: /(Windows Phone 10)/, WINDOWS_NT_4_0: { and: [/(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/, { not: /Windows NT 10.0/ }] }, MACOSX: /(MAC OS X\s*[^ 0-9])/, MACOSX_3: /(Darwin 10.3|Mac OS X 10.3)/, MACOSX_4: /(Darwin 10.4|Mac OS X 10.4)/, MACOSX_5: /(Mac OS X 10.5)/, MACOSX_6: /(Mac OS X 10.6)/, MACOSX_7: /(Mac OS X 10.7)/, MACOSX_8: /(Mac OS X 10.8)/, MACOSX_9: /(Mac OS X 10.9)/, MACOSX_10: /(Mac OS X 10.10)/, MACOSX_11: /(Mac OS X 10.11)/, MACOSX_12: /(Mac OS X 10.12)/, MACOSX_13: /(Mac OS X 10.13)/, MACOSX_14: /(Mac OS X 10.14)/, MACOSX_15: /(Mac OS X 10.15)/, MACOSX_16: /(Mac OS X 10.16)/, MACOSX_11_0: { or: [/11_0 like Mac OS X/, /Mac OS X 11/] }, iOS: /(iPhone OS\s*[0-9_]+)/, ANDROID_9: /(Android 9)/ }, _V = { CHROME: [/\bChrome\/([\d\.]+)\b/, /\bCriOS\/([\d\.]+)\b/, /\bHeadlessChrome\/([\d\.]+)\b/], FIREFOX: [/\bFirefox\/([\d\.]+)\b/, /\bFxiOS\/([\d\.]+)\b/], SAFARI: [/\bVersion\/([\d\.]+)\b/, /\bSafari\/([\d\.]+)\b/], OPERA: [/\bVersion\/([\d\.]+)\b/, /\bOPR\/([\d\.]+)\b/], IE: [/\bMSIE ([\d\.]+\w?)\b/, /\brv:([\d\.]+\w?)\b/], MS_EDGE: /\bEdg(?:e|A|iOS)\/([\d\.]+)\b/, MS_EDGE_CHROMIUM: /\bEdg\/([\d\.]+)\b/, SAMSUNG: /\bSamsungBrowser\/([\d\.]+)\b/, UCBROWSER: /\bUCBrowser\/([\d\.]+)\b/ }, wV = (t, e) => (t[e] = bV[e], t), SV = Object.keys(bV).reduce(wV, {}), xV = (t, e) => (t[uV[e]] = _V[e], t), TV = Object.keys(_V).reduce(xV, {}); var EV = Object.freeze({ __proto__: null, GENERAL: cV, BROWSERS: uV, MOBILES_RE: hV, TABLETS_RE: dV, DEVICES: pV, DESKTOP_DEVICES: fV, OS: mV, OS_VERSIONS: gV, OS_RE: vV, BROWSERS_RE: { CHROME: { and: [{ or: [/\bChrome\b/, /\bCriOS\b/, /\bHeadlessChrome\b/] }, { not: { or: [/\bOPR\b/, /\bEdg(e|A|iOS)\b/, /\bEdg\/\b/, /\bSamsungBrowser\b/, /\bUCBrowser\b/] } }] }, FIREFOX: { or: [/\bFirefox\b/, /\bFxiOS\b/] }, SAFARI: { and: [/^((?!CriOS).)*\Safari\b.*$/, { not: { or: [/\bOPR\b/, /\bEdg(e|A|iOS)\b/, /\bEdg\/\b/, /\bWindows Phone\b/, /\bSamsungBrowser\b/, /\bUCBrowser\b/] } }] }, OPERA: { or: [/Opera\b/, /\bOPR\b/] }, IE: { or: [/\bMSIE\b/, /\bTrident\b/, /^Mozilla\/5\.0 \(Windows NT 10\.0; Win64; x64\)$/] }, MS_EDGE: { or: [/\bEdg(e|A|iOS)\b/] }, MS_EDGE_CHROMIUM: /\bEdg\/\b/, PS4: /\bMozilla\/5.0 \(PlayStation 4\b/, VITA: /\bMozilla\/5.0 \(Play(S|s)tation Vita\b/, FB_MESSANGER: /\bFBAN\/MessengerForiOS\b/, SAMSUNG: /\bSamsungBrowser\b/, UCBROWSER: /\bUCBrowser\b/ }, DEVICES_RE: yV, OS_VERSIONS_RE_MAP: bV, BROWSER_VERSIONS_RE_MAP: _V, OS_VERSIONS_RE: SV, BROWSER_VERSIONS_RE: TV, "\u02750": wV, "\u02751": xV }); class MV { constructor() { } test(t, e) { return "string" == typeof e && (e = new RegExp(e)), e instanceof RegExp ? e.test(t) : e && Array.isArray(e.and) ? e.and.every(e => this.test(t, e)) : e && Array.isArray(e.or) ? e.or.some(e => this.test(t, e)) : !(!e || !e.not || this.test(t, e.not)) } exec(t, e) { return "string" == typeof e && (e = new RegExp(e)), e instanceof RegExp ? e.exec(t) : e && Array.isArray(e) ? e.reduce((e, n) => e || this.exec(t, n), null) : null } } var AV = (() => (function (t) { t.Mobile = "mobile", t.Tablet = "tablet", t.Desktop = "desktop", t.Unknown = "unknown" }(AV || (AV = {})), AV))(), CV = (() => (function (t) { t.Portrait = "portrait", t.Landscape = "landscape" }(CV || (CV = {})), CV))(); let PV = (() => { class t { constructor(t) { this.platformId = t, this.ua = "", this.userAgent = "", this.os = "", this.browser = "", this.device = "", this.os_version = "", this.browser_version = "", this.reTree = new MV, this.deviceType = "", this.orientation = "", gh(this.platformId) && "undefined" != typeof window && (this.userAgent = window.navigator.userAgent), this.setDeviceInfo(this.userAgent) } setDeviceInfo(t = this.userAgent) { t !== this.userAgent && (this.userAgent = t); const e = [{ const: "OS", prop: "os" }, { const: "BROWSERS", prop: "browser" }, { const: "DEVICES", prop: "device" }, { const: "OS_VERSIONS", prop: "os_version" }]; if (e.forEach(e => { this[e.prop] = Object.keys(EV[e.const]).reduce((n, r) => "device" === EV[e.const][r] && gh(this.platformId) && (this.reTree.test(this.userAgent, dV.iPad) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1) ? (n[EV[e.const][r]] = "iPad", Object) : (n[EV[e.const][r]] = this.reTree.test(t, EV[`${e.const}_RE`][r]), n), {}) }), e.forEach(t => { this[t.prop] = Object.keys(EV[t.const]).map(e => EV[t.const][e]).reduce((e, n) => "device" === t.prop && e === EV[t.const].ANDROID ? this[t.prop][n] ? n : e : e === EV[t.const].UNKNOWN && this[t.prop][n] ? n : e, EV[t.const].UNKNOWN) }), this.browser_version = "0", this.browser !== uV.UNKNOWN) { const e = this.reTree.exec(t, TV[this.browser]); e && (this.browser_version = e[1]) } this.orientation = "undefined" != typeof window && window.matchMedia ? window.matchMedia("(orientation: landscape)").matches ? CV.Landscape : CV.Portrait : cV.UKNOWN, this.deviceType = this.isTablet() ? AV.Tablet : this.isMobile(this.userAgent) ? AV.Mobile : this.isDesktop(this.userAgent) ? AV.Desktop : AV.Unknown } getDeviceInfo() { return { userAgent: this.userAgent, os: this.os, browser: this.browser, device: this.device, os_version: this.os_version, browser_version: this.browser_version, deviceType: this.deviceType, orientation: this.orientation } } isMobile(t = this.userAgent) { return !this.isTablet(t) && !!Object.keys(hV).find(e => this.reTree.test(t, hV[e])) } isTablet(t = this.userAgent) { return !(!gh(this.platformId) || !(this.reTree.test(this.userAgent, dV.iPad) || "undefined" != typeof navigator && "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1)) || !!Object.keys(dV).find(e => !!this.reTree.test(t, dV[e])) } isDesktop(t = this.userAgent) { return (this.device !== pV.UNKNOWN || !this.isMobile(t) && !this.isTablet(t)) && fV.indexOf(this.device) > -1 } } return t.\u0275fac = function (e) { return new (e || t)(fr(Ac)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(Ac)) }, token: t, providedIn: "root" }), t })(); function RV(t, e) { if (1 & t) { const t = Go(); Fo(0, "div", 1), Fo(1, "div", 2), Fo(2, "h2", 3), ya(3, "Welcome! Let's begin with your wallet"), No(), Fo(4, "p"), ya(5, " Connect your wallet or create a new wallet. "), No(), Fo(6, "ga-button", 4), Jo("click", function () { return Oe(t), Ko().connect() }), Fo(7, "span", 5), Bo(8, "img", 6), ya(9, " Connect Metamask "), No(), No(), Fo(10, "p"), Fo(11, "a", 7), Jo("click", function () { return Oe(t), Ko().walletDialog() }), ya(12, "What is a wallet?"), No(), No(), No(), No() } } const LV = [{ path: "profile", children: [...oV], canActivate: [JE] }, { path: "login", children: [{ path: "", component: (() => { class t { constructor(t, e, n, r, i, s, o, a, l, c) { this.dialog = t, this.sessionService = e, this.loadingService = n, this.selfService = r, this.router = i, this.route = s, this.snackBar = o, this.deviceDetectorService = a, this.gaService = l, this.blockchain = c, this.loading$ = this.loadingService.loading$, this.dappPath = window.location.href.toString().replace(/(http[s]*:\/\/)/, ""), this.mobleMetamaskUrl = `https://metamask.app.link/dapp/${this.dappPath}?mm=true` } ngOnInit() { } connect() { this.deviceDetectorService.isDesktop() || window.location.href.includes("mm=true") || window.open(this.mobleMetamaskUrl, "_blank"); let t = this.sessionService.connect().pipe(yg(t => (4001 === (null == t ? void 0 : t.code) ? this.router.navigateByUrl(this.route.snapshot.queryParams.referrer || "/") : this.dialog.alert("Install MetaMask", "You need to install MetaMask before connecting to VOX", { url: "https://metamask.io", text: "Go to MetaMask website" }), Xd)), V(t => this.selfService.setSelf(t)), Dg(t => { this.router.navigateByUrl(this.route.snapshot.queryParams.referrer || "/"), this.gaService.eventEmitter("login", "metamask", "on connect"), B(this.blockchain.getBalance()).subscribe(t => { const e = +lV.utils.formatUnits(t); this.gaService.eventEmitter("login", "metamask", "on balance", e) }) }), this.snackBar.handle("Signed in with MetaMask")); this.loadingService.watch(t).subscribe(t => { }, () => this.loadingService.next(!1), () => this.loadingService.next(!1)) } walletDialog() { this.dialog.confirm("What is a wallet?", "Wallets are used to send, receive, and store digital assets like Ether. Wallets come in many forms. They are either built into your browser, an extension added to your browser, a piece of hardware plugged into your computer, or even an app on your phone.", { yesText: "Ok" }).subscribe() } } return t.\u0275fac = function (e) { return new (e || t)(Do(mM), Do(yM), Do(vM), Do(jE), Do(fb), Do(Xv), Do(iM), Do(PV), Do(gM), Do(zE)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-login"]], decls: 2, vars: 3, consts: [["class", "container h-screen-3/4 flex items-center justify-center", 4, "ngIf"], [1, "container", "h-screen-3/4", "flex", "items-center", "justify-center"], [1, "flex", "flex-col", "items-center", "text-center"], [1, "text-center"], ["color", "secondary", 1, "my-8", 3, "click"], [1, "flex", "items-center", "text-white"], ["src", "assets/metamask_logo.png", "alt", "Connect MetaMask", 1, "w-8", "h-8", "mr-2"], [1, "cursor-pointer", 3, "click"]], template: function (t, e) { 1 & t && (Lo(0, RV, 13, 0, "div", 0), Zl(1, "async")), 2 & t && Io("ngIf", !1 === Kl(1, 1, e.loading$)) }, directives: [th, QE], pipes: [hh], styles: [""] }), t })(), canActivate: [aV] }] }, { path: "faqs", component: eC }, { path: "terms-and-conditions", component: SG }, { path: ":slug/buy", component: tC, canActivate: [JE] }, { path: ":slug/admin", component: xG, canActivate: [JE] }, { path: ":slug/debug/:index", component: LG }, { path: ":slug/provenance", component: AG, canActivate: [JE] }, { path: ":slug/:index", component: bG, canActivate: [JE] }, { path: "**", redirectTo: "town-star/buy", pathMatch: "full" }]; let kV = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[Pb.forRoot(LV, { enableTracing: !1, initialNavigation: "enabled" })], Pb] }), t })(); const DV = ["*", [["mat-toolbar-row"]]], IV = ["*", "mat-toolbar-row"], OV = iS(class { constructor(t) { this._elementRef = t } }); let FV = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Yt({ type: t, selectors: [["mat-toolbar-row"]], hostAttrs: [1, "mat-toolbar-row"], exportAs: ["matToolbarRow"] }), t })(), NV = (() => { class t extends OV { constructor(t, e, n) { super(t), this._platform = e, this._document = n } ngAfterViewInit() { this._platform.isBrowser && (this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes())) } _checkToolbarMixedModes() { } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(p_), Do(wu)) }, t.\u0275cmp = Jt({ type: t, selectors: [["mat-toolbar"]], contentQueries: function (t, e, n) { if (1 & t && mc(n, FV, 5), 2 & t) { let t; pc(t = gc()) && (e._toolbarRows = t) } }, hostAttrs: [1, "mat-toolbar"], hostVars: 4, hostBindings: function (t, e) { 2 & t && aa("mat-toolbar-multiple-rows", e._toolbarRows.length > 0)("mat-toolbar-single-row", 0 === e._toolbarRows.length) }, inputs: { color: "color" }, exportAs: ["matToolbar"], features: [vo], ngContentSelectors: IV, decls: 2, vars: 0, template: function (t, e) { 1 & t && (Qo(DV), $o(0), $o(1, 1)) }, styles: [".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"], encapsulation: 2, changeDetection: 0 }), t })(), BV = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[nS], nS] }), t })(); class HV { constructor(t, e) { this._document = e; const n = this._textarea = this._document.createElement("textarea"), r = n.style; r.position = "fixed", r.top = r.opacity = "0", r.left = "-999em", n.setAttribute("aria-hidden", "true"), n.value = t, this._document.body.appendChild(n) } copy() { const t = this._textarea; let e = !1; try { if (t) { const n = this._document.activeElement; t.select(), t.setSelectionRange(0, t.value.length), e = this._document.execCommand("copy"), n && n.focus() } } catch (wN) { } return e } destroy() { const t = this._textarea; t && (t.parentNode && t.parentNode.removeChild(t), this._textarea = void 0) } } let UV = (() => { class t { constructor(t) { this._document = t } copy(t) { const e = this.beginCopy(t), n = e.copy(); return e.destroy(), n } beginCopy(t) { return new HV(t, this._document) } } return t.\u0275fac = function (e) { return new (e || t)(fr(wu)) }, t.\u0275prov = ft({ factory: function () { return new t(fr(wu)) }, token: t, providedIn: "root" }), t })(), GV = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({}), t })(); function VV(t, e = t_) { var n; const r = (n = t) instanceof Date && !isNaN(+n) ? +t - e.now() : Math.abs(t); return t => t.lift(new zV(r, e)) } class zV { constructor(t, e) { this.delay = t, this.scheduler = e } call(t, e) { return e.subscribe(new jV(t, this.delay, this.scheduler)) } } class jV extends m { constructor(t, e, n) { super(t), this.delay = e, this.scheduler = n, this.queue = [], this.active = !1, this.errored = !1 } static dispatch(t) { const e = t.source, n = e.queue, r = t.scheduler, i = t.destination; for (; n.length > 0 && n[0].time - r.now() <= 0;)n.shift().notification.observe(i); if (n.length > 0) { const e = Math.max(0, n[0].time - r.now()); this.schedule(t, e) } else this.unsubscribe(), e.active = !1 } _schedule(t) { this.active = !0, this.destination.add(t.schedule(jV.dispatch, this.delay, { source: this, destination: this.destination, scheduler: t })) } scheduleNotification(t) { if (!0 === this.errored) return; const e = this.scheduler, n = new JV(e.now() + this.delay, t); this.queue.push(n), !1 === this.active && this._schedule(e) } _next(t) { this.scheduleNotification(Kd.createNext(t)) } _error(t) { this.errored = !0, this.queue = [], this.destination.error(t), this.unsubscribe() } _complete() { this.scheduleNotification(Kd.createComplete()), this.unsubscribe() } } class JV { constructor(t, e) { this.time = t, this.notification = e } } const XV = ["mat-menu-item", ""], WV = ["*"]; function qV(t, e) { if (1 & t) { const t = Go(); Fo(0, "div", 0), Jo("keydown", function (e) { return Oe(t), Ko()._handleKeydown(e) })("click", function () { return Oe(t), Ko().closed.emit("click") })("@transformMenu.start", function (e) { return Oe(t), Ko()._onAnimationStart(e) })("@transformMenu.done", function (e) { return Oe(t), Ko()._onAnimationDone(e) }), Fo(1, "div", 1), $o(2), No(), No() } if (2 & t) { const t = Ko(); Io("id", t.panelId)("ngClass", t._classList)("@transformMenu", t._panelAnimationState), Ro("aria-label", t.ariaLabel || null)("aria-labelledby", t.ariaLabelledby || null)("aria-describedby", t.ariaDescribedby || null) } } const ZV = { transformMenu: pp("transformMenu", [vp("void", gp({ opacity: 0, transform: "scale(0.8)" })), yp("void => enter", fp("120ms cubic-bezier(0, 0, 0.2, 1)", gp({ opacity: 1, transform: "scale(1)" }))), yp("* => void", fp("100ms 25ms linear", gp({ opacity: 0 })))]), fadeInItems: pp("fadeInItems", [vp("showing", gp({ opacity: 1 })), yp("void => *", [gp({ opacity: 0 }), fp("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }, KV = new Kn("MatMenuContent"); let YV = (() => { class t { constructor(t, e, n, r, i, s, o) { this._template = t, this._componentFactoryResolver = e, this._appRef = n, this._injector = r, this._viewContainerRef = i, this._document = s, this._changeDetectorRef = o, this._attached = new M } attach(t = {}) { this._portal || (this._portal = new D_(this._template, this._viewContainerRef)), this.detach(), this._outlet || (this._outlet = new F_(this._document.createElement("div"), this._componentFactoryResolver, this._appRef, this._injector)); const e = this._template.elementRef.nativeElement; e.parentNode.insertBefore(this._outlet.outletElement, e), this._changeDetectorRef && this._changeDetectorRef.markForCheck(), this._portal.attach(this._outlet, t), this._attached.next() } detach() { this._portal.isAttached && this._portal.detach() } ngOnDestroy() { this._outlet && this._outlet.dispose() } } return t.\u0275fac = function (e) { return new (e || t)(Do(Tl), Do(za), Do(cu), Do(mo), Do(Ll), Do(wu), Do(bl)) }, t.\u0275dir = Yt({ type: t, selectors: [["ng-template", "matMenuContent", ""]], features: [Ua([{ provide: KV, useExisting: t }])] }), t })(); const QV = new Kn("MAT_MENU_PANEL"), $V = sS(rS(class { })); let tz = (() => { class t extends $V { constructor(t, e, n, r) { super(), this._elementRef = t, this._focusMonitor = n, this._parentMenu = r, this.role = "menuitem", this._hovered = new M, this._focused = new M, this._highlighted = !1, this._triggersSubmenu = !1, r && r.addItem && r.addItem(this) } focus(t, e) { this._focusMonitor && t ? this._focusMonitor.focusVia(this._getHostElement(), t, e) : this._getHostElement().focus(e), this._focused.next(this) } ngAfterViewInit() { this._focusMonitor && this._focusMonitor.monitor(this._elementRef, !1) } ngOnDestroy() { this._focusMonitor && this._focusMonitor.stopMonitoring(this._elementRef), this._parentMenu && this._parentMenu.removeItem && this._parentMenu.removeItem(this), this._hovered.complete(), this._focused.complete() } _getTabIndex() { return this.disabled ? "-1" : "0" } _getHostElement() { return this._elementRef.nativeElement } _checkDisabled(t) { this.disabled && (t.preventDefault(), t.stopPropagation()) } _handleMouseEnter() { this._hovered.next(this) } getLabel() { var t, e; const n = this._elementRef.nativeElement.cloneNode(!0), r = n.querySelectorAll("mat-icon, .material-icons"); for (let i = 0; i < r.length; i++) { const e = r[i]; null === (t = e.parentNode) || void 0 === t || t.removeChild(e) } return (null === (e = n.textContent) || void 0 === e ? void 0 : e.trim()) || "" } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(wu), Do(Ww), Do(QV, 8)) }, t.\u0275cmp = Jt({ type: t, selectors: [["", "mat-menu-item", ""]], hostAttrs: [1, "mat-focus-indicator"], hostVars: 10, hostBindings: function (t, e) { 1 & t && Jo("click", function (t) { return e._checkDisabled(t) })("mouseenter", function () { return e._handleMouseEnter() }), 2 & t && (Ro("role", e.role)("tabindex", e._getTabIndex())("aria-disabled", e.disabled.toString())("disabled", e.disabled || null), aa("mat-menu-item", !0)("mat-menu-item-highlighted", e._highlighted)("mat-menu-item-submenu-trigger", e._triggersSubmenu)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", role: "role" }, exportAs: ["matMenuItem"], features: [vo], attrs: XV, ngContentSelectors: WV, decls: 2, vars: 2, consts: [["matRipple", "", 1, "mat-menu-ripple", 3, "matRippleDisabled", "matRippleTrigger"]], template: function (t, e) { 1 & t && (Qo(), $o(0), Bo(1, "div", 0)), 2 & t && (ns(1), Io("matRippleDisabled", e.disableRipple || e.disabled)("matRippleTrigger", e._getHostElement())) }, directives: [gS], encapsulation: 2, changeDetection: 0 }), t })(); const ez = new Kn("mat-menu-default-options", { providedIn: "root", factory: function () { return { overlapTrigger: !1, xPosition: "after", yPosition: "below", backdropClass: "cdk-overlay-transparent-backdrop" } } }); let nz = 0, rz = (() => { class t { constructor(t, e, n) { this._elementRef = t, this._ngZone = e, this._defaultOptions = n, this._xPosition = this._defaultOptions.xPosition, this._yPosition = this._defaultOptions.yPosition, this._directDescendantItems = new rc, this._tabSubscription = d.EMPTY, this._classList = {}, this._panelAnimationState = "void", this._animationDone = new M, this.overlayPanelClass = this._defaultOptions.overlayPanelClass || "", this.backdropClass = this._defaultOptions.backdropClass, this._overlapTrigger = this._defaultOptions.overlapTrigger, this._hasBackdrop = this._defaultOptions.hasBackdrop, this.closed = new ec, this.close = this.closed, this.panelId = "mat-menu-panel-" + nz++ } get xPosition() { return this._xPosition } set xPosition(t) { this._xPosition = t, this.setPositionClasses() } get yPosition() { return this._yPosition } set yPosition(t) { this._yPosition = t, this.setPositionClasses() } get overlapTrigger() { return this._overlapTrigger } set overlapTrigger(t) { this._overlapTrigger = Bb(t) } get hasBackdrop() { return this._hasBackdrop } set hasBackdrop(t) { this._hasBackdrop = Bb(t) } set panelClass(t) { const e = this._previousPanelClass; e && e.length && e.split(" ").forEach(t => { this._classList[t] = !1 }), this._previousPanelClass = t, t && t.length && (t.split(" ").forEach(t => { this._classList[t] = !0 }), this._elementRef.nativeElement.className = "") } get classList() { return this.panelClass } set classList(t) { this.panelClass = t } ngOnInit() { this.setPositionClasses() } ngAfterContentInit() { this._updateDirectDescendants(), this._keyManager = new Pw(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd(), this._tabSubscription = this._keyManager.tabOut.subscribe(() => this.closed.emit("tab")), this._directDescendantItems.changes.pipe(fg(this._directDescendantItems), ep(t => W(...t.map(t => t._focused)))).subscribe(t => this._keyManager.updateActiveItem(t)) } ngOnDestroy() { this._directDescendantItems.destroy(), this._tabSubscription.unsubscribe(), this.closed.complete() } _hovered() { return this._directDescendantItems.changes.pipe(fg(this._directDescendantItems), ep(t => W(...t.map(t => t._hovered)))) } addItem(t) { } removeItem(t) { } _handleKeydown(t) { const e = t.keyCode, n = this._keyManager; switch (e) { case 27: H_(t) || (t.preventDefault(), this.closed.emit("keydown")); break; case 37: this.parentMenu && "ltr" === this.direction && this.closed.emit("keydown"); break; case 39: this.parentMenu && "rtl" === this.direction && this.closed.emit("keydown"); break; default: 38 !== e && 40 !== e || n.setFocusOrigin("keyboard"), n.onKeydown(t) } } focusFirstItem(t = "program") { this.lazyContent ? this._ngZone.onStable.pipe(hg(1)).subscribe(() => this._focusFirstItem(t)) : this._focusFirstItem(t) } _focusFirstItem(t) { const e = this._keyManager; if (e.setFocusOrigin(t).setFirstItemActive(), !e.activeItem && this._directDescendantItems.length) { let t = this._directDescendantItems.first._getHostElement().parentElement; for (; t;) { if ("menu" === t.getAttribute("role")) { t.focus(); break } t = t.parentElement } } } resetActiveItem() { this._keyManager.setActiveItem(-1) } setElevation(t) { const e = Math.min(this._baseElevation + t, 24), n = `${this._elevationPrefix}${e}`, r = Object.keys(this._classList).find(t => t.startsWith(this._elevationPrefix)); r && r !== this._previousElevation || (this._previousElevation && (this._classList[this._previousElevation] = !1), this._classList[n] = !0, this._previousElevation = n) } setPositionClasses(t = this.xPosition, e = this.yPosition) { const n = this._classList; n["mat-menu-before"] = "before" === t, n["mat-menu-after"] = "after" === t, n["mat-menu-above"] = "above" === e, n["mat-menu-below"] = "below" === e } _startAnimation() { this._panelAnimationState = "enter" } _resetAnimation() { this._panelAnimationState = "void" } _onAnimationDone(t) { this._animationDone.next(t), this._isAnimating = !1 } _onAnimationStart(t) { this._isAnimating = !0, "enter" === t.toState && 0 === this._keyManager.activeItemIndex && (t.element.scrollTop = 0) } _updateDirectDescendants() { this._allItems.changes.pipe(fg(this._allItems)).subscribe(t => { this._directDescendantItems.reset(t.filter(t => t._parentMenu === this)), this._directDescendantItems.notifyOnChanges() }) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(Vc), Do(ez)) }, t.\u0275dir = Yt({ type: t, contentQueries: function (t, e, n) { if (1 & t && (mc(n, KV, 5), mc(n, tz, 5), mc(n, tz, 4)), 2 & t) { let t; pc(t = gc()) && (e.lazyContent = t.first), pc(t = gc()) && (e._allItems = t), pc(t = gc()) && (e.items = t) } }, viewQuery: function (t, e) { if (1 & t && fc(Tl, 5), 2 & t) { let t; pc(t = gc()) && (e.templateRef = t.first) } }, inputs: { backdropClass: "backdropClass", xPosition: "xPosition", yPosition: "yPosition", overlapTrigger: "overlapTrigger", hasBackdrop: "hasBackdrop", panelClass: ["class", "panelClass"], classList: "classList", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"] }, outputs: { closed: "closed", close: "close" } }), t })(), iz = (() => { class t extends rz { constructor(t, e, n) { super(t, e, n), this._elevationPrefix = "mat-elevation-z", this._baseElevation = 4 } } return t.\u0275fac = function (e) { return new (e || t)(Do(Wa), Do(Vc), Do(ez)) }, t.\u0275cmp = Jt({ type: t, selectors: [["mat-menu"]], hostVars: 3, hostBindings: function (t, e) { 2 & t && Ro("aria-label", null)("aria-labelledby", null)("aria-describedby", null) }, exportAs: ["matMenu"], features: [Ua([{ provide: QV, useExisting: t }]), vo], ngContentSelectors: WV, decls: 1, vars: 0, consts: [["tabindex", "-1", "role", "menu", 1, "mat-menu-panel", 3, "id", "ngClass", "keydown", "click"], [1, "mat-menu-content"]], template: function (t, e) { 1 & t && (Qo(), Lo(0, qV, 3, 6, "ng-template")) }, directives: [Ku], styles: ['mat-menu{display:none}.mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-menu-panel{outline:solid 1px}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}.cdk-high-contrast-active .mat-menu-item{margin-top:1px}.cdk-high-contrast-active .mat-menu-item.cdk-program-focused,.cdk-high-contrast-active .mat-menu-item.cdk-keyboard-focused,.cdk-high-contrast-active .mat-menu-item-highlighted{outline:dotted 1px}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:"";display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\n'], encapsulation: 2, data: { animation: [ZV.transformMenu, ZV.fadeInItems] }, changeDetection: 0 }), t })(); const sz = new Kn("mat-menu-scroll-strategy"), oz = { provide: sz, deps: [mw], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }, az = __({ passive: !0 }); let lz = (() => { class t { constructor(t, e, n, r, i, s, o, a) { this._overlay = t, this._element = e, this._viewContainerRef = n, this._menuItemInstance = s, this._dir = o, this._focusMonitor = a, this._overlayRef = null, this._menuOpen = !1, this._closingActionsSubscription = d.EMPTY, this._hoverSubscription = d.EMPTY, this._menuCloseSubscription = d.EMPTY, this._handleTouchStart = t => { Fw(t) || (this._openedBy = "touch") }, this._openedBy = void 0, this.restoreFocus = !0, this.menuOpened = new ec, this.onMenuOpen = this.menuOpened, this.menuClosed = new ec, this.onMenuClose = this.menuClosed, this._scrollStrategy = r, this._parentMaterialMenu = i instanceof rz ? i : void 0, e.nativeElement.addEventListener("touchstart", this._handleTouchStart, az), s && (s._triggersSubmenu = this.triggersSubmenu()) } get _deprecatedMatMenuTriggerFor() { return this.menu } set _deprecatedMatMenuTriggerFor(t) { this.menu = t } get menu() { return this._menu } set menu(t) { t !== this._menu && (this._menu = t, this._menuCloseSubscription.unsubscribe(), t && (this._menuCloseSubscription = t.close.subscribe(t => { this._destroyMenu(t), "click" !== t && "tab" !== t || !this._parentMaterialMenu || this._parentMaterialMenu.closed.emit(t) }))) } ngAfterContentInit() { this._checkMenu(), this._handleHover() } ngOnDestroy() { this._overlayRef && (this._overlayRef.dispose(), this._overlayRef = null), this._element.nativeElement.removeEventListener("touchstart", this._handleTouchStart, az), this._menuCloseSubscription.unsubscribe(), this._closingActionsSubscription.unsubscribe(), this._hoverSubscription.unsubscribe() } get menuOpen() { return this._menuOpen } get dir() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } triggersSubmenu() { return !(!this._menuItemInstance || !this._parentMaterialMenu) } toggleMenu() { return this._menuOpen ? this.closeMenu() : this.openMenu() } openMenu() { if (this._menuOpen) return; this._checkMenu(); const t = this._createOverlay(), e = t.getConfig(); this._setPosition(e.positionStrategy), e.hasBackdrop = null == this.menu.hasBackdrop ? !this.triggersSubmenu() : this.menu.hasBackdrop, t.attach(this._getPortal()), this.menu.lazyContent && this.menu.lazyContent.attach(this.menuData), this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu()), this._initMenu(), this.menu instanceof rz && this.menu._startAnimation() } closeMenu() { this.menu.close.emit() } focus(t, e) { this._focusMonitor && t ? this._focusMonitor.focusVia(this._element, t, e) : this._element.nativeElement.focus(e) } updatePosition() { var t; null === (t = this._overlayRef) || void 0 === t || t.updatePosition() } _destroyMenu(t) { if (!this._overlayRef || !this.menuOpen) return; const e = this.menu; this._closingActionsSubscription.unsubscribe(), this._overlayRef.detach(), !this.restoreFocus || "keydown" !== t && this._openedBy && this.triggersSubmenu() || this.focus(this._openedBy), this._openedBy = void 0, e instanceof rz ? (e._resetAnimation(), e.lazyContent ? e._animationDone.pipe(od(t => "void" === t.toState), hg(1), a_(e.lazyContent._attached)).subscribe({ next: () => e.lazyContent.detach(), complete: () => this._setIsMenuOpen(!1) }) : this._setIsMenuOpen(!1)) : (this._setIsMenuOpen(!1), e.lazyContent && e.lazyContent.detach()) } _initMenu() { this.menu.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : void 0, this.menu.direction = this.dir, this._setMenuElevation(), this.menu.focusFirstItem(this._openedBy || "program"), this._setIsMenuOpen(!0) } _setMenuElevation() { if (this.menu.setElevation) { let t = 0, e = this.menu.parentMenu; for (; e;)t++, e = e.parentMenu; this.menu.setElevation(t) } } _setIsMenuOpen(t) { this._menuOpen = t, this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit(), this.triggersSubmenu() && (this._menuItemInstance._highlighted = t) } _checkMenu() { } _createOverlay() { if (!this._overlayRef) { const t = this._getOverlayConfig(); this._subscribeToPositions(t.positionStrategy), this._overlayRef = this._overlay.create(t), this._overlayRef.keydownEvents().subscribe() } return this._overlayRef } _getOverlayConfig() { return new q_({ positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withGrowAfterOpen().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"), backdropClass: this.menu.backdropClass || "cdk-overlay-transparent-backdrop", panelClass: this.menu.overlayPanelClass, scrollStrategy: this._scrollStrategy(), direction: this._dir }) } _subscribeToPositions(t) { this.menu.setPositionClasses && t.positionChanges.subscribe(t => { this.menu.setPositionClasses("start" === t.connectionPair.overlayX ? "after" : "before", "top" === t.connectionPair.overlayY ? "below" : "above") }) } _setPosition(t) { let [e, n] = "before" === this.menu.xPosition ? ["end", "start"] : ["start", "end"], [r, i] = "above" === this.menu.yPosition ? ["bottom", "top"] : ["top", "bottom"], [s, o] = [r, i], [a, l] = [e, n], c = 0; this.triggersSubmenu() ? (l = e = "before" === this.menu.xPosition ? "start" : "end", n = a = "end" === e ? "start" : "end", c = "bottom" === r ? 8 : -8) : this.menu.overlapTrigger || (s = "top" === r ? "bottom" : "top", o = "top" === i ? "bottom" : "top"), t.withPositions([{ originX: e, originY: s, overlayX: a, overlayY: r, offsetY: c }, { originX: n, originY: s, overlayX: l, overlayY: r, offsetY: c }, { originX: e, originY: o, overlayX: a, overlayY: i, offsetY: -c }, { originX: n, originY: o, overlayX: l, overlayY: i, offsetY: -c }]) } _menuClosingActions() { const t = this._overlayRef.backdropClick(), e = this._overlayRef.detachments(); return W(t, this._parentMaterialMenu ? this._parentMaterialMenu.closed : id(), this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe(od(t => t !== this._menuItemInstance), od(() => this._menuOpen)) : id(), e) } _handleMousedown(t) { Ow(t) || (this._openedBy = 0 === t.button ? "mouse" : void 0, this.triggersSubmenu() && t.preventDefault()) } _handleKeydown(t) { const e = t.keyCode; 13 !== e && 32 !== e || (this._openedBy = "keyboard"), this.triggersSubmenu() && (39 === e && "ltr" === this.dir || 37 === e && "rtl" === this.dir) && (this._openedBy = "keyboard", this.openMenu()) } _handleClick(t) { this.triggersSubmenu() ? (t.stopPropagation(), this.openMenu()) : this.toggleMenu() } _handleHover() { this.triggersSubmenu() && this._parentMaterialMenu && (this._hoverSubscription = this._parentMaterialMenu._hovered().pipe(od(t => t === this._menuItemInstance && !t.disabled), VV(0, Kb)).subscribe(() => { this._openedBy = "mouse", this.menu instanceof rz && this.menu._isAnimating ? this.menu._animationDone.pipe(hg(1), VV(0, Kb), a_(this._parentMaterialMenu._hovered())).subscribe(() => this.openMenu()) : this.openMenu() })) } _getPortal() { return this._portal && this._portal.templateRef === this.menu.templateRef || (this._portal = new D_(this.menu.templateRef, this._viewContainerRef)), this._portal } } return t.\u0275fac = function (e) { return new (e || t)(Do(mw), Do(Wa), Do(Ll), Do(sz), Do(QV, 8), Do(tz, 10), Do(T_, 8), Do(Ww)) }, t.\u0275dir = Yt({ type: t, selectors: [["", "mat-menu-trigger-for", ""], ["", "matMenuTriggerFor", ""]], hostAttrs: ["aria-haspopup", "true", 1, "mat-menu-trigger"], hostVars: 2, hostBindings: function (t, e) { 1 & t && Jo("mousedown", function (t) { return e._handleMousedown(t) })("keydown", function (t) { return e._handleKeydown(t) })("click", function (t) { return e._handleClick(t) }), 2 & t && Ro("aria-expanded", e.menuOpen || null)("aria-controls", e.menuOpen ? e.menu.panelId : null) }, inputs: { restoreFocus: ["matMenuTriggerRestoreFocus", "restoreFocus"], _deprecatedMatMenuTriggerFor: ["mat-menu-trigger-for", "_deprecatedMatMenuTriggerFor"], menu: ["matMenuTriggerFor", "menu"], menuData: ["matMenuTriggerData", "menuData"] }, outputs: { menuOpened: "menuOpened", onMenuOpen: "onMenuOpen", menuClosed: "menuClosed", onMenuClose: "onMenuClose" }, exportAs: ["matMenuTrigger"] }), t })(), cz = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [oz], imports: [nS] }), t })(), uz = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [oz], imports: [[mh, nS, vS, vw, cz], P_, nS, cz] }), t })(); function hz(t, e) { if (1 & t) { const t = Go(); Fo(0, "ga-button", 4), Jo("click", function () { return Oe(t), Ko(3).login() }), ya(1, " Connect Wallet "), No() } } function dz(t, e) { if (1 & t && (Ho(0), Lo(1, hz, 2, 0, "ga-button", 3), Zl(2, "async"), Uo()), 2 & t) { const t = Ko(2); ns(1), Io("ngIf", Kl(2, 1, t.isEthereumAvailable$)) } } function pz(t, e) { if (1 & t && (Fo(0, "div", 12), ya(1), No()), 2 & t) { const t = Ko(3).ngIf; ns(1), _a(" ", t.address, " ") } } function fz(t, e) { if (1 & t && (Fo(0, "button", 8), Lo(1, pz, 2, 1, "ng-template", null, 9, _c), Fo(3, "div", 10), Bo(4, "img", 11), No(), No()), 2 & t) { Ko(); const t = ko(3), e = Ko(2); Io("matMenuTriggerFor", t), ns(4), Io("src", e.basehref + "assets/avatar.svg", si) } } function mz(t, e) { if (1 & t) { const t = Go(); Fo(0, "div", 13), Fo(1, "span", 14), ya(2), No(), Fo(3, "mat-icon", 15), Jo("click", function () { Oe(t); const e = Ko(2).ngIf; return Ko().copyToClipboard(e.address) }), ya(4, "content_copy "), No(), No(), Fo(5, "div", 16), Bo(6, "img", 17), Fo(7, "div"), Fo(8, "div", 18), ya(9, "Balance:"), No(), Fo(10, "div"), ya(11), Zl(12, "number"), Zl(13, "bigNumber"), Zl(14, "async"), No(), No(), No(), Fo(15, "button", 19), ya(16, " Buy Vox "), No(), Fo(17, "button", 20), ya(18, " My Collection "), No() } if (2 & t) { const t = Ko(2).ngIf, e = Ko(); ns(2), ba(e.truncate(t.address)), ns(4), Io("src", e.basehref + "assets/eth-circle.svg", si), ns(5), _a("", Yl(12, 3, Kl(13, 6, Kl(14, 8, e.balance$)), "1.0-4"), " ETH") } } function gz(t, e) { 1 & t && (Lo(0, fz, 5, 2, "button", 5), Zl(1, "async"), Fo(2, "mat-menu", null, 6), Lo(4, mz, 19, 10, "ng-template", 7), No()), 2 & t && Io("ngIf", Kl(1, 1, Ko(2).self$)) } function vz(t, e) { if (1 & t && (Ho(0), Lo(1, dz, 3, 3, "ng-container", 0), Lo(2, gz, 5, 3, "ng-template", null, 2, _c), Uo()), 2 & t) { const t = e.ngIf, n = ko(3); ns(1), Io("ngIf", !t.authenticated)("ngIfElse", n) } } function yz(t, e) { if (1 & t) { const t = Go(); Fo(0, "ga-button", 22), Jo("click", function () { return Oe(t), Ko(2).login() }), ya(1, " Connect Wallet "), No() } } function bz(t, e) { if (1 & t && (Lo(0, yz, 2, 0, "ga-button", 21), Zl(1, "async")), 2 & t) { const t = Ko(); Io("ngIf", Kl(1, 1, t.isMetamaskInstalled$ && t.isEthereumAvailable$)) } } let _z = (() => { class t { constructor(t, e, n, r, i, s) { var o, a; this.platformId = t, this.sessionService = e, this.selfService = n, this.clipboard = r, this.snackbar = i, this.blockchain = s, this.basehref = "", this.isEthereumAvailable$ = id(gh(this.platformId)), this.isMetamaskInstalled$ = id(!1), this.session$ = this.sessionService.session$, this.self$ = this.selfService.self$, this.balance$ = this.session$.pipe(od(t => !!t.address), V(() => B(this.blockchain.getBalance()))), void 0 !== (null === (a = null === (o = null === global || void 0 === global ? void 0 : global.window) || void 0 === o ? void 0 : o.ethereum) || void 0 === a ? void 0 : a.isMetaMask) && (this.isMetamaskInstalled$ = id(!0)), gh(t) && this.sessionService.checkConnected().pipe(Dg(t => this.selfService.setSelf(t))).subscribe() } truncate(t) { return t.slice(0, 12) + "..." + t.slice(-4) } login() { this.selfService.goToLogin() } copyToClipboard(t) { this.clipboard.copy(t), this.snackbar.info("Address copied to clipboard") } } return t.\u0275fac = function (e) { return new (e || t)(Do(Ac), Do(yM), Do(jE), Do(UV), Do(iM), Do(zE)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-authenticate"]], inputs: { basehref: "basehref" }, decls: 4, vars: 4, consts: [[4, "ngIf", "ngIfElse"], ["loginButton", ""], ["authenticated", ""], ["color", "primary", "variant", "transparent", "size", "small", 3, "click", 4, "ngIf"], ["color", "primary", "variant", "transparent", "size", "small", 3, "click"], ["class", "flex items-center", 3, "matMenuTriggerFor", 4, "ngIf"], ["menu", "matMenu"], ["matMenuContent", ""], [1, "flex", "items-center", 3, "matMenuTriggerFor"], ["address", ""], [1, "flex", "align-start", "h-55"], [1, "h-10", 3, "src"], [1, "w-48", "truncate"], [1, "p-4", "bg-dark", "text-white", "flex"], [1, "pr-4"], [1, "cursor-pointer", 3, "click"], [1, "eth-balance", "border-b", "border-gray-light", "font-semibold", "flex", "items-center"], [1, "inline", "mr-3", "h-10", 3, "src"], [1, "text-gray"], ["mat-menu-item", "", "routerLink", "/", 1, "buy-vox"], ["mat-menu-item", "", "routerLink", "profile/collection"], ["color", "primary", "variant", "outline", "size", "small", 3, "click", 4, "ngIf"], ["color", "primary", "variant", "outline", "size", "small", 3, "click"]], template: function (t, e) { if (1 & t && (Lo(0, vz, 4, 2, "ng-container", 0), Zl(1, "async"), Lo(2, bz, 2, 3, "ng-template", null, 1, _c)), 2 & t) { const t = ko(3); Io("ngIf", Kl(1, 2, e.session$))("ngIfElse", t) } }, directives: [th, QE, iz, YV, lz, dE, tz, mb], pipes: [hh, fh, AM], styles: [".eth-balance[_ngcontent-%COMP%]{padding:16px}@media (min-width:640px){.buy-vox[_ngcontent-%COMP%]{display:none}}"] }), t })(); function wz(t, e) { 1 & t && Bo(0, "ga-authenticate", 6), 2 & t && Io("basehref", Ko().basehref) } const Sz = ["*"]; let xz = (() => { class t { constructor(t) { this.location = t, this.basehref = "", this.urlBlacklist = ["/login", "/create/account", "/create/verify"] } get loginVisible() { const t = this.location.path(); return !new RegExp(this.urlBlacklist.join("|")).test(t) } } return t.\u0275fac = function (e) { return new (e || t)(Do(Fu)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-header"]], inputs: { basehref: "basehref" }, ngContentSelectors: Sz, decls: 8, vars: 1, consts: [[1, "grid-cols-3", "items-center"], [1, "flex", "md:justify-center", "col-span-1", "md:col-start-2"], ["href", "/", "alt", "VOX - Avatars That Defi"], [1, "flex", "items-center", "col-span-2", "md:col-span-1"], ["color", "primary", "variant", "outline", "size", "small", "routerLink", "/", 1, "ml-auto", "mr-4"], ["class", "ml-auto sm:ml-0", 3, "basehref", 4, "ngIf"], [1, "ml-auto", "sm:ml-0", 3, "basehref"]], template: function (t, e) { 1 & t && (Qo(), Fo(0, "mat-toolbar", 0), Fo(1, "div", 1), Fo(2, "a", 2), $o(3), No(), No(), Fo(4, "div", 3), Fo(5, "ga-button", 4), ya(6, "Buy Vox"), No(), Lo(7, wz, 1, 1, "ga-authenticate", 5), No(), No()), 2 & t && (ns(7), Io("ngIf", e.loginVisible)) }, directives: [NV, QE, mb, th, _z], styles: [".mat-toolbar[_ngcontent-%COMP%]{background-color:initial;display:grid;padding-top:.5rem;padding-bottom:.5rem}ga-button[_ngcontent-%COMP%]{display:none}@media (min-width:640px){ga-button[_ngcontent-%COMP%]{display:inline-block}}"] }), t })(); function Tz(t, e) { 1 & t && (Fo(0, "div", 1), Fo(1, "div", 2), Bo(2, "div"), Bo(3, "div"), Bo(4, "div"), Bo(5, "div"), No(), No()) } let Ez = (() => { class t { constructor(t) { this.loadingService = t, this.loading$ = this.loadingService.loading$ } } return t.\u0275fac = function (e) { return new (e || t)(Do(vM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-loading"]], decls: 2, vars: 3, consts: [["class", "h-screen-3/4 container flex justify-center items-center", 4, "ngIf"], [1, "h-screen-3/4", "container", "flex", "justify-center", "items-center"], [1, "lds-ring"]], template: function (t, e) { 1 & t && (Lo(0, Tz, 6, 0, "div", 0), Zl(1, "async")), 2 & t && Io("ngIf", Kl(1, 1, e.loading$)) }, directives: [th], pipes: [hh], styles: [".lds-ring[_ngcontent-%COMP%]{display:inline-block;position:relative;width:80px;height:80px}.lds-ring[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{box-sizing:border-box;display:block;position:absolute;width:64px;height:64px;margin:8px;border-radius:50%;animation:lds-ring 1.2s cubic-bezier(.5,0,.5,1) infinite;border:8px solid #0000;border-top-color:#000}.lds-ring[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:first-child{animation-delay:-.45s}.lds-ring[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(2){animation-delay:-.3s}.lds-ring[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]:nth-child(3){animation-delay:-.15s}@keyframes lds-ring{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}"] }), t })(); function Mz(t, e) { if (1 & t) { const t = Go(); Fo(0, "a", 9), Jo("click", function () { const e = Oe(t).$implicit; return Ko().handleOutboundLinkClicks(e.url) }), Bo(1, "img", 10), ya(2), No() } if (2 & t) { const t = e.$implicit, n = Ko(); Io("href", t.url, si), ns(1), Io("src", n.basehref + t.icon, si), ns(1), _a(" ", t.name, " ") } } const Az = ["*"]; let Cz = (() => { class t { constructor(t) { this.gaService = t, this.basehref = "", this.socials = [{ name: "Instagram", icon: "assets/icons/icon-instagram.svg", url: "https://www.instagram.com/gogalagames" }, { name: "Twitter", icon: "assets/icons/icon-twitter.svg", url: "https://twitter.com/GoGalaGames" }, { name: "Discord", icon: "assets/icons/icon-discord.svg", url: "http://galagames.chat/" }, { name: "Medium", icon: "assets/icons/icon-medium.svg", url: "https://blog.gala.games/" }], this.email = new mT("", [Cx.required, Cx.email]) } get year() { return (new Date).getFullYear() } handleOutboundLinkClicks(t) { this.gaService.eventEmitter("Outbound Link", "click", t) } getErrorMessage() { return this.email.hasError("required") ? "You must enter a value" : this.email.hasError("email") ? "Not a valid email" : "" } } return t.\u0275fac = function (e) { return new (e || t)(Do(gM)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-footer"]], inputs: { basehref: "basehref" }, ngContentSelectors: Az, decls: 13, vars: 2, consts: [[1, "w-full"], [1, "container", "py-16", "text-white", "flex", "flex-col", "sm:flex-row"], [1, "text-gray", "flex-grow", "md:w-96"], [1, "footer-links"], ["routerLink", "terms-and-conditions"], ["routerLink", "faqs"], [1, "mt-12", "sm:mt-4", "md:text-right"], ["target", "_blank", "class", "pb-4 flex items-center", 3, "href", "click", 4, "ngFor", "ngForOf"], [1, "text-center", "text-gray", "py-3", "text-sm"], ["target", "_blank", 1, "pb-4", "flex", "items-center", 3, "href", "click"], [1, "mr-3", "h-5", 3, "src"]], template: function (t, e) { 1 & t && (Qo(), Fo(0, "footer", 0), Fo(1, "div", 1), Fo(2, "div", 2), $o(3), Fo(4, "div", 3), Fo(5, "a", 4), ya(6, "Terms and Conditions"), No(), Fo(7, "a", 5), ya(8, "FAQs"), No(), No(), No(), Fo(9, "div", 6), Lo(10, Mz, 3, 3, "a", 7), No(), No(), Fo(11, "div", 8), ya(12), No(), No()), 2 & t && (ns(10), Io("ngForOf", e.socials), ns(2), _a("\xa9", e.year, " Gala Labs")) }, directives: [gb, Qu], styles: ["footer{background-color:#16181e}footer .footer-links>*{display:block;color:#fff;margin-top:1rem}@media (min-width:640px){footer .container.flex{flex-direction:row;align-items:flex-start}}"], encapsulation: 2 }), t })(), Pz = (() => { class t { constructor(t) { this.router = t, this.router.events.subscribe(t => { t instanceof Gg && (gtag("set", "page", t.urlAfterRedirects), gtag("send", "pageview")) }) } onActivate() { window.scroll(0, 0) } } return t.\u0275fac = function (e) { return new (e || t)(Do(fb)) }, t.\u0275cmp = Jt({ type: t, selectors: [["ga-root"]], decls: 6, vars: 0, consts: [["src", "assets/vox-logo.png", 1, "h-12"], [3, "activate"], ["src", "assets/gala-labs-white.svg", 1, "w-40", "pb-4"]], template: function (t, e) { 1 & t && (Fo(0, "ga-header"), Bo(1, "img", 0), No(), Fo(2, "router-outlet", 1), Jo("activate", function () { return e.onActivate() }), No(), Bo(3, "ga-loading"), Fo(4, "ga-footer"), Bo(5, "img", 2), No()) }, directives: [xz, bb, Ez, Cz], styles: ["[_nghost-%COMP%]{min-height:100%;display:flex;flex-direction:column}"] }), t })(), Rz = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({}), t })(), Lz = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[vS, nS, Cw, Rz], nS, Rz] }), t })(), kz = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ imports: [[mh, fx, XT, Lz, NT, pE, QT, UE, BV, NS, uz, Pb, FT, GV, gE]] }), t })(), Dz = (() => { class t { constructor(t, e, n) { this.appRef = e, this.router = n; const r = up(xz, { injector: t }); customElements.define("vox-header", r); const i = up(Cz, { injector: t }); customElements.define("vox-footer", i); const s = up(ZA, { injector: t }); customElements.define("vox-faqs", s); const o = up(dG, { injector: t }); customElements.define("vox-viewer", o) } ngDoBootstrap() { document.querySelector("ga-root") ? this.appRef.bootstrap(Pz) : this.router.events.subscribe(t => { t instanceof Gg && (history.replaceState(null, "homepage", "/"), window.location.href = "store" + t.url) }) } } return t.\u0275fac = function (e) { return new (e || t)(fr(mo), fr(cu), fr(fb)) }, t.\u0275mod = Zt({ type: t }), t.\u0275inj = mt({ providers: [qE, zE, ZE, yM, iM, mM, jE, vM, ph, bM, gM], imports: [[td.withServerTransition({ appId: "serverApp" }), rd, kV, Qm, Ud, kz, gE]] }), t })(); (function () { if (eu) throw new Error("Cannot enable prod mode after platform setup."); tu = !1 })(), document.addEventListener("DOMContentLoaded", () => { Qh().bootstrapModule(Dz).catch(t => console.error(t)) }) }, 8677: () => { }, 1525: () => { } }, t => { "use strict"; t(t.s = 4075) }]);